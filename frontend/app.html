<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>ODRAS — UI Restart</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico" />
  <link rel="icon" type="image/png" href="/static/avian-link-black.png" />

  <!-- Markdown parsing and syntax highlighting -->
  <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css">
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/highlight.min.js"></script>

  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #0b1220;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #60a5fa;
      --border: #1f2937;
      --warn: #f59e0b;
      --ok: #10b981;
      --err: #ef4444;
      --iconbar-w: 56px;
      --tree-w: 320px;
      --tree-w-min: 220px;
      --tree-w-max: 520px;
      --onto-iconbar-w: 56px;
      --onto-tree-w: 300px;
      --onto-tree-w-min: 180px;
      --onto-tree-w-max: 520px;
      --onto-tree-collapsed-w: 40px;
      --onto-props-w: 300px;
      --onto-props-w-min: 200px;
      --onto-props-w-max: 520px;
      --onto-props-collapsed-w: 40px;
      --toolbar-h: 48px;
      --bottombar-h: 32px;
      /* DAS (Digital Assistant Service) */
      --das-w: 420px;
      --das-h: 40vh;
      --das-toolbar-h: 40px;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, sans-serif;
    }

    .layout {
      display: grid;
      grid-template-rows: var(--toolbar-h) 1fr var(--bottombar-h);
      height: 100vh;
    }

    .topbar,
    .bottombar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0 12px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }

    .bottombar {
      border-top: 1px solid var(--border);
      border-bottom: none;
      color: var(--muted);
      gap: 16px;
    }

    .brand {
      font-weight: 600;
      letter-spacing: .5px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .brand-icon {
      width: 24px;
      height: 24px;
      flex-shrink: 0;
    }

    .spacer {
      flex: 1;
    }

    /* Installation Info Styling */
    .installation-info {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--muted);
      font-size: 12px;
    }

    .install-org {
      font-weight: 500;
      color: var(--text);
    }

    .install-type {
      background: var(--panel-2);
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid var(--border);
      text-transform: uppercase;
      font-size: 10px;
      font-weight: 500;
    }

    .install-office {
      color: var(--muted);
      font-style: italic;
    }

    .btn,
    select {
      background: #0b1220;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
    }

    .btn:hover {
      background: var(--panel);
      border-color: var(--accent);
    }

    #previewFullscreenBtn:hover,
    #previewPopoutBtn:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    #fileDropZone:hover {
      background: rgba(15, 22, 40, 0.5) !important;
      border-color: #6b7280 !important;
    }

    select {
      padding: 6px;
    }

    .content {
      display: grid;
      grid-template-columns: var(--iconbar-w) var(--tree-w) 6px 1fr;
      height: 100%;
      transition: grid-template-columns 0.2s ease;
    }

    /* When tree dock is collapsed, adjust grid columns */
    .content:has(.tree-dock-collapsed) {
      grid-template-columns: var(--iconbar-w) 40px 6px 1fr;
    }

    .iconbar {
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px 6px;
      gap: 8px;
      position: relative;
    }

    .icon {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--panel-2);
      display: grid;
      place-items: center;
      color: var(--muted);
      cursor: pointer;
    }

    .icon svg {
      width: 22px;
      height: 22px;
      stroke: currentColor;
    }

    .icon[data-wb="settings"] {
      position: absolute;
      bottom: 56px;
      /* 8px (admin bottom) + 40px (admin height) + 8px (gap) */
      left: 50%;
      transform: translateX(-50%);
    }

    .icon[data-wb="admin"] {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
    }

    .icon.active {
      color: var(--accent);
      border-color: var(--accent);
    }

    /* Analysis Lab Styling */
    .analysis-container {
      display: flex;
      height: calc(100vh - 200px);
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--panel);
      overflow: hidden;
      margin-top: 20px;
    }

    .jupyter-toolbar {
      width: 60px;
      background: var(--panel-2);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      padding: 8px 4px;
      gap: 4px;
      overflow-y: auto;
    }

    .jupyter-canvas {
      flex: 1;
      position: relative;
      background: var(--bg);
    }

    .jupyter-placeholder {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: var(--muted);
      background: var(--bg);
    }

    .jupyter-placeholder-content {
      text-align: center;
      padding: 40px;
    }

    .jupyter-icon {
      width: 80px;
      height: 80px;
      margin: 0 auto 24px;
      color: var(--accent);
      opacity: 0.8;
    }

    .jupyter-icon svg {
      width: 100%;
      height: 100%;
    }

    .jupyter-placeholder-content h3 {
      margin: 0 0 12px 0;
      color: var(--text);
      font-size: 24px;
      font-weight: 600;
    }

    .jupyter-placeholder-content p {
      margin: 0 0 24px 0;
      color: var(--muted);
      font-size: 16px;
      line-height: 1.5;
    }

    .jupyter-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .jupyter-toolbar .icon {
      width: 48px;
      height: 48px;
      margin: 0;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .jupyter-toolbar .icon:hover {
      background: var(--accent);
      color: white;
    }

    .jupyter-toolbar .icon svg {
      width: 20px;
      height: 20px;
    }

    /* Tree Separator */
    .tree-separator {
      margin: 8px 0;
      padding: 0;
      list-style: none;
    }

    .separator-line {
      height: 1px;
      background: var(--border);
      margin: 0 8px;
    }

    /* Main Tree Collapse Functionality */
    .tree-dock-collapsed {
      width: 40px !important;
      min-width: 40px !important;
      max-width: 40px !important;
    }


    .tree-dock-collapsed .tree-scroll {
      display: none;
    }

    .tree-dock-collapsed .tree-header {
      padding: 8px 4px;
      justify-content: center;
    }

    .tree-dock-collapsed .tree-header-left {
      display: none;
    }

    .tree-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      flex-shrink: 0;
      padding: 6px;
    }

    .tree-toggle svg {
      width: 16px;
      height: 16px;
      transition: transform 0.2s ease;
      stroke: currentColor;
      fill: none;
    }

    /* When tree is expanded (normal state): chevron points left (←) indicating "close" */
    .tree-toggle svg {
      transform: rotate(0deg);
    }

    /* When tree is collapsed: chevron points right (→) indicating "open" */
    .tree-dock-collapsed .tree-toggle svg {
      transform: rotate(180deg);
    }

    .tree {
      border-right: 1px solid var(--border);
      background: var(--panel-2);
      display: grid;
      grid-template-rows: auto 1fr;
      min-width: var(--tree-w-min);
      max-width: var(--tree-w-max);
      width: var(--tree-w);
    }

    .tree-header {
      padding: 10px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }

    .tree-header-left {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .tree-scroll {
      overflow: auto;
      padding: 8px;
    }

    /* CAD-like tree view */
    .treeview [role="tree"] {
      list-style: none;
      margin: 0;
      padding: 4px;
    }

    .treeview [role="group"] {
      list-style: none;
      margin: 0;
      padding-left: 16px;
      border-left: 1px dashed var(--border);
    }

    .treeview li[role="treeitem"] {
      margin: 2px 0;
      outline: none;
    }

    .treeview li[role="treeitem"][aria-expanded="false"]>ul[role="group"] {
      display: none;
    }

    .node-row {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      border: 1px solid transparent;
      border-radius: 6px;
      cursor: default;
    }

    .node-row:hover {
      background: #0d1426;
      border-color: var(--border);
    }

    .node-row.selected {
      background: #0f1a33;
      border-color: var(--accent);
    }

    .twist {
      width: 12px;
      text-align: center;
      color: var(--muted);
      user-select: none;
    }

    li[role="treeitem"][aria-expanded="false"]>.node-row .twist::before {
      content: '▸';
    }

    li[role="treeitem"][aria-expanded="true"]>.node-row .twist::before {
      content: '▾';
    }

    li[role="treeitem"]:not([aria-expanded])>.node-row .twist::before {
      content: '•';
      opacity: .25;
    }

    .node-icon {
      width: 14px;
      height: 14px;
      border: 1px solid var(--border);
      border-radius: 3px;
      background: #0a1120;
    }

    .node-icon.folder {
      background: linear-gradient(180deg, #0f1a33, #0c1529);
    }

    .node-icon.req {
      background: #1b2a45;
    }

    .node-icon.doc {
      background: #1b2a45;
      border-style: dashed;
    }

    .node-icon.out {
      background: #1b2a45;
      border-color: #2a3b5f;
    }

    .node-icon.docreq {
      background: #263b61;
      border-color: #3b5a8f;
    }

    .node-icon.docknow {
      background: #2a3f5f;
      border-color: #4a6a9a;
    }

    .node-icon.onto {
      background: #22304f;
      border-color: #39507a;
    }

    .node-label {
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .resizer {
      width: 6px;
      cursor: col-resize;
      background: transparent;
      position: relative;
    }

    .resizer::after {
      content: "";
      position: absolute;
      inset: 0;
    }

    .main {
      padding: 8px 8px 0 8px;
      overflow: hidden;
      height: calc(100vh - var(--toolbar-h) - var(--bottombar-h));
      display: flex;
      flex-direction: column;
    }

    .workbench {
      display: none;
    }

    .workbench.active {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    .workbench.active .onto-layout {
      flex: 1;
      min-height: 0;
    }

    /* Admin workbench specific styling for scrollable content */
    #wb-admin.workbench.active {
      overflow-y: auto;
      padding: 16px;
      padding-bottom: 32px;
      /* Extra bottom padding to ensure last section is fully visible */
    }

    /* Event Manager workbench specific styling for scrollable content */
    #wb-events.workbench.active {
      overflow-y: scroll;
      /* Always show scrollbar */
      padding: 16px;
      padding-bottom: 32px;
      /* Extra bottom padding to ensure last section is fully visible */
      /* Ensure scrollbar is always visible for better UX */
      scrollbar-width: thin;
      scrollbar-color: var(--border) var(--panel);
    }

    /* Webkit scrollbar styling for Event Manager - always visible */
    #wb-events.workbench.active::-webkit-scrollbar {
      width: 12px;
      /* Slightly wider for better visibility */
      background: var(--panel);
    }

    #wb-events.workbench.active::-webkit-scrollbar-track {
      background: var(--panel);
      border-radius: 6px;
      margin: 4px 0;
    }

    #wb-events.workbench.active::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 6px;
      border: 2px solid var(--panel);
    }

    #wb-events.workbench.active::-webkit-scrollbar-thumb:hover {
      background: var(--muted);
    }

    #wb-events.workbench.active::-webkit-scrollbar-corner {
      background: var(--panel);
    }

    /* Files workbench specific styling for scrollable content */
    #wb-files.workbench.active {
      overflow-y: auto;
      padding: 16px;
      padding-bottom: 32px;
      /* Extra bottom padding to ensure upload area is accessible */
    }

    /* Requirements workbench specific styling for scrollable content */
    #wb-requirements.workbench.active {
      overflow-y: scroll;
      /* Always show scrollbar for better UX */
      padding: 16px;
      padding-bottom: 32px;
      /* Extra bottom padding to ensure requirement details are accessible */
      scrollbar-width: thin;
      scrollbar-color: var(--border) var(--panel);
    }

    /* Webkit scrollbar styling for Requirements workbench - always visible */
    #wb-requirements.workbench.active::-webkit-scrollbar {
      width: 12px;
      background: var(--panel);
    }

    #wb-requirements.workbench.active::-webkit-scrollbar-track {
      background: var(--panel);
      border-radius: 6px;
      margin: 4px 0;
    }

    #wb-requirements.workbench.active::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 6px;
      border: 2px solid var(--panel);
    }

    #wb-requirements.workbench.active::-webkit-scrollbar-thumb:hover {
      background: var(--muted);
    }

    #wb-requirements.workbench.active::-webkit-scrollbar-corner {
      background: var(--panel);
    }

    /* Default files layout */
    #filesMainContainer {
      grid-template-columns: minmax(420px, 1fr) 8px minmax(300px, 400px);
    }

    /* When DAS is open and docked right, reduce right panel width */
    body.das-open-right #filesMainContainer {
      grid-template-columns: minmax(300px, 1fr) 8px minmax(200px, 280px);
    }

    /* When DAS is open and docked left, also adjust layout */
    body.das-open-left #filesMainContainer {
      grid-template-columns: minmax(300px, 1fr) 8px minmax(250px, 320px);
    }

    /* When DAS is docked bottom, can use full width */
    body.das-open-bottom #filesMainContainer {
      grid-template-columns: minmax(420px, 1fr) 8px minmax(350px, 450px);
    }

    .status-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }

    .ok {
      background: var(--ok);
    }

    .warn {
      background: var(--warn);
    }

    .err {
      background: var(--err);
    }

    .muted {
      color: var(--muted);
    }

    /* Collapsible sections */
    .section {
      margin-bottom: 16px;
    }

    .section-header {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      color: var(--text);
      transition: background-color 0.2s ease;
    }

    .section-header:hover {
      background: var(--panel);
    }

    .section-toggle {
      transition: transform 0.2s ease;
      font-size: 0.8em;
      color: var(--muted);
    }

    .section.collapsed .section-toggle {
      transform: rotate(-90deg);
    }

    .section-content {
      padding: 16px;
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 8px 8px;
      background: var(--panel);
    }

    .section.collapsed .section-content {
      display: none;
    }

    /* Ontology Workbench Header */
    .ontology-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-bottom: 8px;
      flex: 0 0 auto;
    }

    /* Workbench Tabs */
    .workbench-tabs {
      display: flex;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      padding: 0 12px;
      margin-bottom: 8px;
    }

    .workbench-tab {
      background: none;
      border: none;
      padding: 12px 20px;
      color: var(--muted);
      cursor: pointer;
      font-size: 14px;
      border-bottom: 2px solid transparent;
      transition: all 0.2s ease;
    }

    .workbench-tab:hover {
      color: var(--text);
      background: rgba(255, 255, 255, 0.05);
    }

    .workbench-tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    /* Individual Tables Content */
    .individuals-content {
      display: none;
      height: calc(100vh - 200px);
    }

    .individuals-content.active {
      display: flex;
    }

    .individuals-tabs-nav {
      width: 200px;
      background: var(--panel-2);
      border-right: 1px solid var(--border);
      padding: 8px;
    }

    .individuals-tab-item {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      margin-bottom: 4px;
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      border-radius: 4px;
      width: 100%;
      text-align: left;
      transition: background 0.2s ease;
    }

    .individuals-tab-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .individuals-tab-item.active {
      background: var(--accent);
      color: white;
    }

    .individuals-tab-icon {
      margin-right: 8px;
      font-size: 16px;
    }

    .individuals-table-area {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      background: var(--bg);
    }

    .header-left {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .workbench-title {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }

    .graph-label {
      color: var(--muted);
      font-size: 13px;
      font-weight: 500;
      max-width: 400px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Menu Bar */
    .header-menu {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .menu-group {
      position: relative;
    }

    .menu-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .menu-btn:hover {
      background: var(--panel-2);
      border-color: var(--accent);
    }

    .menu-btn .menu-icon {
      width: 16px;
      height: 16px;
      stroke: currentColor;
    }

    .menu-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      min-width: 200px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .4);
      padding: 8px 0;
      z-index: 1000;
      display: none;
    }

    .menu-group:hover .menu-dropdown {
      display: block;
    }

    .menu-label {
      padding: 8px 12px 4px 12px;
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .menu-select {
      width: calc(100% - 24px);
      margin: 0 12px 8px 12px;
      padding: 6px 8px;
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 12px;
    }

    .menu-item {
      width: 100%;
      padding: 8px 12px;
      background: transparent;
      color: var(--text);
      border: none;
      text-align: left;
      font-size: 13px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .menu-item:hover {
      background: var(--panel);
    }

    #cy {
      width: 100%;
      min-width: 0;
      height: 100%;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #0a0f1f;
      background-image:
        linear-gradient(to right, rgba(255, 255, 255, 0.08) .1px, transparent 1px),
        linear-gradient(to bottom, rgba(255, 255, 255, 0.08) .1px, transparent 1px);
      background-size: 20px 20px;
    }

    .onto-layout {
      display: grid;
      grid-template-columns: var(--onto-tree-w) var(--onto-tree-divider-w, 4px) var(--onto-iconbar-w) minmax(0, 1fr) var(--onto-props-divider-w, 4px) var(--onto-props-w);
      grid-template-rows: 1fr;
      gap: 0;
      align-items: stretch;
      overflow: hidden;
      width: 100%;
      flex: 1 1 auto;
      min-height: 0;
    }

    /* Inline editor for canvas labels */
    #ontoInlineEdit {
      position: fixed;
      z-index: 9999;
      display: none;
      background: #0b1220;
      color: #e5e7eb;
      border: 1px solid var(--accent);
      border-radius: 6px;
      padding: 4px 6px;
      font: inherit;
    }

    /* Fullscreen adjustments */
    #wb-ontology:fullscreen #cy {
      height: calc(100vh - 140px);
    }

    /* Context menu */
    .onto-menu {
      position: fixed;
      z-index: 9999;
      display: none;
      min-width: 180px;
      background: var(--panel-2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .4);
      padding: 4px 0;
    }

    .menu-section {
      padding: 4px 0;
    }

    .menu-item {
      width: 100%;
      background: transparent;
      color: var(--text);
      border: none;
      text-align: left;
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      transition: background-color 0.2s ease;
    }

    .menu-item:hover {
      background: var(--panel);
    }

    .menu-item-secondary {
      color: var(--muted);
    }

    .menu-item-secondary:hover {
      color: var(--text);
    }

    .menu-icon {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      flex-shrink: 0;
    }

    .menu-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    /* IRI Display */
    .iri-display {
      margin-top: 6px;
      margin-bottom: 8px;
      padding: 4px 8px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 4px;
      height: 28px;
      flex: 0 0 auto;
      overflow: hidden;
    }

    .iri-content {
      display: flex;
      align-items: center;
      gap: 6px;
      height: 100%;
    }

    .iri-label {
      font-size: 0.8em;
      font-weight: 500;
      color: var(--muted);
      white-space: nowrap;
    }

    .iri-value {
      font-family: 'Courier New', monospace;
      font-size: 0.75em;
      color: #60a5fa;
      word-break: break-all;
      flex: 1;
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .iri-copy-btn {
      padding: 2px 6px;
      font-size: 0.7em;
      display: none;
      flex-shrink: 0;
    }

    /* Empty state */
    .onto-empty-state {
      margin-top: 10px;
      display: none;
      text-align: center;
      padding: 20px;
      color: var(--muted);
    }

    .connect-source {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }

    /* Pin children to explicit grid columns so hiding resizers doesn't shift layout */
    .onto-layout>.onto-tree {
      grid-column: 1;
    }

    .onto-layout>#ontoResizer {
      grid-column: 2;
    }

    .onto-layout>.onto-iconbar {
      grid-column: 3;
    }

    .onto-layout>#cy {
      grid-column: 4;
    }

    .onto-layout>#ontoPropsResizer {
      grid-column: 5;
    }

    .onto-layout>.onto-props {
      grid-column: 6;
    }

    .onto-iconbar {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 4px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      height: 100%;
      overflow: auto;
    }

    .onto-icon {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--panel-2);
      display: grid;
      place-items: center;
      color: var(--muted);
      cursor: grab;
    }

    .onto-icon svg {
      width: 22px;
      height: 22px;
      stroke: currentColor;
    }

    .onto-tree {
      border: 1px solid var(--border);
      background: var(--panel-2);
      border-radius: 8px;
      display: grid;
      grid-template-rows: auto minmax(0, 1fr);
      min-width: 0;
      height: 100%;
      overflow: hidden;
      min-height: 0;
    }

    .onto-tree-header {
      padding: 6px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      z-index: 1;
      background: var(--panel-2);
    }

    .onto-tree-controls {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .class-visibility-toggle {
      background: none;
      border: none;
      color: var(--muted);
      cursor: pointer;
      padding: 2px 4px;
      margin-left: 4px;
      border-radius: 3px;
      font-size: 12px;
      transition: opacity 0.2s ease;
    }

    .class-visibility-toggle:hover {
      background: var(--border);
      color: var(--text);
    }

    /* Pseudo-import node styling */
    .pseudo-import {
      background-color: #e3f2fd !important;
      border: 2px solid #2196f3 !important;
      border-style: dashed !important;
      font-style: italic !important;
    }

    .pseudo-equivalence {
      stroke: #2196f3 !important;
      stroke-dasharray: 5, 5 !important;
      stroke-width: 2px !important;
    }

    .onto-tree-scroll {
      overflow: auto;
      padding: 6px;
      height: 100%;
      min-height: 0;
    }

    .onto-treeview [role="tree"] {
      list-style: none;
      margin: 0;
      padding: 4px;
    }

    .onto-treeview [role="group"] {
      list-style: none;
      margin: 0;
      padding-left: 16px;
      border-left: 1px dashed var(--border);
    }

    .onto-treeview li[role="treeitem"] {
      margin: 2px 0;
      outline: none;
    }

    .onto-treeview li[role="treeitem"][aria-expanded="false"]>ul[role="group"] {
      display: none;
    }

    .onto-node-row {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      border: 1px solid transparent;
      border-radius: 6px;
      cursor: pointer;
    }

    .onto-node-row:hover {
      background: #0d1426;
      border-color: var(--border);
    }

    .onto-node-row.selected {
      background: #0f1a33;
      border-color: var(--accent);
    }

    .onto-twist {
      width: 12px;
      text-align: center;
      color: var(--muted);
      user-select: none;
    }

    li[role="treeitem"][aria-expanded="false"]>.onto-node-row .onto-twist::before {
      content: '▸';
    }

    li[role="treeitem"][aria-expanded="true"]>.onto-node-row .onto-twist::before {
      content: '▾';
    }

    li[role="treeitem"]:not([aria-expanded])>.onto-node-row .onto-twist::before {
      content: '•';
      opacity: .25;
    }

    .onto-node-label {
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .onto-resizer {
      width: 6px;
      cursor: col-resize;
      background: transparent;
      position: relative;
    }

    .onto-resizer::after {
      content: "";
      position: absolute;
      inset: 0;
    }

    /* Collapsed tree mode */
    #wb-ontology.onto-tree-collapsed .onto-tree {
      overflow: hidden;
    }

    #wb-ontology.onto-tree-collapsed .onto-tree-header .muted {
      display: none;
    }

    #wb-ontology.onto-tree-collapsed .onto-tree-scroll {
      display: none;
    }

    /* Keep the collapse chevron visible and prevent overlap */
    #wb-ontology.onto-tree-collapsed .onto-tree {
      z-index: 2;
    }

    .onto-iconbar {
      z-index: 1;
    }

    #wb-ontology.onto-tree-collapsed #ontoResizer {
      display: none;
    }

    /* Collapse behavior: shrink tree width to rail without affecting tools/canvas/props */
    #wb-ontology.onto-tree-collapsed {
      --onto-tree-w: var(--onto-tree-collapsed-w);
      --onto-tree-divider-w: 0px;
    }

    .iconbtn {
      background: #0b1220;
      color: var(--text);
      border: 1px solid var(--border);
      width: 28px;
      height: 28px;
      border-radius: 8px;
      display: grid;
      place-items: center;
      cursor: pointer;
    }

    .iconbtn svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      transition: transform 160ms ease;
    }

    /* Ontology tree chevron: use same logic as main tree */
    #ontoTreeToggleIcon {
      transform: rotate(0deg);
      transition: transform 0.2s ease;
    }

    #wb-ontology.onto-tree-collapsed #ontoTreeToggleIcon {
      transform: rotate(180deg);
    }

    #wb-ontology.onto-tree-collapsed .onto-tree-header {
      padding: 4px !important;
      flex-direction: column !important;
      gap: 4px !important;
      align-items: center !important;
    }

    #wb-ontology.onto-tree-collapsed .onto-tree-controls {
      flex-direction: column !important;
      gap: 4px !important;
    }

    /* Ontology root node row styling to accommodate visibility button */
    .onto-node-row {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 4px;
      border-radius: 4px;
    }

    .onto-node-row .iconbtn {
      opacity: 0.7;
      transition: opacity 0.2s ease;
    }

    .onto-node-row:hover .iconbtn {
      opacity: 1;
    }

    /* Properties panel */
    .onto-props {
      border: 1px solid var(--border);
      background: var(--panel-2);
      border-radius: 8px;
      display: grid;
      grid-template-rows: auto minmax(0, 1fr);
      min-width: 0;
      height: 100%;
      overflow: hidden;
      min-height: 0;
    }

    .onto-props-header {
      padding: 6px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      z-index: 1;
      background: var(--panel-2);
    }

    /* Properties form styling */
    .props-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
    }

    .props-section {
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      background: var(--panel);
    }

    .props-section-title {
      margin: 0 0 12px 0;
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
    }

    .props-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .props-section-actions {
      display: flex;
      gap: 4px;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group:last-child {
      margin-bottom: 0;
    }

    .form-label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
      font-weight: 500;
      color: var(--muted);
    }

    .form-input,
    .form-select {
      width: 100%;
      padding: 8px 10px;
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 13px;
      transition: border-color 0.2s ease;
    }

    .form-text-display {
      width: 100%;
      padding: 8px 10px;
      background: var(--panel-2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 13px;
      min-height: 20px;
      display: flex;
      align-items: center;
    }

    .form-input:focus,
    .form-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .attrs-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .props-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }

    .save-status {
      font-size: 12px;
      color: var(--muted);
    }

    .onto-props-scroll {
      overflow: auto;
      padding: 6px;
      height: 100%;
      min-height: 0;
    }

    #wb-ontology.onto-props-collapsed .onto-props-header .muted {
      display: none;
    }

    #wb-ontology.onto-props-collapsed .onto-props-header {
      padding: 4px !important;
      justify-content: center !important;
    }

    #wb-ontology.onto-props-collapsed .onto-props-scroll {
      display: none;
    }

    #wb-ontology.onto-props-collapsed #ontoPropsResizer {
      display: none;
    }

    #wb-ontology.onto-props-collapsed {
      --onto-props-w: var(--onto-props-collapsed-w);
      --onto-props-divider-w: 0px;
    }

    #wb-ontology.onto-props-collapsed .onto-props {
      width: var(--onto-props-collapsed-w);
      min-width: var(--onto-props-collapsed-w);
      max-width: var(--onto-props-collapsed-w);
    }

    /* Properties panel chevron: use same logic as main tree */
    #ontoPropsToggleIcon {
      transform: rotate(0deg);
      transition: transform 0.2s ease;
    }

    #wb-ontology.onto-props-collapsed #ontoPropsToggleIcon {
      transform: rotate(180deg);
    }

    .login {
      display: grid;
      place-items: center;
      height: calc(100vh - var(--toolbar-h) - var(--bottombar-h));
    }

    /* Keep login card narrow without constraining other cards */
    #authView .card {
      width: 360px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
    }

    .row {
      display: grid;
      gap: 6px;
      margin-bottom: 10px;
    }

    input[type="text"],
    input[type="password"] {
      background: #0b1220;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 8px;
      border-radius: 6px;
    }

    /* DAS dock styles */
    .das-panel {
      position: fixed;
      z-index: 9000;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
      display: none;
      color: var(--text);
    }

    .das-panel.active {
      display: grid;
      grid-template-rows: var(--das-toolbar-h) 1fr;
    }

    .das-toolbar {
      height: var(--das-toolbar-h);
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 6px 10px;
      border-bottom: 1px solid var(--border);
      background: var(--panel-2);
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
    }

    .das-body {
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    .das-transcript-container {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      padding-bottom: 0;
    }

    .das-input-container {
      padding: 8px;
      border-top: 1px solid var(--border);
      background: var(--panel-2);
    }

    .das-dock-right {
      right: 8px;
      top: 0;
      bottom: 0;
      width: var(--das-w);
    }

    .das-dock-left {
      left: 8px;
      top: 0;
      bottom: 0;
      width: var(--das-w);
    }

    .das-dock-bottom {
      left: 8px;
      right: 8px;
      bottom: 8px;
      height: var(--das-h);
    }

    .das-resizer-x {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 6px;
      cursor: col-resize;
    }

    .das-resizer-y {
      position: absolute;
      left: 0;
      right: 0;
      height: 6px;
      cursor: row-resize;
    }

    .das-dock-right .das-resizer-x {
      left: -3px;
    }

    .das-dock-left .das-resizer-x {
      right: -3px;
    }

    .das-dock-bottom .das-resizer-y {
      top: -3px;
    }

    /* DAS Send Button Hover Effects */
    #dasSendBtn:hover {
      background: var(--text);
      border-color: var(--text);
      transform: translateY(-1px);
    }

    #dasSendBtn:active {
      transform: translateY(0);
    }

    /* DAS suggestions styling */
    .das-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 8px;
    }

    .das-suggestions .btn {
      font-size: 12px;
      padding: 4px 8px;
      margin: 2px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      color: var(--text);
      cursor: pointer;
      border-radius: 4px;
    }

    .das-suggestions .btn:hover {
      background: var(--panel);
      border-color: var(--accent);
    }

    /* Markdown styling for DAS messages */
    .das-markdown {
      line-height: 1.6;
      word-wrap: break-word;
    }

    .das-markdown h1,
    .das-markdown h2,
    .das-markdown h3,
    .das-markdown h4,
    .das-markdown h5,
    .das-markdown h6 {
      margin: 16px 0 8px 0;
      font-weight: 600;
      color: var(--text);
    }

    .das-markdown h1 {
      font-size: 1.5em;
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
    }

    .das-markdown h2 {
      font-size: 1.3em;
    }

    .das-markdown h3 {
      font-size: 1.1em;
    }

    .das-markdown p {
      margin: 8px 0;
    }

    .das-markdown ul,
    .das-markdown ol {
      margin: 8px 0;
      padding-left: 20px;
    }

    .das-markdown li {
      margin: 4px 0;
    }

    .das-markdown blockquote {
      border-left: 4px solid var(--primary);
      margin: 8px 0;
      padding: 8px 16px;
      background: var(--panel-2);
      border-radius: 0 4px 4px 0;
    }

    .das-markdown code {
      background: var(--panel-2);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9em;
    }

    .das-markdown pre {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
      margin: 12px 0;
      overflow-x: auto;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }

    .das-markdown pre code {
      background: none;
      padding: 0;
      border-radius: 0;
    }

    .das-markdown table {
      border-collapse: collapse;
      margin: 12px 0;
      width: 100%;
    }

    .das-markdown th,
    .das-markdown td {
      border: 1px solid var(--border);
      padding: 8px 12px;
      text-align: left;
    }

    .das-markdown th {
      background: var(--panel-2);
      font-weight: 600;
    }

    .das-markdown a {
      color: var(--primary);
      text-decoration: none;
    }

    .das-markdown a:hover {
      text-decoration: underline;
    }

    .das-markdown strong {
      font-weight: 600;
    }

    .das-markdown em {
      font-style: italic;
    }

    /* DAS Sources styling */
    .das-sources {
      margin-top: 12px;
      padding: 8px 12px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .das-sources .sources-title {
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--text);
    }

    .das-sources .source-item {
      margin-bottom: 3px;
      padding-left: 8px;
      line-height: 1.4;
    }

    .das-sources .source-item:last-child {
      margin-bottom: 0;
    }

    /* Edit button styling */
    /* User message container uses inline styles for flexibility */

    /* Ensure user messages are left-aligned */
    .das-user-message {
      text-align: left !important;
    }

    .das-user-message-container {
      text-align: left !important;
    }

    .das-user-message-text {
      text-align: left !important;
      line-height: 1.4;
      word-wrap: break-word;
    }

    .das-edit-btn {
      background: var(--muted);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 0.8em;
      cursor: pointer;
      color: var(--text);
      opacity: 0.7;
      transition: opacity 0.2s;
      flex-shrink: 0;
    }

    .das-edit-btn:hover {
      opacity: 1;
      background: var(--accent);
      color: white;
    }

    .das-edit-input {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--accent);
      border-radius: 4px;
      font-family: inherit;
      font-size: 0.9em;
      margin: 4px 0;
    }

    .das-edit-controls {
      display: flex;
      gap: 8px;
      margin-top: 4px;
    }

    .das-edit-controls button {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      cursor: pointer;
      font-size: 0.8em;
    }

    .das-edit-controls .save-btn {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .das-edit-controls .cancel-btn {
      background: var(--muted);
    }

    /* LLM Status Indicator */
    #llmStatusDot,
    #llmStatusDockDot {
      margin-right: 8px;
      cursor: help;
      transition: background 0.3s ease;
    }

    /* DAS Progress Indicator */
    .das-progress {
      color: var(--muted);
      font-style: italic;
    }

    .ellipsis-dots {
      display: inline-block;
      width: 1.5em;
      /* Fixed width to prevent layout shift */
      text-align: left;
    }

    .streaming-cursor {
      display: inline;
      animation: blink 1s infinite;
      color: var(--accent);
      font-weight: normal;
      margin: 0;
      padding: 0;
      line-height: inherit;
      vertical-align: baseline;
    }

    @keyframes blink {

      0%,
      50% {
        opacity: 1;
      }

      51%,
      100% {
        opacity: 0;
      }
    }

    .das-toolbar .spacer {
      flex: 1;
    }

    .das-help {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 60%;
    }

    /* When DAS is open, shift the app layout to avoid overlap */
    body.das-open-right #app {
      margin-right: calc(var(--das-w) + 16px);
    }

    body.das-open-left #app {
      margin-left: calc(var(--das-w) + 16px);
    }

    body.das-open-bottom #app {
      padding-bottom: calc(var(--das-h) + 16px);
    }

    /* Modal styling */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }

    .modal>div {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }

    .modal h3 {
      margin: 0 0 20px 0;
      color: var(--text);
      font-size: 1.25rem;
      font-weight: 600;
    }

    .modal label {
      display: block;
      margin-bottom: 4px;
      font-weight: 500;
      color: var(--text);
    }

    .modal input,
    .modal select,
    .modal textarea {
      width: 100%;
      padding: 8px 12px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 14px;
    }

    .modal input:focus,
    .modal select:focus,
    .modal textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.1);
    }

    .modal textarea {
      resize: vertical;
      min-height: 80px;
    }

    .modal>div {
      position: relative;
    }

    .modal .button-group {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .modal .button-group .btn {
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 500;
      min-width: 100px;
      border-radius: 6px;
      transition: all 0.2s ease;
    }

    .modal .button-group .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    /* Modal content structure */
    .modal-content {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      max-width: 600px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 24px 16px 24px;
      border-bottom: 1px solid var(--border);
    }

    .modal-header h3 {
      margin: 0;
      color: var(--text);
      font-size: 1.25rem;
      font-weight: 600;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--muted);
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .modal-close:hover {
      color: var(--text);
      background: var(--panel-2);
    }

    .modal-body {
      padding: 20px 24px;
    }

    .modal-footer {
      padding: 16px 24px 20px 24px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .modal-footer .btn {
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 500;
      min-width: 100px;
      border-radius: 6px;
    }

    /* Spinner animation for RAG queries */
    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .loading-spinner {
      animation: spin 1s linear infinite;
    }
  </style>
  <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/cytoscape-edgehandles@4.0.1/cytoscape-edgehandles.min.js"></script>
</head>

<body>
  <div id="app" class="layout">
    <div class="topbar">
      <div class="brand">
        <img src="/static/avian-link-black.png" alt="Avian" class="brand-icon" />
        AVIAN-ODRAS
      </div>
      <div class="spacer"></div>

      <!-- LLM Status Indicator (always visible) -->
      <span id="llmStatusDot" class="status-dot" style="background: #f59e0b;" title="LLM Status: Checking..."></span>

      <!-- Installation Configuration Display -->
      <div id="installationInfo" class="installation-info">
        <div id="installOrg" class="install-org"></div>
        <div id="installType" class="install-type"></div>
        <div id="installOffice" class="install-office"></div>
      </div>

      <div class="spacer"></div>
      <div id="userMenu" class="muted"></div>
      <button class="btn" id="logoutBtn">Logout</button>
    </div>

    <div id="authView" class="login" style="display:none;">
      <div class="card">
        <h3 style="margin:0 0 8px 0; display: flex; justify-content: space-between; align-items: center;">
          Sign in
          <img src="/static/avian-logo-white.png" alt="AVIAN" style="height: 24px; width: auto;" />
        </h3>
        <div class="row"><label>Username</label><input id="u" type="text" /></div>
        <div class="row"><label>Password</label><input id="p" type="password" /></div>
        <button class="btn" id="loginBtn">Login</button>
        <div id="loginMsg" class="muted" style="margin-top:8px;"></div>
      </div>
    </div>

    <div id="mainView" class="content" style="display:none;">
      <nav class="iconbar" aria-label="Workbench">
        <div class="icon" data-wb="project" title="Project Info" aria-label="Project Information">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
            <polyline points="14,2 14,8 20,8" />
            <line x1="16" y1="13" x2="8" y2="13" />
            <line x1="16" y1="17" x2="8" y2="17" />
            <polyline points="10,9 9,9 8,9" />
          </svg>
        </div>
        <div class="icon active" data-wb="ontology" title="Ontology" aria-label="Ontology">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="6" cy="6" r="2" />
            <circle cx="18" cy="6" r="2" />
            <circle cx="6" cy="18" r="2" />
            <circle cx="18" cy="18" r="2" />
            <path d="M8 6h8M6 8v8M18 8v8M8 18h8" />
          </svg>
        </div>
        <div class="icon" data-wb="files" title="Files" aria-label="Files">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 7h5l2 2h11v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z" />
          </svg>
        </div>
        <div class="icon" data-wb="knowledge" title="Knowledge Management" aria-label="Knowledge Management">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3" />
            <path d="M12 1v6" />
            <path d="M12 17v6" />
            <path d="m4.2 4.2 4.2 4.2" />
            <path d="m15.6 15.6 4.2 4.2" />
            <path d="M1 12h6" />
            <path d="M17 12h6" />
            <path d="m4.2 19.8 4.2-4.2" />
            <path d="m15.6 8.4 4.2-4.2" />
          </svg>
        </div>
        <div class="icon" data-wb="requirements" title="Requirements" aria-label="Requirements">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 7h11M9 12h11M9 17h11" />
            <path d="M4 7l1 1 2-2M4 12l1 1 2-2M4 17l1 1 2-2" />
          </svg>
        </div>
        <div class="icon" data-wb="graph" title="GraphDB" aria-label="GraphDB">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <ellipse cx="12" cy="5" rx="8" ry="3" />
            <path d="M4 5v10c0 1.7 3.6 3 8 3s8-1.3 8-3V5" />
            <path d="M4 12c0 1.7 3.6 3 8 3s8-1.3 8-3" />
          </svg>
        </div>
        <div class="icon" data-wb="rag" title="RAG" aria-label="RAG">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="6" />
            <path d="M20 20l-4-4" />
          </svg>
        </div>
        <div class="icon" data-wb="process" title="Process" aria-label="Process">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <rect x="4" y="4" width="8" height="6" rx="1" />
            <rect x="12" y="14" width="8" height="6" rx="1" />
            <path d="M8 10v4M8 14h8M16 14v-4" />
          </svg>
        </div>
        <div class="icon" data-wb="thread" title="Thread" aria-label="Thread">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <rect x="4" y="4" width="16" height="12" rx="2" />
            <path d="M8 16l-4 4v-4" />
            <path d="M8 8h8M8 12h6" />
          </svg>
        </div>
        <div class="icon" data-wb="playground" title="Playground" aria-label="Playground">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 3h6" />
            <path d="M10 3v4l-5 9a3 3 0 0 0 3 5h8a3 3 0 0 0 3-5l-5-9V3" />
            <path d="M8 15h8" />
          </svg>
        </div>
        <div class="icon" data-wb="analysis" title="Analysis" aria-label="Analysis">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 3v18h18" />
            <path d="M18.7 8l-5.1 5.2-2.8-2.7L7 14.3" />
          </svg>
        </div>
        <div class="icon" data-wb="settings" title="Settings" aria-label="Settings">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3" />
            <path
              d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" />
          </svg>
        </div>
        <div class="icon" data-wb="admin" title="Admin" aria-label="Admin">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 3l8 4v6c0 5-5 8-8 8s-8-3-8-8V7l8-4z" />
          </svg>
        </div>
        <div class="icon" data-wb="events" title="Event Manager" aria-label="Event Manager" style="display: none;">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
            <circle cx="9" cy="9" r="2" />
            <path d="m21 15-3.086-3.086a2 2 0 0 0-1.414-.586H13" />
            <circle cx="15" cy="18" r="3" />
            <path d="m21 21-1.5-1.5" />
          </svg>
        </div>
      </nav>

      <aside class="tree" id="treePanel" aria-label="Project Tree">
        <div class="tree-header">
          <div class="tree-header-left">
            <select id="projectSelect2" title="Active project"></select>
            <button class="btn" id="addNodeBtn" title="New Project">＋</button>
          </div>
          <button id="treeToggle" class="btn tree-toggle" title="Toggle Tree Dock" aria-label="Toggle Tree Dock">
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M15 18l-6-6 6-6" />
            </svg>
          </button>
        </div>
        <div class="tree-scroll">
          <nav class="treeview" aria-label="Project">
            <ul role="tree" id="treeRoot" aria-label="Project tree"></ul>
          </nav>
        </div>
      </aside>
      <!-- Project context menu -->
      <div id="projectContextMenu"
        style="position:absolute; display:none; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding:4px; z-index: 9999; min-width: 220px;">
        <button id="projRenameBtn" class="btn"
          style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Rename
          Project…</button>
        <button id="projArchiveBtn" class="btn"
          style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Archive
          Project</button>
        <button id="projDeleteBtn" class="btn"
          style="width:100%; text-align:left; background:none; border:none; padding:8px; color:#ef4444;">Delete
          Project</button>
        <hr style="border:none; border-top:1px solid var(--border); margin:6px 0;" />
        <button id="projShowArchivedBtn" class="btn"
          style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Archived…</button>
      </div>

      <!-- Ontology context menu -->
      <div id="ontologyContextMenu"
        style="position:absolute; display:none; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding:4px; z-index: 9999; min-width: 220px;">
        <button id="ontoRenameBtn" class="btn"
          style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Rename
          Ontology…</button>
        <button id="ontoToggleReferenceBtn" class="btn"
          style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Toggle
          Reference Status</button>
        <button id="ontoDeleteBtn" class="btn"
          style="width:100%; text-align:left; background:none; border:none; padding:8px; color:#ef4444;">Delete
          Ontology</button>
      </div>

      <div class="resizer" id="resizer" aria-hidden="true"></div>

      <main class="main">
        <section id="wb-ontology" class="workbench">
          <div class="ontology-header">
            <!-- Graph Info and Title -->
            <div class="header-left">
              <h2 class="workbench-title">Ontology Workbench</h2>
              <span id="ontoGraphLabel" class="graph-label">No graph selected</span>
            </div>

            <!-- Menu Bar -->
            <div class="header-menu">
              <div class="menu-group">
                <button class="menu-btn" id="ontoLayoutMenuBtn">
                  <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                    stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                    <line x1="9" y1="9" x2="15" y2="9" />
                    <line x1="9" y1="15" x2="15" y2="15" />
                  </svg>
                  Layout
                </button>
                <div class="menu-dropdown" id="ontoLayoutMenu">
                  <div class="menu-section">
                    <div class="menu-label">Layout Algorithm</div>
                    <select id="ontoLayoutSelector" class="menu-select">
                      <option value="cose">Force-Directed (CoSE)</option>
                      <option value="dagre">Hierarchical (Dagre)</option>
                      <option value="concentric">Concentric</option>
                      <option value="breadthfirst">Breadthfirst</option>
                      <option value="circle">Circle</option>
                      <option value="grid">Grid</option>
                      <option value="cola">Constraint-Based</option>
                      <option value="spread">Spread</option>
                    </select>
                    <button class="menu-item" id="ontoLayoutBtn">Apply Layout</button>
                  </div>
                  <div class="menu-divider"></div>
                  <div class="menu-section">
                    <button class="menu-item" id="ontoQuickCoseBtn">Quick CoSE</button>
                    <button class="menu-item" id="ontoQuickDagreBtn">Quick Dagre</button>
                  </div>
                </div>
              </div>

              <div class="menu-group">
                <button class="menu-btn" id="ontoViewMenuBtn">
                  <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
                    <circle cx="12" cy="12" r="3" />
                  </svg>
                  View
                </button>
                <div class="menu-dropdown" id="ontoViewMenu">
                  <button class="menu-item" id="ontoFitBtn">Fit to View</button>
                  <button class="menu-item" id="ontoFullscreenBtn">Fullscreen</button>
                  <button class="menu-item" id="ontoForceRefreshBtn">Refresh</button>
                  <div class="menu-divider"></div>
                  <button class="menu-item" id="ontoClearCacheBtn">Clear Cache</button>
                </div>
              </div>

              <!-- CAD Tools Menu -->
              <div class="menu-group">
                <button class="menu-btn" id="cadToolsMenuBtn">
                  <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path
                      d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />
                  </svg>
                  Tools
                </button>
                <div class="menu-dropdown" id="cadToolsMenu">
                  <div class="menu-section">
                    <div class="menu-label">Grid Settings</div>
                    <button class="menu-item" id="snapGridBtn" onclick="toggleSnapToGrid()">
                      <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                        <path d="M9 9h.01M15 9h.01M9 15h.01M15 15h.01" />
                      </svg>
                      <span id="snapGridStatus">Grid Snap: ON</span>
                    </button>
                    <div style="display: flex; align-items: center; gap: 8px; padding: 4px 12px;">
                      <label style="font-size: 11px; color: var(--muted); min-width: 60px;">Grid Size:</label>
                      <select id="gridSizeSelector" onchange="updateGridSize(this.value)"
                        style="flex: 1; font-size: 11px; background: var(--panel); color: var(--text); border: 1px solid var(--border); border-radius: 3px; padding: 2px;">
                        <option value="10">Fine (10px)</option>
                        <option value="20" selected>Normal (20px)</option>
                        <option value="40">Coarse (40px)</option>
                        <option value="80">Large (80px)</option>
                        <option value="custom">Custom...</option>
                      </select>
                    </div>
                  </div>
                  <div class="menu-divider"></div>
                  <div class="menu-section">
                    <div class="menu-label">Align</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;">
                      <button class="btn btn-sm" onclick="alignElements('left')" title="Align Left (Ctrl+L)">⇤</button>
                      <button class="btn btn-sm" onclick="alignElements('center')" title="Center (Ctrl+M)">⬌</button>
                      <button class="btn btn-sm" onclick="alignElements('right')"
                        title="Align Right (Ctrl+R)">⇥</button>
                      <button class="btn btn-sm" onclick="alignElements('top')" title="Align Top (Ctrl+T)">⇈</button>
                      <button class="btn btn-sm" onclick="alignElements('distribute-vertical')"
                        title="Distribute V">⬍</button>
                      <button class="btn btn-sm" onclick="alignElements('bottom')"
                        title="Align Bottom (Ctrl+B)">⇊</button>
                    </div>
                    <button class="menu-item" onclick="alignElements('distribute-horizontal')"
                      title="Distribute Horizontal (Ctrl+Shift+H)">
                      <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6">
                        <rect x="4" y="6" width="3" height="12" />
                        <rect x="10" y="6" width="4" height="12" />
                        <rect x="17" y="6" width="3" height="12" />
                      </svg>
                      Distribute Horizontal
                    </button>
                  </div>
                  <div class="menu-divider"></div>
                  <div class="menu-section">
                    <div class="menu-label">Edit</div>
                    <button class="menu-item" onclick="copySelectedElements()" title="Copy (Ctrl+C)">
                      <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
                      </svg>
                      Copy Selected
                    </button>
                    <button class="menu-item" onclick="pasteElements()" title="Paste (Ctrl+V)">
                      <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6">
                        <rect x="8" y="2" width="8" height="4" rx="1" ry="1" />
                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />
                      </svg>
                      Paste
                    </button>
                    <button class="menu-item" onclick="performUndo()" title="Undo (Ctrl+Z)">
                      <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6">
                        <path d="M3 7v6h6" />
                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
                      </svg>
                      Undo
                    </button>
                    <button class="menu-item" onclick="performRedo()" title="Redo (Ctrl+Y)">
                      <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6">
                        <path d="M21 7v6h-6" />
                        <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7" />
                      </svg>
                      Redo
                    </button>
                  </div>
                  <div class="menu-divider"></div>
                  <div class="menu-section">
                    <div class="menu-label">View</div>
                    <button class="menu-item" onclick="zoomToSelection()" title="Zoom to Selection (Ctrl+F)">
                      <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6">
                        <circle cx="11" cy="11" r="8" />
                        <path d="M21 21l-4.35-4.35" />
                        <rect x="8" y="8" width="6" height="6" />
                      </svg>
                      Zoom to Selection
                    </button>
                    <button class="menu-item" onclick="zoomToFitAll()" title="Fit All (F)">
                      <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6">
                        <path
                          d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
                      </svg>
                      Fit All
                    </button>
                    <button class="menu-item" onclick="zoomTo100Percent()" title="100% Zoom (Ctrl+1)">
                      <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6">
                        <circle cx="12" cy="12" r="8" />
                        <text x="12" y="16" text-anchor="middle" font-size="8" fill="currentColor">1:1</text>
                      </svg>
                      100% Zoom
                    </button>
                  </div>
                </div>
              </div>

              <div class="menu-group">
                <button class="menu-btn" id="ontoEditMenuBtn">
                  <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" />
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" />
                  </svg>
                  Edit
                </button>
                <div class="menu-dropdown" id="ontoEditMenu">
                  <button class="menu-item" id="ontoDeleteBtn">Delete Selected</button>
                  <button class="menu-item" id="ontoLinkIdenticalBtn">Link Identical Classes</button>
                </div>
              </div>

              <div class="menu-group">
                <button class="menu-btn" id="ontoFileMenuBtn">
                  <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                    <polyline points="14,2 14,8 20,8" />
                  </svg>
                  File
                </button>
                <div class="menu-dropdown" id="ontoFileMenu">
                  <button class="menu-item" id="ontoSaveBtn">Save Ontology</button>
                  <div class="menu-divider"></div>
                  <button class="menu-item" id="ontoImportBtn">Import JSON</button>
                  <button class="menu-item" id="ontoExportBtn">Export JSON</button>
                  <input type="file" id="ontoImportFile" accept="application/json" style="display:none" />
                </div>
              </div>
            </div>
          </div>

          <!-- Workbench Tabs -->
          <div class="workbench-tabs">
            <button class="workbench-tab active" id="ontologyTab" onclick="switchWorkbenchTab('ontology')">
              🧠 Ontologies
            </button>
            <button class="workbench-tab" id="individualsTab" onclick="switchWorkbenchTab('individuals')">
              📋 Individuals
            </button>
          </div>

          <div id="ontoEmpty" class="card onto-empty-state">
            Create or Select an Ontology to begin
          </div>
          <div class="onto-layout" id="ontoLayoutSection">
            <aside class="onto-tree" aria-label="Ontology Tree">
              <div class="onto-tree-header" id="ontoTreeHeader">
                <div class="muted">Ontology</div>
                <div class="onto-tree-controls">
                  <button class="iconbtn" id="ontoTreeToggle" title="Collapse">
                    <svg id="ontoTreeToggleIcon" viewBox="0 0 24 24" fill="none" stroke-width="1.6"
                      stroke-linecap="round" stroke-linejoin="round">
                      <path d="M15 6l-6 6 6 6" />
                    </svg>
                  </button>
                </div>
              </div>
              <div class="onto-tree-scroll">
                <nav class="onto-treeview" aria-label="Ontology">
                  <ul role="tree" id="ontoTreeRoot" aria-label="Ontology tree"></ul>
                </nav>
              </div>
            </aside>
            <div class="onto-resizer" id="ontoResizer" aria-hidden="true"></div>
            <aside class="onto-iconbar" aria-label="Ontology Tools">
              <div class="onto-icon" draggable="true" data-onto-type="class" title="Class">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="6" y="6" width="12" height="12" rx="2" />
                </svg>
              </div>
              <div class="onto-icon" draggable="true" data-onto-type="dataProperty" title="Data Property">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="7" cy="12" r="3" />
                  <rect x="14" y="9" width="6" height="6" rx="1" />
                </svg>
              </div>
              <div class="onto-icon" draggable="true" data-onto-type="note" title="Note">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M4 4h12l4 4v12H4z" />
                  <path d="M16 4v4h4" />
                </svg>
              </div>
            </aside>
            <div id="cy" role="application" aria-label="Ontology Graph Canvas"></div>
            <div class="onto-resizer" id="ontoPropsResizer" aria-hidden="true"></div>
            <aside class="onto-props" aria-label="Properties Panel">
              <div class="onto-props-header" id="ontoPropsHeader">
                <div class="muted">Properties</div>
                <button class="iconbtn" id="ontoPropsToggle" title="Collapse">
                  <svg id="ontoPropsToggleIcon" viewBox="0 0 24 24" fill="none" stroke-width="1.6"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 6l6 6-6 6" />
                  </svg>
                </button>
              </div>
              <div class="onto-props-scroll">
                <form id="ontoPropsForm" class="props-form">
                  <!-- Basic Properties -->
                  <div class="props-section">
                    <h4 class="props-section-title">Basic Properties</h4>
                    <div class="form-group">
                      <label class="form-label" for="propName">Name</label>
                      <input id="propName" type="text" class="form-input" placeholder="Enter name..." />
                    </div>
                    <div class="form-group">
                      <label class="form-label" for="propType">Type</label>
                      <div id="propType" class="form-text-display">
                        <span id="propTypeValue">Class</span>
                      </div>
                    </div>
                  </div>

                  <!-- SHACL Constraints (for Object and Datatype Properties) -->
                  <div id="shaclConstraintsSection" class="props-section" style="display: none;">
                    <h4 class="props-section-title">SHACL Constraints</h4>

                    <!-- Multiplicity (for Object Properties) -->
                    <div id="multiplicitySubsection">
                      <h5 style="font-size: 12px; color: var(--muted); margin: 10px 0 6px 0;">Multiplicity</h5>
                      <div class="form-group">
                        <label class="form-label">Quick Presets</label>
                        <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                          <button type="button" class="btn btn-sm" data-multiplicity="none">None</button>
                          <button type="button" class="btn btn-sm" data-multiplicity="1">Exactly (1)</button>
                          <button type="button" class="btn btn-sm" data-multiplicity="0..1">Zero or one (0..1)</button>
                          <button type="button" class="btn btn-sm" data-multiplicity="0..*">Zero or more (0..*)</button>
                          <button type="button" class="btn btn-sm" data-multiplicity="1..*">One or more (1..*)</button>
                        </div>
                      </div>
                      <div class="form-group">
                        <label class="form-label" for="propMinCount">Minimum Count</label>
                        <input id="propMinCount" type="number" class="form-input" min="0"
                          placeholder="Leave empty for no minimum" />
                      </div>
                      <div class="form-group">
                        <label class="form-label" for="propMaxCount">Maximum Count</label>
                        <input id="propMaxCount" type="number" class="form-input" min="0"
                          placeholder="Leave empty for unlimited" />
                      </div>
                      <div class="form-group">
                        <label class="form-label">Multiplicity Display</label>
                        <div id="multiplicityDisplay" class="form-text-display"
                          style="font-family: monospace; font-weight: bold; color: var(--accent);">
                          No constraints
                        </div>
                      </div>
                    </div>

                    <!-- Datatype Constraints (for Datatype Properties) -->
                    <div id="datatypeSubsection">
                      <h5 style="font-size: 12px; color: var(--muted); margin: 15px 0 6px 0;">Datatype Validation</h5>
                      <div class="form-group">
                        <label class="form-label" for="propDatatypeConstraint">Required Datatype</label>
                        <select id="propDatatypeConstraint" class="form-input">
                          <option value="">No constraint</option>
                          <option value="xsd:string">String (text)</option>
                          <option value="xsd:integer">Integer (whole numbers)</option>
                          <option value="xsd:decimal">Decimal (numbers with fractions)</option>
                          <option value="xsd:double">Double (floating-point)</option>
                          <option value="xsd:boolean">Boolean (true/false)</option>
                          <option value="xsd:date">Date (YYYY-MM-DD)</option>
                          <option value="xsd:dateTime">DateTime (YYYY-MM-DDTHH:MM:SS)</option>
                          <option value="xsd:time">Time (HH:MM:SS)</option>
                          <option value="xsd:anyURI">URI/URL</option>
                        </select>
                      </div>
                      <div class="form-group">
                        <label class="form-label">Datatype Display</label>
                        <div id="datatypeDisplay" class="form-text-display"
                          style="font-family: monospace; color: var(--accent);">
                          No datatype constraint
                        </div>
                      </div>
                    </div>

                    <!-- Enumeration Constraints -->
                    <div id="enumerationSubsection">
                      <h5 style="font-size: 12px; color: var(--muted); margin: 15px 0 6px 0;">Valid Values (Enumeration)
                      </h5>
                      <div class="form-group">
                        <label class="form-label">Quick Presets</label>
                        <div style="display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 8px;">
                          <button type="button" class="btn btn-sm" data-enumeration="requirement-status">Req
                            Status</button>
                          <button type="button" class="btn btn-sm" data-enumeration="criticality">Criticality</button>
                          <button type="button" class="btn btn-sm" data-enumeration="risk-level">Risk Level</button>
                          <button type="button" class="btn btn-sm" data-enumeration="priority">Priority</button>
                          <button type="button" class="btn btn-sm" data-enumeration="custom">Custom...</button>
                        </div>
                      </div>
                      <div class="form-group">
                        <label class="form-label" for="propEnumerationValues">Valid Values</label>
                        <textarea id="propEnumerationValues" class="form-input" rows="3"
                          placeholder="Enter valid values (one per line):&#10;Draft&#10;Reviewed&#10;Approved"></textarea>
                        <small style="color: var(--muted); font-size: 11px;">One value per line</small>
                      </div>
                      <div class="form-group">
                        <label class="form-label">Enumeration Display</label>
                        <div id="enumerationDisplay" class="form-text-display"
                          style="font-family: monospace; color: var(--accent);">
                          No enumeration constraint
                        </div>
                      </div>
                    </div>

                    <!-- Constraint Summary -->
                    <div class="form-group"
                      style="margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--border);">
                      <label class="form-label">All Constraints Preview</label>
                      <div id="allConstraintsDisplay" class="form-text-display"
                        style="font-family: monospace; font-size: 11px; line-height: 1.4; color: var(--text);">
                        No constraints defined
                      </div>
                    </div>
                  </div>

                  <!-- CAD-like Precise Positioning (for nodes only) -->
                  <div id="positioningSection" class="props-section" style="display: none;">
                    <h4 class="props-section-title">Precise Positioning</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                      <div class="form-group">
                        <label class="form-label" for="propPosX">X Coordinate</label>
                        <input id="propPosX" type="number" class="form-input" step="1" placeholder="X position" />
                      </div>
                      <div class="form-group">
                        <label class="form-label" for="propPosY">Y Coordinate</label>
                        <input id="propPosY" type="number" class="form-input" step="1" placeholder="Y position" />
                      </div>
                    </div>
                    <div class="form-group">
                      <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                        <button type="button" class="btn btn-sm" onclick="snapNodeToGrid()">Snap to Grid</button>
                        <button type="button" class="btn btn-sm" onclick="centerNodeInView()">Center in View</button>
                      </div>
                    </div>
                  </div>

                  <!-- Annotations -->
                  <div class="props-section">
                    <div class="props-section-header">
                      <h4 class="props-section-title">Annotations</h4>
                      <div class="props-section-actions">
                        <button type="button" id="addAttrBtn" class="btn btn-sm">+ Add</button>
                        <button type="button" id="resetAttrsBtn" class="btn btn-sm">Reset</button>
                      </div>
                    </div>
                    <div id="propAttrsContainer" class="attrs-container">
                      <!-- Dynamic annotation fields will be inserted here -->
                    </div>
                  </div>

                  <!-- Actions -->
                  <div class="props-actions">
                    <button type="button" class="btn btn-primary" id="propSaveBtn">Save Changes</button>
                    <span id="propSaveStatus" class="save-status"></span>
                  </div>
                </form>
              </div>
            </aside>
          </div>
          <input id="ontoInlineEdit" type="text" />
          <div id="ontoContextMenu" class="onto-menu">
            <div class="menu-section">
              <button id="menuAddRel" class="menu-item">
                <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                  stroke-linejoin="round">
                  <circle cx="7" cy="12" r="3" />
                  <circle cx="17" cy="12" r="3" />
                  <path d="M10 12h4" />
                </svg>
                Add Relationship
              </button>
              <button id="menuAddDataProp" class="menu-item">
                <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                  stroke-linejoin="round">
                  <circle cx="7" cy="12" r="3" />
                  <rect x="14" y="9" width="6" height="6" rx="1" />
                </svg>
                Add Data Property
              </button>
            </div>
            <div class="menu-divider"></div>
            <div class="menu-section">
              <button id="menuCancel" class="menu-item menu-item-secondary">Cancel</button>
            </div>
          </div>

          <!-- Edge Context Menu for Multiplicity -->
          <div id="edgeContextMenu" class="onto-menu">
            <div class="menu-header"
              style="padding: 8px 12px; background: var(--panel-1); font-weight: 600; border-bottom: 1px solid var(--border); border-radius: 8px 8px 0 0; margin: -4px 0 4px;">
              <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                stroke-linejoin="round" style="display: inline; vertical-align: middle; margin-right: 6px;">
                <path d="M3 12h18M12 3v18" />
              </svg>
              Multiplicity Constraint
            </div>
            <div class="menu-section">
              <button data-action="mult-none" class="menu-item">
                <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                  stroke-linejoin="round">
                  <path d="M18 6L6 18M6 6l12 12" />
                </svg>
                No constraint
              </button>
              <button data-action="mult-1" class="menu-item">
                <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                  stroke-linejoin="round">
                  <path d="M10 2v20M16 8l-4-4-4 4" />
                </svg>
                Exactly one (1)
              </button>
              <button data-action="mult-0-1" class="menu-item">
                <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                  stroke-linejoin="round">
                  <path d="M8 12h8M16 8l-4-4-4 4" />
                </svg>
                Zero or one (0..1)
              </button>
              <button data-action="mult-0-*" class="menu-item">
                <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                  stroke-linejoin="round">
                  <path d="M12 2v10M8 18h8" />
                </svg>
                Zero or more (0..*)
              </button>
              <button data-action="mult-1-*" class="menu-item">
                <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                  stroke-linejoin="round">
                  <path d="M10 2v10M14 18h-8" />
                </svg>
                One or more (1..*)
              </button>
              <button data-action="mult-custom" class="menu-item">
                <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                  stroke-linejoin="round">
                  <path d="M12 2v20M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6" />
                </svg>
                Custom range...
              </button>
            </div>
            <div class="menu-divider"></div>
            <div class="menu-section">
              <button data-action="edit-edge" class="menu-item">
                <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round"
                  stroke-linejoin="round">
                  <path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z" />
                </svg>
                Edit relationship
              </button>
              <button id="edgeMenuCancel" class="menu-item menu-item-secondary">Cancel</button>
            </div>
          </div>

          <!-- Element IRI Display at bottom - fixed height -->
          <div id="ontoElementIriContainer" class="iri-display">
            <div class="iri-content">
              <span class="iri-label">IRI:</span>
              <span id="ontoElementIri" class="iri-value" title="Click to copy IRI to clipboard">No element
                selected</span>
              <button id="ontoCopyIriBtn" class="btn btn-sm iri-copy-btn" title="Copy IRI to clipboard">Copy</button>
            </div>
          </div>

          <!-- Individual Tables Content Area -->
          <div id="individualsContent" class="individuals-content">
            <div class="individuals-tabs-nav">
              <div id="individualsTabList" class="individuals-tab-list">
                <div style="padding: 20px; text-align: center; color: var(--muted);">Loading...</div>
              </div>
            </div>
            <div class="individuals-table-area">
              <div id="individualsTableContent">
                <div style="padding: 40px; text-align: center; color: var(--muted);">
                  <h3>Individual Tables</h3>
                  <p>Select an ontology to view its individual instances</p>
                </div>
              </div>
            </div>
          </div>

        </section>
        <section id="wb-files" class="workbench">
          <h2>File Management</h2>
          <div class="muted">Upload requirements and knowledge docs (MinIO).</div>
          <div class="card" style="margin-top:8px;">
            <div class="muted" style="font-weight:600; margin-bottom:6px;">How it works</div>
            <ol style="margin:0; padding-left:18px; color:#9aa4b2;">
              <li>Upload files (drag & drop or choose files)</li>
              <li>Files are automatically processed for knowledge</li>
              <li>View processing status in the Library section</li>
            </ol>
          </div>
          <div id="filesToast" class="muted" style="margin-top:6px;"></div>
          <div class="files-toolbar" style="display:flex; gap:8px; align-items:center; margin:10px 0; flex-wrap:wrap;">
            <label class="muted" for="filesDocType">Type</label>
            <select id="filesDocType"
              style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
              <option value="">All Types</option>
              <option value="requirements">Requirements</option>
              <option value="knowledge">Knowledge</option>
              <option value="reference">Reference</option>
              <option value="specification">Specification</option>
              <option value="unknown">Unknown</option>
            </select>
            <label class="muted" for="filesStatus">Status</label>
            <select id="filesStatus"
              style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
              <option value="">Any</option>
              <option value="new">New</option>
              <option value="ingested">Ingested</option>
              <option value="embedded">Embedded</option>
            </select>
            <input id="filesTags" type="text" placeholder="tags (comma)"
              style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px; min-width:200px;" />
            <label class="muted"><input type="checkbox" id="filesIncludePublic" /> Include public files</label>
            <button class="btn" id="filesRefreshBtn" title="Refresh">Refresh</button>
            <div class="spacer"></div>
            <button class="btn" id="filesBulkProcessBtn" title="Extract requirements using BPMN workflows">📋 Extract
              Requirements</button>
            <button class="btn" id="filesBulkDeleteBtn" title="Delete selected">Delete Selected</button>

          </div>

          <div class="card" style="margin-top:8px;">
            <div class="muted">Upload or import by URL</div>
            <div style="display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap;">
              <input type="file" id="fileUploadInput" multiple style="display:none" />
              <button class="btn" id="fileChooseBtn" type="button">Choose Files</button>
              <input id="fileUrlInput" type="url" placeholder="https://example.com/doc.pdf"
                style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px; min-width:320px;" />
              <button class="btn" id="fileUrlImportBtn">Import URL</button>
            </div>
            <div id="fileDropZone" tabindex="0" role="button" aria-label="Drop files or click to select"
              style="margin-top:10px; border:2px dashed var(--border); border-radius:8px; padding:20px; text-align:center; color:#9aa4b2; user-select:none; cursor:pointer; background:rgba(15, 22, 40, 0.3); transition:all 0.2s ease;">
              Drag & drop files here, or use the Choose Files button above

            </div>
            <div id="uploadPreview" class="muted" style="margin-top:6px;"></div>
          </div>

          <div id="filesMainContainer" class="card"
            style="margin-top:10px; display:grid; gap:0; align-items:stretch; transition: grid-template-columns 0.3s ease;">
            <div style="display:grid; gap:10px;">
              <div>
                <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                  <div class="muted">Staged files</div>
                  <div style="display:flex; gap:8px; align-items:center;">
                    <button class="btn" id="filesUploadAllBtn" type="button">Upload All</button>
                    <button class="btn" id="filesClearStagedBtn" type="button">Clear</button>
                  </div>
                </div>

                <!-- Document Type Selector for Staged Files -->
                <div id="stagedDocTypeSelector"
                  style="display:none; margin:6px 0; padding:8px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px;">
                  <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                    <span class="muted" style="font-size:12px;">Set document type for upload:</span>
                    <select id="stagedDocType"
                      style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:4px 8px; font-size:12px;">
                      <option value="unknown">Unknown</option>
                      <option value="requirements">Requirements</option>
                      <option value="knowledge">Knowledge</option>
                      <option value="reference">Reference</option>
                      <option value="specification">Specification</option>
                      <option value="analysis_template">Analysis Template</option>
                    </select>
                    <button class="btn" id="setStagedDocType" style="padding:4px 8px; font-size:12px;">Apply to All
                      Staged</button>
                    <button class="btn" id="knowledgeProcessingInfoBtn"
                      style="padding:4px 8px; font-size:12px; background:#3b82f6; color:#93c5fd;"
                      title="Knowledge Processing Guidance">ℹ️ Info</button>
                    <span class="muted" style="font-size:11px;" id="stagedDocTypeHint">Files will be uploaded with this
                      document type</span>
                  </div>
                </div>

                <!-- Automatic Knowledge Processing Options -->
                <div id="knowledgeProcessingOptions"
                  style="display:none; margin:6px 0; padding:8px; background:rgba(34, 197, 94, 0.1); border:1px solid #22c55e; border-radius:6px;">
                  <div style="margin-bottom:8px;">
                    <div class="muted"
                      style="font-size:11px; color:var(--muted); display:flex; align-items:center; gap:4px;">
                      Files are processed for knowledge with intelligent defaults
                      <button id="knowledgeProcessingInfoBtn" class="btn"
                        style="padding:2px 4px; font-size:10px; background:transparent; border:1px solid var(--border); color:var(--muted);"
                        title="Learn about chunking strategies and embedding models">ℹ️</button>
                    </div>
                  </div>
                  <div id="knowledgeProcessingConfig" style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                    <div>
                      <label class="muted" style="font-size:10px; display:block; margin-bottom:2px;">Embedding
                        Model:</label>
                      <div style="display:flex; gap:4px; align-items:center;">
                        <select id="embeddingModel"
                          style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:4px; padding:2px 4px; font-size:10px; flex:1;">
                          <option value="all-MiniLM-L6-v2">all-MiniLM-L6-v2 (Fast)</option>
                          <option value="all-mpnet-base-v2">all-mpnet-base-v2 (Better)</option>
                        </select>
                        <button id="embeddingModelInfoBtn" class="btn"
                          style="padding:2px 4px; font-size:10px; background:transparent; border:1px solid var(--border); color:var(--muted);"
                          title="Learn about embedding models">ℹ️</button>
                      </div>
                    </div>
                    <div>
                      <label class="muted" style="font-size:10px; display:block; margin-bottom:2px;">Chunking
                        Strategy:</label>
                      <div style="display:flex; gap:4px; align-items:center;">
                        <select id="chunkingStrategy"
                          style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:4px; padding:2px 4px; font-size:10px; flex:1;">
                          <option value="">Smart Default</option>
                          <option value="hybrid">Hybrid</option>
                          <option value="semantic">Semantic</option>
                          <option value="fixed">Fixed Size</option>
                        </select>
                        <button id="chunkingStrategyInfoBtn" class="btn"
                          style="padding:2px 4px; font-size:10px; background:transparent; border:1px solid var(--border); color:var(--muted);"
                          title="Learn about chunking strategies">ℹ️</button>
                      </div>
                    </div>
                  </div>
                </div>

                <div id="stagedList" style="display:grid; gap:6px; margin-top:6px;"></div>
              </div>
              <div>
                <div class="muted" style="margin-bottom:6px;">Library</div>
                <div id="filesList" style="display:block; overflow:auto;"></div>
              </div>
            </div>
            <div style="width:8px; cursor:col-resize;" id="filesSplitResizer" aria-hidden="true"></div>
            <aside id="filePreviewPane" style="border-left:1px solid var(--border); padding-left:10px; overflow:auto;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                <div class="muted">Preview</div>
                <div id="previewControls" style="display:flex; gap:6px; align-items:center;">
                  <button class="btn" id="previewFullscreenBtn" title="Fullscreen preview"
                    style="min-width:auto; padding:6px 8px; font-size:14px; background:var(--panel-2); border:1px solid var(--border); color:var(--text);">⛶</button>
                  <button class="btn" id="previewPopoutBtn" title="Open in new window"
                    style="display:none; min-width:auto; padding:6px 8px; font-size:14px; background:var(--panel-2); border:1px solid var(--border); color:var(--text);">↗</button>
                </div>
              </div>
              <div id="fileMetaBox" class="card" style="margin-bottom:8px;">
                <div class="muted">Metadata</div>
                <div id="fileMetaContent" class="muted">Select a file to see metadata.</div>
              </div>
              <div class="card">
                <div class="muted" style="margin-bottom:6px;">Content</div>
                <div id="filePreviewContent" class="muted">Select a file to preview.</div>
              </div>
              <div class="card" style="margin-top:8px;">
                <div class="muted" style="margin-bottom:6px;">Recent Runs</div>
                <div id="fileRunsContent" class="muted">No runs yet.</div>
              </div>
            </aside>
          </div>
        </section>

        <!-- Files: Ingestion Params Modal -->
        <div id="ingestParamsModal"
          style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); z-index:9999;">
          <div
            style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:10px; width:460px; max-width:90vw; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,0.4);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <h3 style="margin:0; font-size:16px;">🧠 Knowledge Processing Parameters</h3>
              <button class="btn" id="ingestParamsCloseBtn" style="min-width:auto;">✕</button>
            </div>
            <div style="display:grid; gap:10px;">
              <div style="display:grid; gap:6px;">
                <label class="muted">Chunking</label>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                  <div>
                    <label class="muted" for="ing_chunk_size">Size (tokens)</label>
                    <input id="ing_chunk_size" type="number" value="350" min="50" max="2000" step="10"
                      style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;" />
                  </div>
                  <div>
                    <label class="muted" for="ing_chunk_overlap">Overlap (tokens)</label>
                    <input id="ing_chunk_overlap" type="number" value="50" min="0" max="500" step="5"
                      style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;" />
                  </div>
                </div>
                <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
                  <label><input type="checkbox" id="ing_respect_headings" checked /> Respect headings</label>
                  <label><input type="checkbox" id="ing_join_short" checked /> Join short paragraphs</label>
                  <label><input type="checkbox" id="ing_split_code" checked /> Split code blocks</label>
                </div>
              </div>
              <div style="display:grid; gap:6px;">
                <label class="muted">Embedding</label>
                <select id="ing_model_id"
                  style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
                  <option value="simple-hasher">Simple Hasher (Testing)</option>
                  <option value="all-MiniLM-L6-v2" selected>all-MiniLM-L6-v2 (384 dim)</option>
                  <option value="all-mpnet-base-v2">all-mpnet-base-v2 (768 dim)</option>
                  <option value="text-embedding-3-small">OpenAI text-embedding-3-small (1536 dim)</option>
                  <option value="text-embedding-3-large">OpenAI text-embedding-3-large (3072 dim)</option>
                </select>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                  <div>
                    <label class="muted" for="ing_batch_size">Batch size</label>
                    <input id="ing_batch_size" type="number" value="64" min="1" max="1000" step="1"
                      style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;" />
                  </div>
                  <div style="display:flex; align-items:center; padding-top:20px;">
                    <label><input type="checkbox" id="ing_normalize" checked /> Normalize vectors</label>
                  </div>
                </div>
              </div>
              <div style="display:flex; gap:8px; justify-content:flex-end;">
                <button class="btn" id="ingestParamsCancelBtn" style="background: var(--muted);">Cancel</button>
                <button class="btn" id="ingestParamsStartBtn">Start</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Fullscreen Preview Modal -->
        <div id="previewFullscreenModal"
          style="position:fixed; inset:0; display:none; background:rgba(0,0,0,0.95); z-index:10000; padding:20px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <div id="fullscreenPreviewTitle" style="color:#e5e7eb; font-weight:600; font-size:16px;">Document Preview
            </div>
            <div style="display:flex; gap:8px;">
              <button class="btn" id="fullscreenPopoutBtn" title="Open in new window"
                style="display:none; min-width:auto; padding:6px 12px;">↗ Popout</button>
              <button class="btn" id="fullscreenCloseBtn" title="Close fullscreen"
                style="min-width:auto; padding:6px 12px;">✕ Close</button>
            </div>
          </div>
          <div id="fullscreenPreviewContent"
            style="width:100%; height:calc(100vh - 80px); background:var(--panel); border:1px solid var(--border); border-radius:8px; overflow:hidden;">
            <!-- Preview content will be cloned here -->
          </div>
        </div>

        <section id="wb-knowledge" class="workbench">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <div>
              <h2>Knowledge Management</h2>
              <div class="muted">All uploaded files are automatically transformed into searchable knowledge with
                AI-powered insights</div>
            </div>
            <div style="display:flex; gap:8px; align-items:center;">
              <button class="btn" id="knowledgeRefreshBtn">Refresh</button>
            </div>
          </div>

          <div
            style="display:grid; grid-template-columns: 2fr 1fr; gap:20px; height:calc(100vh - 140px); max-height:calc(100vh - 140px);">
            <!-- Main Knowledge Area -->
            <div style="display:flex; flex-direction:column; gap:16px; min-height:0;">
              <!-- Knowledge Assets List -->
              <div
                style="flex:1; background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:16px; min-height:0; display:flex; flex-direction:column;">
                <div
                  style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; flex-shrink:0;">
                  <h3 style="margin:0;">Knowledge Assets</h3>
                  <div style="display:flex; gap:8px; align-items:center;">
                    <input type="text" id="knowledgeSearchInput" placeholder="Search knowledge..."
                      style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px 10px; width:200px;" />
                  </div>
                </div>
                <div id="knowledgeAssetsList" style="flex:1; overflow-y:auto; min-height:0;">
                  <div class="muted" style="padding:20px; text-align:center;">
                    No knowledge assets yet.<br />
                    <small>Upload and process documents to begin building your knowledge base.</small>
                  </div>
                </div>
              </div>

              <!-- Processing Status -->
              <div
                style="background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:16px; height:120px; flex-shrink:0;">
                <h4 style="margin:0 0 8px 0;">Processing Status</h4>
                <div id="knowledgeProcessingStatus" style="overflow-y:auto; height:calc(100% - 32px);">
                  <div class="muted">No processing jobs running</div>
                </div>
              </div>
            </div>

            <!-- Knowledge Panel -->
            <div
              style="background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:16px; display:flex; flex-direction:column; min-height:0;">
              <div
                style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; flex-shrink:0;">
                <h4 style="margin:0;">Knowledge Details</h4>
                <div style="display:flex; gap:4px;">
                  <button class="btn" id="knowledgeQueryBtn" title="Query Knowledge"
                    style="min-width:auto; padding:4px 8px; font-size:16px; display:none;">🔍</button>
                  <button class="btn" id="knowledgeGraphBtn" title="View Graph"
                    style="min-width:auto; padding:4px 8px; font-size:16px; display:none;">🕸️</button>
                </div>
              </div>
              <div id="knowledgeDetailsContent" style="flex:1; overflow-y:auto; min-height:0;">
                <div class="muted" style="padding:20px; text-align:center;">
                  Select a knowledge asset to view details
                </div>
              </div>
            </div>
          </div>
        </section>
        <section id="wb-requirements" class="workbench">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <div>
              <h2>Requirements Workbench</h2>
              <div class="muted">Extract, analyze, and manage requirements with DAS AI assistance.</div>
            </div>
            <div style="display:flex; gap:8px;">
              <button id="reqExtractBtn" class="btn btn-primary">
                <svg style="width:16px; height:16px; margin-right:4px;" viewBox="0 0 24 24" fill="none"
                  stroke="currentColor" stroke-width="2">
                  <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                  <polyline points="14,2 14,8 20,8" />
                  <path d="M10 13l2 2 4-4" />
                </svg>
                Extract from Document
              </button>
              <button id="reqCreateBtn" class="btn">
                <svg style="width:16px; height:16px; margin-right:4px;" viewBox="0 0 24 24" fill="none"
                  stroke="currentColor" stroke-width="2">
                  <path d="M12 5v14M5 12h14" />
                </svg>
                New Requirement
              </button>
              <button id="reqImportBtn" class="btn">
                <svg style="width:16px; height:16px; margin-right:4px;" viewBox="0 0 24 24" fill="none"
                  stroke="currentColor" stroke-width="2">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                  <polyline points="14,2 14,8 20,8" />
                  <path d="M3 17l3-3 3 3" />
                  <path d="M6 14v7" />
                </svg>
                Import Requirements
              </button>
              <button id="reqBatchPublishBtn" class="btn btn-success" style="display:none;">
                <svg style="width:16px; height:16px; margin-right:4px;" viewBox="0 0 24 24" fill="none"
                  stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10" />
                  <path d="M12 6v6l4 2" />
                </svg>
                Publish Selected (<span id="selectedCount">0</span>)
              </button>
            </div>
          </div>

          <!-- Filters and Search -->
          <div class="card" style="margin-bottom:16px;">
            <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
              <div style="display:flex; align-items:center; gap:6px;">
                <label style="font-size:12px; font-weight:600;">Search:</label>
                <input id="reqSearchInput" type="text" placeholder="Search requirements..."
                  style="padding:6px 10px; border:1px solid var(--border); border-radius:4px; width:250px;" />
              </div>
              <div style="display:flex; align-items:center; gap:6px;">
                <label style="font-size:12px; font-weight:600;">Type:</label>
                <select id="reqTypeFilter" style="padding:6px; border:1px solid var(--border); border-radius:4px;">
                  <option value="">All Types</option>
                  <option value="functional">Functional</option>
                  <option value="non_functional">Non-Functional</option>
                  <option value="performance">Performance</option>
                  <option value="safety">Safety</option>
                  <option value="security">Security</option>
                  <option value="interface">Interface</option>
                  <option value="operational">Operational</option>
                  <option value="design">Design</option>
                </select>
              </div>
              <div style="display:flex; align-items:center; gap:6px;">
                <label style="font-size:12px; font-weight:600;">Status:</label>
                <select id="reqStateFilter" style="padding:6px; border:1px solid var(--border); border-radius:4px;">
                  <option value="">All States</option>
                  <option value="draft">Draft</option>
                  <option value="review">Review</option>
                  <option value="approved">Approved</option>
                  <option value="published">Published</option>
                  <option value="deprecated">Deprecated</option>
                </select>
              </div>
              <div style="display:flex; align-items:center; gap:6px;">
                <label style="font-size:12px; font-weight:600;">Priority:</label>
                <select id="reqPriorityFilter" style="padding:6px; border:1px solid var(--border); border-radius:4px;">
                  <option value="">All Priorities</option>
                  <option value="critical">Critical</option>
                  <option value="high">High</option>
                  <option value="medium">Medium</option>
                  <option value="low">Low</option>
                </select>
              </div>
              <button id="reqClearFilters" class="btn btn-sm">Clear Filters</button>
              <button id="reqRefreshBtn" class="btn btn-sm">
                <svg style="width:14px; height:14px;" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                  stroke-width="2">
                  <path d="M1 4v6h6M23 20v-6h-6" />
                  <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15" />
                </svg>
                Refresh
              </button>
            </div>
          </div>

          <!-- Requirements Table -->
          <div class="card">
            <div id="requirementsTableHeader"
              style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
              <h3>Requirements</h3>
              <div id="reqTableStats" class="muted" style="font-size:12px;">Loading...</div>
            </div>
            <div id="requirementsTableContainer" style="overflow:auto; max-height:600px;">
              <div id="requirementsLoadingMsg" style="text-align:center; padding:40px; color:var(--muted-color);">
                Loading requirements...
              </div>
            </div>
          </div>

          <!-- Requirement Details Panel -->
          <div id="requirementDetailsPanel" class="card" style="margin-top:16px; display:none;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
              <h3>Requirement Details</h3>
              <div style="display:flex; gap:8px;">
                <button id="reqDASReviewBtn" class="btn btn-primary" style="font-size:12px;">
                  <svg style="width:14px; height:14px; margin-right:4px;" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2">
                    <path d="M9 11l3 3L22 4" />
                    <path d="M21 12c-.12 2.51-.61 4.92-1.44 7.08" />
                    <path d="M16 19.35l-.35.35c-1.96 1.96-5.14 1.96-7.1 0l-.35-.35" />
                  </svg>
                  DAS Review
                </button>
                <button id="reqEditBtn" class="btn" style="font-size:12px;">
                  <svg style="width:14px; height:14px; margin-right:4px;" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" />
                    <path d="M18.5 2.5a2.12 2.12 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" />
                  </svg>
                  Edit
                </button>
                <button id="reqPublishBtn" class="btn btn-success" style="font-size:12px; display:none;">
                  <svg style="width:14px; height:14px; margin-right:4px;" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2">
                    <path d="M12 6v6l4 2" />
                    <circle cx="12" cy="12" r="10" />
                  </svg>
                  Publish
                </button>
                <button id="reqUnpublishBtn" class="btn btn-warning" style="font-size:12px; display:none;">
                  <svg style="width:14px; height:14px; margin-right:4px;" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2">
                    <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />
                    <path d="M10 2h4v4H10z" />
                  </svg>
                  Unpublish
                </button>
                <button id="reqUnimportBtn" class="btn btn-danger" style="font-size:12px; display:none;">
                  <svg style="width:14px; height:14px; margin-right:4px;" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
                    <path d="M10 11v6M14 11v6" />
                  </svg>
                  Un-import
                </button>
                <button id="reqCloseDetails" class="btn" style="font-size:12px;">
                  <svg style="width:14px; height:14px;" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2">
                    <path d="M18 6L6 18M6 6l12 12" />
                  </svg>
                  Close
                </button>
              </div>
            </div>
            <div id="requirementDetailsContent">
              <!-- Content will be populated by JavaScript -->
            </div>
          </div>
        </section>
        <section id="wb-graph" class="workbench">
          <h2>Graph Explorer</h2>
          <div class="muted">Quick look into RDF store (SPARQL).
            <button class="btn" id="btnRefreshSummary" style="margin-left:8px;">Refresh Summary</button>
          </div>
          <div id="graphSummary" class="card" style="margin-top:10px;"></div>
          <div class="card" style="margin-top:10px;">
            <div class="muted">Run SPARQL (SELECT):</div>
            <textarea id="sparqlInput" rows="6"
              style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:8px;">SELECT ?s ?p ?o WHERE { ?s ?p ?o } LIMIT 25</textarea>
            <div style="margin-top:6px; display:flex; gap:8px; align-items:center;">
              <button class="btn" id="btnRunSparql">Run</button>
              <span id="sparqlStatus" class="muted"></span>
            </div>
            <pre id="sparqlResult" style="margin-top:8px; white-space:pre-wrap;"></pre>
          </div>
        </section>
        <section id="wb-rag" class="workbench">
          <h2>RAG</h2>
          <div class="muted">Develop/test BPMN workflows with LLM help.</div>
        </section>
        <section id="wb-process" class="workbench">
          <h2>Process</h2>
          <div class="muted">Manage extraction BPMN processes.</div>
        </section>
        <section id="wb-thread" class="workbench">
          <h2>Thread Manager</h2>
          <div class="muted">Debug and manage DAS project threads, conversation history, and prompt context.</div>

          <div
            style="margin-top: 20px; display: grid; gap: 16px; max-height: calc(100vh - 120px); overflow-y: auto; padding-right: 8px;">
            <!-- Thread Overview -->
            <div class="card">
              <h3>Current Project Thread</h3>
              <div id="thread-overview" style="margin-top: 12px;">
                <div class="muted">Select a project to view thread details</div>
              </div>
            </div>

            <!-- Conversation History -->
            <div class="card">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <h3>Conversation History</h3>
                <button id="refresh-thread-btn" class="btn" style="padding: 4px 8px; font-size: 12px;">
                  Refresh
                </button>
              </div>
              <div id="conversation-list" style="max-height: 400px; overflow-y: auto;">
                <div class="muted">No conversation history loaded</div>
              </div>
            </div>

            <!-- Prompt Inspector -->
            <div class="card">
              <h3>Prompt Inspector</h3>
              <div style="margin-top: 12px;">
                <label style="display: block; margin-bottom: 4px; font-weight: 500;">
                  Select conversation entry to inspect:
                </label>
                <select id="prompt-entry-select"
                  style="width: 100%; padding: 8px; background: var(--panel-2); border: 1px solid var(--border); border-radius: 4px;">
                  <option value="">Select conversation entry...</option>
                </select>
              </div>

              <div id="prompt-details" style="margin-top: 16px; display: none;">
                <div style="margin-bottom: 12px;">
                  <label style="display: block; margin-bottom: 4px; font-weight: 500;">
                    Full Prompt Sent to LLM:
                  </label>
                  <textarea id="prompt-content" readonly style="width: 100%; height: 300px; font-family: monospace; font-size: 12px;
                           background: var(--panel-2); border: 1px solid var(--border); border-radius: 4px;
                           padding: 12px; resize: vertical; color: var(--text) !important;"></textarea>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                  <div>
                    <label style="display: block; margin-bottom: 4px; font-weight: 500;">
                      User Message:
                    </label>
                    <textarea id="user-message-edit" style="width: 100%; height: 80px; background: var(--panel-2); border: 1px solid var(--border);
                             border-radius: 4px; padding: 8px; resize: vertical; color: var(--text);"></textarea>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 4px; font-weight: 500;">
                      DAS Response:
                    </label>
                    <textarea id="das-response-edit" style="width: 100%; height: 80px; background: var(--panel-2); border: 1px solid var(--border);
                             border-radius: 4px; padding: 8px; resize: vertical; color: var(--text);"></textarea>
                  </div>
                </div>

                <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                  <button id="update-entry-btn" class="btn" style="background: var(--accent); color: white;">
                    Update Entry
                  </button>
                  <button id="delete-entry-btn" class="btn" style="background: var(--err); color: white;">
                    Delete Entry
                  </button>
                  <button id="test-prompt-btn" class="btn">
                    Test Custom Prompt
                  </button>
                </div>

                <!-- Context Inspector -->
                <div style="margin-top: 16px;">
                  <label style="display: block; margin-bottom: 4px; font-weight: 500;">
                    RAG & Project Context:
                  </label>
                  <textarea id="context-details" readonly style="width: 100%; height: 150px; font-family: monospace; font-size: 12px;
                           background: var(--panel-2); border: 1px solid var(--border); border-radius: 4px;
                           padding: 12px; resize: vertical; color: var(--text) !important;"></textarea>
                </div>
              </div>
            </div>
          </div>
        </section>
        <section id="wb-playground" class="workbench">
          <h2>LLM Playground</h2>
          <div class="muted">Ask questions, generate white papers, save to project.</div>
        </section>
        <section id="wb-settings" class="workbench">
          <h2>Settings</h2>
          <div class="muted">Application preferences and configuration options.</div>
          <div id="settingsContent">
            <div class="card">
              <h3>General Settings</h3>
              <div class="row">
                <label>Theme</label>
                <select id="themeSelect">
                  <option value="dark">Dark</option>
                  <option value="light">Light</option>
                </select>
              </div>
              <div class="row">
                <label>Language</label>
                <select id="languageSelect">
                  <option value="en">English</option>
                </select>
              </div>
            </div>
            <div class="card">
              <h3>Display Settings</h3>
              <div class="row">
                <label>Tree Width</label>
                <input type="range" id="treeWidthSlider" min="200" max="400" value="300">
                <span id="treeWidthValue">300px</span>
              </div>
            </div>
          </div>
        </section>
        <section id="wb-analysis" class="workbench">
          <h2>Analysis Lab</h2>
          <div class="muted">Interactive Jupyter Lab for data analysis, modeling, and simulation. Test → Validate →
            Release proven assets to Artifacts.</div>

          <!-- Enhanced Jupyter Lab Integration with Dedicated Toolbar -->
          <div id="jupyterLabContainer" class="analysis-container">
            <!-- Jupyter Lab Toolbar -->
            <div class="jupyter-toolbar">
              <!-- Core Jupyter Functions -->
              <div class="icon" title="New Notebook" onclick="createNewNotebook()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                  <polyline points="14,2 14,8 20,8" />
                  <line x1="16" y1="13" x2="8" y2="13" />
                  <line x1="16" y1="17" x2="8" y2="17" />
                </svg>
              </div>
              <div class="icon" title="Open File" onclick="openFile()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                  <polyline points="14,2 14,8 20,8" />
                </svg>
              </div>
              <div class="icon" title="Save" onclick="saveNotebook()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <polyline points="17,21 17,13 7,13 7,21" />
                  <polyline points="7,3 7,8 15,8" />
                </svg>
              </div>
              <div class="icon" title="Run Cell" onclick="runCell()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <polygon points="5,3 19,12 5,21" />
                </svg>
              </div>
              <div class="icon" title="Stop" onclick="stopExecution()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="6" y="6" width="12" height="12" rx="2" />
                </svg>
              </div>
              <div class="icon" title="Restart Kernel" onclick="restartKernel()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                  <path d="M21 3v5h-5" />
                  <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                  <path d="M3 21v-5h5" />
                </svg>
              </div>

              <!-- Separator -->
              <div style="height: 1px; background: var(--border); margin: 8px 4px;"></div>

              <!-- ODRAS Integration -->
              <div class="icon" title="Load ODRAS Data" onclick="loadOdrasData()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path
                    d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z" />
                  <polyline points="3.27,6.96 12,12.01 20.73,6.96" />
                  <line x1="12" y1="22.08" x2="12" y2="12" />
                </svg>
              </div>
              <div class="icon" title="Save to Artifacts" onclick="saveToArtifacts()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                  <polyline points="14,2 14,8 20,8" />
                  <line x1="16" y1="13" x2="8" y2="13" />
                  <line x1="16" y1="17" x2="8" y2="17" />
                  <circle cx="12" cy="12" r="2" />
                </svg>
              </div>
              <div class="icon" title="Export Report" onclick="exportReport()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                  <polyline points="14,2 14,8 20,8" />
                  <line x1="16" y1="13" x2="8" y2="13" />
                  <line x1="16" y1="17" x2="8" y2="17" />
                  <path d="M12 18h.01" />
                </svg>
              </div>
              <div class="icon" title="Link to Project" onclick="linkToProject()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
                  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
                </svg>
              </div>

              <!-- Separator -->
              <div style="height: 1px; background: var(--border); margin: 8px 4px;"></div>

              <!-- Analysis Tools -->
              <div class="icon" title="Quick Plot" onclick="quickPlot()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M3 3v18h18" />
                  <path d="M18.7 8l-5.1 5.2-2.8-2.7L7 14.3" />
                </svg>
              </div>
              <div class="icon" title="ML Templates" onclick="openMLTemplates()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path
                    d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
                </svg>
              </div>
              <div class="icon" title="Simulation" onclick="openSimulation()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="10" />
                  <polygon points="10,8 16,12 10,16 10,8" />
                </svg>
              </div>

              <!-- Separator -->
              <div style="height: 1px; background: var(--border); margin: 8px 4px;"></div>

              <!-- Collaboration -->
              <div class="icon" title="Share" onclick="shareNotebook()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="18" cy="5" r="3" />
                  <circle cx="6" cy="12" r="3" />
                  <circle cx="18" cy="19" r="3" />
                  <line x1="8.59" y1="13.51" x2="15.42" y2="17.49" />
                  <line x1="15.41" y1="6.51" x2="8.59" y2="10.49" />
                </svg>
              </div>
              <div class="icon" title="Templates" onclick="openTemplates()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                  <polyline points="14,2 14,8 20,8" />
                  <line x1="16" y1="13" x2="8" y2="13" />
                  <line x1="16" y1="17" x2="8" y2="17" />
                  <polyline points="10,9 9,9 8,9" />
                </svg>
              </div>
              <div class="icon" title="Help" onclick="showJupyterHelp()">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="10" />
                  <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" />
                  <line x1="12" y1="17" x2="12.01" y2="17" />
                </svg>
              </div>
            </div>

            <!-- Jupyter Lab Canvas -->
            <div class="jupyter-canvas">
              <!-- Jupyter Lab Content Area -->
              <div id="jupyterLabContent" class="jupyter-placeholder">
                <div class="jupyter-placeholder-content">
                  <div class="jupyter-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke-width="1.5" stroke-linecap="round"
                      stroke-linejoin="round">
                      <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                      <path d="M9 9h6v6H9z" />
                      <path d="M9 1v6" />
                      <path d="M15 1v6" />
                      <path d="M9 17v6" />
                      <path d="M15 17v6" />
                      <path d="M1 9h6" />
                      <path d="M17 9h6" />
                      <path d="M1 15h6" />
                      <path d="M17 15h6" />
                    </svg>
                  </div>
                  <h3>Jupyter Lab</h3>
                  <p>Interactive analysis environment for data science, modeling, and simulation</p>
                  <div class="jupyter-actions">
                    <button class="btn" onclick="startJupyterLab()">Launch Jupyter Lab</button>
                    <button class="btn" onclick="showJupyterInfo()">Learn More</button>
                  </div>
                </div>
              </div>

              <!-- Jupyter Lab iframe (hidden by default) -->
              <iframe id="jupyterLabFrame" src="about:blank"
                style="width: 100%; height: 100%; border: none; display: none;" title="Jupyter Lab">
              </iframe>
            </div>
          </div>
        </section>
        <section id="wb-project" class="workbench">
          <h2>Project Information</h2>
          <div class="muted">Current project details and metadata.</div>

          <!-- Project Details Card -->
          <div style="margin-top: 20px;">
            <div id="projectInfoCard"
              style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 20px;">
              <div style="text-align: center; color: var(--muted);">No project selected</div>
            </div>
          </div>
        </section>

        <section id="wb-admin" class="workbench">
          <h2>Admin</h2>
          <div class="muted">Namespace management and system administration.</div>

          <!-- Installation Configuration Section -->
          <div style="margin-top: 20px;">
            <h3 style="margin: 0 0 16px 0; color: var(--text);">Installation Configuration</h3>
            <div id="installationConfig"
              style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                <div>
                  <label><strong>Organization:</strong></label>
                  <div id="configOrganization" class="muted">Loading...</div>
                </div>
                <div>
                  <label><strong>Base URI:</strong></label>
                  <div id="configBaseUri" class="muted">Loading...</div>
                </div>
                <div>
                  <label><strong>Type:</strong></label>
                  <div id="configType" class="muted">Loading...</div>
                </div>
                <div>
                  <label><strong>Program Office:</strong></label>
                  <div id="configProgramOffice" class="muted">Loading...</div>
                </div>
              </div>
            </div>
          </div>

          <!-- RAG Implementation Configuration Section -->
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)"
              style="cursor: pointer; padding: 12px 16px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h3 style="margin: 0; color: var(--text); font-size: 16px;">RAG Implementation</h3>
                <div style="font-size: 12px; color: var(--muted); margin-top: 2px;">Configure how DAS processes
                  knowledge queries</div>
              </div>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div id="ragConfig"
                style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 20px;">

                <!-- Current Status -->
                <div style="margin-bottom: 24px;">
                  <h4 style="margin: 0 0 12px 0; color: var(--text); font-size: 14px; font-weight: 600;">Current
                    Configuration</h4>
                  <div style="display: flex; gap: 24px; flex-wrap: wrap;">
                    <div style="min-width: 200px;">
                      <div style="font-size: 12px; color: var(--muted); margin-bottom: 4px;">Implementation</div>
                      <div id="currentRagImplementation" class="muted" style="font-weight: 500;">Loading...</div>
                    </div>
                    <div id="currentBpmnModelDisplay" style="min-width: 200px; display: none;">
                      <div style="font-size: 12px; color: var(--muted); margin-bottom: 4px;">BPMN Model</div>
                      <div id="currentRagBpmnModel" class="muted" style="font-weight: 500;">-</div>
                    </div>
                    <div id="currentModelVersionDisplay" style="min-width: 120px; display: none;">
                      <div style="font-size: 12px; color: var(--muted); margin-bottom: 4px;">Version</div>
                      <div id="currentRagModelVersion" class="muted" style="font-weight: 500;">-</div>
                    </div>
                  </div>
                </div>

                <!-- Configuration Form -->
                <div style="border-top: 1px solid var(--border); padding-top: 20px;">
                  <h4 style="margin: 0 0 16px 0; color: var(--text); font-size: 14px; font-weight: 600;">Update
                    Configuration</h4>

                  <div
                    style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 16px; align-items: end; margin-bottom: 16px;">
                    <div>
                      <label
                        style="display: block; font-size: 12px; color: var(--text); margin-bottom: 6px; font-weight: 500;">Implementation
                        Type</label>
                      <select id="ragImplementationSelect" onchange="toggleBpmnOptions()"
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-size: 14px;">
                        <option value="hardcoded">Hardcoded RAG</option>
                        <option value="bpmn">BPMN RAG</option>
                      </select>
                    </div>

                    <div id="bpmnModelSelect" style="display: none;">
                      <label
                        style="display: block; font-size: 12px; color: var(--text); margin-bottom: 6px; font-weight: 500;">BPMN
                        Model</label>
                      <select id="ragBpmnModelSelect" onchange="updateModelVersions()"
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-size: 14px;">
                        <option value="">Select Model...</option>
                      </select>
                    </div>

                    <div id="modelVersionSelect" style="display: none;">
                      <label
                        style="display: block; font-size: 12px; color: var(--text); margin-bottom: 6px; font-weight: 500;">Version</label>
                      <select id="ragModelVersionSelect"
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-size: 14px;">
                        <option value="">Select Version...</option>
                      </select>
                    </div>

                    <button class="btn" onclick="updateRagImplementation()"
                      style="height: 42px; padding: 0 20px; white-space: nowrap;">
                      Update
                    </button>
                  </div>

                  <!-- Model Description -->
                  <div id="modelDescription"
                    style="margin-top: 16px; padding: 12px; background: rgba(59, 130, 246, 0.08); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 6px; font-size: 13px; color: var(--text); display: none;">
                    <div id="modelDescriptionText"></div>
                  </div>
                </div>

                <!-- Help Text -->
                <div
                  style="margin-top: 20px; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;">
                  <div style="font-size: 12px; color: var(--muted); line-height: 1.5;">
                    <div style="margin-bottom: 8px;"><strong>Hardcoded RAG:</strong> Direct service calls for fast,
                      simple responses</div>
                    <div><strong>BPMN RAG:</strong> Workflow-based processing with advanced features and configurable
                      models</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- File Processing Configuration Section -->
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)"
              style="cursor: pointer; padding: 12px 16px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h3 style="margin: 0; color: var(--text); font-size: 16px;">File Processing Implementation</h3>
                <div style="font-size: 12px; color: var(--muted); margin-top: 2px;">Configure how uploaded files are
                  processed for knowledge</div>
              </div>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div id="fileProcessingConfig"
                style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 20px;">

                <!-- Current Status -->
                <div style="margin-bottom: 24px;">
                  <h4 style="margin: 0 0 12px 0; color: var(--text); font-size: 14px; font-weight: 600;">Current
                    Configuration</h4>
                  <div style="display: flex; gap: 24px; flex-wrap: wrap;">
                    <div style="min-width: 250px;">
                      <div style="font-size: 12px; color: var(--muted); margin-bottom: 4px;">File Processing Method
                      </div>
                      <div id="currentFileProcessingImplementation" class="muted" style="font-weight: 500;">Loading...
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Configuration Form -->
                <div style="border-top: 1px solid var(--border); padding-top: 20px;">
                  <h4 style="margin: 0 0 16px 0; color: var(--text); font-size: 14px; font-weight: 600;">Update
                    Configuration</h4>

                  <div
                    style="display: grid; grid-template-columns: 1fr auto; gap: 16px; align-items: end; margin-bottom: 16px;">
                    <div>
                      <label
                        style="display: block; font-size: 12px; color: var(--text); margin-bottom: 6px; font-weight: 500;">Implementation
                        Type</label>
                      <select id="fileProcessingImplementationSelect"
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-size: 14px;">
                        <option value="hardcoded">Hardcoded Processing (SQL-first)</option>
                        <option value="bpmn">BPMN Workflow Processing</option>
                      </select>
                    </div>

                    <button class="btn" onclick="updateFileProcessingImplementation()"
                      style="height: 42px; padding: 0 20px; white-space: nowrap;">
                      Update
                    </button>
                  </div>
                </div>

                <!-- Help Text -->
                <div
                  style="margin-top: 20px; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;">
                  <div style="font-size: 12px; color: var(--muted); line-height: 1.5;">
                    <div style="margin-bottom: 8px;"><strong>Hardcoded Processing:</strong> Direct SQL-first approach
                      with fast processing, complete knowledge asset lifecycle, and PostgreSQL as source of truth</div>
                    <div><strong>BPMN Workflow Processing:</strong> Workflow-based processing with external task
                      workers, configurable steps, and Camunda orchestration</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Prefix Management Section -->
          <div class="section collapsed">
            <div class="section-header" onclick="toggleSection(this)"
              style="cursor: pointer; padding: 10px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: bold; color: var(--text);">Prefix Management</span>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button class="btn" onclick="loadPrefixes()">Refresh Prefixes</button>
                <button class="btn" onclick="showCreatePrefixModal()">Create Prefix</button>
              </div>

              <!-- Prefix List -->
              <div id="prefixList"
                style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                <div style="text-align: center; color: var(--muted);">Loading prefixes...</div>
              </div>
            </div>
          </div>

          <!-- Domain Management Section -->
          <div class="section collapsed">
            <div class="section-header" onclick="toggleSection(this)"
              style="cursor: pointer; padding: 10px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: bold; color: var(--text);">Domain Management</span>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button class="btn" onclick="loadDomains()">Refresh Domains</button>
                <button class="btn" onclick="showCreateDomainModal()">Create Domain</button>
              </div>

              <!-- Domain List -->
              <div id="domainList"
                style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                <div style="text-align: center; color: var(--muted);">Loading domains...</div>
              </div>
            </div>
          </div>

          <!-- Namespace Management Section -->
          <div class="section collapsed">
            <div class="section-header" onclick="toggleSection(this)"
              style="cursor: pointer; padding: 10px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: bold; color: var(--text);">Namespace Management</span>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button class="btn" onclick="loadNamespaces()">Refresh Namespaces</button>
                <button class="btn" onclick="showCreateNamespaceModal()">Create Namespace</button>
              </div>

              <!-- Namespace List -->
              <div id="namespaceList"
                style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                <div style="text-align: center; color: var(--muted);">Loading namespaces...</div>
              </div>
            </div>
          </div>

          <!-- User Management Section -->
          <div class="section collapsed">
            <div class="section-header" onclick="toggleSection(this)"
              style="cursor: pointer; padding: 10px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: bold; color: var(--text);">User Management</span>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <button class="btn" onclick="loadUsers()">Refresh Users</button>
                <button class="btn" onclick="showCreateUserModal()">Create User</button>
                <button class="btn" onclick="showChangePasswordModal()">Change My Password</button>
                <label style="display: flex; align-items: center; gap: 8px; margin-left: auto;">
                  <input type="checkbox" id="showInactiveUsers" onchange="loadUsers()" style="margin: 0;">
                  <span style="color: var(--text); font-size: 14px;">Show inactive users</span>
                </label>
              </div>

              <!-- User List -->
              <div id="userList"
                style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                <div style="text-align: center; color: var(--muted);">Loading users...</div>
              </div>
            </div>
          </div>

          <!-- Document Management Section -->
          <div class="section collapsed">
            <div class="section-header" onclick="toggleSection(this)"
              style="cursor: pointer; padding: 10px; background: var(--panel); border: 2px solid #f59e0b; border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: bold; color: var(--text);">📄 Document Management (NEW)</span>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; align-items: center;">
                <button class="btn" onclick="loadAllDocuments()">Refresh All Resources</button>
                <button class="btn" onclick="analyzeSystemHealth()" style="background: #3b82f6; color: #60a5fa;">System
                  Health</button>
                <button class="btn" onclick="cleanupOrphanedFiles()"
                  style="background: #f59e0b; color: #fbbf24;">Cleanup Orphaned Files</button>
                <button class="btn" onclick="cleanupDuplicates()" style="background: #7c3aed; color: #a78bfa;">Find
                  Duplicates</button>
                <button class="btn" onclick="comprehensiveCleanup()"
                  style="background: #dc2626; color: #f87171;">Comprehensive Cleanup</button>

                <div style="display: flex; align-items: center; gap: 8px; margin-left: 16px;">
                  <label style="color: var(--text); font-size: 14px;">Filter by user:</label>
                  <select id="adminDocUserFilter" onchange="loadAllDocuments()"
                    style="background: #0b1220; color: #e5e7eb; border: 1px solid var(--border); border-radius: 6px; padding: 4px 8px; font-size: 12px;">
                    <option value="">All Users</option>
                  </select>
                </div>

                <div style="display: flex; align-items: center; gap: 8px;">
                  <label style="color: var(--text); font-size: 14px;">Filter by type:</label>
                  <select id="adminDocTypeFilter" onchange="loadAllDocuments()"
                    style="background: #0b1220; color: #e5e7eb; border: 1px solid var(--border); border-radius: 6px; padding: 4px 8px; font-size: 12px;">
                    <option value="">All Types</option>
                    <option value="unknown">Unknown</option>
                    <option value="requirements">Requirements</option>
                    <option value="knowledge">Knowledge</option>
                    <option value="reference">Reference</option>
                    <option value="specification">Specification</option>
                    <option value="document">Document</option>
                    <option value="code">Code</option>
                    <option value="data">Data</option>
                  </select>
                </div>

                <div style="display: flex; align-items: center; gap: 8px;">
                  <label style="color: var(--text); font-size: 14px;">Resource Type:</label>
                  <select id="adminResourceTypeFilter" onchange="loadAllDocuments()"
                    style="background: #0b1220; color: #e5e7eb; border: 1px solid var(--border); border-radius: 6px; padding: 4px 8px; font-size: 12px;">
                    <option value="all">All Resources</option>
                    <option value="files">Files Only</option>
                    <option value="knowledge">Knowledge Assets Only</option>
                    <option value="orphaned_files">Orphaned Files</option>
                    <option value="orphaned_knowledge">Orphaned Knowledge</option>
                    <option value="broken_links">Broken Links</option>
                  </select>
                </div>

                <div style="display: flex; align-items: center; gap: 8px;">
                  <label style="color: var(--text); font-size: 14px;">Status:</label>
                  <select id="adminStatusFilter" onchange="loadAllDocuments()"
                    style="background: #0b1220; color: #e5e7eb; border: 1px solid var(--border); border-radius: 6px; padding: 4px 8px; font-size: 12px;">
                    <option value="">All Status</option>
                    <option value="linked">Linked</option>
                    <option value="orphaned">Orphaned</option>
                    <option value="broken">Broken Links</option>
                    <option value="duplicate">Potential Duplicates</option>
                  </select>
                </div>
              </div>

              <div style="display: flex; gap: 10px; margin-top: 12px; flex-wrap: wrap;">
                <button class="btn" onclick="manageOrphanedAssets()" style="background: #f59e0b; color: #fbbf24;">Manage
                  Orphaned Assets</button>
                <button class="btn" onclick="archiveOldOrphanedAssets()"
                  style="background: #7c3aed; color: #a78bfa;">Archive Old Orphaned</button>
              </div>

              <!-- Document List -->
              <div id="adminDocumentList"
                style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px; max-height: 600px; overflow-y: auto;">
                <div style="text-align: center; color: var(--muted);">Click "Refresh All Documents" to load documents...
                </div>
              </div>

              <!-- Cleanup Results -->
              <div id="cleanupResults"
                style="display: none; background: var(--panel-2); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-top: 16px;">
                <h4 style="margin: 0 0 12px 0; color: var(--text);">Cleanup Results</h4>
                <div id="cleanupResultsContent"></div>
              </div>
            </div>
          </div>

        </section>

        <!-- Event Manager Workbench (Admin Only) -->
        <section id="wb-events" class="workbench">
          <h2>Event Manager</h2>
          <div class="muted">Real-time event monitoring and management for administrators.</div>

          <!-- Manual Refresh Controls -->
          <div
            style="margin-top: 16px; padding: 12px; background: var(--panel); border: 1px solid var(--border); border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
            <div style="font-size: 14px; color: var(--text);">
              📊 Event Manager Controls
            </div>
            <div style="display: flex; gap: 8px;">
              <button onclick="forceLoadEventManager()"
                style="padding: 6px 12px; background: var(--ok); color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">
                🔄 Load Data
              </button>
              <button onclick="testEventManagerLoad()"
                style="padding: 6px 12px; background: var(--primary); color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">
                🧪 Debug Test
              </button>
            </div>
          </div>

          <!-- Event System Health Status -->
          <div style="margin-top: 20px;">
            <h3 style="margin: 0 0 16px 0; color: var(--text);">System Health</h3>
            <div id="eventSystemHealth"
              style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                <div>
                  <div style="font-size: 12px; color: var(--muted); margin-bottom: 4px;">System Status</div>
                  <div id="eventSystemStatus" style="font-weight: 600; color: var(--ok);">Loading...</div>
                </div>
                <div>
                  <div style="font-size: 12px; color: var(--muted); margin-bottom: 4px;">SQL-First Storage</div>
                  <div id="eventSqlFirstStatus" style="font-weight: 600;">Loading...</div>
                </div>
                <div>
                  <div style="font-size: 12px; color: var(--muted); margin-bottom: 4px;">Events (24h)</div>
                  <div id="eventCount24h" style="font-weight: 600; cursor: pointer;" onclick="testEventManagerLoad()"
                    title="Click to manually load data">Loading...</div>
                </div>
              </div>
              <div style="margin-top: 12px; font-size: 11px; color: var(--muted);">
                💡 If data not loading, click "Events (24h)" count to manually refresh
              </div>
            </div>
          </div>

          <!-- Event Statistics Dashboard -->
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)"
              style="cursor: pointer; padding: 12px 16px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h3 style="margin: 0; color: var(--text); font-size: 16px;">Event Analytics</h3>
                <div style="font-size: 12px; color: var(--muted); margin-top: 2px;">Statistics and trends for event
                  activity</div>
              </div>
              <span class="section-toggle" style="font-size: 14px;">▼</span>
            </div>
            <div class="section-content">
              <div id="eventAnalytics"
                style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 20px;">

                <!-- Statistics Cards -->
                <div
                  style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 24px;">
                  <div
                    style="background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 16px; text-align: center;">
                    <div style="font-size: 24px; font-weight: 600; color: var(--text);" id="totalEvents24h">0</div>
                    <div style="font-size: 12px; color: var(--muted);">Events (24 hours)</div>
                  </div>
                  <div
                    style="background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 16px; text-align: center;">
                    <div style="font-size: 24px; font-weight: 600; color: var(--text);" id="totalEvents7d">0</div>
                    <div style="font-size: 12px; color: var(--muted);">Events (7 days)</div>
                  </div>
                  <div
                    style="background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 16px; text-align: center;">
                    <div style="font-size: 24px; font-weight: 600; color: var(--text);" id="activeProjects24h">0</div>
                    <div style="font-size: 12px; color: var(--muted);">Active Projects</div>
                  </div>
                </div>

                <!-- Top Event Types -->
                <div style="margin-bottom: 24px;">
                  <h4 style="margin: 0 0 12px 0; color: var(--text); font-size: 14px;">Top Event Types (24h)</h4>
                  <div id="topEventTypes" style="display: grid; gap: 8px;">
                    <div style="color: var(--muted); padding: 8px;">Loading event statistics...</div>
                  </div>
                </div>

                <!-- Most Active Project -->
                <div>
                  <h4 style="margin: 0 0 12px 0; color: var(--text); font-size: 14px;">Most Active Project</h4>
                  <div id="mostActiveProject"
                    style="padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;">
                    <div style="color: var(--muted);">Loading...</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Live Event Monitor -->
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)"
              style="cursor: pointer; padding: 12px 16px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h3 style="margin: 0; color: var(--text); font-size: 16px;">Live Event Monitor</h3>
                <div style="font-size: 12px; color: var(--muted); margin-top: 2px;">Real-time event stream with
                  filtering</div>
              </div>
              <span class="section-toggle" style="font-size: 14px;">▼</span>
            </div>
            <div class="section-content">
              <div id="liveEventMonitor"
                style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 20px;">

                <!-- Monitor Controls -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                  <div style="display: flex; gap: 12px; align-items: center;">
                    <button id="toggleEventMonitor" onclick="toggleEventMonitor()"
                      style="padding: 8px 16px; background: var(--ok); color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">
                      ▶ Start Monitor
                    </button>
                    <button id="clearEventFeed" onclick="clearEventFeed()"
                      style="padding: 8px 16px; background: var(--warn); color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">
                      Clear Feed
                    </button>
                    <div style="display: flex; align-items: center; gap: 8px;">
                      <input type="checkbox" id="autoScrollEvents" checked>
                      <label for="autoScrollEvents" style="font-size: 14px; color: var(--text);">Auto-scroll</label>
                    </div>
                  </div>
                  <div style="display: flex; gap: 12px; align-items: center;">
                    <select id="eventTypeFilter" onchange="filterEventFeed()"
                      style="padding: 6px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text);">
                      <option value="">All Events</option>
                      <option value="project_created">Project Events</option>
                      <option value="ontology_created">Ontology Events</option>
                      <option value="file_uploaded">File Events</option>
                      <option value="das_interaction">DAS Events</option>
                    </select>
                    <div style="font-size: 12px; color: var(--muted);">
                      Events: <span id="eventFeedCount">0</span>
                    </div>
                  </div>
                </div>

                <!-- Event Feed -->
                <div id="eventFeed"
                  style="background: var(--bg); border: 1px solid var(--border); border-radius: 6px; height: 400px; overflow-y: auto; padding: 12px; font-family: 'Monaco', 'Consolas', monospace; font-size: 12px; line-height: 1.4;">
                  <div style="color: var(--muted); text-align: center; padding: 20px;">
                    Event monitor stopped. Click "Start Monitor" to begin live streaming.
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Event Configuration -->
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)"
              style="cursor: pointer; padding: 12px 16px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h3 style="margin: 0; color: var(--text); font-size: 16px;">Event Configuration</h3>
                <div style="font-size: 12px; color: var(--muted); margin-top: 2px;">Manage event types and system
                  settings</div>
              </div>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div id="eventConfiguration"
                style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 20px;">

                <!-- Event Types List -->
                <div style="margin-bottom: 24px;">
                  <h4 style="margin: 0 0 12px 0; color: var(--text); font-size: 14px;">Event Types</h4>
                  <div id="eventTypesList" style="display: grid; gap: 8px;">
                    <div style="color: var(--muted); padding: 8px;">Loading event types...</div>
                  </div>
                </div>

                <!-- Maintenance Actions -->
                <div style="border-top: 1px solid var(--border); padding-top: 16px;">
                  <h4 style="margin: 0 0 12px 0; color: var(--text); font-size: 14px;">Maintenance</h4>
                  <div style="display: flex; gap: 12px; align-items: center;">
                    <button onclick="clearOldEvents()"
                      style="padding: 8px 16px; background: var(--warn); color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">
                      Clear Old Events (30+ days)
                    </button>
                    <button onclick="refreshEventStats()"
                      style="padding: 8px 16px; background: var(--primary); color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">
                      Refresh Statistics
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Future Features Preview -->
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)"
              style="cursor: pointer; padding: 12px 16px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h3 style="margin: 0; color: var(--text); font-size: 16px;">Future Features</h3>
                <div style="font-size: 12px; color: var(--muted); margin-top: 2px;">Planned enhancements for the event
                  system</div>
              </div>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div
                style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 20px;">
                <div style="display: grid; gap: 16px;">
                  <div
                    style="padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;">
                    <div style="font-weight: 600; color: var(--text); margin-bottom: 4px;">🔔 Smart Notifications</div>
                    <div style="font-size: 12px; color: var(--muted);">Intelligent alerting based on event patterns and
                      anomalies</div>
                  </div>
                  <div
                    style="padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;">
                    <div style="font-weight: 600; color: var(--text); margin-bottom: 4px;">📊 Advanced Analytics</div>
                    <div style="font-size: 12px; color: var(--muted);">Trend analysis, correlation detection, and
                      predictive insights</div>
                  </div>
                  <div
                    style="padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;">
                    <div style="font-weight: 600; color: var(--text); margin-bottom: 4px;">🔄 Event Automation</div>
                    <div style="font-size: 12px; color: var(--muted);">Triggered workflows and automated responses to
                      event patterns</div>
                  </div>
                  <div
                    style="padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;">
                    <div style="font-weight: 600; color: var(--text); margin-bottom: 4px;">🔗 External Integrations
                    </div>
                    <div style="font-size: 12px; color: var(--muted);">Webhook support and third-party system
                      integrations</div>
                  </div>
                  <div
                    style="padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;">
                    <div style="font-weight: 600; color: var(--text); margin-bottom: 4px;">📈 Event Visualization</div>
                    <div style="font-size: 12px; color: var(--muted);">Timeline views, relationship graphs, and
                      interactive event exploration</div>
                  </div>
                  <div
                    style="padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;">
                    <div style="font-weight: 600; color: var(--text); margin-bottom: 4px;">🛠️ Event Debugging</div>
                    <div style="font-size: 12px; color: var(--muted);">Event replay, debugging tools, and system
                      troubleshooting</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

        </section>

      </main>
    </div>

    <div class="bottombar">
      <span><span class="status-dot ok"></span>Camunda</span>
      <span><span class="status-dot ok"></span>Fuseki</span>
      <span><span class="status-dot ok"></span>Vector</span>
      <span class="spacer"></span>
      <span id="currentNamespace" class="muted" style="font-family: monospace; font-size: 12px;">No project
        selected</span>
      <span class="spacer"></span>
      <span class="muted">UI Restart Prototype</span>
    </div>
  </div>

  <!-- DAS docked panel scaffold -->
  <section id="dasPanel" class="das-panel das-dock-right" aria-label="Digital Assistant">
    <div class="das-toolbar">
      <strong>DAS</strong>
      <span class="muted" id="dasStatus" style="margin-left:8px;">Idle</span>
      <div class="spacer"></div>
      <span id="llmStatusDockDot" class="status-dot" style="background: #f59e0b;"
        title="LLM Status: Checking..."></span>
      <span class="das-help">Ctrl+Alt+D (or Alt+Shift+D) to toggle; <br>Alt+Shift+←/→/↓ to dock</span>
    </div>
    <div class="das-body" id="dasBody">
      <div class="das-transcript-container">
        <div id="dasTranscript" style="display:grid; gap:8px;"></div>
      </div>
      <div class="das-input-container">
        <div class="card" style="margin:0;">
          <div class="row" style="grid-template-columns: 1fr auto; align-items:flex-end; gap:8px;">
            <textarea id="dasPrompt" placeholder="Type a prompt..." rows="1"
              style="resize:none; overflow:hidden; min-height:32px; max-height:120px; background:#0b1220; color:var(--text); border:1px solid var(--border); padding:8px; border-radius:6px; font-family:inherit; font-size:inherit; line-height:1.4;"></textarea>
            <button id="dasSendBtn" type="button"
              style="width:36px; height:36px; border-radius:50%; background:var(--accent); border:1px solid var(--accent); color:white; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:all 0.2s ease; flex-shrink:0;">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round" width="16" height="16">
                <path d="m18 15-6-6-6 6" />
                <path d="M12 3v12" />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
    <div class="das-resizer-x" id="dasResizerX" aria-hidden="true"></div>
    <div class="das-resizer-y" id="dasResizerY" aria-hidden="true"></div>
  </section>

  <script>
    const qs = (s, r = document) => r.querySelector(s);
    const qsa = (s, r = document) => Array.from(r.querySelectorAll(s));
    function debounce(fn, wait) {
      let t; return function (...args) { clearTimeout(t); t = setTimeout(() => fn.apply(this, args), wait); };
    }
    // Ensure we persist canvas before unload/refresh
    window.addEventListener('beforeunload', () => { try { if (ontoState && ontoState.cy && activeOntologyIri) persistOntologyToLocalStorage(); } catch (_) { } });

    // Ontology workbench state
    const ontoState = {
      cy: null,
      eh: null,
      connectMode: false,
      clickConnectFrom: null,
      nextId: 1,
      currentPredicateType: 'objectProperty',
      isCanvasActive: false,
      suspendAutosave: false,
      autosaveBound: false,
      layoutRunning: false,     // Flag to prevent saves during layout algorithms
      // CAD-like features
      snapToGrid: true,         // Snap to grid enabled by default
      gridSize: 20,             // Grid size (matches CSS background)
      undoStack: [],            // Undo history
      redoStack: [],            // Redo history
      maxUndoLevels: 50,        // Maximum undo levels
      clipboard: null,          // Copy/paste clipboard
      visibilityState: {
        classes: true,
        dataProperties: true,
        notes: true,
        edges: true,
        imported: true
      },
      collapsedImports: new Set(), // Track which imports are collapsed
      elementVisibility: {}, // Track individual element visibility {elementId: true/false}
      activeNamedView: null, // Track currently active named view
      beforeViewState: null // Track state before applying any named view
    };
    let activeProject = null;
    let suppressWorkbenchSwitch = false;
    let activeOntologyIri = null;

    // URL state management
    function updateURL(projectId = null, workbench = null) {
      try {
        const url = new URL(window.location);
        if (projectId) {
          url.searchParams.set('project', projectId);
        } else {
          url.searchParams.delete('project');
        }
        if (workbench) {
          url.searchParams.set('wb', workbench);
        } else {
          url.searchParams.delete('wb');
        }
        window.history.replaceState({}, '', url);
      } catch (error) {
        console.warn('Failed to update URL:', error);
      }
    }

    function getURLState() {
      try {
        const url = new URL(window.location);
        return {
          projectId: url.searchParams.get('project'),
          workbench: url.searchParams.get('wb')
        };
      } catch (error) {
        console.warn('Failed to read URL state:', error);
        return { projectId: null, workbench: null };
      }
    }

    function updateOntoGraphLabel() {
      const el = qs('#ontoGraphLabel');
      if (!el) return;
      if (activeOntologyIri) {
        el.textContent = 'Graph: ' + activeOntologyIri;
        el.title = activeOntologyIri;
      } else {
        el.textContent = 'No graph selected';
        el.title = '';
      }

      // Also update element IRI display when graph changes
      updateElementIriDisplay();

      // Toggle empty-state hint
      const empty = qs('#ontoEmpty');
      const layout = qs('#ontoLayoutSection');
      if (empty && layout) {
        const showEmpty = !activeOntologyIri;
        empty.style.display = showEmpty ? 'block' : 'none';
        layout.style.display = showEmpty ? 'none' : 'grid';
      }
    }

    function slugify(str) {
      try {
        return String(str || '')
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-+|-+$/g, '') || 'ontology';
      } catch (_) { return 'ontology'; }
    }

    // Installation configuration - loaded from API
    let INSTALLATION_CONFIG = {
      organization: "ODRAS Development",
      baseUri: "http://odras.local",  // Will be loaded from API
      prefix: "odras",
      type: "development"  // navy, airforce, army, industry, research, etc.
    };

    // Load installation configuration from API
    async function loadInstallationConfig() {
      try {
        const response = await fetch('/api/installation/config');
        if (response.ok) {
          const config = await response.json();
          INSTALLATION_CONFIG = { ...INSTALLATION_CONFIG, ...config };
          console.log('🔧 Loaded installation config:', INSTALLATION_CONFIG);
          updateInstallationConfigDisplay();
        }
      } catch (error) {
        console.warn('⚠️ Failed to load installation config, using defaults:', error);
        updateInstallationConfigDisplay();
      }
    }

    // Load config on page load
    loadInstallationConfig().then(() => {
      loadRagConfig();
      loadFileProcessingConfig(); // Load file processing config alongside RAG config
    });

    // Update installation config display
    function updateInstallationConfigDisplay() {
      // Update admin panel display
      document.getElementById('configOrganization').textContent = INSTALLATION_CONFIG.organization;
      document.getElementById('configBaseUri').textContent = INSTALLATION_CONFIG.baseUri;
      document.getElementById('configType').textContent = INSTALLATION_CONFIG.type;

      // Update topbar display
      const installOrg = document.getElementById('installOrg');
      const installType = document.getElementById('installType');
      const installOffice = document.getElementById('installOffice');

      if (installOrg) installOrg.textContent = INSTALLATION_CONFIG.organization || 'ODRAS';
      if (installType) installType.textContent = INSTALLATION_CONFIG.type || 'development';
      if (installOffice) installOffice.textContent = INSTALLATION_CONFIG.programOffice || '';
      document.getElementById('configProgramOffice').textContent = INSTALLATION_CONFIG.programOffice || 'N/A';
    }

    // RAG Configuration Management
    let CURRENT_RAG_CONFIG = null;
    let AVAILABLE_BPMN_MODELS = {};

    // Load RAG configuration from API
    async function loadRagConfig() {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.warn('⚠️ No authentication token found - RAG config requires admin access');
          document.getElementById('currentRagImplementation').textContent = 'Login required';
          return;
        }

        const response = await fetch('/api/admin/rag-config', {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (response.ok) {
          const config = await response.json();
          CURRENT_RAG_CONFIG = config;
          console.log('🔧 Loaded RAG config:', CURRENT_RAG_CONFIG);
          await loadBpmnModels(); // Load BPMN models after config
          updateRagConfigDisplay();
        } else {
          console.error('Failed to load RAG config:', response.status, response.statusText);
          if (response.status === 401 || response.status === 403) {
            document.getElementById('currentRagImplementation').textContent = 'Admin access required';
          } else {
            document.getElementById('currentRagImplementation').textContent = 'Error loading configuration';
          }
        }
      } catch (error) {
        console.warn('⚠️ Failed to load RAG config:', error);
        document.getElementById('currentRagImplementation').textContent = 'Error loading configuration';
      }
    }

    // ===== EVENT MANAGER FUNCTIONALITY =====

    // Event Manager global variables
    let EVENT_MONITOR_ACTIVE = false;
    let EVENT_MONITOR_INTERVAL = null;
    let EVENT_STATISTICS = null;
    let LAST_EVENT_TIMESTAMP = null;

    // Initialize Event Manager when workbench becomes active
    async function initializeEventManager() {
      try {
        console.log('📊 Initializing Event Manager...');

        // Check if required elements exist
        const eventCount24h = document.getElementById('eventCount24h');
        const totalEvents24h = document.getElementById('totalEvents24h');
        const eventSystemStatus = document.getElementById('eventSystemStatus');

        console.log('🔍 Event Manager elements check:');
        console.log('   eventCount24h:', !!eventCount24h);
        console.log('   totalEvents24h:', !!totalEvents24h);
        console.log('   eventSystemStatus:', !!eventSystemStatus);

        // Set loading states
        if (eventCount24h) eventCount24h.textContent = 'Loading...';
        if (eventSystemStatus) eventSystemStatus.textContent = 'Loading...';

        // Load initial data with error handling
        console.log('📊 Loading Event Manager data...');

        try {
          await loadEventStatistics();
          console.log('✅ Event statistics loaded');
        } catch (error) {
          console.error('❌ Event statistics failed:', error);
        }

        try {
          await loadEventTypes();
          console.log('✅ Event types loaded');
        } catch (error) {
          console.error('❌ Event types failed:', error);
        }

        try {
          await loadEventHealth();
          console.log('✅ Event health loaded');
        } catch (error) {
          console.error('❌ Event health failed:', error);
        }

        console.log('✅ Event Manager initialization complete');
      } catch (error) {
        console.error('❌ Event Manager initialization failed:', error);

        // Set error states
        const eventCount24h = document.getElementById('eventCount24h');
        const eventSystemStatus = document.getElementById('eventSystemStatus');
        if (eventCount24h) eventCount24h.textContent = 'Error';
        if (eventSystemStatus) eventSystemStatus.textContent = 'Error';
      }
    }

    // Load event statistics for dashboard
    async function loadEventStatistics() {
      try {
        console.log('📊 Loading event statistics...');
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.warn('⚠️ No auth token for event statistics');
          document.getElementById('eventCount24h').textContent = 'No Auth';
          return;
        }

        console.log('🔑 Auth token available, calling API...');
        const response = await fetch('/api/events/statistics', {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        console.log('📊 Event statistics response:', response.status);

        if (response.ok) {
          EVENT_STATISTICS = await response.json();
          console.log('📊 Event statistics data received:', EVENT_STATISTICS);
          updateEventStatisticsDisplay();
          console.log('✅ Event statistics display updated');
        } else {
          console.error('Failed to load event statistics:', response.status, await response.text());
          document.getElementById('eventCount24h').textContent = `Error ${response.status}`;
        }
      } catch (error) {
        console.error('Error loading event statistics:', error);
        document.getElementById('eventCount24h').textContent = 'Error';
      }
    }

    // Update statistics display
    function updateEventStatisticsDisplay() {
      if (!EVENT_STATISTICS) {
        console.warn('⚠️ No event statistics data to display');
        return;
      }

      console.log('🔄 Updating Event Manager display with data:', EVENT_STATISTICS);

      // Update health status counts (with null checks)
      const elements = {
        'eventCount24h': EVENT_STATISTICS.total_events_24h || 0,
        'totalEvents24h': EVENT_STATISTICS.total_events_24h || 0,
        'totalEvents7d': EVENT_STATISTICS.total_events_7d || 0,
        'activeProjects24h': EVENT_STATISTICS.active_projects_24h || 0
      };

      for (const [elementId, value] of Object.entries(elements)) {
        const element = document.getElementById(elementId);
        if (element) {
          element.textContent = value;
          console.log(`✅ Updated ${elementId}: ${value}`);
        } else {
          console.warn(`⚠️ Element not found: ${elementId}`);
        }
      }

      // Update system status with color
      const statusElement = document.getElementById('eventSystemStatus');
      if (statusElement && EVENT_STATISTICS.system_health) {
        const health = EVENT_STATISTICS.system_health;
        statusElement.textContent = health.charAt(0).toUpperCase() + health.slice(1);
        statusElement.style.color = health === 'healthy' ? 'var(--ok)' :
          health === 'warning' ? 'var(--warn)' : 'var(--err)';
        console.log(`✅ Updated system status: ${health}`);
      }

      // Update top event types
      const topEventTypesEl = document.getElementById('topEventTypes');
      if (topEventTypesEl) {
        if (EVENT_STATISTICS.top_event_types && EVENT_STATISTICS.top_event_types.length > 0) {
          topEventTypesEl.innerHTML = EVENT_STATISTICS.top_event_types
            .map(et => `
              <div style="display: flex; justify-content: space-between; padding: 8px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;">
                <span style="color: var(--text);">${et.event_type.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase())}</span>
                <span style="color: var(--muted);">${et.count} events</span>
              </div>
            `).join('');
          console.log(`✅ Updated top event types: ${EVENT_STATISTICS.top_event_types.length} types`);
        } else {
          topEventTypesEl.innerHTML = '<div style="color: var(--muted); padding: 8px;">No events in last 24 hours</div>';
          console.log('ℹ️ No event types to display');
        }
      }

      // Update most active project
      const mostActiveEl = document.getElementById('mostActiveProject');
      if (mostActiveEl) {
        if (EVENT_STATISTICS.most_active_project) {
          const project = EVENT_STATISTICS.most_active_project;
          mostActiveEl.innerHTML = `
            <div style="font-weight: 600; color: var(--text);">${project.project_name}</div>
            <div style="font-size: 12px; color: var(--muted); margin-top: 4px;">
              ${project.event_count} events • Project ID: ${project.project_id.substring(0, 8)}...
            </div>
          `;
          console.log(`✅ Updated most active project: ${project.project_name}`);
        } else {
          mostActiveEl.innerHTML = '<div style="color: var(--muted);">No active projects in last 24 hours</div>';
          console.log('ℹ️ No active project to display');
        }
      }

      console.log('✅ Event statistics display update complete');
    }

    // Toggle live event monitor
    function toggleEventMonitor() {
      const button = document.getElementById('toggleEventMonitor');

      if (EVENT_MONITOR_ACTIVE) {
        // Stop monitoring
        EVENT_MONITOR_ACTIVE = false;
        if (EVENT_MONITOR_INTERVAL) {
          clearInterval(EVENT_MONITOR_INTERVAL);
          EVENT_MONITOR_INTERVAL = null;
        }
        button.innerHTML = '▶ Start Monitor';
        button.style.background = 'var(--ok)';

        const feed = document.getElementById('eventFeed');
        feed.innerHTML += '<div style="color: var(--muted); text-align: center; padding: 10px; border-top: 1px solid var(--border); margin-top: 10px;">--- Event monitoring stopped ---</div>';

        console.log('📊 Event monitor stopped');
      } else {
        // Start monitoring
        EVENT_MONITOR_ACTIVE = true;
        button.innerHTML = '⏸ Stop Monitor';
        button.style.background = 'var(--err)';

        const feed = document.getElementById('eventFeed');
        feed.innerHTML = '<div style="color: var(--ok); text-align: center; padding: 10px;">--- Live event monitoring started ---</div>';

        // Start polling for new events
        EVENT_MONITOR_INTERVAL = setInterval(pollForNewEvents, 3000); // Poll every 3 seconds

        console.log('📊 Event monitor started - polling every 3 seconds');
      }
    }

    // Poll for new events
    async function pollForNewEvents() {
      if (!EVENT_MONITOR_ACTIVE) return;

      try {
        const token = localStorage.getItem('odras_token');
        if (!token) return;

        const eventTypeFilter = document.getElementById('eventTypeFilter').value;
        let url = '/api/events/recent?limit=10';
        if (eventTypeFilter) {
          url += `&event_type=${eventTypeFilter}`;
        }

        const response = await fetch(url, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
          const events = await response.json();
          displayNewEvents(events);
        } else {
          console.error('Failed to poll events:', response.status);
        }
      } catch (error) {
        console.error('Error polling for events:', error);
      }
    }

    // Display new events in feed
    function displayNewEvents(events) {
      const feed = document.getElementById('eventFeed');
      const countEl = document.getElementById('eventFeedCount');
      const autoScroll = document.getElementById('autoScrollEvents').checked;

      if (!events || events.length === 0) return;

      // Filter events newer than last displayed timestamp
      const newEvents = LAST_EVENT_TIMESTAMP ?
        events.filter(e => new Date(e.created_at) > new Date(LAST_EVENT_TIMESTAMP)) : events;

      if (newEvents.length === 0) return;

      // Add new events to feed
      const eventHtml = newEvents.map(event => {
        const timestamp = new Date(event.created_at).toLocaleTimeString();
        const eventTypeColor = getEventTypeColor(event.event_type);

        return `
          <div style="margin-bottom: 8px; padding: 8px; border-left: 3px solid ${eventTypeColor}; background: var(--panel-2);">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 4px;">
              <span style="font-weight: 600; color: var(--text); font-size: 11px;">${event.event_type.toUpperCase()}</span>
              <span style="color: var(--muted); font-size: 10px;">${timestamp}</span>
            </div>
            <div style="color: var(--text); margin-bottom: 4px; font-size: 11px;">${event.semantic_summary}</div>
            <div style="display: flex; gap: 12px; font-size: 10px; color: var(--muted);">
              ${event.project_name ? `<span>📁 ${event.project_name.substring(0, 25)}${event.project_name.length > 25 ? '...' : ''}</span>` : ''}
              <span>👤 ${event.user_id.substring(0, 8)}...</span>
            </div>
          </div>
        `;
      }).join('');

      // Update feed
      feed.innerHTML += eventHtml;

      // Update count
      const currentCount = parseInt(countEl.textContent) || 0;
      countEl.textContent = currentCount + newEvents.length;

      // Auto-scroll to bottom if enabled
      if (autoScroll) {
        feed.scrollTop = feed.scrollHeight;
      }

      // Update last timestamp
      LAST_EVENT_TIMESTAMP = Math.max(...newEvents.map(e => new Date(e.created_at).getTime()));
    }

    // Get color for event type
    function getEventTypeColor(eventType) {
      if (eventType.includes('project')) return 'var(--primary)';
      if (eventType.includes('ontology') || eventType.includes('class')) return 'var(--warn)';
      if (eventType.includes('file')) return 'var(--ok)';
      if (eventType.includes('das')) return '#9333ea';
      if (eventType.includes('knowledge')) return '#0891b2';
      if (eventType.includes('error')) return 'var(--err)';
      return 'var(--muted)';
    }

    // Clear event feed
    function clearEventFeed() {
      const feed = document.getElementById('eventFeed');
      const countEl = document.getElementById('eventFeedCount');

      feed.innerHTML = '<div style="color: var(--muted); text-align: center; padding: 20px;">Event feed cleared. New events will appear here.</div>';
      countEl.textContent = '0';
      LAST_EVENT_TIMESTAMP = new Date().getTime();

      console.log('📊 Event feed cleared');
    }

    // Filter event feed
    function filterEventFeed() {
      if (EVENT_MONITOR_ACTIVE) {
        // Restart monitoring with new filter
        clearEventFeed();
      }
    }

    // Clear old events (maintenance)
    async function clearOldEvents() {
      if (!confirm('Clear events older than 30 days? This cannot be undone.')) return;

      try {
        const token = localStorage.getItem('odras_token');
        if (!token) return;

        const response = await fetch('/api/events/clear?days_old=30', {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
          const result = await response.json();
          alert(`✅ Cleared ${result.events_cleared} old events`);
          await loadEventStatistics(); // Refresh stats
        } else {
          alert('❌ Failed to clear old events');
        }
      } catch (error) {
        console.error('Error clearing old events:', error);
        alert('❌ Error clearing old events');
      }
    }

    // Refresh event statistics
    async function refreshEventStats() {
      try {
        await loadEventStatistics();
        await loadEventHealth();
        console.log('📊 Event statistics refreshed');
      } catch (error) {
        console.error('Error refreshing event stats:', error);
      }
    }

    // Force load Event Manager data (simple approach)
    async function forceLoadEventManager() {
      console.log('🔄 FORCE LOADING EVENT MANAGER DATA');

      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('❌ No authentication token - please login first');
          return;
        }

        // Direct API call and immediate UI update
        const response = await fetch('/api/events/statistics', {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
          const data = await response.json();
          console.log('📊 Event data loaded:', data);

          // Immediately update all UI elements
          document.getElementById('eventCount24h').textContent = data.total_events_24h || 0;
          document.getElementById('totalEvents24h').textContent = data.total_events_24h || 0;
          document.getElementById('totalEvents7d').textContent = data.total_events_7d || 0;
          document.getElementById('activeProjects24h').textContent = data.active_projects_24h || 0;

          const statusEl = document.getElementById('eventSystemStatus');
          statusEl.textContent = (data.system_health || 'Unknown').charAt(0).toUpperCase() + (data.system_health || 'unknown').slice(1);
          statusEl.style.color = data.system_health === 'healthy' ? 'var(--ok)' : 'var(--warn)';

          document.getElementById('eventSqlFirstStatus').textContent = 'Active';
          document.getElementById('eventSqlFirstStatus').style.color = 'var(--ok)';

          // Update most active project
          if (data.most_active_project) {
            const project = data.most_active_project;
            document.getElementById('mostActiveProject').innerHTML = `
              <div style='font-weight: 600; color: var(--text);'>${project.project_name}</div>
              <div style='font-size: 12px; color: var(--muted); margin-top: 4px;'>
                ${project.event_count} events • Project ID: ${project.project_id.substring(0, 8)}...
              </div>
            `;
          } else {
            document.getElementById('mostActiveProject').innerHTML = '<div style=\"color: var(--muted);\">No active projects in last 24 hours</div>';
          }

          // Update top event types
          if (data.top_event_types && data.top_event_types.length > 0) {
            document.getElementById('topEventTypes').innerHTML = data.top_event_types
              .map(et => `
                <div style=\"display: flex; justify-content: space-between; padding: 8px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;\">
                  <span style=\"color: var(--text);\">${et.event_type.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase())}</span>
                  <span style=\"color: var(--muted);\">${et.count} events</span>
                </div>
              `).join('');
          }

          alert(`✅ Event Manager loaded! ${data.total_events_24h} events (24h), System: ${data.system_health}`);

        } else {
          alert(`❌ API failed: ${response.status}`);
        }

      } catch (error) {
        console.error('Force load error:', error);
        alert('❌ Load failed: ' + error.message);
      }
    }

    // Manual test function for debugging (clickable from UI)
    async function testEventManagerLoad() {
      console.log('🧪 MANUAL EVENT MANAGER LOAD TEST');

      // Check elements
      const elements = ['eventCount24h', 'totalEvents24h', 'eventSystemStatus', 'mostActiveProject'];
      elements.forEach(id => {
        const el = document.getElementById(id);
        console.log(`${id}:`, !!el);
      });

      // Check auth
      const token = localStorage.getItem('odras_token');
      console.log('Auth token:', !!token);

      if (token) {
        try {
          // Manual API test
          const response = await fetch('/api/events/statistics', {
            headers: { 'Authorization': `Bearer ${token}` }
          });

          console.log('Manual API response:', response.status);

          if (response.ok) {
            const data = await response.json();
            console.log('Manual API data:', data);

            // Force update elements
            const eventCount24h = document.getElementById('eventCount24h');
            const totalEvents24h = document.getElementById('totalEvents24h');
            const eventSystemStatus = document.getElementById('eventSystemStatus');
            const mostActiveProject = document.getElementById('mostActiveProject');

            if (eventCount24h) {
              eventCount24h.textContent = data.total_events_24h || 0;
              eventCount24h.style.color = 'var(--ok)';
              console.log('✅ Manually updated eventCount24h');
            }

            if (totalEvents24h) {
              totalEvents24h.textContent = data.total_events_24h || 0;
              console.log('✅ Manually updated totalEvents24h');
            }

            if (eventSystemStatus) {
              eventSystemStatus.textContent = (data.system_health || 'unknown').charAt(0).toUpperCase() + (data.system_health || 'unknown').slice(1);
              eventSystemStatus.style.color = data.system_health === 'healthy' ? 'var(--ok)' : 'var(--warn)';
              console.log('✅ Manually updated eventSystemStatus');
            }

            if (mostActiveProject && data.most_active_project) {
              const project = data.most_active_project;
              mostActiveProject.innerHTML = `
                <div style='font-weight: 600; color: var(--text);'>${project.project_name}</div>
                <div style='font-size: 12px; color: var(--muted); margin-top: 4px;'>
                  ${project.event_count} events • Project ID: ${project.project_id.substring(0, 8)}...
                </div>
              `;
              console.log('✅ Manually updated mostActiveProject');
            }

            alert('✅ Event Manager data manually loaded! Check the updated values.');

          } else {
            console.error('Manual API failed:', response.status);
            alert('❌ API call failed: ' + response.status);
          }

        } catch (error) {
          console.error('Manual test error:', error);
          alert('❌ Manual test failed: ' + error.message);
        }
      } else {
        alert('❌ No authentication token found');
      }
    }

    // Load event types configuration
    async function loadEventTypes() {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) return;

        const response = await fetch('/api/events/types', {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
          const eventTypes = await response.json();
          updateEventTypesDisplay(eventTypes);
        } else {
          console.error('Failed to load event types:', response.status);
        }
      } catch (error) {
        console.error('Error loading event types:', error);
      }
    }

    // Update event types display
    function updateEventTypesDisplay(eventTypes) {
      const eventTypesEl = document.getElementById('eventTypesList');
      if (!eventTypesEl || !eventTypes) return;

      const typesByCategory = {
        'Project': eventTypes.filter(et => et.event_type.startsWith('project_')),
        'Ontology': eventTypes.filter(et => et.event_type.includes('ontology') || et.event_type.includes('class')),
        'Files': eventTypes.filter(et => et.event_type.startsWith('file_')),
        'Knowledge': eventTypes.filter(et => et.event_type.includes('knowledge')),
        'DAS': eventTypes.filter(et => et.event_type.startsWith('das_')),
        'System': eventTypes.filter(et => et.event_type.includes('user_') || et.event_type.includes('system_'))
      };

      eventTypesEl.innerHTML = Object.entries(typesByCategory)
        .filter(([category, types]) => types.length > 0)
        .map(([category, types]) => `
          <div style="margin-bottom: 16px;">
            <h5 style="margin: 0 0 8px 0; color: var(--text); font-size: 13px; font-weight: 600;">${category}</h5>
            <div style="display: grid; gap: 6px; padding-left: 12px;">
              ${types.map(et => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; font-size: 12px;">
                  <span style="color: var(--text);">${et.description}</span>
                  <div style="display: flex; gap: 8px; align-items: center;">
                    <span style="color: var(--muted);">${et.count_24h}</span>
                    <span style="width: 8px; height: 8px; border-radius: 50%; background: ${et.enabled ? 'var(--ok)' : 'var(--muted)'};"></span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        `).join('') || '<div style="color: var(--muted); padding: 8px;">No event types found</div>';
    }

    // Load event system health
    async function loadEventHealth() {
      try {
        console.log('🏥 Loading event health...');
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.warn('⚠️ No auth token for event health');
          return;
        }

        const response = await fetch('/api/events/health', {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        console.log('🏥 Event health response:', response.status);

        if (response.ok) {
          const health = await response.json();
          console.log('🏥 Event health data received:', health);
          updateEventHealthDisplay(health);
          console.log('✅ Event health display updated');
        } else {
          console.error('Failed to load event health:', response.status);
          const statusEl = document.getElementById('eventSystemStatus');
          if (statusEl) statusEl.textContent = `Error ${response.status}`;
        }
      } catch (error) {
        console.error('Error loading event health:', error);
        const statusEl = document.getElementById('eventSystemStatus');
        if (statusEl) statusEl.textContent = 'Error';
      }
    }

    // Update event health display
    function updateEventHealthDisplay(health) {
      const statusEl = document.getElementById('eventSystemStatus');
      const sqlFirstEl = document.getElementById('eventSqlFirstStatus');

      if (statusEl) {
        statusEl.textContent = health.status.charAt(0).toUpperCase() + health.status.slice(1);
        statusEl.style.color = health.status === 'healthy' ? 'var(--ok)' :
          health.status === 'warning' ? 'var(--warn)' : 'var(--err)';
      }

      if (sqlFirstEl) {
        sqlFirstEl.textContent = health.sql_first_active ? 'Active' : 'Inactive';
        sqlFirstEl.style.color = health.sql_first_active ? 'var(--ok)' : 'var(--err)';
      }
    }

    // Load file processing configuration from API
    async function loadFileProcessingConfig() {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.warn('⚠️ No authentication token found - File processing config requires admin access');
          document.getElementById('currentFileProcessingImplementation').textContent = 'Login required';
          return;
        }

        const response = await fetch('/api/admin/file-processing-config', {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (response.ok) {
          const config = await response.json();
          console.log('🔧 Loaded file processing config:', config);

          const implementation = config.file_processing_implementation;
          const displayText = implementation === 'hardcoded'
            ? 'Hardcoded Processing (SQL-first)'
            : 'BPMN Workflow Processing';

          document.getElementById('currentFileProcessingImplementation').textContent = displayText;
          document.getElementById('fileProcessingImplementationSelect').value = implementation;
        } else {
          console.error('Failed to load file processing config:', response.status, response.statusText);
          if (response.status === 401 || response.status === 403) {
            document.getElementById('currentFileProcessingImplementation').textContent = 'Admin access required';
          } else {
            document.getElementById('currentFileProcessingImplementation').textContent = 'Error loading configuration';
          }
        }
      } catch (error) {
        console.warn('⚠️ Failed to load file processing config:', error);
        document.getElementById('currentFileProcessingImplementation').textContent = 'Error loading configuration';
      }
    }

    // Load RAG configuration for DAS (public endpoint, no admin required)
    async function loadRagConfigForDAS() {
      try {
        const response = await fetch('/api/rag-config', {
          headers: {
            ...authHeader(),
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const config = await response.json();
          CURRENT_RAG_CONFIG = config;
          console.log('🔧 DAS loaded RAG config:', CURRENT_RAG_CONFIG);
          console.log('🔧 DAS RAG implementation:', CURRENT_RAG_CONFIG?.rag_implementation);
          console.log('🔧 DAS will use workflow:', CURRENT_RAG_CONFIG?.rag_implementation === 'bpmn');
        } else {
          console.error('🔧 DAS failed to load RAG config:', response.status);
          // Fallback to hardcoded if API fails
          CURRENT_RAG_CONFIG = {
            success: true,
            rag_implementation: 'hardcoded',
            rag_bpmn_model: null,
            rag_model_version: null
          };
        }
      } catch (error) {
        console.error('🔧 DAS error loading RAG config:', error);
        // Fallback to hardcoded if API fails
        CURRENT_RAG_CONFIG = {
          success: true,
          rag_implementation: 'hardcoded',
          rag_bpmn_model: null,
          rag_model_version: null
        };
      }
    }

    // Load BPMN models from Camunda
    async function loadBpmnModels() {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) return;

        const response = await fetch('/api/admin/bpmn-models', {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (response.ok) {
          const data = await response.json();
          AVAILABLE_BPMN_MODELS = {};
          data.models.forEach(model => {
            AVAILABLE_BPMN_MODELS[model.key] = model;
          });
          console.log('🔧 Loaded BPMN models:', AVAILABLE_BPMN_MODELS);
          populateBpmnModelOptions();
        } else {
          console.error('Failed to load BPMN models:', response.status, response.statusText);
        }
      } catch (error) {
        console.warn('⚠️ Failed to load BPMN models:', error);
      }
    }

    // Populate BPMN model options
    function populateBpmnModelOptions() {
      const modelSelect = document.getElementById('ragBpmnModelSelect');
      modelSelect.innerHTML = '<option value="">Select Model...</option>';

      for (const [key, model] of Object.entries(AVAILABLE_BPMN_MODELS)) {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = model.name;
        modelSelect.appendChild(option);
      }
    }

    // Update RAG configuration display
    function updateRagConfigDisplay() {
      if (CURRENT_RAG_CONFIG) {
        const implementation = CURRENT_RAG_CONFIG.rag_implementation;
        const bpmnModel = CURRENT_RAG_CONFIG.rag_bpmn_model;
        const modelVersion = CURRENT_RAG_CONFIG.rag_model_version;

        // Update current display
        const displayText = implementation === 'hardcoded' ? 'Hardcoded RAG (Direct Service)' : 'BPMN RAG (Workflow-based)';
        document.getElementById('currentRagImplementation').textContent = displayText;

        // Show/hide BPMN model info
        const bpmnModelDisplay = document.getElementById('currentBpmnModelDisplay');
        const versionDisplay = document.getElementById('currentModelVersionDisplay');

        if (implementation === 'bpmn') {
          bpmnModelDisplay.style.display = 'block';
          versionDisplay.style.display = 'block';
          const modelInfo = AVAILABLE_BPMN_MODELS[bpmnModel];
          document.getElementById('currentRagBpmnModel').textContent = modelInfo ? modelInfo.name : bpmnModel;
          document.getElementById('currentRagModelVersion').textContent = modelVersion;
        } else {
          bpmnModelDisplay.style.display = 'none';
          versionDisplay.style.display = 'none';
        }

        // Update form controls
        document.getElementById('ragImplementationSelect').value = implementation;
        document.getElementById('ragBpmnModelSelect').value = bpmnModel;
        updateModelVersions(); // This will set the version dropdown
        toggleBpmnOptions(); // This will show/hide BPMN options
      }
    }

    // Toggle BPMN options visibility
    function toggleBpmnOptions() {
      const implementation = document.getElementById('ragImplementationSelect').value;
      const bpmnModelDiv = document.getElementById('bpmnModelSelect');
      const versionDiv = document.getElementById('modelVersionSelect');
      const descriptionDiv = document.getElementById('modelDescription');

      if (implementation === 'bpmn') {
        bpmnModelDiv.style.display = 'block';
        versionDiv.style.display = 'block';
        updateModelVersions();
      } else {
        bpmnModelDiv.style.display = 'none';
        versionDiv.style.display = 'none';
        descriptionDiv.style.display = 'none';
      }
    }

    // Update model versions based on selected model
    function updateModelVersions() {
      const selectedModel = document.getElementById('ragBpmnModelSelect').value;
      const versionSelect = document.getElementById('ragModelVersionSelect');
      const descriptionDiv = document.getElementById('modelDescription');
      const descriptionText = document.getElementById('modelDescriptionText');

      versionSelect.innerHTML = '<option value="">Select Version...</option>';

      if (selectedModel && AVAILABLE_BPMN_MODELS[selectedModel]) {
        const model = AVAILABLE_BPMN_MODELS[selectedModel];

        // Populate versions
        model.versions.forEach(version => {
          const option = document.createElement('option');
          option.value = version;
          option.textContent = `v${version}`;
          versionSelect.appendChild(option);
        });

        // Set current version if available
        if (CURRENT_RAG_CONFIG && CURRENT_RAG_CONFIG.rag_bpmn_model === selectedModel) {
          versionSelect.value = CURRENT_RAG_CONFIG.rag_model_version;
        }

        // Show description
        descriptionText.textContent = model.description;
        descriptionDiv.style.display = 'block';
      } else {
        descriptionDiv.style.display = 'none';
      }
    }

    // Update file processing implementation
    async function updateFileProcessingImplementation() {
      const selectedImplementation = document.getElementById('fileProcessingImplementationSelect').value;
      const updateButton = document.querySelector('button[onclick="updateFileProcessingImplementation()"]');

      if (!selectedImplementation) {
        showNotification('Please select an implementation type', 'warning');
        return;
      }

      const token = localStorage.getItem('odras_token');
      if (!token) {
        showNotification('Authentication required to update configuration', 'error');
        return;
      }

      // Update button state
      const originalText = updateButton.textContent;
      updateButton.textContent = 'Updating...';
      updateButton.disabled = true;

      try {
        const requestBody = {
          file_processing_implementation: selectedImplementation
        };

        const response = await fetch('/api/admin/file-processing-config', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(requestBody)
        });

        if (response.ok) {
          const result = await response.json();
          showNotification(`File processing configuration updated successfully! ${result.message}`, 'success');
          console.log('✅ File processing configuration updated:', result);
          await loadFileProcessingConfig(); // Refresh the display
        } else {
          const error = await response.json();
          if (response.status === 401 || response.status === 403) {
            showNotification('Admin access required to update file processing configuration', 'error');
          } else {
            showNotification(`Failed to update file processing configuration: ${error.detail || 'Unknown error'}`, 'error');
          }
          console.error('Failed to update file processing config:', response.status, error);
        }
      } catch (error) {
        console.error('Error updating file processing config:', error);
        showNotification('Error updating file processing configuration. Check console for details.', 'error');
      } finally {
        // Restore button state
        updateButton.textContent = originalText;
        updateButton.disabled = false;
      }
    }

    // Update RAG implementation
    async function updateRagImplementation() {
      const selectedImplementation = document.getElementById('ragImplementationSelect').value;
      const updateButton = document.querySelector('button[onclick="updateRagImplementation()"]');

      if (!selectedImplementation) {
        showNotification('Please select an implementation type', 'warning');
        return;
      }

      // Validate BPMN-specific fields when BPMN is selected
      let selectedModel = null;
      let selectedVersion = null;

      if (selectedImplementation === 'bpmn') {
        selectedModel = document.getElementById('ragBpmnModelSelect').value;
        selectedVersion = document.getElementById('ragModelVersionSelect').value;

        if (!selectedModel) {
          showNotification('Please select a BPMN model', 'warning');
          return;
        }
        if (!selectedVersion) {
          showNotification('Please select a model version', 'warning');
          return;
        }
      }

      const token = localStorage.getItem('odras_token');
      if (!token) {
        showNotification('Authentication required - please login as admin', 'error');
        return;
      }

      // Show loading state
      const originalText = updateButton.textContent;
      updateButton.textContent = 'Updating...';
      updateButton.disabled = true;

      try {
        const requestBody = {
          rag_implementation: selectedImplementation
        };

        // Add BPMN-specific parameters when using BPMN
        if (selectedImplementation === 'bpmn') {
          requestBody.rag_bpmn_model = selectedModel;
          requestBody.rag_model_version = selectedVersion;
        }

        const response = await fetch('/api/admin/rag-config', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(requestBody)
        });

        if (response.ok) {
          const result = await response.json();
          showNotification(`RAG configuration updated successfully! ${result.message}`, 'success');
          console.log('✅ RAG configuration updated:', result);
          await loadRagConfig(); // Refresh the display
        } else {
          const error = await response.json();
          if (response.status === 401 || response.status === 403) {
            showNotification('Admin access required to update RAG configuration', 'error');
          } else {
            showNotification(`Failed to update RAG configuration: ${error.detail || 'Unknown error'}`, 'error');
          }
          console.error('Failed to update RAG config:', response.status, error);
        }
      } catch (error) {
        console.error('Error updating RAG config:', error);
        showNotification('Error updating RAG configuration. Check console for details.', 'error');
      } finally {
        // Restore button state
        updateButton.textContent = originalText;
        updateButton.disabled = false;
      }
    }

    // Show notification (simple implementation)
    function showNotification(message, type = 'info') {
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 16px;
        border-radius: 6px;
        color: white;
        font-size: 14px;
        font-weight: 500;
        z-index: 10000;
        max-width: 400px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        transition: all 0.3s ease;
      `;

      // Set color based on type
      switch (type) {
        case 'success':
          notification.style.background = '#10b981';
          break;
        case 'warning':
          notification.style.background = '#f59e0b';
          break;
        case 'error':
          notification.style.background = '#ef4444';
          break;
        default:
          notification.style.background = '#3b82f6';
      }

      notification.textContent = message;
      document.body.appendChild(notification);

      // Auto remove after 4 seconds
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, 4000);
    }

    // Load namespaces for project ontology creation
    async function loadNamespacesForProject(selectElement) {
      try {
        const response = await fetch('/api/admin/namespaces/available/namespaces');
        if (response.ok) {
          const namespaces = await response.json();

          selectElement.innerHTML = '<option value="">Select a namespace...</option>' +
            namespaces.map(ns => `<option value="${ns.id}">${ns.name} (${ns.type}) - ${ns.description || 'No description'}</option>`).join('');
        } else {
          console.error('Failed to load namespaces:', response.status, response.statusText);
          selectElement.innerHTML = '<option value="">Error loading namespaces</option>';
        }
      } catch (error) {
        console.error('Error loading namespaces:', error);
        selectElement.innerHTML = '<option value="">Error loading namespaces</option>';
      }
    }

    // View ontologies in a namespace
    async function viewNamespaceOntologies(namespaceId, namespaceName) {
      try {
        // For now, show a simple modal with placeholder content
        // In a full implementation, this would fetch actual ontologies from the namespace
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div>
            <h3>Ontologies in ${namespaceName}</h3>
            <div style="margin: 20px 0; padding: 16px; background: var(--panel-2); border-radius: 6px; border: 1px solid var(--border);">
              <div style="text-align: center; color: var(--muted);">
                <p>This feature will show all ontologies created using the "${namespaceName}" namespace.</p>
                <p>Currently, this is a placeholder. In a full implementation, this would:</p>
                <ul style="text-align: left; margin: 16px 0;">
                  <li>Query the database for ontologies using this namespace</li>
                  <li>Show ontology details, creation dates, and owners</li>
                  <li>Allow viewing and editing of individual ontologies</li>
                  <li>Show URI structure and namespace usage</li>
                </ul>
              </div>
            </div>
            <div class="button-group">
              <button onclick="this.closest('.modal').remove()" class="btn" style="background: var(--muted);">Close</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      } catch (error) {
        console.error('Error viewing namespace ontologies:', error);
        alert(`Error viewing namespace ontologies: ${error.message}`);
      }
    }

    // Delete a namespace
    async function deleteNamespace(namespaceId, namespaceName) {
      try {
        // Confirm deletion
        if (!confirm(`Are you sure you want to delete the namespace "${namespaceName}"?\n\nThis action cannot be undone.`)) {
          return;
        }

        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/admin/namespaces/${namespaceId}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const result = await response.json();
          alert(`Namespace "${namespaceName}" deleted successfully.`);
          // Refresh the namespace list
          loadNamespaces();
        } else {
          const error = await response.json();
          alert(`Error deleting namespace: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error deleting namespace:', error);
        alert('Error deleting namespace: ' + error.message);
      }
    }

    // Auto-generate namespace name and path based on prefix and type
    function updateNamespaceFields() {
      const typeSelect = document.getElementById('nsType');
      const nameInput = document.getElementById('nsName');
      const pathInput = document.getElementById('nsPath');

      if (!typeSelect || !nameInput || !pathInput) return;

      // Use the ordered prefixes
      const selectedPrefixes = selectedPrefixOrder;
      const type = typeSelect.value;

      if (selectedPrefixes.length === 0) {
        nameInput.value = '';
        pathInput.value = '';
        return;
      }

      // Generate name as prefix1-prefix2-type (or just prefix-type if single)
      const prefixString = selectedPrefixes.join('-');
      const name = `${prefixString}-${type}`;
      nameInput.value = name;

      // Generate path based on type and selected prefixes
      let path = '';
      const prefixPath = selectedPrefixes.join('/');

      // Simplified, consistent logic: type always comes after the prefix path
      switch (type) {
        case 'core':
          path = `${prefixPath}/core`;
          break;
        case 'service':
          path = `${prefixPath}/service`;
          break;
        case 'domain':
          path = `${prefixPath}/domain`;
          break;
        case 'program':
          path = `${prefixPath}/program`;
          break;
        case 'project':
          path = `${prefixPath}/project`;
          break;
        case 'industry':
          path = `${prefixPath}/industry`;
          break;
        case 'vocab':
          path = `${prefixPath}/vocab`;
          break;
        case 'shapes':
          path = `${prefixPath}/shapes`;
          break;
        case 'align':
          path = `${prefixPath}/align`;
          break;
        default:
          path = `${prefixPath}/${type}`;
      }

      pathInput.value = path;
    }

    // Simplified ontology creation - inherits project namespace
    async function showCreateOntologyModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div>
          <h3>Create New Ontology</h3>

          <div style="margin-bottom: 16px;">
            <label>Current Project Namespace:</label>
            <div id="modalNamespaceDisplay" style="padding: 8px; background: var(--panel-2); border: 1px solid var(--border); border-radius: 4px; font-family: monospace; color: var(--muted);">
              Loading project namespace...
            </div>
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Ontologies inherit their project's namespace automatically
            </div>
          </div>

          <div style="margin-bottom: 16px;">
            <label>Ontology Name:</label>
            <input type="text" id="simpleOntologyName" placeholder="e.g., flight-control" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);" />
          </div>

          <div style="margin-bottom: 16px;">
            <label>Title:</label>
            <input type="text" id="simpleOntologyTitle" placeholder="e.g., Flight Control System Ontology" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);" />
          </div>

          <div style="margin-bottom: 16px;">
            <label>Description:</label>
            <textarea id="simpleOntologyDescription" placeholder="Brief description of the ontology" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text); height: 80px; resize: vertical;"></textarea>
          </div>

          <div class="button-group">
            <button onclick="this.closest('.modal').remove()" class="btn" style="background: var(--muted);">Cancel</button>
            <button onclick="createSimpleOntology()" class="btn" style="background: var(--accent); color: white; border-color: var(--accent);">Create Ontology</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);

      // Load current project's namespace for display
      loadCurrentProjectNamespace(document.getElementById('modalNamespaceDisplay'));
    }

    async function createSimpleOntology() {
      try {
        const name = document.getElementById('simpleOntologyName').value.trim();
        const title = document.getElementById('simpleOntologyTitle').value.trim();
        const description = document.getElementById('simpleOntologyDescription').value.trim();

        if (!name) {
          alert('Please enter an ontology name');
          return;
        }

        const currentProjectId = localStorage.getItem('active_project_id');
        if (!currentProjectId) {
          alert('No project selected - select a project first');
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }

        console.log('🔧 Creating ontology with inherited namespace:', {
          name, title, description, project: currentProjectId
        });

        const response = await fetch('/api/ontologies', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            project: currentProjectId,
            name: name,
            label: title || name,
            description: description || null
            // No namespace_id - will be inherited from project
          })
        });

        if (response.ok) {
          const newOntology = await response.json();
          console.log('🔧 Created ontology:', newOntology);
          document.querySelector('.modal').remove();

          // Refresh ontology list or switch to new ontology
          // This will depend on your existing ontology management code
          alert('Ontology created successfully!');

          // Reload the current project to show the new ontology
          window.location.reload();
        } else {
          const error = await response.json();
          console.error('🔧 Error creating ontology:', error);
          alert(`Error creating ontology: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error creating ontology:', error);
        alert('Error creating ontology: ' + error.message);
      }
    }

    function updateOntoUriPreview() {
      const type = document.getElementById('ontologyNamespaceType').value;
      const name = document.getElementById('ontologyName').value || 'ontology';

      let uri = INSTALLATION_CONFIG.baseUri;

      if (type === 'core') {
        uri += `/core/${name}`;
      } else if (type === 'domain') {
        const domain = document.getElementById('ontologyDomain').value || 'domain';
        uri += `/${domain}/${name}`;
      } else if (type === 'program') {
        const program = document.getElementById('ontologyProgram').value || 'program';
        uri += `/${program}/core/${name}`;
      } else if (type === 'project') {
        const program = document.getElementById('ontologyProgram').value || 'program';
        const project = document.getElementById('ontologyProject').value || 'project';
        uri += `/${program}/${project}/${name}`;
      } else if (type === 'se') {
        const seDomain = document.getElementById('ontologySeDomain').value || 'se-domain';
        uri += `/se/${seDomain}/${name}`;
      } else if (type === 'mission') {
        const missionType = document.getElementById('ontologyMissionType').value || 'mission-type';
        uri += `/mission/${missionType}/${name}`;
      } else if (type === 'platform') {
        const platformType = document.getElementById('ontologyPlatformType').value || 'platform-type';
        uri += `/platform/${platformType}/${name}`;
      } else {
        uri += `/${name}`;
      }

      document.getElementById('ontologyUriPreview').textContent = uri;
    }

    async function createOntology() {
      try {
        const type = document.getElementById('ontologyNamespaceType').value;
        const name = document.getElementById('ontologyName').value;
        const title = document.getElementById('ontologyTitle').value || name;
        const description = document.getElementById('ontologyDescription').value;

        if (!name) {
          alert('Please enter an ontology name');
          return;
        }

        // Generate the URI
        let uri = INSTALLATION_CONFIG.baseUri;
        let projectId = 'core';

        if (type === 'core') {
          uri += `/core/${name}`;
          projectId = 'core';
        } else if (type === 'domain') {
          const domain = document.getElementById('ontologyDomain').value || 'domain';
          uri += `/${domain}/${name}`;
          projectId = `domain-${domain}`;
        } else if (type === 'program') {
          const program = document.getElementById('ontologyProgram').value || 'program';
          uri += `/${program}/core/${name}`;
          projectId = `program-${program}`;
        } else if (type === 'project') {
          const program = document.getElementById('ontologyProgram').value || 'program';
          const project = document.getElementById('ontologyProject').value || 'project';
          uri += `/${program}/${project}/${name}`;
          projectId = `project-${program}-${project}`;
        } else if (type === 'se') {
          const seDomain = document.getElementById('ontologySeDomain').value || 'se-domain';
          uri += `/se/${seDomain}/${name}`;
          projectId = `se-${seDomain}`;
        } else if (type === 'mission') {
          const missionType = document.getElementById('ontologyMissionType').value || 'mission-type';
          uri += `/mission/${missionType}/${name}`;
          projectId = `mission-${missionType}`;
        } else if (type === 'platform') {
          const platformType = document.getElementById('ontologyPlatformType').value || 'platform-type';
          uri += `/platform/${platformType}/${name}`;
          projectId = `platform-${platformType}`;
        } else {
          uri += `/${name}`;
          projectId = 'general';
        }

        // Create the ontology
        const response = await authenticatedFetch('/api/ontology', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            project: projectId,
            name: name,
            label: title,
            description: description,
            is_reference: true  // These are reference ontologies
          })
        });

        if (response.ok) {
          const result = await response.json();
          console.log('✅ Ontology created:', result);
          document.querySelector('.modal').remove();
          await loadNamespaces();
          alert('Ontology created successfully!');
        } else {
          const error = await response.text();
          throw new Error(`HTTP ${response.status}: ${error}`);
        }
      } catch (error) {
        console.error('Error creating ontology:', error);
        alert(`Error creating ontology: ${error.message}`);
      }
    }

    function computeOntologyIri(projectId, name, version) {
      // This function generates project-scoped ontology URIs following the namespace design
      // Pattern: {base_uri}/{namespace_path}/{project_uuid}/ontologies/{name}
      console.log('⚠️ computeOntologyIri called - this may be generating old-format URIs');
      console.log('Project ID:', projectId, 'Name:', name, 'Version:', version);

      // For now, return a simple placeholder - the backend ResourceURIService should handle proper URI generation
      const pid = encodeURIComponent(projectId || 'project');
      const n = slugify(name || 'ontology');
      const ver = version ? ('/v' + encodeURIComponent(version)) : '';

      // Note: This is a legacy pattern - proper URIs should come from backend ResourceURIService
      const uri = `${INSTALLATION_CONFIG.baseUri}/legacy/${pid}/${n}${ver}`;
      console.log('⚠️ Generated legacy URI:', uri, '(should be replaced by backend service)');
      return uri;
    }

    async function handleTreeSelection(li) {
      if (!li || !li.dataset) return;
      const type = li.dataset.nodeType || '';

      if (type === 'ontology') {
        const iri = li.dataset.iri;
        if (iri) {
          // Save previous active ontology canvas before switching
          const prevIri = activeOntologyIri;
          ensureOntologyInitialized();
          if (ontoState.cy && prevIri) {
            saveGraphToLocal(prevIri);
          }
          // Switch active ontology
          activeOntologyIri = iri;
          try {
            const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
            localStorage.setItem(`onto_active_iri__${pid}`, iri);
            // Set model name for properties panel based on discovered label or IRI tail
            const friendly = (li.dataset.label && li.dataset.label.trim()) || iri.split('/').pop() || iri;
            // FIXED: Use ontology-specific localStorage keys consistently  
            const ontologyKey = iri ? iri.split('/').pop() : 'default';
            const modelNameKey = `onto_model_name__${pid}__${ontologyKey}`;
            const modelAttrsKey = `onto_model_attrs__${pid}__${ontologyKey}`;

            localStorage.setItem(modelNameKey, friendly);
            // Also store display label, graph, and namespace in model attributes
            let attrs = {};

            try { attrs = JSON.parse(localStorage.getItem(modelAttrsKey) || '{}'); } catch (_) { attrs = {}; }
            attrs.displayLabel = friendly;
            attrs.graphIri = iri;
            // Set namespace based on installation configuration
            attrs.namespace = iri;  // Use the actual graph IRI as namespace
            localStorage.setItem(modelAttrsKey, JSON.stringify(attrs));
            // Keep project-scoped label map in sync so the top node reflects selection
            try { saveOntologyLabel(iri, friendly); } catch (_) { }

            // Load collapsed imports state for this ontology
            ontoState.collapsedImports = loadCollapsedImports(iri);

            // Load visibility state for this ontology
            ontoState.visibilityState = loadVisibilityState(iri);

            // Load individual element visibility for this ontology
            ontoState.elementVisibility = loadElementVisibility(iri);
          } catch (_) { }
          updateOntoGraphLabel();
          // Load new graph from local storage if present, otherwise fetch from API
          if (ontoState.cy) {
            // Avoid racing autosave during restore
            ontoState.suspendAutosave = true;
            try { ontoState.cy.elements().remove(); } catch (_) { }
            await loadGraphFromLocalOrAPI(iri);
            // Refresh overlay imports to restore visible imported ontologies
            await overlayImportsRefresh();
            // Apply saved visibility states after overlay refresh
            updateCanvasVisibility();
            setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
          }
          // Show model-level props when nothing selected
          updatePropertiesPanelFromSelection();
          // Rebuild ontology tree (top node label and contents)
          try { refreshOntologyTree(); } catch (_) { }
          // Switch to Ontology workbench view unless suppressed during restore
          if (!suppressWorkbenchSwitch) {
            const ico = document.querySelector('.icon[data-wb="ontology"]');
            if (ico && !document.querySelector('#wb-ontology.workbench.active')) {
              ico.click();
            }
          }
          // Reflect in hash for deep-linking (preserve current workbench)
          try {
            const params = new URLSearchParams(location.hash.replace(/^#/, ''));
            const wb = localStorage.getItem('active_workbench') || 'ontology';
            params.set('wb', wb);
            params.set('graph', encodeURIComponent(iri));
            location.hash = params.toString();
          } catch (_) { }
        }
      } else if (type === 'class' || type === 'dataProperty' || type === 'note') {
        // Handle individual element selection
        const nodeId = li.dataset.nodeId;
        if (nodeId && ontoState.cy) {
          // Clear current selection
          ontoState.cy.$(':selected').unselect();

          // Find and select the corresponding node in the canvas (escape special characters in ID)
          const node = ontoState.cy.$(`#${CSS.escape(nodeId)}`);
          if (node.length > 0) {
            node.select();

            // Center the view on the selected node
            ontoState.cy.animate({
              center: { eles: node },
              zoom: Math.max(ontoState.cy.zoom(), 0.8) // Ensure minimum zoom level
            }, {
              duration: 300
            });

            // Update properties panel with selected element data
            updatePropertiesPanelFromSelection();
          } else {
            console.log('🔍 Could not find node with ID:', nodeId);
          }
        }
      } else if (type === 'namedView') {
        // Handle named view selection with toggle functionality
        const viewId = li.dataset.viewId;
        if (viewId) {
          const views = await loadNamedViews(activeOntologyIri);
          const view = views.find(v => v.id === viewId);
          if (view) {
            if (ontoState.activeNamedView === viewId) {
              // Toggle off - restore original state before any named views
              console.log('🔍 Toggling off named view:', view.name, 'returning to original state');
              if (ontoState.beforeViewState) {
                restoreOriginalState();
              } else {
                ontoState.activeNamedView = null;
                refreshOntologyTree();
              }
            } else {
              // Capture current state as "before state" if this is the first named view applied
              if (!ontoState.activeNamedView && !ontoState.beforeViewState) {
                console.log('🔍 Capturing current state before applying first named view');
                ontoState.beforeViewState = captureCurrentView('__original_state__');
              }

              // Apply the view
              console.log('🔍 Applying named view:', view.name, 'with visible imports:', view.visibleImports);
              restoreView(view);
            }
          }
        }
      } else if (type === 'edge') {
        // Handle edge selection
        const edgeId = li.dataset.edgeId;
        if (edgeId && ontoState.cy) {
          // Clear current selection
          ontoState.cy.$(':selected').unselect();

          // Find and select the corresponding edge in the canvas (escape special characters in ID)
          const edge = ontoState.cy.$(`#${CSS.escape(edgeId)}`);
          if (edge.length > 0) {
            edge.select();

            // Center the view on the selected edge
            ontoState.cy.animate({
              center: { eles: edge },
              zoom: Math.max(ontoState.cy.zoom(), 0.8)
            }, {
              duration: 300
            });

            // Update properties panel with selected element data
            updatePropertiesPanelFromSelection();
          } else {
            console.log('🔍 Could not find edge with ID:', edgeId);
          }
        }
      }
    }
    function ensureOntologyInitialized() {
      if (ontoState.cy) return;
      const container = qs('#cy');
      if (!container) return;
      // Make canvas focusable for keyboard events (Delete)
      try { container.setAttribute('tabindex', '0'); container.style.outline = 'none'; } catch (_) { }
      try {
        if (window.cytoscape && (window.cytoscapeEdgehandles || window.edgehandles)) {
          const plugin = window.cytoscapeEdgehandles || window.edgehandles;
          if (plugin && typeof plugin === 'function') window.cytoscape.use(plugin);
        }
      } catch (_) { }
      ontoState.cy = cytoscape({
        container,
        layout: { name: 'grid', padding: 10, avoidOverlap: true },
        wheelSensitivity: 0.15,  // Much more gentle mouse wheel zoom (default: 1)
        minZoom: 0.1,
        maxZoom: 3,
        // CAD-like features
        boxSelectionEnabled: true,  // Enable selection box like SolidWorks
        selectionType: 'single',   // Single selection by default, Ctrl+click for multi-select
        style: [
          {
            selector: 'node', style: {
              'shape': 'round-rectangle',
              'background-color': '#1b2a45',
              'border-color': '#2a3b5f',
              'border-width': 1,
              'label': 'data(label)',
              'color': '#e5e7eb',
              'font-size': 12,
              'text-wrap': 'wrap',
              'text-max-width': 180,
              'text-valign': 'center',
              'text-halign': 'center'
            }
          },
          { selector: 'node[type = "class"]', style: { 'width': 180, 'height': 56 } },
          {
            selector: 'node[type = "dataProperty"]', style: {
              'width': 160,
              'height': 48,
              'background-color': '#154e5a',
              'border-color': '#2ea3b0'
            }
          },
          {
            selector: 'edge', style: {
              'curve-style': 'bezier',
              'width': 2,
              'line-color': '#3b4a6b',
              'target-arrow-shape': 'triangle',
              'target-arrow-color': '#3b4a6b',
              'arrow-scale': 1,
              'label': 'data(predicate)',
              'color': '#e5e7eb',
              'font-size': 10,
              'text-rotation': 'autorotate',
              'text-background-color': '#0b1220',
              'text-background-opacity': 0.6,
              'text-background-padding': 2,
              // Multiplicity label at target (arrow tip) - only for edges with multiplicity
              'target-label': 'data(multiplicityDisplay)',
              'target-text-offset': 15,  // Distance from arrow tip
              'target-text-rotation': 0,  // Keep horizontal
              'target-text-color': '#60a5fa',  // Accent color for visibility
              'target-text-background-color': '#0b1220',
              'target-text-background-opacity': 0.8,
              'target-text-background-padding': 3,
              'target-text-border-width': 1,
              'target-text-border-color': '#60a5fa',
              'target-text-border-opacity': 0.5
            }
          },
          {
            selector: 'edge[type = "note"], edge[predicate = "note_for"]', style: {
              'target-arrow-shape': 'circle',
              'target-arrow-color': '#9ca3af',
              'arrow-scale': 0.8,
              'source-arrow-shape': 'none'
            }
          },
          {
            selector: '.imported', style: {
              'opacity': 0.55
            }
          },
          { selector: 'edge.imported', style: { 'line-style': 'dashed' } },
          {
            selector: 'edge.imported-equivalence', style: {
              'line-style': 'dotted',
              'width': 1.5,
              'line-color': '#60a5fa',
              'label': '≡',
              'color': '#9ca3af',
              'font-size': 9,
              'text-background-opacity': 0
            }
          },
          {
            selector: 'node[type = "note"], .note', style: {
              'shape': 'rectangle',
              'background-color': function (ele) {
                const noteType = ele.data('attrs') && ele.data('attrs').noteType;
                return getNoteTypeStyle(noteType || 'Note').backgroundColor;
              },
              'border-color': function (ele) {
                const noteType = ele.data('attrs') && ele.data('attrs').noteType;
                return getNoteTypeStyle(noteType || 'Note').borderColor;
              },
              'border-style': 'solid',
              'border-width': 1,
              'label': function (ele) {
                const noteType = ele.data('attrs') && ele.data('attrs').noteType;
                const symbol = getNoteTypeStyle(noteType || 'Note').symbol;
                const content = ele.data('attrs') && ele.data('attrs').content;
                const text = content || ele.data('label') || 'Note';
                return symbol + ' ' + text;
              },
              'color': function (ele) {
                const noteType = ele.data('attrs') && ele.data('attrs').noteType;
                return getNoteTypeStyle(noteType || 'Note').textColor;
              },
              'font-size': 12,
              'text-wrap': 'wrap',
              'text-max-width': 220,
              'text-valign': 'center',
              'text-halign': 'center',
              'width': 220, 'height': 80
            }
          },
          {
            selector: ':selected', style: {
              'border-color': '#60a5fa',
              'border-width': 2,
              'line-color': '#60a5fa',
              'target-arrow-color': '#60a5fa'
            }
          }
        ],
        elements: []
      });
      window._cy = ontoState.cy;
      ontoState.nextId = 1;
      // Focus canvas on interaction so Delete works reliably
      ontoState.cy.on('tap', () => { try { container.focus(); } catch (_) { } });
      ontoState.cy.on('select', () => { try { container.focus(); } catch (_) { } });
      try { container.addEventListener('keydown', handleDeleteKey); } catch (_) { }

      // Mark canvas active on any interaction
      ontoState.cy.on('tap', () => { ontoState.isCanvasActive = true; });

      if (typeof ontoState.cy.edgehandles === 'function') {
        ontoState.eh = ontoState.cy.edgehandles({
          handleSize: 8,
          handleNodes: 'node[type = "class"], node[type = "note"]',
          handleColor: '#60a5fa',
          handleOutlineColor: '#0b1220',
          handleOutlineWidth: 2,
          toggleOffOnLeave: true,
          enabled: true,
          edgeParams: () => ({ data: { predicate: 'relatedTo', type: 'objectProperty' } })
        });
        ontoState.cy.on('ehcomplete', (event, sourceNode, targetNode, addedEdge) => {
          try {
            const srcType = (sourceNode.data('type') || 'class');
            const tgtType = (targetNode.data('type') || 'class');
            const edgeType = (addedEdge && addedEdge.data('type')) || ontoState.currentPredicateType || 'objectProperty';
            let invalid = false;
            // Allow note -> class as 'note_for' (reverse if class->note used)
            if ((srcType === 'note' && (tgtType === 'class' || tgtType === 'dataProperty')) || ((srcType === 'class' || srcType === 'dataProperty') && tgtType === 'note')) {
              // Ensure direction note -> class
              if ((srcType === 'class' || srcType === 'dataProperty') && tgtType === 'note') {
                addedEdge.data('source', targetNode.id());
                addedEdge.data('target', sourceNode.id());
              }
              addedEdge.data('predicate', 'note_for');
              addedEdge.data('type', 'note');
            } else {
              // For object properties, only allow class→class
              if (edgeType === 'objectProperty' && (srcType !== 'class' || tgtType !== 'class')) invalid = true;
              // Disallow any other note edges
              if (srcType === 'note' || tgtType === 'note') invalid = true;
              if (invalid && addedEdge) { addedEdge.remove(); return; }
            }
          } catch (_) { }
          requestAnimationFrame(() => { refreshOntologyTree(); persistOntologyToLocalStorage(); });
        });
        ontoState.cy.on('select unselect add remove data free', () => {
          updatePropertiesPanelFromSelection();
          persistOntologyToLocalStorage();

          // Highlight corresponding tree item when canvas selection changes
          const selected = ontoState.cy.$(':selected');
          if (selected.length === 1) {
            const element = selected[0];
            if (element.isNode()) {
              highlightTreeItem(element.id(), 'node');
            } else if (element.isEdge()) {
              highlightTreeItem(element.id(), 'edge');
            }
          } else {
            // Clear tree selection when nothing is selected on canvas
            qsa('.node-row').forEach(r => r.classList.remove('selected'));
          }
        });
        // Persist overlay positions when moved
        ontoState.cy.on('free', 'node.imported', (ev) => {
          try {
            const n = ev.target; const imp = n.data('importSource');
            if (!imp || !activeOntologyIri) return;
            const curr = loadOverlayPositions(activeOntologyIri, imp);
            curr[n.id()] = n.position();
            console.log('🔍 Saving position for', n.id(), ':', n.position(), 'in import', imp);
            saveOverlayPositions(activeOntologyIri, imp, curr);
          } catch (_) { }
        });
        // Persist overlay positions when moved
        ontoState.cy.on('free', 'node.imported', (ev) => {
          try {
            const n = ev.target; const imp = n.data('importSource');
            if (!imp || !activeOntologyIri) return;
            const curr = loadOverlayPositions(activeOntologyIri, imp);
            curr[n.id()] = n.position();
            console.log('🔍 Saving position for', n.id(), ':', n.position(), 'in import', imp);
            saveOverlayPositions(activeOntologyIri, imp, curr);
          } catch (_) { }
        });
      } else {
        ontoState.cy.on('tap', 'node', (ev) => {
          if (!ontoState.connectMode) return;
          const node = ev.target;
          if (!ontoState.clickConnectFrom) {
            ontoState.clickConnectFrom = node.id();
          } else {
            const from = ontoState.clickConnectFrom;
            const to = node.id();
            if (from !== to) {
              const src = ontoState.cy.$(`#${from}`)[0];
              const tgt = ontoState.cy.$(`#${to}`)[0];
              const srcType = (src && (src.data('type') || 'class')) || 'class';
              const tgtType = (tgt && (tgt.data('type') || 'class')) || 'class';
              if (srcType !== 'note' && tgtType !== 'note' && srcType === 'class' && tgtType === 'class') {
                const edgeAttrs = addCreationMetadata({});
                ontoState.cy.add({ group: 'edges', data: { id: `e${Date.now()}`, source: from, target: to, predicate: 'relatedTo', type: 'objectProperty', attrs: edgeAttrs } });
                refreshOntologyTree();
                persistOntologyToLocalStorage();
              }
            }
            ontoState.clickConnectFrom = null;
          }
        });
        ontoState.cy.on('select unselect add remove data free', () => {
          updatePropertiesPanelFromSelection();
          persistOntologyToLocalStorage();

          // Highlight corresponding tree item when canvas selection changes
          const selected = ontoState.cy.$(':selected');
          if (selected.length === 1) {
            const element = selected[0];
            if (element.isNode()) {
              highlightTreeItem(element.id(), 'node');
            } else if (element.isEdge()) {
              highlightTreeItem(element.id(), 'edge');
            }
          } else {
            // Clear tree selection when nothing is selected on canvas
            qsa('.node-row').forEach(r => r.classList.remove('selected'));
          }
        });
      }

      // Background click clears selection and shows model-level props
      ontoState.cy.on('tap', (ev) => {
        if (ev.target === ontoState.cy) {
          ontoState.cy.$(':selected').unselect();
          updatePropertiesPanelFromSelection();
          hideMenu();
          hideEdgeMenu();
          clearConnectState();
        }
      });

      // Inline label editor on F2 or Enter when focused
      ontoState.cy.on('cxttap', 'node', (ev) => {
        const n = ev.target; const t = (n.data('type') || 'class');
        const rect = qs('#cy').getBoundingClientRect();
        const rp = ev.renderedPosition || n.renderedPosition();
        // Configure menu per node type
        const menu = qs('#ontoContextMenu');
        if (!menu) return;
        const btnRel = qs('#menuAddRel');
        const btnDP = qs('#menuAddDataProp');
        if (t === 'note') {
          if (btnRel) {
            btnRel.innerHTML = `
              <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="7" cy="12" r="3"/><circle cx="17" cy="12" r="3"/><path d="M10 12h4"/>
              </svg>
              Link to Class/Property
            `;
          }
          if (btnDP) btnDP.style.display = 'none';
        } else {
          if (btnRel) {
            btnRel.innerHTML = `
              <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="7" cy="12" r="3"/><circle cx="17" cy="12" r="3"/><path d="M10 12h4"/>
              </svg>
              Add Relationship
            `;
          }
          if (btnDP) btnDP.style.display = 'block';
        }
        showMenuAt(rect.left + rp.x + 6, rect.top + rp.y + 6);
        menu.dataset.nodeId = n.id();
        menu.dataset.nodeType = t;
      });

      // Edge right-click context menu for multiplicity constraints
      ontoState.cy.on('cxttap', 'edge', (ev) => {
        const edge = ev.target;
        const edgeData = edge.data();

        // Only show context menu for object properties (relationships)
        if (edgeData.type !== 'objectProperty') return;

        // Don't allow editing of imported elements
        if (edge.hasClass('imported')) {
          console.log('🔍 Cannot edit imported edge:', edge.data('predicate'));
          return;
        }

        const rect = qs('#cy').getBoundingClientRect();
        const rp = ev.renderedPosition || edge.renderedMidpoint();

        showEdgeMenuAt(rect.left + rp.x + 6, rect.top + rp.y + 6);
        const edgeMenu = qs('#edgeContextMenu');
        if (edgeMenu) {
          edgeMenu.dataset.edgeId = edge.id();
        }
      });
      function showInlineEditor(target) {
        // Don't allow editing of imported elements
        if (target.hasClass('imported')) {
          console.log('🔍 Cannot edit imported element:', target.data('label'));
          return;
        }

        const input = qs('#ontoInlineEdit'); if (!input) return;
        const pos = target.renderedPosition();
        const rect = qs('#cy').getBoundingClientRect();

        let current = '';
        if (target.isNode()) {
          const nodeType = target.data('type') || 'class';
          if (nodeType === 'note') {
            // For notes, show the current rdfs:comment from attributes  
            const attrs = target.data('attrs') || {};
            current = attrs.content || '';  // Use 'content' to match the template mapping
          } else {
            // For other nodes, show the label as before
            current = target.data('label') || '';
          }
        } else {
          // For edges, show predicate
          current = target.data('predicate') || '';
        }

        input.value = current;
        input.style.left = (rect.left + pos.x - Math.min(100, rect.width * 0.2)) + 'px';
        input.style.top = (rect.top + pos.y - 12) + 'px';
        input.style.display = 'block';
        input.focus();
        input.select();
        function commit(save) {
          if (save) {
            const v = input.value.trim();
            if (target.isNode()) {
              const nodeType = target.data('type') || 'class';

              if (nodeType === 'note') {
                // For notes, update the rdfs:comment in attributes, not the label
                const currentAttrs = target.data('attrs') || {};
                currentAttrs.content = v || current;  // Use 'content' to match the template mapping
                const updatedAttrs = updateModificationMetadata(currentAttrs);
                target.data('attrs', updatedAttrs);
              } else {
                // For other nodes (classes, etc.), update the label as before
                target.data('label', v || current);
                // Update modification metadata for inline label changes
                const currentAttrs = target.data('attrs') || {};
                const updatedAttrs = updateModificationMetadata(currentAttrs);
                target.data('attrs', updatedAttrs);
              }
            } else {
              target.data('predicate', v || current);
              // Update modification metadata for inline predicate changes
              const currentAttrs = target.data('attrs') || {};
              const updatedAttrs = updateModificationMetadata(currentAttrs);
              target.data('attrs', updatedAttrs);
            }
            refreshOntologyTree();
            persistOntologyToLocalStorage();
          }
          input.style.display = 'none';
          input.onkeydown = null; input.onblur = null;
        }
        input.onkeydown = (e) => {
          if (e.key === 'Enter') commit(true);
          else if (e.key === 'Escape') commit(false);
        };
        input.onblur = () => commit(true);
      }
      ontoState.cy.on('keydown', 'node,edge', (ev) => {
        if (ev.originalEvent && ev.originalEvent.key === 'F2') showInlineEditor(ev.target);
      });
      // Double-click to edit
      ontoState.cy.on('dblclick', 'node,edge', (ev) => showInlineEditor(ev.target));

      // CAD-like snap-to-grid (only on drag end for smooth experience)
      ontoState.cy.on('dragfree', 'node', (ev) => {
        const node = ev.target;
        if (ontoState.snapToGrid && !node.hasClass('imported')) {
          const snappedPos = snapToGrid(node.position());
          node.position(snappedPos);
          showTemporaryMessage(`Snapped to grid (${snappedPos.x}, ${snappedPos.y})`, 800);
        }
      });

      // Add to undo stack on significant changes
      ontoState.cy.on('add remove', (ev) => {
        const actionType = ev.type;
        const elementType = ev.target.isNode() ? 'node' : 'edge';
        addToUndoStack(actionType, { elementType, count: 1 });
      });

      // Update position inputs when nodes are moved (CAD-like coordinate display)
      ontoState.cy.on('position', 'node', (ev) => {
        // Only update if this node is currently selected
        const node = ev.target;
        if (node.selected()) {
          updatePositionInputs();
        }
      });

      // Context menu actions
      document.addEventListener('click', (e) => {
        const menu = qs('#ontoContextMenu');
        if (!menu) return;
        if (e.target === qs('#menuCancel')) { hideMenu(); return; }
        if (e.target === qs('#menuAddRel')) {
          hideMenu();
          const id = menu.dataset.nodeId; if (!id) return;
          const node = ontoState.cy.$('#' + id)[0]; if (!node) return;
          const t = menu.dataset.nodeType || 'class';
          clearConnectState(); startConnectFrom(node); cmState.sourceType = t;
          return;
        }
        if (e.target === qs('#menuAddDataProp')) {
          hideMenu();
          const id = menu.dataset.nodeId; if (!id) return;
          const node = ontoState.cy.$('#' + id)[0]; if (!node) return;
          // Add a default data property node near the class
          const pos = node.position();
          const pid = `DP${Date.now()}`;
          const label = `Data Property ${Date.now() % 1000}`;
          const dpAttrs = addCreationMetadata({});
          ontoState.cy.add({ group: 'nodes', data: { id: pid, label, type: 'dataProperty', attrs: dpAttrs }, position: { x: pos.x + 120, y: pos.y } });
          // Use objectProperty for the visual connector edge
          const edgeAttrs = addCreationMetadata({});
          ontoState.cy.add({ group: 'edges', data: { id: `edp${Date.now()}`, source: id, target: pid, predicate: label, type: 'objectProperty', attrs: edgeAttrs } });
          refreshOntologyTree(); persistOntologyToLocalStorage();
          return;
        }
      });

      // Edge context menu actions for multiplicity constraints
      document.addEventListener('click', (e) => {
        const edgeMenu = qs('#edgeContextMenu');
        if (!edgeMenu || edgeMenu.style.display === 'none') return;

        const action = e.target.dataset.action;
        if (!action && e.target.id !== 'edgeMenuCancel') return;

        if (e.target.id === 'edgeMenuCancel') {
          hideEdgeMenu();
          return;
        }

        const edgeId = edgeMenu.dataset.edgeId;
        const edge = edgeId ? ontoState.cy.$('#' + edgeId)[0] : null;

        if (!edge) {
          hideEdgeMenu();
          return;
        }

        let minCount = null, maxCount = null;

        switch (action) {
          case 'mult-none':
            minCount = null; maxCount = null;
            break;
          case 'mult-1':
            minCount = 1; maxCount = 1;
            break;
          case 'mult-0-1':
            minCount = 0; maxCount = 1;
            break;
          case 'mult-0-*':
            minCount = 0; maxCount = null;
            break;
          case 'mult-1-*':
            minCount = 1; maxCount = null;
            break;
          case 'mult-custom':
            hideEdgeMenu();
            showCustomMultiplicityDialog(edge);
            return;
          case 'edit-edge':
            hideEdgeMenu();
            showInlineEditor(edge);
            return;
          default:
            return;
        }

        // Update edge multiplicity
        updateEdgeMultiplicity(edge, minCount, maxCount);
        hideEdgeMenu();
      });
      // Clicking a target after 'Add relationship' completes the edge
      ontoState.cy.on('tap', 'node', (ev) => {
        const target = ev.target; if (!cmState.sourceId) return;
        const tgtType = (target.data('type') || 'class');
        const source = ontoState.cy.$('#' + cmState.sourceId)[0]; if (!source) { clearConnectState(); return; }
        const srcType = cmState.sourceType || (source.data('type') || 'class');
        if (source.id() !== target.id()) {
          if (srcType === 'note' && (tgtType === 'class' || tgtType === 'dataProperty')) {
            const edgeAttrs = addCreationMetadata({});
            ontoState.cy.add({ group: 'edges', data: { id: `enote${Date.now()}`, source: source.id(), target: target.id(), predicate: 'note_for', type: 'note', attrs: edgeAttrs } });
            refreshOntologyTree(); persistOntologyToLocalStorage();
          } else if (srcType === 'class' && tgtType === 'class') {
            const edgeAttrs = addCreationMetadata({});
            ontoState.cy.add({ group: 'edges', data: { id: `e${Date.now()}`, source: source.id(), target: target.id(), predicate: 'relatedTo', type: 'objectProperty', attrs: edgeAttrs } });
            refreshOntologyTree(); persistOntologyToLocalStorage();
          }
        }
        source.removeClass('connect-source');
        clearConnectState();
      });

      // Drag-and-drop from tool icons
      const icons = Array.from(document.querySelectorAll('.onto-icon'));
      icons.forEach(icon => {
        icon.addEventListener('dragstart', (ev) => {
          ev.dataTransfer.setData('text/onto-type', icon.getAttribute('data-onto-type') || 'class');
          try { ev.dataTransfer.effectAllowed = 'copy'; } catch (_) { }
        });
      });

      container.addEventListener('dragenter', (ev) => { ev.preventDefault(); });
      container.addEventListener('dragover', (ev) => { ev.preventDefault(); ontoState.isCanvasActive = true; try { ev.dataTransfer.dropEffect = 'copy'; } catch (_) { } });
      container.addEventListener('drop', async (ev) => {
        ev.preventDefault();
        ontoState.isCanvasActive = true;
        const ontoType = ev.dataTransfer.getData('text/onto-type') || 'class';
        const rect = container.getBoundingClientRect();
        const renderedPos = { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
        const pan = ontoState.cy.pan();
        const zoom = ontoState.cy.zoom();
        const pos = { x: (renderedPos.x - pan.x) / zoom, y: (renderedPos.y - pan.y) / zoom };
        if (ontoType === 'class') {
          const label = `Class ${ontoState.nextId}`;
          const id = await addClassNodeAt(label, pos);
          if (id) { ontoState.cy.$('#' + id).select(); }
        } else if (ontoType === 'objectProperty') {
          ontoState.currentPredicateType = 'objectProperty';
          setConnectMode(true);
          // With edgehandles enabled, user can drag handle from a class to another class
        } else if (ontoType === 'dataProperty') {
          const sel = ontoState.cy.nodes(':selected').filter(n => (n.data('type') || 'class') === 'class');
          if (sel.length !== 1) { return; }
          const prop = `Data Property ${Date.now() % 1000}`;
          const pid = `DP${Date.now()}`;
          const dpAttrs = addCreationMetadata({});
          ontoState.cy.add({ group: 'nodes', data: { id: pid, label: prop, type: 'dataProperty', attrs: dpAttrs }, position: pos });
          // Link edge is a visual connector; keep it as objectProperty for consistency
          const edgeAttrs = addCreationMetadata({});
          ontoState.cy.add({ group: 'edges', data: { id: `edp${Date.now()}`, source: sel[0].id(), target: pid, predicate: prop, type: 'objectProperty', attrs: edgeAttrs } });
          refreshOntologyTree();
        } else if (ontoType === 'note') {
          const nid = `Note${Date.now()}`;
          const text = `Note ${nid.slice(-4)}`;

          // Add note with proper metadata
          const attrs = addCreationMetadata({
            noteType: 'Note',
            author: getCurrentUsername() // Keep legacy field for backward compatibility
          });

          ontoState.cy.add({
            group: 'nodes',
            data: {
              id: nid,
              label: text,
              type: 'note',
              attrs
            },
            position: pos,
            classes: 'note'
          });
          // If exactly one class is selected, auto-link note -> class
          const sel = ontoState.cy.nodes(':selected').filter(n => (n.data('type') || 'class') === 'class');
          if (sel && sel.length === 1) {
            const edgeAttrs = addCreationMetadata({});
            ontoState.cy.add({ group: 'edges', data: { id: `enote${Date.now()}`, source: nid, target: sel[0].id(), predicate: 'note_for', type: 'note', attrs: edgeAttrs } });
          }
          refreshOntologyTree(); persistOntologyToLocalStorage();
        }
        persistOntologyToLocalStorage();
      });
      // Bind autosave on edits (add/remove/data) - NOT position changes
      try {
        const autosave = debounce(() => { try { if (activeOntologyIri) persistOntologyToLocalStorage(); } catch (_) { } }, 250);
        ontoState.cy.on('add remove data', autosave);  // Removed 'position' event

        // Create a separate debounced save for layout changes with longer delay
        const layoutSave = debounce(() => {
          try {
            if (activeOntologyIri && !ontoState.layoutRunning) {
              console.log('🔄 Layout save triggered after 5 second delay');
              const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({ data: n.data(), position: n.position() }));
              const edges = ontoState.cy.edges().filter(e => !e.hasClass('imported')).map(e => ({ data: e.data() }));
              saveLayoutToServer(activeOntologyIri, nodes, edges);
            } else if (ontoState.layoutRunning) {
              console.log('⏸️ Layout save skipped - layout algorithm is running');
            }
          } catch (_) { }
        }, 5000); // 5 second delay for layout saves

        // Create a fast debounced save for localStorage (100ms) to prevent excessive writes
        const localStorageSave = debounce(() => {
          try {
            if (activeOntologyIri && !ontoState.layoutRunning) {
              persistOntologyToLocalStorage();

              // Also save layout to localStorage for quick recovery
              const pan = ontoState.cy.pan();
              const zoom = ontoState.cy.zoom();
              const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({
                iri: n.data('id'),
                x: n.position('x'),
                y: n.position('y')
              }));

              const layoutData = {
                nodes: nodes,
                zoom: zoom,
                pan: pan,
                timestamp: Date.now()
              };

              const localLayoutKey = `onto_layout_${encodeURIComponent(activeOntologyIri)}`;
              localStorage.setItem(localLayoutKey, JSON.stringify(layoutData));
              console.log('💾 Layout saved to localStorage');
            }
          } catch (_) { }
        }, 100); // Very short delay - just to batch rapid movements

        ontoState.cy.on('position', layoutSave);
        ontoState.cy.on('position', localStorageSave); // Also save to localStorage quickly
        ontoState.autosaveBound = true;

        // Update modification metadata when elements are moved
        ontoState.cy.on('position', 'node', (evt) => {
          try {
            const node = evt.target;
            if (!node.hasClass('imported')) { // Don't update metadata for imported elements
              const currentAttrs = node.data('attrs') || {};
              const updatedAttrs = updateModificationMetadata(currentAttrs);
              node.data('attrs', updatedAttrs);
            }
          } catch (_) { }
        });
      } catch (_) { }

      // Initialize element IRI display
      updateElementIriDisplay();
    }

    async function addClassNode(label) {
      ensureOntologyInitialized();
      const id = `Class${ontoState.nextId++}`;
      const x = 100 + Math.random() * 400;
      const y = 100 + Math.random() * 300;

      // Add to Cytoscape graph first with metadata
      const attrs = addCreationMetadata({});
      ontoState.cy.add({ group: 'nodes', data: { id, label, type: 'class', attrs }, position: { x, y } });

      // Call backend API to persist to Fuseki with correct graph context
      try {
        const graphUri = activeOntologyIri;
        const url = graphUri ? `/api/ontology/classes?graph=${encodeURIComponent(graphUri)}` : '/api/ontology/classes';

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('odras_token')}`
          },
          body: JSON.stringify({
            name: id,
            label: label,
            comment: ''
          })
        });

        if (response.ok) {
          console.log('✅ Class created in Fuseki:', label);
        } else {
          console.error('❌ Failed to create class in Fuseki:', response.status, response.statusText);
        }
      } catch (error) {
        console.error('❌ Error creating class in Fuseki:', error);
      }

      refreshOntologyTree();
      persistOntologyToLocalStorage();
    }

    async function addClassNodeAt(label, position) {
      ensureOntologyInitialized();
      const id = `Class${ontoState.nextId++}`;

      // Add to Cytoscape graph first with metadata
      const attrs = addCreationMetadata({});
      ontoState.cy.add({ group: 'nodes', data: { id, label, type: 'class', attrs }, position });

      // Call backend API to persist to Fuseki with correct graph context
      try {
        const graphUri = activeOntologyIri;
        const url = graphUri ? `/api/ontology/classes?graph=${encodeURIComponent(graphUri)}` : '/api/ontology/classes';

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('odras_token')}`
          },
          body: JSON.stringify({
            name: id,
            label: label,
            comment: ''
          })
        });

        if (response.ok) {
          console.log('✅ Class created in Fuseki:', label);
        } else {
          console.error('❌ Failed to create class in Fuseki:', response.status, response.statusText);
        }
      } catch (error) {
        console.error('❌ Error creating class in Fuseki:', error);
      }

      refreshOntologyTree();
      persistOntologyToLocalStorage();
      return id;
    }

    function runAutoLayout() {
      // Legacy function - now uses advanced layout
      runAdvancedLayout('cose');
    }

    function runAdvancedLayout(layoutType) {
      ensureOntologyInitialized();
      if (!ontoState.cy) return;

      // Check if a layout is already running
      if (ontoState.layoutRunning) {
        console.log('⏭️ Layout already in progress, skipping...');
        return;
      }

      // Suspend layout saves during layout algorithm execution
      ontoState.layoutRunning = true;
      console.log('🔄 Layout algorithm starting, suspending position saves...');

      let layoutOptions = {
        animate: true,
        animationDuration: 800,
        animationEasing: 'ease-out'
      };

      switch (layoutType) {
        case 'grid':
          layoutOptions = {
            ...layoutOptions,
            name: 'grid',
            cols: Math.ceil(Math.sqrt(ontoState.cy.nodes().length)),
            rows: Math.ceil(ontoState.cy.nodes().length / Math.ceil(Math.sqrt(ontoState.cy.nodes().length))),
            spacingFactor: 1.5
          };
          break;

        case 'circle':
          layoutOptions = {
            ...layoutOptions,
            name: 'circle',
            radius: Math.max(200, ontoState.cy.nodes().length * 30),
            spacingFactor: 1.2
          };
          break;

        case 'concentric':
          layoutOptions = {
            ...layoutOptions,
            name: 'concentric',
            concentric: (node) => {
              // Use node degree as concentric level
              return node.degree();
            },
            levelWidth: (nodes) => {
              return Math.max(100, nodes.length * 20);
            },
            spacingFactor: 1.5
          };
          break;

        case 'breadthfirst':
          layoutOptions = {
            ...layoutOptions,
            name: 'breadthfirst',
            directed: true,
            spacingFactor: 1.5,
            avoidOverlap: true,
            nodeDimensionsIncludeLabels: true
          };
          break;

        case 'cose':
          layoutOptions = {
            ...layoutOptions,
            name: 'cose',
            idealEdgeLength: 150,
            nodeOverlap: 20,
            refresh: 20,
            fit: true,
            padding: 30,
            randomize: false,
            componentSpacing: 100,
            nodeRepulsion: 400000,
            edgeElasticity: 100,
            nestingFactor: 5,
            gravity: 80,
            numIter: 1000,
            initialTemp: 200,
            coolingFactor: 0.95,
            minTemp: 1.0
          };
          break;

        case 'dagre':
          layoutOptions = {
            ...layoutOptions,
            name: 'dagre',
            rankDir: 'TB', // Top to Bottom
            rankSep: 100,
            nodeSep: 50,
            edgeSep: 10,
            ranker: 'tight-tree'
          };
          break;

        case 'cola':
          layoutOptions = {
            ...layoutOptions,
            name: 'cola',
            animate: true,
            refresh: 1,
            maxSimulationTime: 4000,
            ungrabifyWhileSimulating: false,
            fit: true,
            padding: 30,
            randomize: false,
            avoidOverlap: true,
            handleDisconnected: true,
            convergenceThreshold: 0.01,
            nodeSpacing: 20,
            flow: { axis: 'y', minSeparation: 30 },
            alignment: undefined,
            gapInequalities: undefined,
            centerGraph: true
          };
          break;

        case 'spread':
          layoutOptions = {
            ...layoutOptions,
            name: 'spread',
            minDist: 100,
            expandingFactor: -1.0,
            maxExpandingIterations: 4,
            maxContractingIterations: 4,
            initialTemp: 200,
            finalTemp: 0.1,
            coolingFactor: 0.99
          };
          break;

        default:
          console.warn('Unknown layout type:', layoutType);
          layoutOptions.name = 'cose';
      }

      try {
        const layout = ontoState.cy.layout(layoutOptions);

        // Reset flag when layout completes
        layout.on('layoutstop', () => {
          console.log('✅ Layout algorithm completed');
          ontoState.layoutRunning = false;

          // Update modification metadata for all moved nodes
          ontoState.cy.nodes().forEach(node => {
            if (!node.hasClass('imported')) {
              const currentAttrs = node.data('attrs') || {};
              const updatedAttrs = updateModificationMetadata(currentAttrs);
              node.data('attrs', updatedAttrs);
            }
          });

          // Directly save to localStorage and trigger server save
          if (activeOntologyIri) {
            console.log('💾 Saving layout after algorithm completion...');

            // Save to localStorage immediately
            persistOntologyToLocalStorage();

            // Save layout to localStorage for quick recovery
            const pan = ontoState.cy.pan();
            const zoom = ontoState.cy.zoom();
            const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({
              iri: n.data('id'),
              x: n.position('x'),
              y: n.position('y')
            }));

            const layoutData = {
              nodes: nodes,
              zoom: zoom,
              pan: pan,
              timestamp: Date.now()
            };

            const localLayoutKey = `onto_layout_${encodeURIComponent(activeOntologyIri)}`;
            localStorage.setItem(localLayoutKey, JSON.stringify(layoutData));
            console.log('💾 Layout saved to localStorage');

            // Trigger server save after 5 seconds
            setTimeout(() => {
              if (activeOntologyIri) {
                const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({ data: n.data(), position: n.position() }));
                const edges = ontoState.cy.edges().filter(e => !e.hasClass('imported')).map(e => ({ data: e.data() }));
                saveLayoutToServer(activeOntologyIri, nodes, edges);
              }
            }, 5000);
          }

          console.log(`📍 Layout complete - updated metadata for ${ontoState.cy.nodes().filter(n => !n.hasClass('imported')).length} nodes`);
        });

        layout.run();

        // Fit the graph after layout completes
        setTimeout(() => {
          ontoState.cy.fit(undefined, 20);
        }, layoutOptions.animationDuration + 100);

      } catch (error) {
        console.error('Layout error:', error);
        ontoState.layoutRunning = false; // Reset flag on error
        // Fallback to basic cose layout
        const fallbackLayout = ontoState.cy.layout({
          name: 'cose',
          animate: true,
          animationDuration: 500
        });
        fallbackLayout.on('layoutstop', () => {
          ontoState.layoutRunning = false;
          // Update modification metadata for all moved nodes
          ontoState.cy.nodes().forEach(node => {
            if (!node.hasClass('imported')) {
              const currentAttrs = node.data('attrs') || {};
              const updatedAttrs = updateModificationMetadata(currentAttrs);
              node.data('attrs', updatedAttrs);
            }
          });

          // Directly save layout (same as main layout handler)
          if (activeOntologyIri) {
            console.log('💾 Saving layout after fallback algorithm completion...');
            persistOntologyToLocalStorage();

            const pan = ontoState.cy.pan();
            const zoom = ontoState.cy.zoom();
            const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({
              iri: n.data('id'),
              x: n.position('x'),
              y: n.position('y')
            }));

            const layoutData = {
              nodes: nodes,
              zoom: zoom,
              pan: pan,
              timestamp: Date.now()
            };

            const localLayoutKey = `onto_layout_${encodeURIComponent(activeOntologyIri)}`;
            localStorage.setItem(localLayoutKey, JSON.stringify(layoutData));
            console.log('💾 Layout saved to localStorage (fallback)');

            setTimeout(() => {
              if (activeOntologyIri) {
                const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({ data: n.data(), position: n.position() }));
                const edges = ontoState.cy.edges().filter(e => !e.hasClass('imported')).map(e => ({ data: e.data() }));
                saveLayoutToServer(activeOntologyIri, nodes, edges);
              }
            }, 5000);
          }

          console.log(`📍 Layout complete (fallback) - updated metadata for ${ontoState.cy.nodes().filter(n => !n.hasClass('imported')).length} nodes`);
        });
        fallbackLayout.run();
      }
    }

    function setConnectMode(enabled) {
      ensureOntologyInitialized();
      ontoState.connectMode = !!enabled;
      const btn = qs('#ontoConnectBtn');
      if (btn) btn.style.borderColor = enabled ? '#60a5fa' : 'var(--border)';
      if (ontoState.eh) {
        if (enabled) ontoState.eh.enableDrawMode(); else ontoState.eh.disableDrawMode();
      } else {
        if (!enabled) ontoState.clickConnectFrom = null;
      }
    }

    function ensureAttributesExist() {
      // Ensure all nodes have an attrs property
      ontoState.cy.nodes().forEach(n => {
        if (!n.data('attrs')) {
          n.data('attrs', {});
        }
      });

      // Ensure all edges have an attrs property
      ontoState.cy.edges().forEach(e => {
        if (!e.data('attrs')) {
          e.data('attrs', {});
        }
      });
    }

    // Ontology loading progress indicator functions
    function showOntologyLoadingIndicator() {
      // Remove any existing indicator
      hideOntologyLoadingIndicator();

      // Create loading overlay
      const overlay = document.createElement('div');
      overlay.id = 'ontology-loading-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      `;

      const container = document.createElement('div');
      container.style.cssText = `
        background: white;
        border-radius: 12px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        text-align: center;
        min-width: 300px;
        max-width: 500px;
      `;

      const title = document.createElement('h3');
      title.textContent = 'Loading Ontology';
      title.style.cssText = `
        margin: 0 0 20px 0;
        color: #333;
        font-size: 18px;
        font-weight: 600;
      `;

      const progressBar = document.createElement('div');
      progressBar.style.cssText = `
        width: 100%;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 15px;
      `;

      const progressFill = document.createElement('div');
      progressFill.id = 'ontology-progress-fill';
      progressFill.style.cssText = `
        height: 100%;
        background: linear-gradient(90deg, #4CAF50, #45a049);
        width: 0%;
        transition: width 0.3s ease;
        border-radius: 4px;
      `;

      const statusText = document.createElement('div');
      statusText.id = 'ontology-status-text';
      statusText.textContent = 'Initializing...';
      statusText.style.cssText = `
        color: #666;
        font-size: 14px;
        margin-bottom: 10px;
      `;

      const progressText = document.createElement('div');
      progressText.id = 'ontology-progress-text';
      progressText.textContent = '0%';
      progressText.style.cssText = `
        color: #999;
        font-size: 12px;
      `;

      progressBar.appendChild(progressFill);
      container.appendChild(title);
      container.appendChild(progressBar);
      container.appendChild(statusText);
      container.appendChild(progressText);
      overlay.appendChild(container);
      document.body.appendChild(overlay);
    }

    function updateOntologyLoadingProgress(status, percentage) {
      const statusText = document.getElementById('ontology-status-text');
      const progressText = document.getElementById('ontology-progress-text');
      const progressFill = document.getElementById('ontology-progress-fill');

      if (statusText) statusText.textContent = status;
      if (progressText) progressText.textContent = `${percentage}%`;
      if (progressFill) progressFill.style.width = `${percentage}%`;
    }

    function hideOntologyLoadingIndicator() {
      const overlay = document.getElementById('ontology-loading-overlay');
      if (overlay) {
        overlay.remove();
      }
    }

    // Lazy load additional metadata when user clicks on elements
    async function loadAdditionalMetadataForElement(elementId, graphIri) {
      try {
        // Check if we already have rich metadata for this element
        const element = ontoState.cy.getElementById(elementId);
        if (!element || element.data('attrs')?.definition) {
          return; // Already loaded or element doesn't exist
        }

        // Fetch additional metadata for this specific element
        const query = `
          PREFIX owl: <http://www.w3.org/2002/07/owl#>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX dc11: <http://purl.org/dc/elements/1.1/>
          SELECT ?label ?comment ?definition ?example ?identifier WHERE {
            GRAPH <${graphIri}> {
              <${elementId}> rdfs:label ?label .
              OPTIONAL { <${elementId}> rdfs:comment ?comment }
              OPTIONAL { <${elementId}> skos:definition ?definition }
              OPTIONAL { <${elementId}> skos:example ?example }
              OPTIONAL { <${elementId}> dc11:identifier ?identifier }
            }
          }`;

        const response = await authenticatedFetch('/api/ontology/sparql', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query })
        });

        if (response.ok) {
          const result = await response.json();
          if (result.results?.bindings?.length > 0) {
            const binding = result.results.bindings[0];
            const attrs = element.data('attrs') || {};

            // Add the additional metadata
            if (binding.definition) attrs.definition = binding.definition.value;
            if (binding.example) attrs.example = binding.example.value;
            if (binding.identifier) attrs.identifier = binding.identifier.value;
            if (binding.comment) attrs.comment = binding.comment.value;

            element.data('attrs', attrs);

            // Update the properties panel if this element is selected
            if (ontoState.selectedElement && ontoState.selectedElement.id() === elementId) {
              updatePropertiesPanelFromSelection();
            }
          }
        }
      } catch (error) {
        console.error('Error loading additional metadata:', error);
      }
    }

    async function exportOntologyJSON() {
      ensureOntologyInitialized();
      ensureAttributesExist(); // Make sure all elements have attrs property

      // Get ontology name for filename
      const modelNameField = document.querySelector('#propName');
      const ontologyName = modelNameField?.value || 'Ontology Model';
      const safeFilename = ontologyName.toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '')
        .replace(/-+/g, '-');

      // Capture graph data
      const nodes = ontoState.cy.nodes().map(n => ({ data: n.data(), position: n.position() }));
      const edges = ontoState.cy.edges().map(e => ({ data: e.data() }));

      // Get model metadata from properties panel
      const modelMetadata = {};
      if (activeOntologyIri) {
        const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
        const ontologyKey = activeOntologyIri ? activeOntologyIri.split('/').pop() : 'default';
        const modelNameKey = `onto_model_name__${pid}__${ontologyKey}`;
        const modelAttrsKey = `onto_model_attrs__${pid}__${ontologyKey}`;

        modelMetadata.name = localStorage.getItem(modelNameKey) || ontologyName;
        modelMetadata.type = 'Model';

        try {
          const attrs = JSON.parse(localStorage.getItem(modelAttrsKey) || '{}');
          modelMetadata.comment = attrs.comment || '';
          modelMetadata.definition = attrs.definition || '';
          modelMetadata.version = attrs.version || '';
          modelMetadata.namespace = attrs.namespace || activeOntologyIri;
          modelMetadata.imports = attrs.imports || '';
        } catch (_) {
          modelMetadata.comment = '';
          modelMetadata.definition = '';
          modelMetadata.version = '';
          modelMetadata.namespace = activeOntologyIri;
          modelMetadata.imports = '';
        }
      }

      // Get named views
      let namedViews = [];
      try {
        namedViews = await loadNamedViews(activeOntologyIri);
      } catch (error) {
        console.warn('Could not load named views for export:', error);
        namedViews = [];
      }

      // Create complete export payload
      const payload = {
        metadata: {
          exportedBy: getCurrentUsername(),
          exportedDate: getCurrentDate(),
          exportedTimestamp: getCurrentTimestamp(),
          ontologyIri: activeOntologyIri,
          exportVersion: '1.0'
        },
        model: modelMetadata,
        nodes: nodes,
        edges: edges,
        namedViews: namedViews
      };

      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${safeFilename}.json`;
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();

      console.log(`📋 Exported ontology as: ${safeFilename}.json`);
      console.log('📋 Export includes:', Object.keys(payload));
    }

    function slugId(text) {
      return String(text || '').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
    }

    function iriMapKey(graphIri) { return 'onto_iri_map__' + encodeURIComponent(graphIri); }
    function loadIriMap(graphIri) { try { return JSON.parse(localStorage.getItem(iriMapKey(graphIri)) || '{}'); } catch (_) { return {}; } }
    function saveIriMap(graphIri, map) {
      try { localStorage.setItem(iriMapKey(graphIri), JSON.stringify(map || {})); } catch (_) { }
    }

    /**
     * Extract RDF property URI from attribute template label
     * Example: 'Comment (rdfs:comment)' → 'rdfs:comment'
     */
    function extractRdfPropertyFromLabel(label) {
      const match = label.match(/\(([^)]+)\)$/);
      return match ? match[1] : null;
    }

    /**
     * Create flexible mapping from UI attributes to RDF properties
     * Uses the attributeTemplates to automatically map UI fields to RDF predicates
     */
    function getAttributeToRdfMapping(objectType) {
      const template = attributeTemplates[objectType] || {};
      const mapping = {};

      Object.entries(template).forEach(([attrKey, config]) => {
        const rdfProperty = extractRdfPropertyFromLabel(config.label || attrKey);
        if (rdfProperty) {
          mapping[attrKey] = rdfProperty;
        }
      });

      return mapping;
    }

    /**
     * Generate RDF triples for element attributes
     * Converts UI attributes to proper RDF annotation properties
     */
    function generateAttributeTriples(elementIri, attrs, objectType) {
      const mapping = getAttributeToRdfMapping(objectType);
      const triples = [];

      Object.entries(attrs).forEach(([attrKey, value]) => {
        const rdfProperty = mapping[attrKey];

        // Skip if no RDF mapping or empty value
        if (!rdfProperty || !value) return;

        // Skip readonly metadata fields that shouldn't be saved as RDF
        if (attrKey.includes('_timestamp') || attrKey.includes('readonly')) return;

        // Handle different data types
        if (typeof value === 'boolean') {
          triples.push(`<${elementIri}> ${rdfProperty} ${value} .`);
        } else if (typeof value === 'string') {
          // Escape quotes and backslashes for RDF literals
          const escapedValue = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
          triples.push(`<${elementIri}> ${rdfProperty} "${escapedValue}" .`);
        }
      });

      return triples;
    }

    function toTurtle(graphIri, linkedPairsOpt) {
      // Build per-graph stable id→IRI map
      const iriMap = loadIriMap(graphIri);
      const lines = [
        '@prefix owl: <http://www.w3.org/2002/07/owl#> .',
        '@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .',
        '@prefix skos: <http://www.w3.org/2004/02/skos/core#> .',
        '@prefix dc: <http://purl.org/dc/elements/1.1/> .',
        '@prefix dcterms: <http://purl.org/dc/terms/> .',
        '@prefix odras: <http://odras.system/ontology#> .',
        '@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .',
        (() => {
          try {
            const labels = loadOntologyLabelMap(activeProject);
            const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';

            // FIXED: Use ontology-specific localStorage keys
            const ontologyKey = graphIri ? graphIri.split('/').pop() : 'default';
            const modelNameKey = `onto_model_name__${pid}__${ontologyKey}`;
            const modelAttrsKey = `onto_model_attrs__${pid}__${ontologyKey}`;

            const scopedName = localStorage.getItem(modelNameKey) || '';
            const mapLabel = labels[graphIri] || '';
            const tail = (graphIri.split('/').pop() || graphIri);
            // Prefer the actively edited model name, then label map, then IRI tail
            const chosen = ((activeOntologyIri === graphIri && scopedName.trim()) || mapLabel || tail);
            const lbl = String(chosen || '');

            // Get ontology metadata attributes from localStorage using ontology-specific key
            let ontologyAttrs = {};
            try {
              ontologyAttrs = JSON.parse(localStorage.getItem(modelAttrsKey) || '{}');
            } catch (_) {
              ontologyAttrs = {};
            }

            // Build ontology declaration with all metadata
            let ontologyDecl = `\n<${graphIri}> a owl:Ontology ;\n`;
            ontologyDecl += `    rdfs:label "${String(lbl || '').replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;

            // Add comment if present
            if (ontologyAttrs.comment && ontologyAttrs.comment.trim()) {
              ontologyDecl += ` ;\n    rdfs:comment "${String(ontologyAttrs.comment).replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
            }

            // Add definition if present
            if (ontologyAttrs.definition && ontologyAttrs.definition.trim()) {
              ontologyDecl += ` ;\n    skos:definition "${String(ontologyAttrs.definition).replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
            }

            // Add version if present
            if (ontologyAttrs.version && ontologyAttrs.version.trim()) {
              ontologyDecl += ` ;\n    owl:versionInfo "${String(ontologyAttrs.version).replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
            }

            ontologyDecl += ' .\n';
            return ontologyDecl;
          } catch (_) { return `\n<${graphIri}> a owl:Ontology .\n`; }
        })()
      ];
      // Include owl:imports from local storage
      try {
        const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(graphIri)) || '[]');
        imports.forEach(imp => { lines.push(`<${graphIri}> <http://www.w3.org/2002/07/owl#imports> <${imp}> .`); });
      } catch (_) { }
      const nodes = ontoState.cy.nodes();
      const edges = ontoState.cy.edges();
      function nodeIri(n) {
        const id = n.id();
        if (iriMap[id]) return iriMap[id];
        const explicit = n.data('iri');
        if (explicit) { iriMap[id] = explicit; return explicit; }

        // Use model namespace instead of graph IRI for element IRIs
        const modelNamespace = getModelNamespace();
        const base = slugId(n.data('label') || id) || id;
        const iri = `${modelNamespace}#${base}`;
        iriMap[id] = iri;
        return iri;
      }
      // Classes and data properties (exclude imported overlays)
      nodes.forEach(n => {
        if (n.hasClass && n.hasClass('imported')) return;
        const t = n.data('type') || 'class';
        const iri = nodeIri(n);
        const label = (n.data('label') || '').replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        if (t === 'class') {
          lines.push(`<${iri}> a owl:Class ; rdfs:label "${label}" .`);

          // Add attributes as RDF annotation properties
          const attrs = n.data('attrs') || {};
          const attributeTriples = generateAttributeTriples(iri, attrs, 'class');
          lines.push(...attributeTriples);
        } else if (t === 'dataProperty') {
          lines.push(`<${iri}> a owl:DatatypeProperty ; rdfs:label "${label}" .`);
          const incoming = n.incomers('edge');
          if (incoming && incoming.length) {
            const src = incoming[0].source();
            const srcIri = nodeIri(src);
            lines.push(`<${iri}> rdfs:domain <${srcIri}> .`);
            lines.push(`<${iri}> rdfs:range <http://www.w3.org/2001/XMLSchema#string> .`);
          }

          // Add attributes as RDF annotation properties
          const attrs = n.data('attrs') || {};
          const attributeTriples = generateAttributeTriples(iri, attrs, 'dataProperty');
          lines.push(...attributeTriples);
        } else if (t === 'note') {
          lines.push(`<${iri}> a skos:Note ; rdfs:label "${label}" .`);

          // Add attributes as RDF annotation properties
          const attrs = n.data('attrs') || {};
          const attributeTriples = generateAttributeTriples(iri, attrs, 'note');
          lines.push(...attributeTriples);
        }
      });
      // Object properties from edges
      const existingEquiv = new Set();
      edges.forEach(e => {
        if (e.hasClass && (e.hasClass('imported') || e.hasClass('imported-equivalence'))) return;
        const s = e.source(); const t = e.target();
        const pred = (e.data('predicate') || 'relatedTo').replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        const modelNamespace = getModelNamespace();
        const propIri = `${modelNamespace}#${slugId(pred)}`;
        const sIri = nodeIri(s); const tIri = nodeIri(t);
        const isData = (e.data('type') || 'objectProperty') === 'dataProperty';
        const sType = (s.data('type') || 'class'); const tType = (t.data('type') || 'class');
        if (!isData) {
          if (sType === 'class' && tType === 'class') {
            // Treat special case for equivalence edges represented in UI as predicate 'equivalentClass'
            if (pred === 'equivalentClass' || pred === 'linked_by') {
              const key = `${sIri}|${tIri}`;
              if (!existingEquiv.has(key)) {
                existingEquiv.add(key);
                lines.push(`<${sIri}> owl:equivalentClass <${tIri}> .`);
              }
            } else {
              lines.push(`<${propIri}> a owl:ObjectProperty ; rdfs:label "${pred}" ; rdfs:domain <${sIri}> ; rdfs:range <${tIri}> .`);

              // Add attributes as RDF annotation properties for object properties
              const attrs = e.data('attrs') || {};
              const attributeTriples = generateAttributeTriples(propIri, attrs, 'objectProperty');
              lines.push(...attributeTriples);
            }
          } else if (sType === 'note' && (tType === 'class' || tType === 'dataProperty') && pred === 'note_for') {
            // Emit skos:note_for relationship to connect note to target element
            lines.push(`<${sIri}> skos:note_for <${tIri}> .`);
          }
        }
      });
      // Add auto-computed equivalence pairs (no UI edges) if provided
      if (Array.isArray(linkedPairsOpt)) {
        linkedPairsOpt.forEach(p => {
          try {
            const n = p.baseNode; const targetIri = p.importIri;
            const sIri = nodeIri(n);
            const key = `${sIri}|${targetIri}`;
            if (!existingEquiv.has(key)) {
              existingEquiv.add(key);
              lines.push(`<${sIri}> owl:equivalentClass <${targetIri}> .`);
            }
          } catch (_) { }
        });
      }
      saveIriMap(graphIri, iriMap);
      return lines.join('\n');
    }

    // Compute linked_by pairs between base classes and imported graphs by label/local name
    async function computeLinkedByPairs(graphIri) {
      try {
        const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(graphIri)) || '[]');
        if (!imports || !imports.length || !ontoState.cy) return [];
        const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type') || 'class') === 'class' && !n.hasClass('imported'));
        const norm = (s) => String(s || '').trim().toLowerCase();
        const baseByLabel = new Map();
        baseClasses.forEach(n => { baseByLabel.set(norm(n.data('label') || n.id()), n); });
        const pairs = [];
        for (const imp of imports) {
          const q = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?c ?label WHERE { GRAPH <${imp}> { ?c a owl:Class . OPTIONAL { ?c rdfs:label ?label } } }`;
          const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
          if (!res.ok) continue;
          const json = await res.json();
          const rows = (json && json.results && json.results.bindings) ? json.results.bindings : [];
          rows.forEach(b => {
            const iri = b.c && b.c.value; const label = b.label && b.label.value;
            const local = iri ? (iri.includes('#') ? iri.split('#').pop() : iri.split('/').pop()) : '';
            const key = norm(label || local);
            const base = baseByLabel.get(key);
            if (base && iri) pairs.push({ baseNode: base, importIri: iri });
          });
        }
        // Deduplicate pairs by base id + target iri
        const out = [];
        const seen = new Set();
        pairs.forEach(p => { const k = p.baseNode.id() + '|' + p.importIri; if (!seen.has(k)) { seen.add(k); out.push(p); } });
        return out;
      } catch (_) { return []; }
    }

    // Imported overlay visibility persistence
    function visibleImportsKey(graphIri) { return 'onto_imports_visible__' + encodeURIComponent(graphIri || ''); }
    function loadVisibleImports(graphIri) { try { return new Set(JSON.parse(localStorage.getItem(visibleImportsKey(graphIri)) || '[]')); } catch (_) { return new Set(); } }
    function saveVisibleImports(graphIri, set) { try { localStorage.setItem(visibleImportsKey(graphIri), JSON.stringify(Array.from(set || []))); } catch (_) { } }

    // Reference ontology selector
    async function showReferenceOntologySelector() {
      try {
        const token = localStorage.getItem(tokenKey);
        const res = await fetch('/api/ontologies/reference', {
          headers: { Authorization: 'Bearer ' + token }
        });

        if (!res.ok) {
          throw new Error('Failed to fetch reference ontologies');
        }

        const json = await res.json();
        const referenceOntologies = json.reference_ontologies || [];

        // Create overlay
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.inset = '0';
        overlay.style.background = 'rgba(0,0,0,0.4)';
        overlay.style.zIndex = '9998';

        const panel = document.createElement('div');
        panel.style.position = 'fixed';
        panel.style.top = '10%';
        panel.style.left = '50%';
        panel.style.transform = 'translateX(-50%)';
        panel.style.background = 'var(--panel)';
        panel.style.border = '1px solid var(--border)';
        panel.style.borderRadius = '12px';
        panel.style.padding = '20px';
        panel.style.minWidth = '600px';
        panel.style.maxWidth = '80vw';
        panel.style.maxHeight = '80vh';
        panel.style.overflow = 'auto';
        panel.style.zIndex = '9999';

        panel.innerHTML = `
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <h3 style="margin:0;">Import Reference Ontology</h3>
            <button id="refOntClose" class="btn" style="background: var(--muted);">Close</button>
          </div>


          <!-- Existing Reference Ontologies Section -->
          <div>
            <h4 style="margin:0 0 12px 0;">📚 Existing Reference Ontologies</h4>
            <div id="refOntList" style="max-height:300px; overflow-y:auto;">
              ${referenceOntologies.length === 0 ?
            '<div style="text-align:center; color:var(--muted); padding:20px;">No reference ontologies available</div>' :
            referenceOntologies.map(onto => `
                  <div style="display:flex; justify-content:space-between; align-items:center; border:1px solid var(--border); border-radius:8px; padding:12px; margin-bottom:8px; cursor:pointer;"
                       data-graph-iri="${onto.graph_iri}" class="ref-onto-item">
                    <div>
                      <div style="font-weight:500;">${onto.label || onto.graph_iri.split('/').pop()}</div>
                      <div style="font-size:0.9em; color:var(--muted);">${onto.project_name} • ${onto.graph_iri}</div>
                    </div>
                    <button class="btn" data-graph-iri="${onto.graph_iri}">Import</button>
                  </div>
                `).join('')
          }
            </div>
          </div>
        `;

        document.body.appendChild(overlay);
        document.body.appendChild(panel);

        const close = () => {
          try {
            document.body.removeChild(panel);
            document.body.removeChild(overlay);
          } catch (_) { }
        };

        panel.querySelector('#refOntClose').onclick = close;
        overlay.onclick = close;


        // Add hover effects for existing ontologies
        panel.querySelectorAll('.ref-onto-item').forEach(item => {
          item.onmouseover = () => item.style.background = 'var(--hover)';
          item.onmouseout = () => item.style.background = 'transparent';
        });

        // Handle import clicks for existing ontologies
        const listEl = panel.querySelector('#refOntList');
        listEl.addEventListener('click', async (e) => {
          const btn = e.target.closest('button[data-graph-iri]');
          if (!btn) return;

          const graphIri = btn.getAttribute('data-graph-iri');
          const importsKey = 'onto_imports__' + encodeURIComponent(activeOntologyIri || '');

          try {
            const curr = new Set(JSON.parse(localStorage.getItem(importsKey) || '[]'));
            console.log('🔍 Current imports:', Array.from(curr));
            console.log('🔍 Adding import:', graphIri);
            if (!curr.has(graphIri)) {
              curr.add(graphIri);
              localStorage.setItem(importsKey, JSON.stringify(Array.from(curr)));
              console.log('🔍 Import added, refreshing tree...');
              refreshOntologyTree();
              toast('Reference ontology imported successfully');
            } else {
              console.log('🔍 Import already exists');
              toast('Reference ontology already imported', true);
            }
            close();
          } catch (err) {
            console.error('🔍 Error importing reference ontology:', err);
            toast('Failed to import reference ontology', true);
          }
        });

      } catch (err) {
        toast('Failed to load reference ontologies', true);
      }
    }

    // Persist per-import overlay node positions
    function overlayPositionsKey(baseIri, importIri) { return 'onto_import_positions__' + encodeURIComponent(baseIri || '') + '__' + encodeURIComponent(importIri || ''); }
    function loadOverlayPositions(baseIri, importIri) { try { return JSON.parse(localStorage.getItem(overlayPositionsKey(baseIri, importIri)) || '{}'); } catch (_) { return {}; } }
    function saveOverlayPositions(baseIri, importIri, obj) { try { localStorage.setItem(overlayPositionsKey(baseIri, importIri), JSON.stringify(obj || {})); } catch (_) { } }

    // Collapsed imports persistence
    function collapsedImportsKey(baseIri) { return 'onto_collapsed_imports__' + encodeURIComponent(baseIri || ''); }
    function loadCollapsedImports(baseIri) {
      try {
        const data = localStorage.getItem(collapsedImportsKey(baseIri));
        return data ? new Set(JSON.parse(data)) : new Set();
      } catch (_) {
        return new Set();
      }
    }
    function saveCollapsedImports(baseIri, collapsedSet) {
      try {
        localStorage.setItem(collapsedImportsKey(baseIri), JSON.stringify(Array.from(collapsedSet)));
      } catch (_) { }
    }

    // Pseudo-node positions persistence
    function pseudoNodePositionsKey(baseIri) { return 'onto_pseudo_positions__' + encodeURIComponent(baseIri || ''); }
    function loadPseudoNodePositions(baseIri) {
      try {
        return JSON.parse(localStorage.getItem(pseudoNodePositionsKey(baseIri)) || '{}');
      } catch (_) {
        return {};
      }
    }
    function savePseudoNodePositions(baseIri, positions) {
      try {
        localStorage.setItem(pseudoNodePositionsKey(baseIri), JSON.stringify(positions || {}));
      } catch (_) { }
    }

    // Visibility state persistence
    function visibilityStateKey(baseIri) { return 'onto_visibility_state__' + encodeURIComponent(baseIri || ''); }
    function loadVisibilityState(baseIri) {
      try {
        const saved = JSON.parse(localStorage.getItem(visibilityStateKey(baseIri)) || '{}');
        return {
          classes: saved.classes !== undefined ? saved.classes : true,
          dataProperties: saved.dataProperties !== undefined ? saved.dataProperties : true,
          notes: saved.notes !== undefined ? saved.notes : true,
          edges: saved.edges !== undefined ? saved.edges : true,
          imported: saved.imported !== undefined ? saved.imported : true
        };
      } catch (_) {
        return {
          classes: true,
          dataProperties: true,
          notes: true,
          edges: true,
          imported: true
        };
      }
    }
    function saveVisibilityState(baseIri, state) {
      try {
        localStorage.setItem(visibilityStateKey(baseIri), JSON.stringify(state || {}));
      } catch (_) { }
    }

    // Individual element visibility persistence
    function elementVisibilityKey(baseIri) { return 'onto_element_visibility__' + encodeURIComponent(baseIri || ''); }
    function loadElementVisibility(baseIri) {
      try {
        return JSON.parse(localStorage.getItem(elementVisibilityKey(baseIri)) || '{}');
      } catch (_) {
        return {};
      }
    }
    function saveElementVisibility(baseIri, visibility) {
      try {
        localStorage.setItem(elementVisibilityKey(baseIri), JSON.stringify(visibility || {}));
      } catch (_) { }
    }

    async function fetchImportGraphSnapshot(importIri) {
      try {
        // First try to get data from local storage (consistent with importEquivCount)
        const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
        const importKey = `onto_graph__${pid}__` + encodeURIComponent(importIri);
        let importData = localStorage.getItem(importKey);

        if (!importData) {
          console.log('🔍 No local storage data found for import snapshot, attempting to load from API:', importIri);
          try {
            // Try to load the imported ontology data from API
            const token = localStorage.getItem(tokenKey);
            const apiUrl = `/api/ontology/?graph=${encodeURIComponent(importIri)}`;
            const response = await fetch(apiUrl, {
              headers: token ? { 'Authorization': `Bearer ${token}` } : {}
            });

            if (response.ok) {
              const ontologyData = await response.json();
              console.log('🔍 Loaded imported ontology from API for snapshot:', ontologyData);
              console.log('🔍 Snapshot API response structure - classes:', ontologyData.classes);
              console.log('🔍 Snapshot API response structure - object_properties:', ontologyData.object_properties);

              // Convert to Cytoscape format and save to local storage
              // Use a simpler conversion since we don't have rich metadata
              // The API response has the data nested in a 'data' property
              const actualOntologyData = ontologyData.data || ontologyData;
              const cytoscapeData = convertOntologyToCytoscape(actualOntologyData);
              console.log('🔍 Snapshot converted cytoscape data:', cytoscapeData);
              const storageData = {
                nodes: cytoscapeData.nodes || [],
                edges: cytoscapeData.edges || [],
                timestamp: Date.now(),
                source: 'api'
              };

              localStorage.setItem(importKey, JSON.stringify(storageData));
              importData = JSON.stringify(storageData);
              console.log('🔍 Saved imported ontology data to local storage for snapshot');
            } else {
              console.log('🔍 Failed to load imported ontology from API for snapshot:', response.status);
              // Fall through to SPARQL fallback
            }
          } catch (err) {
            console.error('🔍 Error loading imported ontology for snapshot:', err);
            // Fall through to SPARQL fallback
          }
        }

        // Check if cached data is empty and force reload
        if (importData) {
          const cachedData = JSON.parse(importData);
          if (cachedData.nodes && cachedData.nodes.length === 0 && cachedData.edges && cachedData.edges.length === 0) {
            console.log('🔍 Snapshot cached data is empty, forcing reload from API:', importIri);
            try {
              const token = localStorage.getItem(tokenKey);
              const apiUrl = `/api/ontology/?graph=${encodeURIComponent(importIri)}`;
              const response = await fetch(apiUrl, {
                headers: token ? { 'Authorization': `Bearer ${token}` } : {}
              });

              if (response.ok) {
                const ontologyData = await response.json();
                console.log('🔍 Snapshot reloaded imported ontology from API:', ontologyData);
                console.log('🔍 Snapshot reload API response structure - classes:', ontologyData.classes);
                console.log('🔍 Snapshot reload API response structure - object_properties:', ontologyData.object_properties);

                // Convert to Cytoscape format and save to local storage
                // The API response has the data nested in a 'data' property
                const actualOntologyData = ontologyData.data || ontologyData;
                console.log('🔍 Snapshot reload actual ontology data being passed to convertOntologyToCytoscape:', actualOntologyData);
                console.log('🔍 Snapshot reload actualOntologyData.classes:', actualOntologyData.classes);
                const cytoscapeData = convertOntologyToCytoscape(actualOntologyData);
                console.log('🔍 Snapshot reload converted cytoscape data:', cytoscapeData);
                const storageData = {
                  nodes: cytoscapeData.nodes || [],
                  edges: cytoscapeData.edges || [],
                  timestamp: Date.now(),
                  source: 'api'
                };

                localStorage.setItem(importKey, JSON.stringify(storageData));
                importData = JSON.stringify(storageData);
                console.log('🔍 Snapshot reloaded and saved imported ontology data to local storage');
              } else {
                console.log('🔍 Failed to reload imported ontology from API for snapshot:', response.status);
              }
            } catch (err) {
              console.error('🔍 Error reloading imported ontology for snapshot:', err);
            }
          }
        }

        if (importData) {
          console.log('🔍 Using local storage data for import snapshot:', importIri);
          const importOntology = JSON.parse(importData);
          console.log('🔍 Import ontology data:', importOntology);
          const importNodes = importOntology.nodes || [];
          const importEdges = importOntology.edges || [];
          console.log('🔍 Import nodes count:', importNodes.length);
          console.log('🔍 Import edges count:', importEdges.length);

          // Convert Cytoscape nodes to snapshot format
          const classes = importNodes
            .filter(node => (node.data && node.data.type === 'class') || !node.data?.type)
            .map(node => {
              console.log('🔍 Import node data:', node);
              return {
                iri: node.data?.iri || node.id,
                label: node.data?.label || node.data?.id || node.id,
                comment: node.data?.comment || '',
                attrs: node.data?.attrs || {}
              };
            });

          // Convert Cytoscape edges to snapshot format
          const edges = importEdges
            .filter(edge => edge.data && edge.data.source && edge.data.target)
            .map(edge => ({
              sourceIri: edge.data.source,
              targetIri: edge.data.target,
              label: edge.data.predicate || 'relatedTo',
              attrs: edge.data.attrs || {}
            }));

          console.log('🔍 Processed edges count:', edges.length);

          console.log('🔍 Final import classes:', classes);
          classes.forEach((cls, i) => {
            console.log(`🔍 Class ${i}:`, cls);
          });
          return { classes, edges, importNodes };
        }

        // Fallback to SPARQL if no local storage data
        console.log('🔍 No local storage data, using SPARQL for import snapshot:', importIri);
        const qClasses = `
          PREFIX owl: <http://www.w3.org/2002/07/owl#>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX dc11: <http://purl.org/dc/elements/1.1/>
          PREFIX dcterms: <http://purl.org/dc/terms/>
          PREFIX obo: <http://purl.obolibrary.org/obo/>
          SELECT ?c ?label ?comment ?definition ?example ?identifier ?subclassOf ?equivalentClass WHERE {
            GRAPH <${importIri}> {
              ?c a owl:Class .
              OPTIONAL { ?c rdfs:label ?label }
              OPTIONAL { ?c rdfs:comment ?comment }
              OPTIONAL { ?c skos:definition ?definition }
              OPTIONAL { ?c skos:example ?example }
              OPTIONAL { ?c dc11:identifier ?identifier }
              OPTIONAL { ?c rdfs:subClassOf ?subclassOf }
              OPTIONAL { ?c owl:equivalentClass ?equivalentClass }
            }
          }`;

        const qProps = `
          PREFIX owl: <http://www.w3.org/2002/07/owl#>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX dc11: <http://purl.org/dc/elements/1.1/>
          PREFIX dcterms: <http://purl.org/dc/terms/>
          SELECT ?p ?label ?comment ?definition ?example ?identifier ?domain ?range ?inverseOf ?subPropertyOf ?equivalentProperty ?propertyType WHERE {
            GRAPH <${importIri}> {
              ?p a owl:ObjectProperty .
              OPTIONAL { ?p rdfs:label ?label }
              OPTIONAL { ?p rdfs:comment ?comment }
              OPTIONAL { ?p skos:definition ?definition }
              OPTIONAL { ?p skos:example ?example }
              OPTIONAL { ?p dc11:identifier ?identifier }
              OPTIONAL { ?p rdfs:domain ?domain }
              OPTIONAL { ?p rdfs:range ?range }
              OPTIONAL { ?p owl:inverseOf ?inverseOf }
              OPTIONAL { ?p rdfs:subPropertyOf ?subPropertyOf }
              OPTIONAL { ?p owl:equivalentProperty ?equivalentProperty }
              OPTIONAL { ?p a ?propertyType }
            }
          }`;

        const classesRes = await authenticatedFetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qClasses }) });
        const propsRes = await authenticatedFetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qProps }) });
        const classesJson = classesRes.ok ? await classesRes.json() : { results: { bindings: [] } };
        const propsJson = propsRes.ok ? await propsRes.json() : { results: { bindings: [] } };

        // Enhanced class processing with rich metadata
        const cls = (classesJson.results?.bindings || []).map(b => {
          const iri = b.c.value;
          const label = (b.label && b.label.value) || (iri.includes('#') ? iri.split('#').pop() : iri.split('/').pop());
          const attrs = {};

          // Store all available metadata
          if (b.comment && b.comment.value) attrs.comment = b.comment.value;
          if (b.definition && b.definition.value) attrs.definition = b.definition.value;
          if (b.example && b.example.value) attrs.example = b.example.value;
          if (b.identifier && b.identifier.value) attrs.identifier = b.identifier.value;
          if (b.subclassOf && b.subclassOf.value) attrs.subclassOf = b.subclassOf.value;
          if (b.equivalentClass && b.equivalentClass.value) attrs.equivalentClass = b.equivalentClass.value;

          return { iri, label, attrs };
        });

        // Enhanced property processing with rich metadata
        const edges = [];
        (propsJson.results?.bindings || []).forEach(b => {
          const p = b.p.value;
          const label = (b.label && b.label.value) || (p.includes('#') ? p.split('#').pop() : p.split('/').pop());
          const attrs = {};

          // Store all available metadata
          if (b.comment && b.comment.value) attrs.comment = b.comment.value;
          if (b.definition && b.definition.value) attrs.definition = b.definition.value;
          if (b.example && b.example.value) attrs.example = b.example.value;
          if (b.identifier && b.identifier.value) attrs.identifier = b.identifier.value;
          if (b.domain && b.domain.value) attrs.domain = b.domain.value;
          if (b.range && b.range.value) attrs.range = b.range.value;
          if (b.inverseOf && b.inverseOf.value) attrs.inverseOf = b.inverseOf.value;
          if (b.subPropertyOf && b.subPropertyOf.value) attrs.subPropertyOf = b.subPropertyOf.value;
          if (b.equivalentProperty && b.equivalentProperty.value) attrs.equivalentProperty = b.equivalentProperty.value;
          if (b.propertyType && b.propertyType.value) attrs.propertyType = b.propertyType.value;

          // Create edges for domain-range relationships
          if (b.domain && b.range) {
            edges.push({
              sourceIri: b.domain.value,
              targetIri: b.range.value,
              label,
              predicate: p,
              attrs
            });
          }
        });

        return { classes: cls, edges };
      } catch (_) { return { classes: [], edges: [] }; }
    }

    async function overlayImportsRefresh() {
      try {
        if (!ontoState.cy || !activeOntologyIri) {
          console.log('🔍 overlayImportsRefresh: No cytoscape instance or active ontology');
          return;
        }

        const visible = loadVisibleImports(activeOntologyIri);
        const visibleList = Array.from(visible);
        console.log('🔍 overlayImportsRefresh: Visible imports:', visibleList);

        // Before removing overlays, snapshot positions for imports being hidden
        try {
          ontoState.cy.nodes('.imported').forEach(n => {
            const imp = n.data('importSource') || '';
            if (!visible.has(imp)) {
              const curr = loadOverlayPositions(activeOntologyIri, imp);
              curr[n.id()] = n.position();
              saveOverlayPositions(activeOntologyIri, imp, curr);
            }
          });
        } catch (err) {
          console.error('🔍 Error saving overlay positions:', err);
        }

        // Remove overlays for imports no longer visible
        try {
          const elementsToRemove = ontoState.cy.elements('.imported, .imported-equivalence').filter(el => {
            const importSource = el.data('importSource') || '';
            return !visible.has(importSource);
          });
          console.log('🔍 overlayImportsRefresh: Removing', elementsToRemove.length, 'elements');
          elementsToRemove.remove();
        } catch (err) {
          console.error('🔍 Error removing overlay elements:', err);
        }
        // Add overlays for newly visible imports
        for (const imp of visibleList) {
          const existing = ontoState.cy.elements('.imported').filter(e => (e.data('importSource') || '') === imp);
          if (existing && existing.length) continue;
          const snap = await fetchImportGraphSnapshot(imp);
          const added = [];
          // Compute a simple cluster origin to the right of the base graph to avoid overlap (notes included)
          const baseBBox = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).boundingBox();
          const orderIndex = Math.max(0, visibleList.indexOf(imp));
          const padX = 200, padY = 40, jitterX = orderIndex * 100, jitterY = orderIndex * 60;
          const safe = (n, f) => (Number.isFinite(n) ? n : f);
          const originX = safe(baseBBox.x2, 0) + padX + jitterX;
          const originY = safe(baseBBox.y1, 0) + jitterY;
          const total = Math.max(1, snap.classes.length);
          const cols = Math.ceil(Math.sqrt(total));
          const spacing = 160;
          let nextIdx = 0;
          function nextPos() {
            const col = nextIdx % cols; const row = Math.floor(nextIdx / cols); nextIdx += 1;
            return { x: originX + col * spacing, y: originY + row * spacing };
          }
          // Add class nodes in a simple grid within the cluster; apply saved positions if available
          const savedPos = loadOverlayPositions(activeOntologyIri, imp);
          console.log('🔍 Loading saved positions for import:', imp, savedPos);
          const isCollapsed = ontoState.collapsedImports.has(imp);

          if (isCollapsed) {
            // Create pseudo-node for collapsed import
            const importData = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(activeOntologyIri || '')) || '[]').find(importData => importData.iri === imp);
            const importName = importData?.label || imp.split('/').pop() || imp;

            // Check if pseudo-node already exists
            const pseudoNodeId = `pseudo-import-${CSS.escape(imp)}`;
            const existingPseudoNode = ontoState.cy.$(`#${CSS.escape(pseudoNodeId)}`);

            if (existingPseudoNode.length === 0) {
              // Load saved position for pseudo-node
              const pseudoPositions = loadPseudoNodePositions(activeOntologyIri);
              let position = pseudoPositions[pseudoNodeId];

              if (!position) {
                // Calculate center position for pseudo-node if no saved position
                const baseBBox = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).boundingBox();
                const orderIndex = Math.max(0, visibleList.indexOf(imp));
                const padX = 200, jitterX = orderIndex * 100, jitterY = orderIndex * 60;
                const safe = (n, f) => (Number.isFinite(n) ? n : f);
                position = {
                  x: safe(baseBBox.x2, 0) + padX + jitterX,
                  y: safe(baseBBox.y1, 0) + jitterY
                };
              }

              const pseudoNode = ontoState.cy.add({
                group: 'nodes',
                data: {
                  id: pseudoNodeId,
                  label: importName,
                  type: 'import',
                  importSource: imp,
                  isPseudo: true,
                  attrs: {}
                },
                position: position,
                classes: 'imported pseudo-import'
              });
              added.push(pseudoNode);
            }
          } else {
            // Create all imported nodes normally
            snap.classes.forEach((c, index) => {
              // Use the original node ID from the local storage data if available, otherwise generate one
              const originalId = snap.importNodes?.[index]?.data?.id || `Class${index + 1}`;
              const id = `imp:${imp}#${originalId}`;
              console.log('🔍 Creating imported node with ID:', id, 'originalId:', originalId, 'from snapNode:', snap.importNodes?.[index]);
              if (ontoState.cy.$(`#${CSS.escape(id)}`).length) return;
              const pos = savedPos[id] ? savedPos[id] : nextPos();
              console.log('🔍 Position for', id, ':', pos, 'saved:', !!savedPos[id], 'savedPos keys:', Object.keys(savedPos));
              // Generate proper IRI for imported element using import source namespace
              const elementIri = c.iri || `${imp}#${slugId(c.label) || originalId}`;
              console.log('🔍 Creating imported node:', c.label, 'with IRI:', elementIri, 'from data:', c);
              const node = ontoState.cy.add({ group: 'nodes', data: { id, iri: elementIri, label: c.label, type: 'class', importSource: imp, attrs: c.attrs || {} }, position: pos, classes: 'imported' });
              added.push(node);
            });
          }
          if (isCollapsed) {
            // For collapsed imports, create equivalence edges from pseudo-node to base classes
            const pseudoNodeId = `pseudo-import-${CSS.escape(imp)}`;
            const pseudoNode = ontoState.cy.$(`#${CSS.escape(pseudoNodeId)}`);

            if (pseudoNode.length > 0) {
              // Find equivalence relationships by matching imported class labels with base class labels
              const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type') || 'class') === 'class' && !n.hasClass('imported'));
              const byKey = (s) => String(s || '').trim().toLowerCase();
              const baseMap = new Map();
              baseClasses.forEach(n => baseMap.set(byKey(n.data('label') || n.id()), n));

              // Create equivalence edges for each imported class that matches a base class
              snap.classes.forEach(c => {
                const key = byKey(c.label);
                const baseNode = baseMap.get(key);
                if (baseNode) {
                  const equivEdgeId = `pseudo-equiv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                  const equivEdge = ontoState.cy.add({
                    group: 'edges',
                    data: {
                      id: equivEdgeId,
                      source: pseudoNodeId,
                      target: baseNode.id(),
                      predicate: 'equivalentClass',
                      type: 'objectProperty',
                      importSource: imp,
                      isPseudo: true,
                      attrs: {}
                    },
                    classes: 'imported imported-equivalence pseudo-equivalence'
                  });
                  added.push(equivEdge);
                }
              });
            }
          } else {
            // Add edges where both endpoints available; create missing nodes on demand
            let idx = 0;
            snap.edges.forEach(e => {
              const sid = `imp:${imp}#${e.sourceIri}`;
              const tid = `imp:${imp}#${e.targetIri}`;
              if (!ontoState.cy.$(`#${CSS.escape(sid)}`).length) {
                const label = e.sourceIri.includes('#') ? e.sourceIri.split('#').pop() : e.sourceIri.split('/').pop();
                const pos = savedPos[sid] ? savedPos[sid] : nextPos();
                // Use the actual sourceIri as the element IRI
                added.push(ontoState.cy.add({ group: 'nodes', data: { id: sid, iri: e.sourceIri, label, type: 'class', importSource: imp, attrs: e.attrs || {} }, position: pos, classes: 'imported' }));
              }
              if (!ontoState.cy.$(`#${CSS.escape(tid)}`).length) {
                const label = e.targetIri.includes('#') ? e.targetIri.split('#').pop() : e.targetIri.split('/').pop();
                const pos = savedPos[tid] ? savedPos[tid] : nextPos();
                // Use the actual targetIri as the element IRI
                added.push(ontoState.cy.add({ group: 'nodes', data: { id: tid, iri: e.targetIri, label, type: 'class', importSource: imp, attrs: e.attrs || {} }, position: pos, classes: 'imported' }));
              }
              const edge = ontoState.cy.add({ group: 'edges', data: { id: `impE${Date.now()}_${idx++}`, source: sid, target: tid, predicate: e.label, type: 'objectProperty', importSource: imp, attrs: e.attrs || {} }, classes: 'imported' });
              added.push(edge);
            });
          }
          // Make overlays semi-interactive for positioning: allow drag, but don't select or edit
          added.forEach(el => {
            try {
              if (el.isNode && el.isNode()) {
                el.selectable(true); el.grabbable(true); el.locked(false); // Allow selection for imported elements
              } else {
                el.selectable(false); el.grabbable(false); el.locked(true);
              }
            } catch (_) { }
          });

          // Add position saving for pseudo-nodes
          added.filter(el => el.data('isPseudo')).forEach(el => {
            el.on('free', () => {
              const pseudoPositions = loadPseudoNodePositions(activeOntologyIri);
              pseudoPositions[el.id()] = { x: el.position('x'), y: el.position('y') };
              savePseudoNodePositions(activeOntologyIri, pseudoPositions);
            });
          });

          // Add position saving for imported nodes
          added.filter(el => el.isNode && el.isNode() && el.hasClass('imported') && !el.data('isPseudo')).forEach(el => {
            el.on('free', () => {
              const imp = el.data('importSource');
              if (!imp || !activeOntologyIri) return;
              const curr = loadOverlayPositions(activeOntologyIri, imp);
              curr[el.id()] = el.position();
              console.log('🔍 Saving position for imported element', el.id(), ':', el.position(), 'in import', imp);
              saveOverlayPositions(activeOntologyIri, imp, curr);
            });
          });

          // Add owl:equivalentClass visual links between base and imported nodes (by label/local name)
          // Only create equivalence edges for expanded imports
          if (!isCollapsed) {
            try {
              const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type') || 'class') === 'class' && !n.hasClass('imported'));
              const imported = ontoState.cy.nodes().filter(n => (n.data('type') || 'class') === 'class' && n.hasClass('imported') && (n.data('importSource') || '') === imp);
              const byKey = (s) => String(s || '').trim().toLowerCase();
              const baseMap = new Map(); baseClasses.forEach(n => baseMap.set(byKey(n.data('label') || n.id()), n));
              let idx2 = 0;
              imported.forEach(n => {
                const key = byKey(n.data('label') || n.id());
                const base = baseMap.get(key);
                if (base) {
                  const eid = `impEq${Date.now()}_${idx2++}`;
                  const equivEdge = ontoState.cy.add({ group: 'edges', data: { id: eid, source: base.id(), target: n.id(), predicate: 'equivalentClass', type: 'objectProperty', importSource: imp, attrs: {} }, classes: 'imported imported-equivalence' });
                  added.push(equivEdge);
                }
              });
            } catch (_) { }
          }
        }
        // Do not persist imported overlays to base local storage
        refreshOntologyTree();
      } catch (err) {
        console.error('🔍 Error in overlayImportsRefresh:', err);
        // Don't let the error crash the app
      }
    }

    // Context menu helpers
    let cmState = { visible: false, sourceId: null };
    function showMenuAt(x, y) {
      const m = qs('#ontoContextMenu'); if (!m) return;
      m.style.left = x + 'px'; m.style.top = y + 'px'; m.style.display = 'block'; cmState.visible = true;
    }
    function hideMenu() { const m = qs('#ontoContextMenu'); if (!m) return; m.style.display = 'none'; cmState.visible = false; }

    // Edge context menu helpers for multiplicity constraints
    function showEdgeMenuAt(x, y) {
      const m = qs('#edgeContextMenu'); if (!m) return;
      m.style.left = x + 'px'; m.style.top = y + 'px'; m.style.display = 'block';
      // Hide node context menu if visible
      hideMenu();

      // Auto-hide on outside click
      setTimeout(() => {
        const hideOnOutsideClick = (e) => {
          if (!m.contains(e.target)) {
            hideEdgeMenu();
            document.removeEventListener('click', hideOnOutsideClick);
          }
        };
        document.addEventListener('click', hideOnOutsideClick);
      }, 0);
    }
    function hideEdgeMenu() { const m = qs('#edgeContextMenu'); if (!m) return; m.style.display = 'none'; }

    // Update edge label with multiplicity information
    function updateEdgeLabel(edge) {
      const minCount = edge.data('minCount');
      const maxCount = edge.data('maxCount');
      const basePredicate = edge.data('predicate') || 'relatedTo';

      let multiplicity = '';
      if (minCount !== null && minCount !== undefined || maxCount !== null && maxCount !== undefined) {
        if (minCount === 1 && maxCount === 1) multiplicity = ' (1)';
        else if (minCount === 0 && (maxCount === null || maxCount === undefined)) multiplicity = ' (0..*)';
        else if (minCount === 1 && (maxCount === null || maxCount === undefined)) multiplicity = ' (1..*)';
        else if (minCount === 0 && maxCount === 1) multiplicity = ' (0..1)';
        else if (minCount !== null && minCount !== undefined && maxCount !== null && maxCount !== undefined && minCount === maxCount)
          multiplicity = ` (${minCount})`;
        else if (minCount !== null && minCount !== undefined && maxCount !== null && maxCount !== undefined)
          multiplicity = ` (${minCount}..${maxCount})`;
        else if (minCount !== null && minCount !== undefined) multiplicity = ` (${minCount}..*)`;
        else if (maxCount !== null && maxCount !== undefined) multiplicity = ` (0..${maxCount})`;
      }

      // Store multiplicity display  
      edge.data('multiplicityDisplay', multiplicity.trim());
      edge.data('predicate', basePredicate);  // Keep relationship name clean

      // FORCE CYTOSCAPE VISUAL REFRESH
      if (ontoState.cy) {
        ontoState.cy.style().update();
        // Small delay then force redraw
        setTimeout(() => {
          ontoState.cy.forceRender();
        }, 10);
      }

      console.log(`🎯 Updated edge: "${basePredicate}" with multiplicity at arrow tip: "${multiplicity.trim()}"`);

      // Trigger refresh
      refreshOntologyTree();
      persistOntologyToLocalStorage();
    }

    // Apply multiplicity constraint to edge
    function updateEdgeMultiplicity(edge, minCount, maxCount) {
      // Store multiplicity in edge data
      edge.data('minCount', minCount);
      edge.data('maxCount', maxCount);

      // Update modification metadata
      const currentAttrs = edge.data('attrs') || {};
      const updatedAttrs = updateModificationMetadata(currentAttrs);
      edge.data('attrs', updatedAttrs);

      // Update visual display
      updateEdgeLabel(edge);

      // PERSIST TO BACKEND: Save all SHACL constraint changes to RDF store
      saveShaclConstraintsToBackend(edge);
    }

    // Save all SHACL constraints to backend RDF store
    async function saveShaclConstraintsToBackend(edge) {
      const minCount = edge.data('minCount');
      const maxCount = edge.data('maxCount');
      const datatypeConstraint = edge.data('datatypeConstraint');
      const enumerationValues = edge.data('enumerationValues');
      try {
        if (!activeOntologyIri) {
          console.log('❌ No active ontology IRI for saving multiplicity');
          return;
        }

        const propertyName = edge.data('predicate');
        const edgeType = edge.data('type');

        if (edgeType !== 'objectProperty') {
          console.log('⚠️ Skipping multiplicity save for non-object property');
          return;
        }

        console.log(`💾 Saving SHACL constraints to backend for: ${propertyName}`);
        console.log(`   - Multiplicity: min=${minCount} max=${maxCount}`);
        console.log(`   - Datatype: ${datatypeConstraint || 'none'}`);
        console.log(`   - Enumeration: ${enumerationValues ? enumerationValues.join(', ') : 'none'}`);
        console.log(`🔍 Active ontology IRI: ${activeOntologyIri}`);

        // Build SPARQL UPDATE to add/update all SHACL constraints
        const propertyUri = `${activeOntologyIri}#${propertyName}`;
        console.log(`🔍 Property URI: ${propertyUri}`);

        let sparqlUpdate = `
        PREFIX owl: <http://www.w3.org/2002/07/owl#>
        PREFIX odras: <http://odras.ai/ontology/>
        
        DELETE {
          GRAPH <${activeOntologyIri}> {
            <${propertyUri}> odras:minCount ?oldMin .
            <${propertyUri}> odras:maxCount ?oldMax .
            <${propertyUri}> odras:datatypeConstraint ?oldDatatype .
            <${propertyUri}> odras:enumerationValues ?oldEnum .
          }
        }
        WHERE {
          GRAPH <${activeOntologyIri}> {
            OPTIONAL { <${propertyUri}> odras:minCount ?oldMin }
            OPTIONAL { <${propertyUri}> odras:maxCount ?oldMax }
            OPTIONAL { <${propertyUri}> odras:datatypeConstraint ?oldDatatype }
            OPTIONAL { <${propertyUri}> odras:enumerationValues ?oldEnum }
          }
        }
        `;

        // Add new constraints (if any exist)
        if (minCount !== null || maxCount !== null || datatypeConstraint || enumerationValues) {
          sparqlUpdate += `;
          
          INSERT {
            GRAPH <${activeOntologyIri}> {
          `;

          // Multiplicity constraints
          if (minCount !== null) {
            sparqlUpdate += `    <${propertyUri}> odras:minCount ${minCount} .
`;
          }
          if (maxCount !== null) {
            sparqlUpdate += `    <${propertyUri}> odras:maxCount ${maxCount} .
`;
          }

          // Datatype constraint
          if (datatypeConstraint) {
            sparqlUpdate += `    <${propertyUri}> odras:datatypeConstraint "${datatypeConstraint}" .
`;
          }

          // Enumeration constraint (as JSON string)
          if (enumerationValues && enumerationValues.length > 0) {
            const enumJson = JSON.stringify(enumerationValues).replace(/\"/g, '\\\\"');
            sparqlUpdate += `    <${propertyUri}> odras:enumerationValues "${enumJson}" .
`;
          }

          sparqlUpdate += `  }
        } WHERE {}`;
        }

        console.log('🔍 SPARQL Update:');
        console.log(sparqlUpdate);

        // Execute SPARQL update directly to Fuseki update endpoint
        const fusekiUpdateUrl = 'http://localhost:3030/odras/update';
        console.log(`🔍 Sending UPDATE to: ${fusekiUpdateUrl}`);

        try {
          const response = await fetch(fusekiUpdateUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/sparql-update'
            },
            body: sparqlUpdate
          });

          console.log(`🔍 Response status: ${response.status}`);
          console.log(`🔍 Response ok: ${response.ok}`);

          if (response.ok) {
            console.log(`✅ SHACL constraints saved to RDF store for ${propertyName}`);
          } else {
            const errorText = await response.text();
            console.log(`❌ Failed to save SHACL constraints: ${response.status}`);
            console.log(`❌ Error response: ${errorText}`);
          }

        } catch (fetchError) {
          console.log(`❌ Network error saving SHACL constraints: ${fetchError}`);
          console.log(`❌ Error details: ${JSON.stringify(fetchError)}`);
        }

      } catch (error) {
        console.error('❌ Error saving SHACL constraints to backend:', error);
      }
    }

    // Save model-level metadata to backend RDF store
    async function saveModelMetadataToBackend(ontologyIri, modelName, attrs) {
      try {
        console.log(`💾 Saving model metadata for: ${modelName}`);
        console.log(`🔍 Ontology IRI: ${ontologyIri}`);
        console.log(`📋 Attributes:`, attrs);

        // Build SPARQL UPDATE for ontology metadata
        const ontologyUri = ontologyIri;  // The ontology IRI itself is the subject

        let sparqlUpdate = `
        PREFIX owl: <http://www.w3.org/2002/07/owl#>
        PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
        PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
        PREFIX dcterms: <http://purl.org/dc/terms/>
        
        DELETE {
          GRAPH <${ontologyIri}> {
            <${ontologyUri}> rdfs:label ?oldLabel .
            <${ontologyUri}> rdfs:comment ?oldComment .
            <${ontologyUri}> skos:definition ?oldDefinition .
            <${ontologyUri}> owl:versionInfo ?oldVersion .
            <${ontologyUri}> dcterms:description ?oldDescription .
          }
        }
        WHERE {
          GRAPH <${ontologyIri}> {
            OPTIONAL { <${ontologyUri}> rdfs:label ?oldLabel }
            OPTIONAL { <${ontologyUri}> rdfs:comment ?oldComment }
            OPTIONAL { <${ontologyUri}> skos:definition ?oldDefinition }
            OPTIONAL { <${ontologyUri}> owl:versionInfo ?oldVersion }
            OPTIONAL { <${ontologyUri}> dcterms:description ?oldDescription }
          }
        }
        `;

        // Add new metadata if exists
        let hasInserts = false;
        let insertParts = [];

        // Add label (model name)
        if (modelName && modelName.trim()) {
          const escapedName = modelName.replace(/\\\\/g, '\\\\\\\\').replace(/"/g, '\\\\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');
          insertParts.push(`    <${ontologyUri}> rdfs:label "${escapedName}" .`);
          hasInserts = true;
        }

        // Add comment  
        if (attrs.comment && attrs.comment.trim()) {
          const escapedComment = attrs.comment.replace(/\\\\/g, '\\\\\\\\').replace(/"/g, '\\\\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');
          insertParts.push(`    <${ontologyUri}> rdfs:comment "${escapedComment}" .`);
          hasInserts = true;
        }

        // Add definition
        if (attrs.definition && attrs.definition.trim()) {
          const escapedDefinition = attrs.definition.replace(/\\\\/g, '\\\\\\\\').replace(/"/g, '\\\\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');
          insertParts.push(`    <${ontologyUri}> skos:definition "${escapedDefinition}" .`);
          hasInserts = true;
        }

        // Add version info
        if (attrs.versionInfo && attrs.versionInfo.trim()) {
          const escapedVersion = attrs.versionInfo.replace(/\\\\/g, '\\\\\\\\').replace(/"/g, '\\\\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');
          insertParts.push(`    <${ontologyUri}> owl:versionInfo "${escapedVersion}" .`);
          hasInserts = true;
        }

        // Add description
        if (attrs.description && attrs.description.trim()) {
          const escapedDescription = attrs.description.replace(/\\\\/g, '\\\\\\\\').replace(/"/g, '\\\\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');
          insertParts.push(`    <${ontologyUri}> dcterms:description "${escapedDescription}" .`);
          hasInserts = true;
        }

        if (hasInserts) {
          sparqlUpdate += `;
          
          INSERT {
            GRAPH <${ontologyIri}> {
${insertParts.join('\\n')}
            }
          } WHERE {}`;
        }

        console.log('🔍 Model metadata SPARQL Update:');
        console.log(sparqlUpdate);

        // Execute SPARQL update
        const fusekiUpdateUrl = 'http://localhost:3030/odras/update';
        console.log(`🔍 Sending model metadata UPDATE to: ${fusekiUpdateUrl}`);

        try {
          const response = await fetch(fusekiUpdateUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/sparql-update'
            },
            body: sparqlUpdate
          });

          console.log(`🔍 Model metadata response status: ${response.status}`);
          console.log(`🔍 Model metadata response ok: ${response.ok}`);

          if (response.ok) {
            console.log(`✅ Model metadata saved to RDF store for ${modelName}`);
          } else {
            const errorText = await response.text();
            console.log(`❌ Failed to save model metadata: ${response.status}`);
            console.log(`❌ Error response: ${errorText}`);
          }

        } catch (fetchError) {
          console.log(`❌ Network error saving model metadata: ${fetchError}`);
        }

      } catch (error) {
        console.error('❌ Error saving model metadata to backend:', error);
      }
    }

    // ========== CAD-LIKE FEATURES ==========

    // Snap position to grid
    function snapToGrid(position) {
      if (!ontoState.snapToGrid) return position;

      const gridSize = ontoState.gridSize;
      return {
        x: Math.round(position.x / gridSize) * gridSize,
        y: Math.round(position.y / gridSize) * gridSize
      };
    }

    // Toggle snap-to-grid with visual feedback
    function toggleSnapToGrid() {
      ontoState.snapToGrid = !ontoState.snapToGrid;
      const status = ontoState.snapToGrid ? 'ON' : 'OFF';
      console.log(`🔧 Snap-to-grid: ${status} (Grid size: ${ontoState.gridSize}px)`);

      // Update UI status text
      const statusEl = document.querySelector('#snapGridStatus');
      if (statusEl) {
        statusEl.textContent = `Grid Snap: ${status}`;
      }

      // Show temporary visual feedback
      showTemporaryMessage(`Grid Snap: ${status}`, 1500);
    }

    // Update grid size
    function updateGridSize(newSize) {
      if (newSize === 'custom') {
        const customSize = prompt('Enter custom grid size in pixels:', ontoState.gridSize);
        if (customSize && !isNaN(customSize) && customSize > 0) {
          ontoState.gridSize = parseInt(customSize);
        } else {
          // Reset dropdown to current value
          const selector = document.querySelector('#gridSizeSelector');
          if (selector) selector.value = ontoState.gridSize;
          return;
        }
      } else {
        ontoState.gridSize = parseInt(newSize);
      }

      // Update CSS grid background to match
      const canvasEl = document.querySelector('#cy');
      if (canvasEl) {
        canvasEl.style.backgroundSize = `${ontoState.gridSize}px ${ontoState.gridSize}px`;
      }

      console.log(`🔧 Grid size updated to: ${ontoState.gridSize}px`);
      showTemporaryMessage(`Grid: ${ontoState.gridSize}px`, 1000);
    }

    // Show temporary message overlay (like CAD status messages)
    function showTemporaryMessage(message, duration = 2000) {
      // Remove existing message
      const existing = document.querySelector('#cadStatusMessage');
      if (existing) existing.remove();

      const msgDiv = document.createElement('div');
      msgDiv.id = 'cadStatusMessage';
      msgDiv.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: var(--panel-2);
        color: var(--accent);
        border: 1px solid var(--accent);
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 12px;
        font-weight: 600;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        transition: opacity 0.3s ease;
      `;
      msgDiv.textContent = message;
      document.body.appendChild(msgDiv);

      setTimeout(() => {
        if (msgDiv) {
          msgDiv.style.opacity = '0';
          setTimeout(() => msgDiv.remove(), 300);
        }
      }, duration);
    }

    // Align selected elements
    function alignElements(direction) {
      if (!ontoState.cy) return;

      const selected = ontoState.cy.$(':selected').nodes();
      if (selected.length < 2) {
        showTemporaryMessage('Select 2+ elements to align');
        return;
      }

      const positions = selected.map(node => ({ node, pos: node.position() }));
      let referenceValue;

      switch (direction) {
        case 'left':
          referenceValue = Math.min(...positions.map(p => p.pos.x));
          positions.forEach(({ node }) => {
            const newPos = { x: referenceValue, y: node.position().y };
            node.position(snapToGrid(newPos));
          });
          break;
        case 'right':
          referenceValue = Math.max(...positions.map(p => p.pos.x));
          positions.forEach(({ node }) => {
            const newPos = { x: referenceValue, y: node.position().y };
            node.position(snapToGrid(newPos));
          });
          break;
        case 'center':
          const centerX = (Math.min(...positions.map(p => p.pos.x)) + Math.max(...positions.map(p => p.pos.x))) / 2;
          positions.forEach(({ node }) => {
            const newPos = { x: centerX, y: node.position().y };
            node.position(snapToGrid(newPos));
          });
          break;
        case 'top':
          referenceValue = Math.min(...positions.map(p => p.pos.y));
          positions.forEach(({ node }) => {
            const newPos = { x: node.position().x, y: referenceValue };
            node.position(snapToGrid(newPos));
          });
          break;
        case 'bottom':
          referenceValue = Math.max(...positions.map(p => p.pos.y));
          positions.forEach(({ node }) => {
            const newPos = { x: node.position().x, y: referenceValue };
            node.position(snapToGrid(newPos));
          });
          break;
        case 'distribute-horizontal':
          if (selected.length < 3) {
            showTemporaryMessage('Need 3+ elements to distribute');
            return;
          }
          positions.sort((a, b) => a.pos.x - b.pos.x);
          const minX = positions[0].pos.x;
          const maxX = positions[positions.length - 1].pos.x;
          const spacingX = (maxX - minX) / (positions.length - 1);
          positions.forEach(({ node }, index) => {
            const newPos = { x: minX + (index * spacingX), y: node.position().y };
            node.position(snapToGrid(newPos));
          });
          break;
        case 'distribute-vertical':
          if (selected.length < 3) {
            showTemporaryMessage('Need 3+ elements to distribute');
            return;
          }
          positions.sort((a, b) => a.pos.y - b.pos.y);
          const minY = positions[0].pos.y;
          const maxY = positions[positions.length - 1].pos.y;
          const spacingY = (maxY - minY) / (positions.length - 1);
          positions.forEach(({ node }, index) => {
            const newPos = { x: node.position().x, y: minY + (index * spacingY) };
            node.position(snapToGrid(newPos));
          });
          break;
      }

      showTemporaryMessage(`Aligned: ${direction}`);
      addToUndoStack('align', { direction, elements: selected.length });
      persistOntologyToLocalStorage();
    }

    // Undo/Redo system
    function addToUndoStack(action, data) {
      if (!ontoState.cy) return;

      const state = {
        action,
        data,
        timestamp: Date.now(),
        snapshot: ontoState.cy.json() // Full canvas state
      };

      ontoState.undoStack.push(state);
      if (ontoState.undoStack.length > ontoState.maxUndoLevels) {
        ontoState.undoStack.shift(); // Remove oldest
      }

      // Clear redo stack when new action is performed
      ontoState.redoStack = [];
    }

    function performUndo() {
      if (!ontoState.cy || ontoState.undoStack.length === 0) {
        showTemporaryMessage('Nothing to undo');
        return;
      }

      // Save current state to redo stack
      const currentState = {
        action: 'undo_point',
        data: {},
        timestamp: Date.now(),
        snapshot: ontoState.cy.json()
      };
      ontoState.redoStack.push(currentState);

      // Restore previous state
      const previousState = ontoState.undoStack.pop();
      ontoState.cy.json(previousState.snapshot);

      showTemporaryMessage(`Undid: ${previousState.action}`);
      persistOntologyToLocalStorage();
    }

    function performRedo() {
      if (!ontoState.cy || ontoState.redoStack.length === 0) {
        showTemporaryMessage('Nothing to redo');
        return;
      }

      // Save current state to undo stack
      addToUndoStack('redo_point', {});
      ontoState.undoStack.pop(); // Remove the redo_point we just added

      // Restore redo state
      const redoState = ontoState.redoStack.pop();
      ontoState.cy.json(redoState.snapshot);

      showTemporaryMessage('Redid action');
      persistOntologyToLocalStorage();
    }

    // Copy selected elements
    function copySelectedElements() {
      if (!ontoState.cy) return;

      const selected = ontoState.cy.$(':selected');
      if (selected.length === 0) {
        showTemporaryMessage('No elements selected to copy');
        return;
      }

      ontoState.clipboard = {
        nodes: selected.nodes().map(n => ({ data: n.data(), position: n.position() })),
        edges: selected.edges().map(e => ({ data: e.data() })),
        timestamp: Date.now()
      };

      showTemporaryMessage(`Copied ${selected.length} elements`);
    }

    // Paste elements with smart offset
    function pasteElements() {
      if (!ontoState.cy || !ontoState.clipboard) {
        showTemporaryMessage('Nothing to paste');
        return;
      }

      const offset = 40; // Offset like CAD copy operations
      const newElements = [];
      const idMapping = {}; // Map old IDs to new IDs for edges

      // Create new nodes with offset positions
      ontoState.clipboard.nodes.forEach(nodeData => {
        const oldId = nodeData.data.id;
        const newId = `${oldId}_copy_${Date.now()}_${Math.floor(Math.random() * 1000)}`;

        const newPos = {
          x: nodeData.position.x + offset,
          y: nodeData.position.y + offset
        };

        const newNodeData = {
          group: 'nodes',
          data: { ...nodeData.data, id: newId },
          position: snapToGrid(newPos)
        };

        idMapping[oldId] = newId;
        newElements.push(newNodeData);
      });

      // Create new edges with updated source/target IDs
      ontoState.clipboard.edges.forEach(edgeData => {
        const newSource = idMapping[edgeData.data.source];
        const newTarget = idMapping[edgeData.data.target];

        // Only create edge if both nodes were copied
        if (newSource && newTarget) {
          const newId = `edge_copy_${Date.now()}_${Math.floor(Math.random() * 1000)}`;

          const newEdgeData = {
            group: 'edges',
            data: {
              ...edgeData.data,
              id: newId,
              source: newSource,
              target: newTarget
            }
          };

          newElements.push(newEdgeData);
        }
      });

      // Add to canvas and select
      ontoState.cy.add(newElements);
      ontoState.cy.$(':selected').unselect();
      newElements.forEach(el => {
        if (el.group === 'nodes') {
          ontoState.cy.$(`#${el.data.id}`).select();
        }
      });

      showTemporaryMessage(`Pasted ${newElements.length} elements`);
      addToUndoStack('paste', { count: newElements.length });
      persistOntologyToLocalStorage();
    }

    // Snap selected node to grid
    function snapNodeToGrid() {
      if (!ontoState.cy) return;

      const selected = ontoState.cy.$(':selected').nodes();
      if (selected.length === 0) {
        showTemporaryMessage('No node selected');
        return;
      }

      selected.forEach(node => {
        const snappedPos = snapToGrid(node.position());
        node.position(snappedPos);
      });

      // Update position inputs if visible
      updatePositionInputs();
      showTemporaryMessage(`Snapped ${selected.length} node(s) to grid`);
      addToUndoStack('snap', { count: selected.length });
      persistOntologyToLocalStorage();
    }

    // Center selected node in view  
    function centerNodeInView() {
      if (!ontoState.cy) return;

      const selected = ontoState.cy.$(':selected').nodes();
      if (selected.length === 0) {
        showTemporaryMessage('No node selected');
        return;
      }

      ontoState.cy.animate({
        center: { eles: selected },
        zoom: Math.max(ontoState.cy.zoom(), 0.8)
      }, {
        duration: 300
      });

      showTemporaryMessage('Centered in view');
    }

    // Update position input fields
    function updatePositionInputs() {
      const posXInput = qs('#propPosX');
      const posYInput = qs('#propPosY');

      if (!posXInput || !posYInput || !ontoState.cy) return;

      const selected = ontoState.cy.$(':selected').nodes();
      if (selected.length === 1) {
        const pos = selected[0].position();
        posXInput.value = Math.round(pos.x);
        posYInput.value = Math.round(pos.y);
      } else if (selected.length > 1) {
        posXInput.placeholder = 'Multiple selected';
        posYInput.placeholder = 'Multiple selected';
        posXInput.value = '';
        posYInput.value = '';
      } else {
        posXInput.value = '';
        posYInput.value = '';
      }
    }

    // Apply position from input fields
    function applyPositionFromInputs() {
      const posXInput = qs('#propPosX');
      const posYInput = qs('#propPosY');

      if (!posXInput || !posYInput || !ontoState.cy) return;

      const selected = ontoState.cy.$(':selected').nodes();
      if (selected.length === 0) return;

      const x = parseFloat(posXInput.value);
      const y = parseFloat(posYInput.value);

      if (isNaN(x) || isNaN(y)) return;

      const newPos = { x, y };
      const snappedPos = snapToGrid(newPos);

      selected.forEach(node => {
        node.position(snappedPos);
      });

      showTemporaryMessage(`Moved to (${snappedPos.x}, ${snappedPos.y})`);
      addToUndoStack('position', { x: snappedPos.x, y: snappedPos.y });
      persistOntologyToLocalStorage();
    }

    // Enhanced zoom controls (like CAD view controls)
    function zoomToSelection() {
      if (!ontoState.cy) return;

      const selected = ontoState.cy.$(':selected');
      if (selected.length === 0) {
        showTemporaryMessage('No elements selected to zoom to');
        return;
      }

      ontoState.cy.animate({
        fit: { eles: selected, padding: 50 }
      }, {
        duration: 300
      });

      showTemporaryMessage('Zoomed to selection');
    }

    function zoomTo100Percent() {
      if (!ontoState.cy) return;

      ontoState.cy.animate({
        zoom: 1.0,
        center: { eles: ontoState.cy.elements() }
      }, {
        duration: 300
      });

      showTemporaryMessage('Zoom: 100%');
    }

    function zoomToFitAll() {
      if (!ontoState.cy) return;

      ontoState.cy.animate({
        fit: { eles: ontoState.cy.elements(), padding: 30 }
      }, {
        duration: 300
      });

      showTemporaryMessage('Fit all elements');
    }

    // Show custom multiplicity dialog
    function showCustomMultiplicityDialog(edge) {
      const currentMin = edge.data('minCount');
      const currentMax = edge.data('maxCount');

      const dialog = document.createElement('div');
      dialog.style.cssText = `
        position: fixed; top: 50%; left: 50%; 
        transform: translate(-50%, -50%);
        background: var(--panel-2); border: 1px solid var(--border);
        border-radius: 6px; padding: 20px; z-index: 10000;
        min-width: 280px; box-shadow: 0 8px 24px rgba(0, 0, 0, .4);
      `;

      dialog.innerHTML = `
        <h3 style="margin-top: 0; color: var(--text); font-size: 16px;">Custom Multiplicity</h3>
        <div style="margin: 15px 0;">
          <label style="display: block; margin-bottom: 4px; color: var(--text); font-size: 13px;">Minimum count:</label>
          <input type="number" id="minCountInput" value="${currentMin || ''}" min="0" 
                 style="width: 100%; padding: 6px; background: var(--panel); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
        </div>
        <div style="margin: 15px 0;">
          <label style="display: block; margin-bottom: 4px; color: var(--text); font-size: 13px;">Maximum count:</label>
          <input type="number" id="maxCountInput" value="${currentMax || ''}" min="0"
                 style="width: 100%; padding: 6px; background: var(--panel); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
          <small style="display: block; margin-top: 4px; color: var(--muted); font-size: 11px;">
            Leave empty for unlimited
          </small>
        </div>
        <div style="margin-top: 20px; text-align: right;">
          <button id="cancelBtn" style="margin-right: 8px; padding: 6px 12px; background: transparent; border: 1px solid var(--border); border-radius: 4px; color: var(--text); cursor: pointer;">Cancel</button>
          <button id="applyBtn" style="padding: 6px 12px; background: var(--accent); border: none; border-radius: 4px; color: white; cursor: pointer;">Apply</button>
        </div>
      `;

      document.body.appendChild(dialog);

      // Focus first input
      setTimeout(() => {
        const input = dialog.querySelector('#minCountInput');
        if (input) input.focus();
      }, 100);

      dialog.querySelector('#cancelBtn').onclick = () => dialog.remove();
      dialog.querySelector('#applyBtn').onclick = () => {
        const minVal = dialog.querySelector('#minCountInput').value;
        const maxVal = dialog.querySelector('#maxCountInput').value;

        const minCount = minVal ? parseInt(minVal, 10) : null;
        const maxCount = maxVal ? parseInt(maxVal, 10) : null;

        updateEdgeMultiplicity(edge, minCount, maxCount);
        dialog.remove();
      };
    }
    function startConnectFrom(node) {
      cmState.sourceId = node.id();
      node.addClass('connect-source');
    }
    function clearConnectState() {
      if (cmState.sourceId && ontoState.cy) {
        const n = ontoState.cy.$('#' + cmState.sourceId);
        if (n) n.removeClass('connect-source');
      }
      cmState.sourceId = null;
    }

    // Ensure new class IDs do not collide with existing nodes after imports/loads
    function recomputeNextId() {
      try {
        if (!ontoState || !ontoState.cy) return;
        let maxNum = 0;
        ontoState.cy.nodes().forEach(n => {
          try {
            const nid = (n && typeof n.id === 'function') ? n.id() : '';
            const m = /^Class(\d+)$/.exec(String(nid || ''));
            if (m) {
              const num = parseInt(m[1], 10);
              if (!isNaN(num)) maxNum = Math.max(maxNum, num);
            }
          } catch (_) { }
        });
        ontoState.nextId = Math.max(1, maxNum + 1);
      } catch (_) { }
    }

    async function importOntologyJSON(obj) {
      ensureOntologyInitialized();

      // Handle enhanced export format (with metadata, model, namedViews) or legacy format (just nodes/edges)
      let nodes, edges, modelMetadata, namedViews;

      if (obj.metadata && obj.model) {
        // Enhanced format from our new export
        nodes = obj.nodes || [];
        edges = obj.edges || [];
        modelMetadata = obj.model;
        namedViews = obj.namedViews || [];
        console.log('📋 Importing enhanced format with model metadata and named views');
      } else if (Array.isArray(obj.nodes) && Array.isArray(obj.edges)) {
        // Legacy format (just nodes/edges)
        nodes = obj.nodes;
        edges = obj.edges;
        modelMetadata = null;
        namedViews = [];
        console.log('📋 Importing legacy format (nodes/edges only)');
      } else {
        console.error('Invalid import format');
        return;
      }

      // Clear only base elements, keep imported overlays intact
      ontoState.cy.elements().filter(el => !el.hasClass('imported') && !el.hasClass('imported-equivalence')).remove();

      // Migration guard: filter out any overlays accidentally saved to JSON
      const isOverlayNode = (n) => {
        try {
          const d = (n && n.data) ? n.data : {};
          const id = String(d.id || '');
          const cls = String(n.classes || d.classes || '');
          return !!d.importSource || id.startsWith('imp:') || cls.includes('imported');
        } catch (_) { return false; }
      };

      const baseNodes = (nodes || []).filter(n => !isOverlayNode(n));
      const baseNodeIds = new Set(baseNodes.map(n => (n.data && n.data.id) || ''));
      const baseEdges = (edges || []).filter(e => {
        try {
          const d = (e && e.data) ? e.data : {};
          const cls = String(e.classes || d.classes || '');
          if (d.importSource || cls.includes('imported')) return false;
          if (String(d.predicate || '').toLowerCase() === 'equivalentclass') return false;
          return baseNodeIds.has(d.source) && baseNodeIds.has(d.target);
        } catch (_) { return false; }
      });

      // Add back base nodes and edges
      ontoState.cy.add(baseNodes.map(n => ({ group: 'nodes', data: n.data, position: n.position })));
      ontoState.cy.add(baseEdges.map(e => ({ group: 'edges', data: e.data })));
      ontoState.cy.fit();

      // Import model metadata if available
      if (modelMetadata && activeOntologyIri) {
        const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
        const ontologyKey = activeOntologyIri ? activeOntologyIri.split('/').pop() : 'default';
        const modelNameKey = `onto_model_name__${pid}__${ontologyKey}`;
        const modelAttrsKey = `onto_model_attrs__${pid}__${ontologyKey}`;

        // Save model name and attributes
        localStorage.setItem(modelNameKey, modelMetadata.name || 'Imported Ontology');
        const attrs = {
          comment: modelMetadata.comment || '',
          definition: modelMetadata.definition || '',
          version: modelMetadata.version || '',
          namespace: modelMetadata.namespace || activeOntologyIri,
          imports: modelMetadata.imports || ''
        };
        localStorage.setItem(modelAttrsKey, JSON.stringify(attrs));

        console.log('📋 Restored model metadata:', modelMetadata.name);
      }

      // Import named views if available
      if (namedViews && namedViews.length > 0 && activeOntologyIri) {
        try {
          console.log(`📋 Importing ${namedViews.length} named views:`, namedViews.map(v => v.name));
          await saveNamedViews(activeOntologyIri, namedViews);
          console.log('✅ Named views saved to backend successfully');
        } catch (error) {
          console.error('❌ Failed to import named views:', error);
        }
      }

      // Wait for named views to be saved before refreshing tree
      setTimeout(async () => {
        await refreshOntologyTree();
        persistOntologyToLocalStorage();

        // Update ID counter so new classes get unique IDs
        recomputeNextId();

        // Update properties panel to show imported model metadata
        updatePropertiesPanelFromSelection();

        console.log('✅ Import complete including tree refresh');
      }, 200);
    }

    // Auth/UI gating
    const tokenKey = 'odras_token';
    const userKey = 'odras_user';
    function showAuth(show) {
      qs('#authView').style.display = show ? 'grid' : 'none';
      qs('#mainView').style.display = show ? 'none' : 'grid';
      // Hide/show logout button based on auth state
      qs('#logoutBtn').style.display = show ? 'none' : 'block';

      // Only close DAS when logging out - let DAS manage its own visibility when logging in
      if (show) {
        // When logging out: close and clean DAS
        if (typeof window.closeDASAndClean === 'function') {
          window.closeDASAndClean();
        }
      }
      // Don't manually override DAS panel display - let DAS state management handle it
    }

    // Global authentication state
    let isAuthenticated = false;
    let authCheckInProgress = false;

    // Enhanced fetch wrapper that handles authentication
    async function authenticatedFetch(url, options = {}) {
      const token = localStorage.getItem(tokenKey);

      // Add authorization header if token exists
      if (token) {
        options.headers = {
          ...options.headers,
          'Authorization': `Bearer ${token}`
        };
      }

      try {
        const response = await fetch(url, options);

        // Check for 401 Unauthorized
        if (response.status === 401) {
          console.warn('Authentication failed (401), redirecting to login...');
          handleAuthFailure();
          throw new Error('Authentication required');
        }

        return response;
      } catch (error) {
        // Re-throw the error for the caller to handle
        throw error;
      }
    }

    // Handle authentication failure
    function handleAuthFailure() {
      if (authCheckInProgress) return; // Prevent multiple simultaneous auth checks

      authCheckInProgress = true;
      isAuthenticated = false;

      // Close and clean DAS dock when session expires
      if (typeof window.closeDASAndClean === 'function') {
        window.closeDASAndClean();
      }

      // Clear stored auth data
      localStorage.removeItem(tokenKey);
      localStorage.removeItem(userKey);
      localStorage.removeItem('user'); // Clear full user object

      // Clear UI state
      qs('#userMenu').textContent = '';
      activeOntologyIri = null;
      updateOntoGraphLabel();

      // Hide admin UI elements since user is no longer authenticated
      updateAdminUIVisibility(false);

      // Show login screen
      showAuth(true);

      // Show notification
      if (window.toast) {
        window.toast('Session expired. Please log in again.', true);
      }

      authCheckInProgress = false;
    }

    // Periodic authentication check
    let authCheckInterval = null;
    function startAuthMonitoring() {
      // Check auth status every 30 seconds
      authCheckInterval = setInterval(async () => {
        if (!isAuthenticated) return;

        try {
          const token = localStorage.getItem(tokenKey);
          if (!token) {
            handleAuthFailure();
            return;
          }

          const response = await fetch('/api/auth/me', {
            headers: { 'Authorization': `Bearer ${token}` }
          });

          if (!response.ok) {
            handleAuthFailure();
          }
        } catch (error) {
          console.warn('Auth check failed:', error);
          handleAuthFailure();
        }
      }, 30000); // Check every 30 seconds
    }

    function stopAuthMonitoring() {
      if (authCheckInterval) {
        clearInterval(authCheckInterval);
        authCheckInterval = null;
      }
    }
    async function initAuth() {
      const token = localStorage.getItem(tokenKey);
      if (!token) {
        showAuth(true);
        isAuthenticated = false;
        stopAuthMonitoring();
        // Clear any stale user data
        localStorage.removeItem(userKey);
        localStorage.removeItem('user'); // Clear full user object
        qs('#userMenu').textContent = '';
        return;
      }

      try {
        const response = await authenticatedFetch('/api/auth/me');

        const me = await response.json();
        if (!me || me.error || !me.username) {
          // Invalid response, clear auth and show login
          handleAuthFailure();
          return;
        }

        // Success - user is authenticated
        isAuthenticated = true;
        localStorage.setItem(userKey, me.username);
        localStorage.setItem('user', JSON.stringify(me)); // Store full user object for context menu
        qs('#userMenu').textContent = me.username + (me.is_admin ? ' (admin)' : '');
        showAuth(false);

        // Update admin UI elements visibility
        updateAdminUIVisibility(me.is_admin);

        // Load knowledge assets if knowledge workbench is active
        const knowledgeWorkbench = document.getElementById('wb-knowledge');
        if (knowledgeWorkbench && knowledgeWorkbench.style.display !== 'none') {
          console.log('🧠 User authenticated, loading knowledge assets...');
          loadKnowledgeAssets();
        }

        // Start monitoring authentication status
        startAuthMonitoring();
      } catch (error) {
        // Network or other error, clear auth and show login
        console.error('Auth check failed:', error);
        handleAuthFailure();
        return;
      }
      // Restore last active workbench before loading projects
      try {
        const urlState = getURLState();
        const hashWB = (() => { try { const p = new URLSearchParams(location.hash.replace(/^#/, '')); return p.get('wb') || ''; } catch (_) { return ''; } })();
        const wb = urlState.workbench || hashWB || localStorage.getItem('active_workbench') || 'ontology';
        // Activate matching icon and section
        const icon = qs(`.icon[data-wb="${wb}"]`);
        if (icon) {
          // Instead of manually setting classes, trigger a click to run initialization
          icon.click();
        }
        // If no workbench got activated (e.g., missing section), default to ontology
        if (!document.querySelector('.workbench.active')) {
          const fallback = qs('.icon[data-wb="ontology"]');
          if (fallback) fallback.click();
        }

        // Update admin UI visibility based on current user
        try {
          const userData = JSON.parse(localStorage.getItem('user') || '{}');
          updateAdminUIVisibility(userData.is_admin || false);
        } catch (e) {
          console.error('Failed to parse user data for admin UI visibility:', e);
          updateAdminUIVisibility(false);
        }

        // Load admin data if admin workbench is active
        if (wb === 'admin') {
          loadPrefixes();
          loadDomains();
          loadUsers(); // Load user management data
          loadRagConfig(); // Load RAG configuration
          loadFileProcessingConfig(); // Load file processing configuration
          // Only load namespaces if user is authenticated
          const token = localStorage.getItem('odras_token');
          if (token) {
            loadNamespaces();
          }
        }
      } catch (_) { }
      // Initialize Cytoscape BEFORE loading projects so restore can occur during renderTree
      ensureOntologyInitialized();
      // If Files workbench is already active from restore, initialize its handlers now
      try { if (document.querySelector('#wb-files.workbench.active')) { ensureFilesInitialized(); } } catch (_) { }
      await loadProjects();
      // Load project info if project workbench is active (this is now handled in loadProjects)
      // but we'll keep this as a fallback
      try { if (document.querySelector('#wb-project.workbench.active')) { loadProjectInfo(); } } catch (_) { }
      refreshOntologyTree();
      // Bind Files workbench handlers proactively so Choose Files works immediately
      try { ensureFilesInitialized(); } catch (_) { }
      // Restore ontology tree collapsed state
      try {
        // Restore left project tree width
        const uiMainTreeW = parseInt(localStorage.getItem('ui_main_tree_w') || '0', 10);
        if (uiMainTreeW) document.documentElement.style.setProperty('--tree-w', uiMainTreeW + 'px');

        // Restore main tree collapsed state
        const mainTreeCollapsed = localStorage.getItem('main_tree_collapsed') === '1';
        if (mainTreeCollapsed) {
          const treePanel = qs('#treePanel');
          if (treePanel && !treePanel.classList.contains('tree-dock-collapsed')) {
            treePanel.classList.add('tree-dock-collapsed');
          }
        }

        // Restore ontology left tree width
        const ontoTreeW = parseInt(localStorage.getItem('onto_tree_w') || '0', 10);
        if (ontoTreeW) document.documentElement.style.setProperty('--onto-tree-w', ontoTreeW + 'px');
        const treeCollapsed = localStorage.getItem('onto_tree_collapsed') === '1';
        if (treeCollapsed) {
          const sec = qs('#wb-ontology');
          if (sec && !sec.classList.contains('onto-tree-collapsed')) sec.classList.add('onto-tree-collapsed');
          // CSS rotation handles chevron direction automatically
        }
        const propsCollapsed = localStorage.getItem('onto_props_collapsed') === '1';
        if (propsCollapsed) {
          const sec = qs('#wb-ontology');
          if (sec && !sec.classList.contains('onto-props-collapsed')) sec.classList.add('onto-props-collapsed');
          // CSS rotation handles chevron direction automatically
        }
        // CSS rotation handles chevron directions automatically for both panels
        const savedW = parseInt(localStorage.getItem('onto_props_w') || '0', 10);
        if (savedW) document.documentElement.style.setProperty('--onto-props-w', savedW + 'px');
        // Do not load any graph here; renderTree handles per-project restore safely
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      } catch (_) { }
    }
    qs('#loginBtn').onclick = async () => {
      const username = qs('#u').value.trim();
      const password = qs('#p').value;
      qs('#loginMsg').textContent = 'Signing in...';

      try {
        const res = await fetch('/api/auth/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, password })
        });
        const json = await res.json();

        if (res.ok && json.token) {
          localStorage.setItem(tokenKey, json.token);
          localStorage.setItem(userKey, username);
          qs('#loginMsg').textContent = '';
          await initAuth();
        } else {
          qs('#loginMsg').textContent = json.error || 'Login failed';
        }
      } catch (error) {
        console.error('Login error:', error);
        qs('#loginMsg').textContent = 'Login failed: ' + error.message;
      }
    };
    qs('#logoutBtn').onclick = async () => {
      // Call backend logout endpoint to invalidate token
      const token = localStorage.getItem(tokenKey);
      if (token) {
        try {
          await fetch('/api/auth/logout', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` }
          });
        } catch (error) {
          console.warn('Logout API call failed:', error);
          // Continue with local logout even if API call fails
        }
      }

      // Close and clean DAS dock
      if (typeof window.closeDASAndClean === 'function') {
        window.closeDASAndClean();
      }

      // Clear user-specific data from localStorage but preserve URL state
      try {
        // Don't clear active_project_id - let URL state handle it
        localStorage.removeItem('active_ontology_iri');
        localStorage.removeItem('onto_state');
      } catch (error) {
        console.warn('Failed to clear localStorage:', error);
      }

      isAuthenticated = false;
      stopAuthMonitoring();
      localStorage.removeItem(tokenKey);
      localStorage.removeItem(userKey);
      localStorage.removeItem('user'); // Clear full user object
      activeOntologyIri = null;
      updateOntoGraphLabel();
      try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch (_) { }
      qs('#userMenu').textContent = '';  // Clear user display
      showAuth(true);
    };

    // Initialize settings workbench
    function initializeSettings() {
      console.log('⚙️ Initializing Settings workbench...');

      // Load saved settings from localStorage
      const savedTheme = localStorage.getItem('odras_theme') || 'dark';
      const savedTreeWidth = localStorage.getItem('ui_main_tree_w') || '300';

      // Set theme selector
      const themeSelect = document.getElementById('themeSelect');
      if (themeSelect) {
        themeSelect.value = savedTheme;
        themeSelect.addEventListener('change', (e) => {
          localStorage.setItem('odras_theme', e.target.value);
          console.log('Theme changed to:', e.target.value);
        });
      }

      // Set tree width slider
      const treeWidthSlider = document.getElementById('treeWidthSlider');
      const treeWidthValue = document.getElementById('treeWidthValue');
      if (treeWidthSlider && treeWidthValue) {
        treeWidthSlider.value = savedTreeWidth;
        treeWidthValue.textContent = savedTreeWidth + 'px';

        treeWidthSlider.addEventListener('input', (e) => {
          const width = e.target.value;
          treeWidthValue.textContent = width + 'px';
          localStorage.setItem('ui_main_tree_w', width);

          // Apply the width change immediately
          const tree = document.querySelector('.tree');
          if (tree) {
            tree.style.width = width + 'px';
          }
        });
      }
    }

    // Initialize analysis lab workbench
    function initializeAnalysisLab() {
      console.log('📊 Initializing Analysis Lab workbench...');

      // Check if Jupyter Lab is already running
      const jupyterStatus = localStorage.getItem('jupyter_lab_status') || 'stopped';
      updateJupyterStatus(jupyterStatus);
    }

    // Jupyter Lab functions
    function startJupyterLab() {
      console.log('🚀 Starting Jupyter Lab...');

      // Update status to starting
      updateJupyterStatus('starting');

      // Simulate Jupyter Lab startup (in real implementation, this would make API calls)
      setTimeout(() => {
        // For demo purposes, show a placeholder
        const content = document.getElementById('jupyterLabContent');
        const iframe = document.getElementById('jupyterLabFrame');

        if (content && iframe) {
          content.style.display = 'none';
          iframe.style.display = 'block';

          // Set a placeholder URL (in real implementation, this would be the actual Jupyter Lab URL)
          iframe.src = 'data:text/html,<div style="display:flex;align-items:center;justify-content:center;height:100%;background:#f8f9fa;color:#666;font-family:monospace;"><div style="text-align:center;"><h3>Jupyter Lab</h3><p>Jupyter Lab would be running here</p><p style="font-size:12px;color:#999;">This is a placeholder for demonstration</p></div></div>';

          updateJupyterStatus('running');
        }
      }, 2000);
    }

    function showJupyterInfo() {
      alert('Jupyter Lab Integration:\\n\\n• Interactive data analysis environment\\n• Support for Python, R, Julia, and more\\n• Rich visualizations and plots\\n• Collaborative notebooks\\n• Integration with ODRAS data sources\\n\\nThis is a scaffolded interface for future Jupyter Lab integration.');
    }

    function updateJupyterStatus(status) {
      localStorage.setItem('jupyter_lab_status', status);

      const buttons = document.querySelectorAll('#jupyterLabContainer button');
      buttons.forEach(btn => {
        if (btn.textContent.includes('Launch Jupyter Lab')) {
          if (status === 'starting') {
            btn.textContent = 'Starting...';
            btn.disabled = true;
          } else if (status === 'running') {
            btn.textContent = 'Stop Lab';
            btn.disabled = false;
            btn.onclick = stopJupyterLab;
          } else {
            btn.textContent = 'Launch Jupyter Lab';
            btn.disabled = false;
            btn.onclick = startJupyterLab;
          }
        }
      });
    }

    function stopJupyterLab() {
      console.log('🛑 Stopping Jupyter Lab...');

      const content = document.getElementById('jupyterLabContent');
      const iframe = document.getElementById('jupyterLabFrame');

      if (content && iframe) {
        content.style.display = 'flex';
        iframe.style.display = 'none';
        iframe.src = 'about:blank';

        updateJupyterStatus('stopped');
      }
    }

    // Enhanced Jupyter Lab Toolbar Functions
    function createNewNotebook() {
      console.log('📓 Creating new notebook...');
      alert('New notebook creation would be implemented here. This would create a new Jupyter notebook for analysis.');
    }

    function openFile() {
      console.log('📁 Opening file...');
      alert('File browser would be implemented here. This would open the Jupyter Lab file browser.');
    }

    function saveNotebook() {
      console.log('💾 Saving notebook...');
      alert('Notebook save functionality would be implemented here.');
    }

    function runCell() {
      console.log('▶️ Running cell...');
      alert('Cell execution would be implemented here. This would run the current cell in Jupyter Lab.');
    }

    function stopExecution() {
      console.log('⏸️ Stopping execution...');
      alert('Execution stop functionality would be implemented here.');
    }

    function restartKernel() {
      console.log('🔄 Restarting kernel...');
      alert('Kernel restart functionality would be implemented here.');
    }

    function loadOdrasData() {
      console.log('📊 Loading ODRAS data...');
      alert('ODRAS data loading would be implemented here. This would provide access to project data from PostgreSQL, Neo4j, and Qdrant.');
    }

    function saveToArtifacts() {
      console.log('💾 Saving to artifacts...');
      alert('Save to artifacts functionality would be implemented here. This would save notebook outputs to the artifacts section.');
    }

    function exportReport() {
      console.log('📋 Exporting report...');
      alert('Report export functionality would be implemented here. This would generate reports from notebook outputs.');
    }

    function linkToProject() {
      console.log('🔗 Linking to project...');
      alert('Project linking functionality would be implemented here. This would associate the notebook with the current ODRAS project.');
    }

    function quickPlot() {
      console.log('📈 Quick plot...');
      alert('Quick plotting functionality would be implemented here. This would provide quick access to plotting tools.');
    }

    function openMLTemplates() {
      console.log('🤖 Opening ML templates...');
      alert('ML templates would be implemented here. This would provide pre-built machine learning workflow templates.');
    }

    function openSimulation() {
      console.log('🎲 Opening simulation...');
      alert('Simulation functionality would be implemented here. This would provide simulation workflow templates and tools.');
    }

    function shareNotebook() {
      console.log('👥 Sharing notebook...');
      alert('Notebook sharing functionality would be implemented here. This would allow sharing notebooks with team members.');
    }

    function openTemplates() {
      console.log('📚 Opening templates...');
      alert('Template library would be implemented here. This would provide ODRAS-specific notebook templates.');
    }

    function showJupyterHelp() {
      alert('Jupyter Lab Help:\\n\\n• Use Ctrl+Enter to run cells\\n• Use Shift+Enter to run and advance\\n• Use A/B to add cells above/below\\n• Use DD to delete cells\\n• Use M/Y to switch between Markdown/Code\\n\\nODRAS Integration:\\n• Load project data directly\\n• Save results to artifacts\\n• Export reports and visualizations\\n• Collaborate with team members');
    }

    // Projects
    async function loadProjects() {
      const res = await authenticatedFetch('/api/projects');
      const json = await res.json();
      const raw = json.projects || [];
      // Normalize backend shape to { id, name }
      const list = raw.map(p => ({
        id: p.id || p.project_id || p.projectId,
        name: p.name || p.project_name || 'Project'
      })).filter(p => !!p.id);
      const selects = [qs('#projectSelect2')];
      if (list.length) {
        // Check URL state first, then localStorage, then default to first project
        const urlState = getURLState();
        const savedPid = (localStorage.getItem('active_project_id') || '').trim();
        const urlProjectId = urlState.projectId;

        let selected = list[0];
        let projectIdToUse = null;

        // Priority: URL state > localStorage > first available project
        if (urlProjectId) {
          const found = list.find(p => p.id === urlProjectId);
          if (found) {
            selected = found;
            projectIdToUse = urlProjectId;
            console.log('Using project from URL:', urlProjectId);
          } else {
            console.warn('URL project ID not accessible, falling back to localStorage');
          }
        }

        if (!projectIdToUse && savedPid) {
          const found = list.find(p => p.id === savedPid);
          if (found) {
            selected = found;
            projectIdToUse = savedPid;
            console.log('Using project from localStorage:', savedPid);
          } else {
            // Saved project ID not found in accessible projects - clear it
            console.warn('Saved project ID not accessible, clearing selection');
            try {
              localStorage.removeItem('active_project_id');
            } catch (error) {
              console.warn('Failed to clear project selection:', error);
            }
          }
        }

        // Update localStorage and URL to match selected project
        if (projectIdToUse) {
          try {
            localStorage.setItem('active_project_id', projectIdToUse);
            updateURL(projectIdToUse);
          } catch (error) {
            console.warn('Failed to update project state:', error);
          }
        }

        // Update namespace display for initial project
        if (selected) {
          updateNamespaceDisplay(selected.id);
        }
        selects.forEach(sel => { if (sel) { sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join(''); sel.disabled = false; sel.value = selected.id; } });
        await renderTree(selected);

        // Load project info if project workbench is active
        if (document.querySelector('#wb-project.workbench.active')) {
          // Small delay to ensure project selection is fully established
          setTimeout(() => {
            loadProjectInfo();
          }, 100);
        }
      } else {
        // No projects: clear tree and show empty state
        console.warn('No accessible projects found, clearing project selection');
        try {
          localStorage.removeItem('active_project_id');
        } catch (error) {
          console.warn('Failed to clear project selection:', error);
        }
        selects.forEach(sel => { if (sel) { sel.innerHTML = '<option value="" disabled selected>Create Project...</option>'; sel.disabled = true; } });
        await renderTree({ id: null, name: '' });
      }
    }
    // Reusable progress indicator system for project operations
    function createProjectProgressIndicator(message, type = 'info') {
      console.log('🔧 createProjectProgressIndicator called:', message, type);

      // Remove any existing progress indicator
      const existing = document.getElementById('project-operation-progress');
      if (existing) {
        console.log('🔧 Removing existing progress indicator');
        existing.remove();
      }

      const progressDiv = document.createElement('div');
      progressDiv.id = 'project-operation-progress';
      console.log('🔧 Created progress div element');

      const colors = {
        info: '#2196F3',
        success: '#4CAF50',
        error: '#f44336',
        warning: '#FF9800'
      };

      progressDiv.style.cssText = `
        position: fixed; top: 50px; right: 50px;
        background: ${colors[type]}; color: white;
        padding: 20px 30px; border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.5);
        z-index: 99999; font-weight: bold; font-size: 16px;
        animation: pulse 1.5s infinite;
        max-width: 400px; text-align: center;
        transition: all 0.3s ease;
        border: 3px solid white;
      `;
      progressDiv.innerHTML = message;
      console.log('🔧 Appending progress div to body');
      document.body.appendChild(progressDiv);
      console.log('🔧 Progress indicator should now be visible');
      return progressDiv;
    }

    function updateProjectProgress(message, type = 'info') {
      console.log('🔧 updateProjectProgress called:', message, type);
      const progressDiv = document.getElementById('project-operation-progress');
      if (progressDiv) {
        console.log('🔧 Found progress div, updating...');
        progressDiv.innerHTML = message;
        const colors = {
          info: '#2196F3',
          success: '#4CAF50',
          error: '#f44336',
          warning: '#FF9800'
        };
        progressDiv.style.background = colors[type];
        console.log('🔧 Progress updated successfully');
      } else {
        console.warn('🔧 Progress div not found for update');
      }
    }

    function removeProjectProgress(delay = 0) {
      setTimeout(() => {
        const progressDiv = document.getElementById('project-operation-progress');
        if (progressDiv) {
          progressDiv.style.animation = 'fadeOut 0.3s ease';
          setTimeout(() => progressDiv.remove(), 300);
        }
      }, delay);
    }

    // Add CSS for animations
    if (!document.getElementById('project-progress-styles')) {
      const style = document.createElement('style');
      style.id = 'project-progress-styles';
      style.textContent = `
        @keyframes pulse {
          0% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.05); opacity: 0.8; }
          100% { transform: scale(1); opacity: 1; }
        }
        @keyframes fadeOut {
          from { opacity: 1; transform: translateY(0); }
          to { opacity: 0; transform: translateY(-20px); }
        }
      `;
      document.head.appendChild(style);
    }

    // Enhanced project deletion with progress indicator
    async function deleteProjectWithProgress(projectId, projectName) {
      if (!projectId) {
        alert('No project selected for deletion');
        return false;
      }

      // Confirm deletion
      if (!confirm(`Are you sure you want to delete project "${projectName}"?\n\nThis will permanently delete:\n• Project data and settings\n• All uploaded files\n• All knowledge assets\n• All project threads and history\n\nThis action cannot be undone.`)) {
        return false;
      }

      const progressDiv = createProjectProgressIndicator('🗑️ Preparing to delete project...', 'warning');

      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          throw new Error('Authentication required');
        }

        console.log(`🗑️ Deleting project "${projectName}" (${projectId})...`);

        // Step 1: Delete from database
        updateProjectProgress('🗄️ Removing project from database...', 'warning');

        const res = await fetch(`/api/projects/${projectId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(`Failed to delete project: ${res.status} ${errorText}`);
        }

        // Step 2: Clean up UI
        updateProjectProgress('🔄 Updating project list...', 'info');

        // Reload projects
        const pr = await fetch('/api/projects', {
          headers: { Authorization: 'Bearer ' + token }
        }).then(r => r.json()).catch(() => ({ projects: [] }));

        const raw = pr.projects || [];
        const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' })).filter(p => !!p.id);

        // Update project selector
        const sel = qs('#projectSelect2');
        if (sel) {
          sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
          if (list.length) {
            sel.value = list[0].id;
            sel.disabled = false;
          } else {
            sel.innerHTML = '<option value="" disabled selected>No projects</option>';
            sel.disabled = true;
          }
        }

        // Render tree with new selection
        const selected = list[0] || { id: null, name: '' };
        updateProjectProgress('🎨 Updating interface...', 'info');
        await renderTree(selected);

        // Success
        updateProjectProgress(`✅ Project "${projectName}" deleted successfully`, 'success');
        removeProjectProgress(2000);

        console.log(`✅ Project "${projectName}" deleted successfully`);
        return true;

      } catch (error) {
        console.error('❌ Error during project deletion:', error);
        updateProjectProgress('❌ Project deletion failed', 'error');
        removeProjectProgress(3000);
        alert(`Error deleting project: ${error.message}`);
        return false;
      }
    }

    // Global functions for project operations
    window.createProjectProgressIndicator = createProjectProgressIndicator;
    window.updateProjectProgress = updateProjectProgress;
    window.removeProjectProgress = removeProjectProgress;
    window.deleteProjectWithProgress = deleteProjectWithProgress;

    (function () {
      const npb = qs('#newProjectBtn');
      if (!npb) return;
      npb.onclick = async () => {
        // Prevent multiple clicks during project creation
        if (npb.disabled) {
          console.log('🚫 Project creation already in progress...');
          return;
        }

        const name = prompt('Project name');
        if (!name) return;

        // Disable button and show loading state
        const originalText = npb.textContent;
        npb.disabled = true;
        npb.innerHTML = '🔄 Creating...';
        npb.style.opacity = '0.7';
        npb.style.cursor = 'not-allowed';

        // Add progress indicator using reusable system
        console.log('🔧 Creating progress indicator...');
        let progressDiv;
        try {
          progressDiv = createProjectProgressIndicator('🏗️ Creating project...');
          console.log('🔧 Progress indicator created:', progressDiv);
        } catch (progressError) {
          console.error('🔧 Progress indicator failed:', progressError);
          // Fallback: just log to console
          console.log('🏗️ Creating project (progress indicator failed)...');
        }

        try {
          const token = localStorage.getItem(tokenKey);
          console.log(`🏗️ Creating project "${name}"...`);

          // Update progress
          updateProjectProgress('📝 Submitting project data...');

          const res = await fetch('/api/projects', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token },
            body: JSON.stringify({ name })
          });

          // Update progress
          updateProjectProgress('⚙️ Processing project creation...');

          let pid = '';
          let pname = name;
          if (res.ok) {
            const js = await res.json().catch(() => ({}));
            const proj = js.project || js;
            pid = (proj && (proj.id || proj.project_id || proj.projectId)) || '';
            pname = (proj && proj.name) || name;
            if (pid) {
              try { localStorage.setItem('active_project_id', pid); } catch (_) { }
              console.log(`✅ Project "${pname}" created successfully (ID: ${pid})`);
            }
          } else {
            console.error(`❌ Failed to create project: ${res.status} ${res.statusText}`);
            alert(`Failed to create project: ${res.status} ${res.statusText}`);
          }

          // Reload projects, select the created one, and render it
          console.log('🔄 Reloading projects...');
          updateProjectProgress('🔄 Refreshing project list...');

          const pr = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token } }).then(r => r.json()).catch(() => ({ projects: [] }));
          const raw = pr.projects || [];
          const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' })).filter(p => !!p.id);
          const sel = qs('#projectSelect2');
          if (sel) {
            sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
            if (pid && list.find(p => p.id === pid)) sel.value = pid; else if (list.length) sel.value = list[0].id;
            sel.disabled = !list.length;
          }
          const selected = pid ? { id: pid, name: pname } : (list[0] || { id: null, name: '' });
          updateProjectProgress('🎨 Setting up project interface...');
          await renderTree(selected);

          // Success indicator
          updateProjectProgress('✅ Project created successfully!', 'success');
          removeProjectProgress(2000);

          console.log('✅ Project creation and setup completed');

        } catch (error) {
          console.error('❌ Error during project creation:', error);

          // Error indicator
          updateProjectProgress('❌ Project creation failed', 'error');
          removeProjectProgress(3000);

          alert(`Error creating project: ${error.message}`);
        } finally {
          // Re-enable button and restore original state
          npb.disabled = false;
          npb.innerHTML = originalText;
          npb.style.opacity = '1';
          npb.style.cursor = 'pointer';
          console.log('🔓 Project creation button re-enabled');

          // Ensure progress indicator is removed
          removeProjectProgress(100);
        }
      };
    })();
    ['#projectSelect2'].forEach(id => {
      const sel = qs(id); if (!sel) return;
      sel.addEventListener('change', async (e) => {
        const pid = e.target.value;
        try {
          localStorage.setItem('active_project_id', pid);
          updateURL(pid); // Update URL with new project

          // Update Thread Manager with new project
          if (window.updateThreadManagerProject) {
            window.updateThreadManagerProject(pid);
          }
        } catch (_) { }
        const token = localStorage.getItem(tokenKey);
        // Save current ontology canvas before switching projects
        try { if (ontoState && ontoState.cy && activeOntologyIri) saveGraphToLocal(activeOntologyIri); } catch (_) { }
        const res = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token } });
        const json = await res.json();
        const raw = json.projects || [];
        const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' }));
        const proj = list.find(p => p.id === pid);
        if (proj) {
          activeOntologyIri = null;
          updateOntoGraphLabel();
          await renderTree(proj);
          updateNamespaceDisplay(pid);
          // Update project info page if it's active
          if (document.querySelector('#wb-project.workbench.active')) {
            loadProjectInfo();
          }

          // Always reset requirements state when project changes
          if (window.requirementsState) {
            window.requirementsState.currentPage = 1;
            window.requirementsState.filters = {
              search: '',
              requirement_type: '',
              state: '',
              priority: '',
              verification_status: ''
            };
            // Clear filters in UI
            const searchInput = document.getElementById('reqSearchInput');
            if (searchInput) searchInput.value = '';
            const selects = ['reqTypeFilter', 'reqStatusFilter', 'reqPriorityFilter'];
            selects.forEach(id => {
              const el = document.getElementById(id);
              if (el) el.value = '';
            });
          }

          // Update requirements workbench if it's active
          if (document.querySelector('#wb-requirements.workbench.active')) {
            if (window.loadRequirements) {
              window.loadRequirements();
            }
          }

          // Reinitialize DAS dock for new project if dock is open
          console.log('🔄 Project dropdown changed to:', pid);

          if (typeof window.reinitializeDASForProject === 'function') {
            try {
              await window.reinitializeDASForProject(pid);
            } catch (error) {
              console.error('🔄 Error during DAS reinitialize:', error);
            }
          } else {
            console.warn('🔄 reinitializeDASForProject function not available - DAS dock will not update');
          }
        }
      });
    });

    // Plus button near project selector creates a new project
    (function () {
      const btn = qs('#addNodeBtn');
      if (!btn) return;
      btn.addEventListener('click', () => {
        showCreateProjectModal();
      });
    })();

    // Workbench switching
    qsa('.icon').forEach(el => el.onclick = () => {
      // Get the previous workbench
      const previousWb = document.querySelector('.workbench.active')?.id?.replace('wb-', '');

      qsa('.icon').forEach(i => i.classList.remove('active')); el.classList.add('active');
      const wb = el.getAttribute('data-wb');
      qsa('.workbench').forEach(w => w.classList.remove('active'));
      qs('#wb-' + wb).classList.add('active');

      // Load data when switching to specific workbenches
      if (wb === 'settings') {
        initializeSettings();
      } else if (wb === 'analysis') {
        initializeAnalysisLab();
      } else if (wb === 'admin') {
        loadPrefixes();
        loadDomains();
        // Only load namespaces if user is authenticated
        const token = localStorage.getItem('odras_token');
        if (token) {
          loadNamespaces();
        }
      } else if (wb === 'project') {
        // For project workbench, load project info if we have a project selected
        const currentProjectId = localStorage.getItem('active_project_id');
        if (currentProjectId) {
          loadProjectInfo();
        }
      } else if (wb === 'thread') {
        // Initialize Thread Manager workbench
        console.log('🧵 Activating Thread Manager workbench');
        const currentProjectId = localStorage.getItem('active_project_id');
        if (currentProjectId) {
          updateThreadManagerProject(currentProjectId);
        }
        onThreadWorkbenchActivated();
      } else if (wb === 'events') {
        // Initialize Event Manager workbench
        console.log('📊 Activating Event Manager workbench');
        initializeEventManager();
      }

      // Persist selected workbench and update URL
      try {
        localStorage.setItem('active_workbench', wb);
        const currentProjectId = localStorage.getItem('active_project_id');
        updateURL(currentProjectId, wb); // Update URL with workbench
      } catch (_) { }
      // Reflect in hash
      try {
        const params = new URLSearchParams(location.hash.replace(/^#/, ''));
        params.set('wb', wb);
        location.hash = params.toString();
      } catch (_) { }
      if (wb === 'graph') refreshGraphSummary();
      if (wb === 'ontology') { ensureOntologyInitialized(); if (ontoState.cy) ontoState.cy.resize(); }
      if (wb === 'files') {
        ensureFilesInitialized();
        // Load library when files workbench becomes active
        try {
          if (window.loadLibraryFromApi) {
            setTimeout(() => window.loadLibraryFromApi(), 100); // Small delay to ensure auth/project context is ready
          }
        } catch (_) { }
      } else if (wb === 'requirements') {
        // Initialize Requirements Workbench
        console.log('📋 Activating Requirements Workbench');
        if (typeof initializeRequirementsWorkbench === 'function') {
          initializeRequirementsWorkbench();
        } else {
          console.error('❌ initializeRequirementsWorkbench is not defined!');
          console.log('📋 Available functions:', Object.keys(window).filter(k => k.includes('equirement')));
        }
      }
    });

    // Tree collapsible sections
    qsa('.section > button').forEach(btn => {
      btn.onclick = (e) => {
        const sec = e.currentTarget.parentElement;
        const expanded = sec.getAttribute('aria-expanded') !== 'false';
        sec.setAttribute('aria-expanded', expanded ? 'false' : 'true');
      };
    });

    // Admin section toggle function
    function toggleSection(header) {
      console.log('🔄 Toggling section...', header);
      const section = header.closest('.section');
      console.log('Section found:', section);
      if (!section) {
        console.error('❌ Section not found');
        return;
      }

      const content = section.querySelector('.section-content');
      console.log('Content found:', content);
      if (!content) {
        console.error('❌ Content not found');
        return;
      }

      const isCollapsed = section.classList.contains('collapsed');
      console.log('Currently collapsed:', isCollapsed);

      // Toggle the collapsed class
      section.classList.toggle('collapsed');

      // Toggle display style based on collapsed state
      if (section.classList.contains('collapsed')) {
        content.style.display = 'none';
      } else {
        content.style.display = 'block';
      }

      // Update the toggle icon
      const icon = header.querySelector('.section-toggle');
      console.log('Icon found:', icon);
      if (icon) {
        const newIcon = section.classList.contains('collapsed') ? '▶' : '▼';
        icon.textContent = newIcon;
        console.log('✅ Section toggled, icon updated to:', newIcon);
      } else {
        console.error('❌ Icon not found');
      }
    }

    // Resizer
    (function () {
      const res = qs('#resizer');
      const panel = qs('#treePanel');
      let dragging = false;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => {
        dragging = false;
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tree-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tree-w-max'));
        let w = e.clientX - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--iconbar-w'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty('--tree-w', w + 'px');
        try { localStorage.setItem('ui_main_tree_w', String(w)); } catch (_) { }
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    // Ontology panel resizer
    (function () {
      const res = qs('#ontoResizer');
      const panelWidthProp = '--onto-tree-w';
      let dragging = false;
      if (!res) return;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => {
        dragging = false;
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const layout = qs('#wb-ontology .onto-layout'); if (!layout) return;
        const layoutRect = layout.getBoundingClientRect();
        // Grid columns: [tree][divider][iconbar][canvas][divider][props]
        // If tree is collapsed, divider width is 0; math still uses layout left
        let w = e.clientX - layoutRect.left;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-tree-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-tree-w-max'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty(panelWidthProp, w + 'px');
        try { localStorage.setItem('onto_tree_w', String(w)); } catch (_) { }
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    // Properties panel resizer
    (function () {
      const res = qs('#ontoPropsResizer');
      let dragging = false;
      if (!res) return;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => dragging = false);
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const layoutRect = qs('#wb-ontology .onto-layout')?.getBoundingClientRect();
        if (!layoutRect) return;
        let w = layoutRect.right - e.clientX;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-props-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-props-w-max'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty('--onto-props-w', w + 'px');
        try { localStorage.setItem('onto_props_w', String(w)); } catch (_) { }
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    async function renderTree(project) {
      activeProject = project && project.id ? project : null;
      // Reset active ontology when switching context or when no project
      activeOntologyIri = null;
      updateOntoGraphLabel();
      try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch (_) { }
      // Restore per-project active ontology selection (label only)
      try {
        const pid = project && (project.id || project.project_id);
        const savedIri = localStorage.getItem(`onto_active_iri__${pid}`);
        if (savedIri) {
          activeOntologyIri = savedIri;
          updateOntoGraphLabel();
          // Ensure properties panel model name reflects the saved active ontology
          try {
            const labels = loadOntologyLabelMap(project);
            const pid2 = (project && (project.id || project.project_id)) ? (project.id || project.project_id) : 'default';
            const friendly = (labels[savedIri] && String(labels[savedIri]).trim()) || (savedIri.split('/').pop() || savedIri);
            // FIXED: Use ontology-specific localStorage keys consistently
            const ontologyKey = savedIri ? savedIri.split('/').pop() : 'default';
            const modelNameKey = `onto_model_name__${pid2}__${ontologyKey}`;
            const modelAttrsKey = `onto_model_attrs__${pid2}__${ontologyKey}`;

            localStorage.setItem(modelNameKey, friendly);
            let attrs = {};

            try { attrs = JSON.parse(localStorage.getItem(modelAttrsKey) || '{}'); } catch (_) { attrs = {}; }
            attrs.displayLabel = friendly;
            attrs.graphIri = savedIri;
            // Set namespace based on installation configuration
            attrs.namespace = iri;  // Use the actual graph IRI as namespace
            localStorage.setItem(modelAttrsKey, JSON.stringify(attrs));
            updatePropertiesPanelFromSelection();
          } catch (_) { }
          // Attempt to load saved canvas for this active IRI
          try {
            if (ontoState.cy) {
              ontoState.suspendAutosave = true;
              ontoState.cy.elements().remove();
              loadGraphFromLocal(savedIri);
              setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
            }
          } catch (_) { }
        }
      } catch (_) { }
      const root = qs('#treeRoot');
      const makeItem = (id, label, iconCls, children = [], dataAttrs = {}) => {
        const hasChildren = children && children.length > 0;
        const li = document.createElement('li');
        li.setAttribute('role', 'treeitem');
        if (hasChildren) li.setAttribute('aria-expanded', 'true');
        li.dataset.nodeId = id;
        Object.keys(dataAttrs || {}).forEach(k => { li.dataset[k] = dataAttrs[k]; });

        const row = document.createElement('div');
        row.className = 'node-row';
        row.tabIndex = 0;
        row.onclick = async (e) => { selectNode(li); await handleTreeSelection(li); };
        row.onkeydown = (e) => handleKey(e, li);
        // Inline rename on double-click for ontology nodes
        row.ondblclick = (e) => {
          if (li.dataset.nodeType === 'ontology') {
            const current = (li.dataset.label || row.querySelector('.node-label')?.textContent || '').trim();
            const name = prompt('Rename ontology label', current);
            if (!name || name.trim() === current) return;
            try {
              const payload = { graph: li.dataset.iri, label: name.trim() };
              const token = localStorage.getItem(tokenKey);
              fetch('/api/ontologies/label', { method: 'PUT', headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token }, body: JSON.stringify(payload) })
                .then(async (res) => {
                  if (!res.ok) throw new Error('rename failed');
                  const newLabel = name.trim();
                  row.querySelector('.node-label').textContent = newLabel; li.dataset.label = newLabel; saveOntologyLabel(li.dataset.iri, newLabel);
                  if (activeOntologyIri === li.dataset.iri) {
                    const pid = project.id || project.project_id || 'default';
                    // FIXED: Use ontology-specific localStorage keys consistently
                    const ontologyKey = (li.dataset.iri || activeOntologyIri) ? (li.dataset.iri || activeOntologyIri).split('/').pop() : 'default';
                    const modelNameKey = `onto_model_name__${pid}__${ontologyKey}`;
                    const modelAttrsKey = `onto_model_attrs__${pid}__${ontologyKey}`;

                    localStorage.setItem(modelNameKey, newLabel);
                    try {
                      let attrs = {};

                      try { attrs = JSON.parse(localStorage.getItem(modelAttrsKey) || '{}'); } catch (_) { attrs = {}; }
                      attrs.displayLabel = newLabel;
                      // Ensure namespace matches the graph IRI
                      if (!attrs.namespace || attrs.namespace.endsWith('/ontology')) {
                        attrs.namespace = li.dataset.iri || activeOntologyIri;
                      }
                      localStorage.setItem(modelAttrsKey, JSON.stringify(attrs));
                    } catch (_) { }
                    updateOntoGraphLabel();
                    // Immediately update properties panel model name
                    try { updatePropertiesPanelFromSelection(); } catch (_) { }
                    // Immediately reflect in Ontology tree view without a full tree reload
                    try { refreshOntologyTree(); } catch (_) { }
                  }
                  // Avoid immediate server re-fetch that could race and overwrite the fresh label
                })
                .catch(() => { alert('Rename failed'); });
            } catch (_) { }
          }
        };

        const twist = document.createElement('span'); twist.className = 'twist';
        if (hasChildren) {
          twist.onclick = (e) => { e.stopPropagation(); toggleNode(li); };
        }
        row.appendChild(twist);

        const icon = document.createElement('span'); icon.className = 'node-icon ' + iconCls; row.appendChild(icon);
        const text = document.createElement('span'); text.className = 'node-label'; text.textContent = label; row.appendChild(text);
        li.appendChild(row);

        if (hasChildren) {
          const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
          children.forEach(ch => ul.appendChild(ch));
          li.appendChild(ul);
        }
        return li;
      };

      const reqItems = ((project && project.requirements) || []).map((r, idx) => {
        const rid = r.id || `SP-${String(idx + 1).padStart(3, '0')}`;
        const label = rid; // ID only
        return makeItem(rid, label, 'req');
      });
      const docReqItems = (project && project.documents && project.documents.requirements ? project.documents.requirements : []).map(d => makeItem(d.id || d.name, d.name || d.id, 'docreq'));
      const docKnowItems = (project && project.documents && project.documents.knowledge ? project.documents.knowledge : []).map(d => makeItem(d.id || d.name, d.name || d.id, 'docknow'));
      const outItems = ((project && (project.artifacts || project.outputs)) || []).map(o => makeItem(o.id || o.name, o.name || o.id, 'out'));

      // Ontology tree: discover from Fuseki
      let ontologyNode = null;
      try {
        const pid = project && (project.id || project.project_id);
        const res = await fetch(`/api/ontologies${pid ? `?project=${encodeURIComponent(pid)}` : ''}`);
        const json = await res.json();
        const onts = Array.isArray(json.ontologies) ? json.ontologies : [];
        const labelsMap = loadOntologyLabelMap(project);
        const ontoItems = onts.map((o, idx) => {
          const serverLabel = (o.label && String(o.label).trim()) || '';
          const mapLabel = (labelsMap[o.graphIri] && String(labelsMap[o.graphIri]).trim()) || '';
          const displayLabel = mapLabel || serverLabel || o.graphIri;
          const isReference = o.is_reference || false;
          const referenceIndicator = isReference ? ' 📚' : '';
          const li = makeItem(
            `ontology-${idx}-${o.graphIri}`,
            displayLabel + referenceIndicator,
            'onto',
            [],
            { nodeType: 'ontology', iri: o.graphIri, label: displayLabel, isReference: isReference }
          );
          // Enable dragging this ontology into the Imports node
          const row = li.querySelector('.node-row');
          if (row) {
            row.setAttribute('draggable', 'true');
            row.addEventListener('dragstart', (ev) => {
              try { ev.dataTransfer.setData('text/graph-iri', o.graphIri); ev.dataTransfer.effectAllowed = 'copy'; } catch (_) { }
            });

            // Add context menu for ontology nodes (admin only)
            row.oncontextmenu = (ev) => {
              ev.preventDefault();
              console.log('🔍 Right-click detected on ontology node:', o.graphIri);

              const menu = qs('#ontologyContextMenu');
              if (!menu) {
                console.log('❌ Ontology context menu not found');
                return;
              }

              // Check if user is admin
              const user = JSON.parse(localStorage.getItem('user') || '{}');
              console.log('👤 Current user:', user);
              console.log('🔍 User is_admin:', user.is_admin);

              // Temporarily allow all users to test the context menu
              // if (!user.is_admin) {
              //   console.log('❌ User is not admin, context menu disabled');
              //   return;
              // }

              console.log('✅ Showing context menu (admin check temporarily disabled)');

              menu.style.display = 'block';
              menu.style.left = ev.pageX + 'px';
              menu.style.top = ev.pageY + 'px';

              const hide = () => {
                menu.style.display = 'none';
                document.removeEventListener('click', hide, { capture: true });
              };
              setTimeout(() => { document.addEventListener('click', hide, { capture: true }); }, 0);

              // Set up context menu actions
              const renameBtn = qs('#ontoRenameBtn');
              const toggleRefBtn = qs('#ontoToggleReferenceBtn');
              const deleteBtn = qs('#ontoDeleteBtn');

              if (renameBtn) {
                renameBtn.onclick = async () => {
                  hide();
                  const current = displayLabel;
                  const name = prompt('Rename ontology label', current);
                  if (!name || name.trim() === current) return;
                  try {
                    const payload = { graph: o.graphIri, label: name.trim() };
                    const token = localStorage.getItem(tokenKey);
                    const res = await fetch('/api/ontologies/label', {
                      method: 'PUT',
                      headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token },
                      body: JSON.stringify(payload)
                    });
                    if (res.ok) {
                      row.querySelector('.node-label').textContent = name.trim() + referenceIndicator;
                      li.dataset.label = name.trim();
                      saveOntologyLabel(o.graphIri, name.trim());
                      await renderTree(project);
                    } else {
                      alert('Rename failed');
                    }
                  } catch (_) {
                    alert('Rename failed');
                  }
                };
              }

              if (toggleRefBtn) {
                const currentRefStatus = isReference;
                toggleRefBtn.textContent = currentRefStatus ? 'Remove Reference Status' : 'Mark as Reference';
                toggleRefBtn.onclick = async () => {
                  hide();
                  try {
                    const payload = { graph: o.graphIri, is_reference: !currentRefStatus };
                    const token = localStorage.getItem(tokenKey);
                    const res = await fetch('/api/ontologies/reference', {
                      method: 'PUT',
                      headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token },
                      body: JSON.stringify(payload)
                    });
                    if (res.ok) {
                      await renderTree(project);
                    } else {
                      alert('Failed to update reference status');
                    }
                  } catch (_) {
                    alert('Failed to update reference status');
                  }
                };
              }


              if (deleteBtn) {
                deleteBtn.onclick = async () => {
                  hide();
                  if (confirm(`Delete ontology "${displayLabel}"?`)) {
                    try {
                      const token = localStorage.getItem(tokenKey);
                      const res = await fetch(`/api/ontologies?graph=${encodeURIComponent(o.graphIri)}`, {
                        method: 'DELETE',
                        headers: { Authorization: 'Bearer ' + token }
                      });
                      if (res.ok) {
                        // Clear local storage for this ontology
                        try {
                          localStorage.removeItem(storageKeyForGraph(o.graphIri));
                          console.log('🗑️ Cleared local storage for deleted ontology:', o.graphIri);
                        } catch (e) {
                          console.warn('Failed to clear local storage:', e);
                        }

                        await renderTree(project);
                        if (activeOntologyIri === o.graphIri) {
                          activeOntologyIri = null;
                          updateOntoGraphLabel();
                          ensureOntologyInitialized();
                          ontoState.cy?.elements().remove();
                          refreshOntologyTree();
                        }
                      } else {
                        alert('Delete failed');
                      }
                    } catch (_) {
                      alert('Delete failed');
                    }
                  }
                };
              }
            };
          }
          // Initialize label map from server only if missing
          if (!mapLabel && serverLabel) {
            try { saveOntologyLabel(o.graphIri, serverLabel); } catch (_) { }
          }
          return li;
        });
        if (ontoItems.length) {
          ontologyNode = makeItem('ontology', 'Ontologies', 'folder', ontoItems);
        } else {
          // No ontologies: ensure empty state is shown
          activeOntologyIri = null;
          updateOntoGraphLabel();
          ontologyNode = makeItem('ontology', 'Ontologies', 'folder', []);
        }
      } catch (_) {
        // Network/SPARQL error: show a placeholder item
        ontologyNode = makeItem('ontology', 'Ontologies', 'folder', [
          makeItem('onto-error', 'Discovery unavailable', 'onto')
        ]);
      }

      const projectDisplay = (project && (project.name || project.id)) ? (project.name || project.id) : '';
      const projectInfo = makeItem('project-info', `Project: ${projectDisplay}`, 'folder');
      // Enable delete on main tree top node when project is selected
      try {
        const row = projectInfo.querySelector('.node-row');
        if (row && project && (project.id || project.project_id)) {
          // Click handler to open project information page
          row.onclick = (ev) => {
            ev.preventDefault();
            ev.stopPropagation();

            // Switch to project workbench
            const projectIcon = qs('#wb-project');
            if (projectIcon) {
              // Remove active class from all workbenches
              qsa('.workbench').forEach(wb => wb.classList.remove('active'));
              qsa('.icon').forEach(icon => icon.classList.remove('active'));

              // Add active class to project workbench
              projectIcon.classList.add('active');
              qs('#wb-project').classList.add('active');

              // Update localStorage and URL
              try {
                localStorage.setItem('active_workbench', 'project');
                const currentProjectId = localStorage.getItem('active_project_id');
                updateURL(currentProjectId, 'project');
              } catch (_) { }

              // Load project information
              loadProjectInfo();
            }
          };

          // Context menu binding
          row.oncontextmenu = (ev) => {
            ev.preventDefault();
            const menu = qs('#projectContextMenu'); if (!menu) return;
            menu.style.display = 'block';
            menu.style.left = ev.pageX + 'px';
            menu.style.top = ev.pageY + 'px';
            const hide = () => { menu.style.display = 'none'; document.removeEventListener('click', hide, { capture: true }); };
            setTimeout(() => { document.addEventListener('click', hide, { capture: true }); }, 0);
            const pid = project.id || project.project_id;
            const token = localStorage.getItem(tokenKey);
            const archiveBtn = qs('#projArchiveBtn');
            const deleteBtn = qs('#projDeleteBtn');
            const showArchivedBtn = qs('#projShowArchivedBtn');
            const renameBtn = qs('#projRenameBtn');
            if (renameBtn) renameBtn.onclick = async () => {
              try {
                const currentName = (project && (project.name || '')) || '';
                const newName = prompt('Rename project', currentName);
                if (!newName || newName.trim() === currentName) return;
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token },
                  body: JSON.stringify({ name: newName.trim() })
                });
                if (res.ok) {
                  // Verify via API that the rename persisted
                  try {
                    const vr = await fetch(`/api/projects/${encodeURIComponent(pid)}`, { headers: { Authorization: 'Bearer ' + token } });
                    if (vr.ok) {
                      const vj = await vr.json();
                      const vproj = vj.project || vj;
                      const serverName = (vproj.name || vproj.project_name || '').trim();
                      if (serverName !== newName.trim()) {
                        alert('Rename saved but verification failed: expected "' + newName.trim() + '", got "' + serverName + '". UI will refresh.');
                      }
                    } else {
                      const t = await vr.text().catch(() => String(vr.status));
                      alert('Rename saved, but verification request failed: ' + t);
                    }
                  } catch (_) {
                    // Non-fatal verification error
                  }
                  await loadProjects();
                } else {
                  const t = await res.text().catch(() => String(res.status));
                  alert('Rename failed: ' + t);
                }
              } finally { hide(); }
            };
            if (archiveBtn) archiveBtn.onclick = async () => {
              try {
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}/archive`, { method: 'POST', headers: { Authorization: 'Bearer ' + token } });
                if (res.ok) { try { localStorage.removeItem('active_project_id'); } catch (_) { } await loadProjects(); }
                else { const t = await res.text().catch(() => String(res.status)); alert('Archive failed: ' + t); }
              } finally { hide(); }
            };
            if (deleteBtn) deleteBtn.onclick = async () => {
              try {
                if (!confirm('Delete this project? This does not delete external artifacts.')) return;
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token } });
                if (res.ok) { try { localStorage.removeItem('active_project_id'); } catch (_) { } await loadProjects(); }
                else { const t = await res.text().catch(() => String(res.status)); alert('Delete failed: ' + t); }
              } finally { hide(); }
            };
            if (showArchivedBtn) showArchivedBtn.onclick = async () => {
              try {
                const res = await fetch('/api/projects?state=archived', { headers: { Authorization: 'Bearer ' + token } });
                const json = await res.json();
                const rows = (json.projects || []).map(p => ({ id: p.project_id || p.id, name: p.name || 'Project' })).filter(p => p.id);
                const overlay = document.createElement('div');
                overlay.style.position = 'fixed'; overlay.style.inset = '0'; overlay.style.background = 'rgba(0,0,0,0.4)'; overlay.style.zIndex = '9998';
                const panel = document.createElement('div'); panel.style.position = 'fixed'; panel.style.top = '20%'; panel.style.left = '50%'; panel.style.transform = 'translateX(-50%)'; panel.style.background = 'var(--panel)'; panel.style.border = '1px solid var(--border)'; panel.style.borderRadius = '12px'; panel.style.padding = '12px'; panel.style.minWidth = '420px'; panel.style.zIndex = '9999';
                panel.innerHTML = `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;"><strong>Archived Projects</strong><button id="archClose" class="btn">Close</button></div><div id="archList"></div>`;
                document.body.appendChild(overlay); document.body.appendChild(panel);
                const close = () => { try { document.body.removeChild(panel); document.body.removeChild(overlay); } catch (_) { } };
                panel.querySelector('#archClose').onclick = close; overlay.onclick = close;
                const listEl = panel.querySelector('#archList');
                if (!rows.length) { listEl.innerHTML = '<div class="muted">No archived projects.</div>'; return; }
                listEl.innerHTML = rows.map(r => `<div style="display:flex; justify-content:space-between; align-items:center; border:1px solid var(--border); border-radius:8px; padding:8px; margin-bottom:6px;"><span>${r.name}</span><div><button class="btn" data-restore="${r.id}">Restore</button></div></div>`).join('');
                listEl.addEventListener('click', async (e) => {
                  const btn = e.target.closest('button[data-restore]'); if (!btn) return;
                  const rid = btn.getAttribute('data-restore');
                  const rr = await fetch(`/api/projects/${encodeURIComponent(rid)}/restore`, { method: 'POST', headers: { Authorization: 'Bearer ' + token } });
                  if (rr.ok) {
                    try { localStorage.setItem('active_project_id', rid); } catch (_) { }
                    close();
                    await loadProjects();
                  } else {
                    const t = await rr.text().catch(() => String(rr.status)); alert('Restore failed: ' + t);
                  }
                });
              } finally { hide(); }
            };
          };
          row.onkeydown = async (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
              e.preventDefault();
              const pid = project.id || project.project_id;
              const token = localStorage.getItem(tokenKey);
              if (!confirm('Delete this project? This does not delete external artifacts.')) return;
              const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token } });
              if (res.ok) {
                try { localStorage.removeItem('active_project_id'); } catch (_) { }
                await loadProjects();
              } else {
                const t = await res.text().catch(() => String(res.status));
                alert('Delete failed: ' + t);
              }
            }
          };
        }
      } catch (_) { }
      const docsReqNode = makeItem('documents-requirements', 'Requirements Documents', 'folder', docReqItems);
      const docsKnowNode = makeItem('documents-knowledge', 'Knowledge Documents', 'folder', docKnowItems);
      const docsChildren = [];
      if (docReqItems.length) docsChildren.push(docsReqNode);
      if (docKnowItems.length) docsChildren.push(docsKnowNode);
      const docsNode = makeItem('documents', 'Documents', 'folder', docsChildren);
      const reqNode = makeItem('requirements', 'Extracted Requirements', 'folder', reqItems);

      // Create new ODRAS-specific tree nodes
      const knowledgeNode = makeItem('knowledge', 'Knowledge', 'folder', []);

      // Analysis node with nested structure for Test → Validate → Release workflow
      const analysisDataNode = makeItem('analysis-data', 'Data', 'folder', []);
      const analysisModelsNode = makeItem('analysis-models', 'Models', 'folder', []);
      const analysisSimulationsNode = makeItem('analysis-simulations', 'Simulations', 'folder', []);
      const analysisNotebooksNode = makeItem('analysis-notebooks', 'Notebooks', 'folder', []);
      const analysisResultsNode = makeItem('analysis-results', 'Results', 'folder', []);
      const analysisTemplatesNode = makeItem('analysis-templates', 'Templates', 'folder', []);

      const analysisNode = makeItem('analysis', 'Analysis', 'folder', [
        analysisDataNode,
        analysisModelsNode,
        analysisSimulationsNode,
        analysisNotebooksNode,
        analysisResultsNode,
        analysisTemplatesNode
      ]);

      const eventsNode = makeItem('events', 'Events', 'folder', []);

      // Keep artifacts node for backward compatibility
      const outNode = makeItem('artifacts', 'Artifacts', 'folder', outItems);

      // Create horizontal separator
      const separator = document.createElement('li');
      separator.className = 'tree-separator';
      separator.innerHTML = '<div class="separator-line"></div>';

      root.innerHTML = '';
      // If no project, show minimal empty tree
      root.innerHTML = '';
      if (project && (project.id || project.project_id)) {
        // Show new ODRAS tree structure with nested Analysis and separator before artifacts
        [projectInfo, ontologyNode, knowledgeNode, analysisNode, eventsNode, separator, outNode].filter(Boolean).forEach(n => root.appendChild(n));
      }

      // Auto-restore previously selected ontology for this project, if available
      try {
        const pid = project && (project.id || project.project_id);
        const savedIri = pid ? localStorage.getItem(`onto_active_iri__${pid}`) : null;
        const treeEl = qs('#treeRoot');
        if (savedIri && treeEl) {
          const li = Array.from(treeEl.querySelectorAll('li[role="treeitem"]')).find(el => el.dataset && el.dataset.iri === savedIri);
          if (li) {
            // Restore canvas first (if we have saved content), then select the ontology to sync panels
            try {
              if (ontoState.cy) {
                ontoState.suspendAutosave = true;
                ontoState.cy.elements().remove();
                loadGraphFromLocal(savedIri);
                setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
              }
            } catch (_) { }
            selectNode(li);
            // Prevent workbench switching when restoring selection on load
            suppressWorkbenchSwitch = true;
            try { await handleTreeSelection(li); } finally { suppressWorkbenchSwitch = false; }
          } else {
            // Saved IRI no longer present; reset to empty state
            activeOntologyIri = null;
            updateOntoGraphLabel();
            try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch (_) { }
            refreshOntologyTree();
          }
        } else {
          // No saved selection for this project
          activeOntologyIri = null;
          updateOntoGraphLabel();
          try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch (_) { }
          refreshOntologyTree();
        }
      } catch (_) { }

      // Add plus button on Ontology section header (right side)
      try {
        const ontoSection = Array.from(root.children).find(li => li.querySelector('.node-label')?.textContent === 'Ontologies');
        const headerRow = ontoSection ? ontoSection.querySelector('.node-row') : null;
        if (headerRow && !headerRow.querySelector('.tree-add-btn')) {
          const addBtn = document.createElement('button');
          addBtn.className = 'btn tree-add-btn';
          addBtn.title = 'New Ontology';
          addBtn.textContent = '+';
          addBtn.style.marginLeft = '8px';
          addBtn.onclick = async (e) => {
            e.stopPropagation();
            if (!project || !(project.id || project.project_id)) { alert('Create a project first'); return; }

            // Check if user is admin
            const token = localStorage.getItem(tokenKey);
            let isAdmin = false;
            try {
              const userRes = await fetch('/api/auth/me', { headers: { Authorization: 'Bearer ' + token } });
              if (userRes.ok) {
                const user = await userRes.json();
                isAdmin = user.is_admin || false;
                console.log('User admin status:', isAdmin, user);
              }
            } catch (err) {
              console.error('Failed to get user info:', err);
            }

            // Create dialog for ontology creation
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.4)';
            overlay.style.zIndex = '9998';

            const panel = document.createElement('div');
            panel.style.position = 'fixed';
            panel.style.top = '30%';
            panel.style.left = '50%';
            panel.style.transform = 'translateX(-50%)';
            panel.style.background = 'var(--panel)';
            panel.style.border = '1px solid var(--border)';
            panel.style.borderRadius = '12px';
            panel.style.padding = '20px';
            panel.style.minWidth = '400px';
            panel.style.zIndex = '9999';

            panel.innerHTML = `
              <div style="margin-bottom:16px;">
                <h3 style="margin:0 0 16px 0;">Create or Import Ontology</h3>

                <!-- Creation/Import Mode Toggle -->
                <div style="margin-bottom:16px;">
                  <div style="display:flex; gap:8px; margin-bottom:12px;">
                    <button id="createMode" class="btn btn-primary" style="flex:1;">Create New</button>
                    <button id="importMode" class="btn" style="flex:1;">Import from URL</button>
                  </div>
                </div>

                <!-- Create New Ontology Section -->
                <div id="createSection">
                  <div style="margin-bottom:12px;">
                    <label style="display:block; margin-bottom:4px; font-weight:500;">Display Label:</label>
                    <input type="text" id="ontoLabel" placeholder="Enter ontology label" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--input-bg); color:var(--text);" />
                  </div>

                  <div style="margin-bottom:12px;">
                    <label style="display:block; margin-bottom:4px; font-weight:500;">Namespace (inherited from project):</label>
                    <div id="ontoNamespaceDisplay" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--muted); font-family: monospace;">
                      Loading project namespace...
                    </div>
                    <div style="font-size:0.9em; color:var(--muted); margin-top:4px;">
                      Ontologies automatically inherit their project's namespace
                    </div>
                  </div>
                  ${isAdmin ? `
                  <div style="margin-bottom:16px;">
                    <label style="display:flex; align-items:center; cursor:pointer;">
                      <input type="checkbox" id="isReference" style="margin-right:8px;" />
                      <span>Mark as Reference Ontology (Admin only)</span>
                    </label>
                    <div style="font-size:0.9em; color:var(--muted); margin-top:4px;">
                      Reference ontologies can be imported by other projects
                    </div>
                  </div>
                  ` : ''}
                </div>

                <!-- Import from URL Section -->
                <div id="importSection" style="display:none;">
                  <div style="margin-bottom:12px;">
                    <label style="display:block; margin-bottom:4px; font-weight:500;">Ontology URL:</label>
                    <input type="url" id="importUrl" placeholder="https://example.com/ontology.owl" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--input-bg); color:var(--text);" />
                  </div>
                  <div style="margin-bottom:12px;">
                    <label style="display:block; margin-bottom:4px; font-weight:500;">Display Name:</label>
                    <input type="text" id="importName" placeholder="Enter display name" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--input-bg); color:var(--text);" />
                  </div>
                  <div style="margin-bottom:12px;">
                    <label style="display:block; margin-bottom:4px; font-weight:500;">Display Label:</label>
                    <input type="text" id="importLabel" placeholder="Enter display label" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--input-bg); color:var(--text);" />
                  </div>
                  ${isAdmin ? `
                  <div style="margin-bottom:16px;">
                    <label style="display:flex; align-items:center; cursor:pointer;">
                      <input type="checkbox" id="importIsReference" style="margin-right:8px;" />
                      <span>Mark as Reference Ontology (Admin only)</span>
                    </label>
                    <div style="font-size:0.9em; color:var(--muted); margin-top:4px;">
                      Reference ontologies can be imported by other projects
                    </div>
                  </div>
                  ` : ''}
                </div>

                <div style="display:flex; justify-content:flex-end; gap:8px;">
                  <button id="cancelOnto" class="btn" style="background: var(--muted);">Cancel</button>
                  <button id="createOnto" class="btn btn-primary">Create</button>
                  <button id="importOnto" class="btn btn-primary" style="display:none;">Import</button>
                </div>
              </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(panel);

            const close = () => {
              try {
                document.body.removeChild(panel);
                document.body.removeChild(overlay);
              } catch (_) { }
            };

            panel.querySelector('#cancelOnto').onclick = close;
            overlay.onclick = close;

            // Mode toggle handlers
            panel.querySelector('#createMode').onclick = () => {
              panel.querySelector('#createMode').className = 'btn btn-primary';
              panel.querySelector('#importMode').className = 'btn';
              panel.querySelector('#createSection').style.display = 'block';
              panel.querySelector('#importSection').style.display = 'none';
              panel.querySelector('#createOnto').style.display = 'inline-block';
              panel.querySelector('#importOnto').style.display = 'none';
            };

            panel.querySelector('#importMode').onclick = () => {
              panel.querySelector('#importMode').className = 'btn btn-primary';
              panel.querySelector('#createMode').className = 'btn';
              panel.querySelector('#createSection').style.display = 'none';
              panel.querySelector('#importSection').style.display = 'block';
              panel.querySelector('#createOnto').style.display = 'none';
              panel.querySelector('#importOnto').style.display = 'inline-block';
            };

            // Load current project's namespace
            loadCurrentProjectNamespace(panel.querySelector('#ontoNamespaceDisplay'));

            panel.querySelector('#createOnto').onclick = async () => {
              const labelInput = panel.querySelector('#ontoLabel');
              const disp = labelInput.value.trim();

              if (!disp) {
                alert('Please enter a label for the ontology');
                return;
              }

              // Check if project has a namespace
              const currentProjectId = localStorage.getItem('active_project_id');
              if (!currentProjectId) {
                alert('No project selected - select a project first');
                return;
              }

              const isReference = isAdmin && panel.querySelector('#isReference').checked;
              const base = slugify(disp) || `ontology-${Date.now()}`;
              const label = disp;

              try {
                const pid2 = project.id || project.project_id;
                const body = {
                  project: pid2,
                  name: base,
                  label
                };
                if (isReference) {
                  body.is_reference = true;
                }

                console.log('🔧 Creating ontology with project namespace inheritance:', body);
                console.log('🔧 Frontend sending project ID:', pid2, 'from project object:', project);

                const res = await fetch('/api/ontologies', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token },
                  body: JSON.stringify(body)
                });

                if (!res.ok) {
                  const msg = await res.text().catch(() => String(res.status));
                  alert('Create ontology failed: ' + msg);
                  return;
                }

                const created = await res.json();
                if (created && created.graphIri) {
                  try { saveOntologyLabel(created.graphIri, created.label || label); } catch (_) { }
                }

                close();
                await renderTree(project);

                // Ensure label is shown and select the created ontology (guard for valid response)
                if (created && created.graphIri) {
                  const newRoot = qs('#treeRoot');
                  const li = Array.from(newRoot.querySelectorAll('li[role="treeitem"]')).find(el => el.dataset && el.dataset.iri === created.graphIri);
                  // Update top node label immediately
                  try {
                    const ontoTop = qs('#ontoTreeRoot .onto-node-label');
                    if (ontoTop) ontoTop.textContent = created.label || label;
                  } catch (_) { }
                  if (li) {
                    const lbl = li.querySelector('.node-label'); if (lbl) lbl.textContent = created.label || label;
                    li.dataset.label = created.label || label;
                    selectNode(li);
                    await handleTreeSelection(li);
                  } else {
                    // Fallback: set selection and force refresh display
                    activeOntologyIri = created.graphIri;
                    updateOntoGraphLabel();
                    refreshOntologyTree();
                  }
                }
              } catch (err) {
                alert('Failed to create ontology: ' + err.message);
              }
            };

            // Import from URL handler
            panel.querySelector('#importOnto').onclick = async () => {
              const urlInput = panel.querySelector('#importUrl');
              const nameInput = panel.querySelector('#importName');
              const labelInput = panel.querySelector('#importLabel');

              const url = urlInput.value.trim();
              const name = nameInput.value.trim();
              const label = labelInput.value.trim();

              if (!url) {
                alert('Please enter an ontology URL');
                return;
              }

              if (!name) {
                alert('Please enter a display name');
                return;
              }

              if (!label) {
                alert('Please enter a display label');
                return;
              }

              const isReference = isAdmin && panel.querySelector('#importIsReference').checked;

              try {
                const response = await fetch('/api/ontologies/import-url', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + token
                  },
                  body: JSON.stringify({
                    url: url,
                    project_id: (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default',
                    name: name,
                    label: label,
                    is_reference: isReference
                  })
                });

                if (!response.ok) {
                  const error = await response.text();
                  throw new Error(error);
                }

                const result = await response.json();
                toast(`Successfully imported ontology: ${result.label}`);
                close();
                await renderTree(project);

                // Select the imported ontology
                if (result.graph_iri) {
                  const newRoot = qs('#treeRoot');
                  const li = Array.from(newRoot.querySelectorAll('li[role="treeitem"]')).find(el => el.dataset && el.dataset.iri === result.graph_iri);
                  if (li) {
                    const lbl = li.querySelector('.node-label');
                    if (lbl) lbl.textContent = result.label || label;
                    li.dataset.label = result.label || label;
                    selectNode(li);
                    await handleTreeSelection(li);
                  }
                }

              } catch (error) {
                console.error('URL import error:', error);

                // Check if it's a duplicate ontology error
                if (error.message && (
                  error.message.includes('duplicate key value violates unique constraint') ||
                  error.message.includes('ontologies_registry_graph_iri_key') ||
                  error.message.includes('already exists')
                )) {
                  toast('This ontology has already been imported. Each ontology can only be imported once per project.', true);
                } else {
                  toast(`Failed to import ontology: ${error.message}`, true);
                }
              }
            };

            // Focus the input
            setTimeout(() => {
              panel.querySelector('#ontoLabel').focus();
            }, 100);
          };
          headerRow.appendChild(addBtn);
        }
      } catch (_) { }

      // Handle Delete key for ontology deletion
      root.addEventListener('keydown', async (e) => {
        if (e.key === 'Delete' || e.keyCode === 46) {
          const sel = root.querySelector('.node-row.selected');
          if (!sel) return;
          const li = sel.closest('li[role="treeitem"]');
          if (!li || li.dataset.nodeType !== 'ontology') return;
          const iri = li.dataset.iri;
          if (!iri) return;
          try {
            const url = `/api/ontologies?graph=${encodeURIComponent(iri)}`;
            const token = localStorage.getItem(tokenKey);
            const res = await fetch(url, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token } });
            if (res.ok) {
              await renderTree(project);
              if (activeOntologyIri === iri) { activeOntologyIri = null; updateOntoGraphLabel(); ensureOntologyInitialized(); ontoState.cy?.elements().remove(); refreshOntologyTree(); }
            }
          } catch (_) { }
        }
      });
    }

    async function refreshGraphSummary() {
      const el = qs('#graphSummary'); if (!el) return;
      el.textContent = 'Loading summary...';
      try {
        const res = await fetch('/api/ontology/summary');
        const json = await res.json();
        if (json.rows) {
          el.innerHTML = json.rows.map(r => `<div class="row"><span class="muted">${r.type}</span> — ${r.count}</div>`).join('') || '<div class="muted">No data</div>';
        } else {
          el.textContent = json.error || 'No data';
        }
      } catch (e) { el.textContent = 'Error loading summary'; }
    }
    (function () {
      const btnS = () => qs('#btnRefreshSummary');
      const btnQ = () => qs('#btnRunSparql');
      document.addEventListener('click', async (e) => {
        if (e.target === btnS()) {
          refreshGraphSummary();
        } else if (e.target === btnQ()) {
          const q = (qs('#sparqlInput')?.value) || '';
          const st = qs('#sparqlStatus'); const out = qs('#sparqlResult');
          st.textContent = 'Running...'; out.textContent = '';
          try {
            const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
            const json = await res.json();
            if (res.ok) { out.textContent = JSON.stringify(json, null, 2); st.textContent = 'OK'; }
            else { out.textContent = JSON.stringify(json, null, 2); st.textContent = 'Error'; }
          } catch (err) { out.textContent = String(err); st.textContent = 'Error'; }
        }
      });
    })();

    async function refreshOntologyTree() {
      const root = qs('#ontoTreeRoot');
      if (!root || !ontoState.cy) return;

      // Filter nodes based on visibility settings
      const classes = ontoState.cy.nodes().filter(n => {
        const nodeType = n.data('type') || 'class';
        const isImported = n.hasClass('imported');

        // Always show classes in tree regardless of visibility state - visibility only affects canvas
        return !isImported && nodeType === 'class';
      });

      const dataProperties = ontoState.cy.nodes().filter(n => {
        const nodeType = n.data('type') || 'class';
        const isImported = n.hasClass('imported');

        // Always show data properties in tree regardless of visibility state
        return !isImported && nodeType === 'dataProperty';
      });

      const importedClasses = ontoState.cy.nodes().filter(n => {
        const nodeType = n.data('type') || 'class';
        const isImported = n.hasClass('imported');

        // Always show imported classes in tree regardless of visibility state
        return isImported && nodeType === 'class';
      });

      const notes = ontoState.cy.nodes().filter(n => {
        const nodeType = n.data('type') || '';
        const isImported = n.hasClass('imported');

        // Always show notes in tree regardless of visibility state - don't check isVisible
        return !isImported && nodeType === 'note';
      });
      // Simple grouping: Classes as top-level; edges shown under a "Relationships" group per class
      root.innerHTML = '';
      const makeItem = (label, expanded = true, children = []) => {
        const li = document.createElement('li');
        li.setAttribute('role', 'treeitem');
        if (children.length) li.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        const row = document.createElement('div'); row.className = 'onto-node-row';
        row.tabIndex = 0;
        const twist = document.createElement('span'); twist.className = 'onto-twist'; if (children.length) twist.onclick = (e) => { e.stopPropagation(); li.setAttribute('aria-expanded', li.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'); };
        const text = document.createElement('span'); text.className = 'onto-node-label'; text.textContent = label;
        row.appendChild(twist); row.appendChild(text); li.appendChild(row);

        // Add click handler for tree item selection
        row.onclick = async (e) => {
          // Don't trigger if clicking on a button (like visibility toggle)
          if (e.target.tagName === 'BUTTON') return;
          console.log('🔍 Tree item clicked:', li.dataset.nodeType, li.dataset.nodeId);
          selectNode(li);
          await handleTreeSelection(li);
        };
        row.onkeydown = (e) => {
          const ENTER = 13, SPACE = 32;
          if (e.keyCode === ENTER || e.keyCode === SPACE) {
            selectNode(li);
            handleTreeSelection(li).catch(console.error);
            e.preventDefault();
          }
        };

        if (children.length) {
          const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
          children.forEach(c => ul.appendChild(c));
          li.appendChild(ul);
        }
        return li;
      };
      const items = [];
      classes.forEach(cls => {
        const label = cls.data('label') || cls.id();
        const outEdges = cls.outgoers('edge').filter(e => {
          // Always show edges in tree regardless of visibility state
          return true;
        });
        const rels = outEdges.map(e => {
          const other = e.target();
          const pred = e.data('predicate') || 'relatedTo';
          const type = e.data('type') || 'objectProperty';
          const item = makeItem(`${pred} → ${(other.data('label') || other.id())} (${type})`, false, []);
          // Set edge data attributes for tree selection
          item.dataset.edgeId = e.id();
          item.dataset.nodeType = 'edge';
          return item;
        });
        const classItem = makeItem(label, false, rels);
        // Set node data attributes for tree selection
        classItem.dataset.nodeId = cls.id();
        classItem.dataset.nodeType = 'class';

        // Add visibility toggle for individual classes
        const row = classItem.querySelector('.onto-node-row');
        if (row) {
          const visibilityBtn = document.createElement('button');
          visibilityBtn.className = 'class-visibility-toggle';
          visibilityBtn.title = 'Toggle visibility';
          visibilityBtn.innerHTML = '👁';
          visibilityBtn.style.cssText = `
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            padding: 2px 4px;
            margin-left: 4px;
            border-radius: 3px;
            font-size: 12px;
          `;

          // Set initial visibility state based on saved element visibility or global state
          const nodeId = cls.id();
          let isVisible = cls.visible();
          if (ontoState.elementVisibility.hasOwnProperty(nodeId)) {
            isVisible = ontoState.elementVisibility[nodeId];
          }
          visibilityBtn.style.opacity = isVisible ? '1' : '0.3';

          visibilityBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const node = ontoState.cy.$(`#${cls.id()}`);
            if (node.length > 0) {
              if (node.visible()) {
                node.hide();
                visibilityBtn.style.opacity = '0.3';
                // Save individual element visibility
                if (activeOntologyIri) {
                  ontoState.elementVisibility[cls.id()] = false;
                  saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                }
              } else {
                node.show();
                visibilityBtn.style.opacity = '1';
                // Save individual element visibility
                if (activeOntologyIri) {
                  ontoState.elementVisibility[cls.id()] = true;
                  saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                }
              }
              // Update properties panel if this node was selected
              updatePropertiesPanelFromSelection();
            }
          });

          row.appendChild(visibilityBtn);
        }

        items.push(classItem);
      });

      // Add data properties
      if (dataProperties.length) {
        const dataPropertyChildren = dataProperties.map(dp => {
          const item = makeItem(dp.data('label') || dp.id(), false, []);
          item.dataset.nodeId = dp.id();
          item.dataset.nodeType = 'dataProperty';

          // Add visibility toggle for data properties
          const row = item.querySelector('.onto-node-row');
          if (row) {
            const visibilityBtn = document.createElement('button');
            visibilityBtn.className = 'class-visibility-toggle';
            visibilityBtn.title = 'Toggle visibility';
            visibilityBtn.innerHTML = '👁';
            visibilityBtn.style.cssText = `
              background: none;
              border: none;
              color: var(--muted);
              cursor: pointer;
              padding: 2px 4px;
              margin-left: 4px;
              border-radius: 3px;
              font-size: 12px;
            `;

            // Set initial visibility state based on saved element visibility or global state
            const nodeId = dp.id();
            let isVisible = dp.visible();
            if (ontoState.elementVisibility.hasOwnProperty(nodeId)) {
              isVisible = ontoState.elementVisibility[nodeId];
            }
            visibilityBtn.style.opacity = isVisible ? '1' : '0.3';

            visibilityBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const node = ontoState.cy.$(`#${dp.id()}`);
              if (node.length > 0) {
                if (node.visible()) {
                  node.hide();
                  visibilityBtn.style.opacity = '0.3';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[dp.id()] = false;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                } else {
                  node.show();
                  visibilityBtn.style.opacity = '1';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[dp.id()] = true;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                }
                // Update properties panel if this node was selected
                updatePropertiesPanelFromSelection();
              }
            });

            row.appendChild(visibilityBtn);
          }

          return item;
        });
        items.push(makeItem('Data Properties', true, dataPropertyChildren));
      }

      if (importedClasses.length) {
        const importedChildren = importedClasses.map(cls => {
          const item = makeItem((cls.data('label') || cls.id()) + ' (imported)', false, []);
          item.dataset.nodeId = cls.id();
          item.dataset.nodeType = 'class';

          // Add visibility toggle for imported classes
          const row = item.querySelector('.onto-node-row');
          if (row) {
            const visibilityBtn = document.createElement('button');
            visibilityBtn.className = 'class-visibility-toggle';
            visibilityBtn.title = 'Toggle visibility';
            visibilityBtn.innerHTML = '👁';
            visibilityBtn.style.cssText = `
              background: none;
              border: none;
              color: var(--muted);
              cursor: pointer;
              padding: 2px 4px;
              margin-left: 4px;
              border-radius: 3px;
              font-size: 12px;
            `;

            // Set initial visibility state based on saved element visibility or global state
            const nodeId = cls.id();
            let isVisible = cls.visible();
            if (ontoState.elementVisibility.hasOwnProperty(nodeId)) {
              isVisible = ontoState.elementVisibility[nodeId];
            }
            visibilityBtn.style.opacity = isVisible ? '1' : '0.3';

            visibilityBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const node = ontoState.cy.$(`#${CSS.escape(cls.id())}`);
              if (node.length > 0) {
                if (node.visible()) {
                  node.hide();
                  visibilityBtn.style.opacity = '0.3';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[cls.id()] = false;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                } else {
                  node.show();
                  visibilityBtn.style.opacity = '1';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[cls.id()] = true;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                }
                // Update properties panel if this node was selected
                updatePropertiesPanelFromSelection();
              }
            });

            row.appendChild(visibilityBtn);
          }

          return item;
        });
        items.push(makeItem('Imported Classes', true, importedChildren));
      }
      if (notes.length) {
        const noteChildren = notes.map(n => {
          const item = makeItem(n.data('label') || n.id(), false, []);
          item.dataset.nodeId = n.id();
          item.dataset.nodeType = 'note';

          // Add visibility toggle for notes
          const row = item.querySelector('.onto-node-row');
          if (row) {
            const visibilityBtn = document.createElement('button');
            visibilityBtn.className = 'class-visibility-toggle';
            visibilityBtn.title = 'Toggle visibility';
            visibilityBtn.innerHTML = '👁';
            visibilityBtn.style.cssText = `
              background: none;
              border: none;
              color: var(--muted);
              cursor: pointer;
              padding: 2px 4px;
              margin-left: 4px;
              border-radius: 3px;
              font-size: 12px;
            `;

            // Set initial visibility state based on saved element visibility or global state
            const nodeId = n.id();
            let isVisible = n.visible();
            if (ontoState.elementVisibility.hasOwnProperty(nodeId)) {
              isVisible = ontoState.elementVisibility[nodeId];
            }
            visibilityBtn.style.opacity = isVisible ? '1' : '0.3';

            visibilityBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const node = ontoState.cy.$(`#${n.id()}`);
              if (node.length > 0) {
                if (node.visible()) {
                  node.hide();
                  visibilityBtn.style.opacity = '0.3';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[n.id()] = false;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                } else {
                  node.show();
                  visibilityBtn.style.opacity = '1';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[n.id()] = true;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                }
                // Update properties panel if this node was selected
                updatePropertiesPanelFromSelection();
              }
            });

            row.appendChild(visibilityBtn);
          }

          return item;
        });
        items.push(makeItem('Notes', true, noteChildren));
      }

      // Add Named Views section
      const namedViews = await loadNamedViews(activeOntologyIri);
      if (namedViews.length > 0 || true) { // Always show section even if empty
        const viewChildren = namedViews.map(view => {
          const isActive = ontoState.activeNamedView === view.id;
          const displayName = isActive ? `● ${view.name}` : view.name;
          const item = makeItem(displayName, false, []);
          item.dataset.viewId = view.id;
          item.dataset.nodeType = 'namedView';

          // Style active view differently
          if (isActive) {
            const label = item.querySelector('.onto-node-label');
            if (label) {
              label.style.color = '#60a5fa';
              label.style.fontWeight = 'bold';
            }
          }

          // Add view management buttons with SVG icons
          const row = item.querySelector('.onto-node-row');
          if (row) {
            // Add rename button with edit SVG icon
            const renameBtn = document.createElement('button');
            renameBtn.className = 'class-visibility-toggle';
            renameBtn.title = 'Rename view';
            renameBtn.innerHTML = `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px;">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            `;
            renameBtn.style.cssText = `
              background: none;
              border: none;
              color: var(--muted);
              cursor: pointer;
              padding: 2px 4px;
              margin-left: 4px;
              border-radius: 3px;
            `;

            renameBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              renameNamedView(view.id);
            });

            // Add delete button with trash SVG icon
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'class-visibility-toggle';
            deleteBtn.title = 'Delete view';
            deleteBtn.innerHTML = `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px;">
                <polyline points="3,6 5,6 21,6"/>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                <line x1="10" y1="11" x2="10" y2="17"/>
                <line x1="14" y1="11" x2="14" y2="17"/>
              </svg>
            `;
            deleteBtn.style.cssText = `
              background: none;
              border: none;
              color: var(--danger);
              cursor: pointer;
              padding: 2px 4px;
              margin-left: 4px;
              border-radius: 3px;
            `;

            deleteBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              deleteNamedView(view.id);
            });

            row.appendChild(renameBtn);
            row.appendChild(deleteBtn);
          }

          return item;
        });

        // Add the Named Views section with buttons
        const viewsSection = makeItem('Named Views', true, viewChildren);
        const viewsRow = viewsSection.querySelector('.onto-node-row');
        if (viewsRow) {
          // Add Return button (only visible when a view is active)
          if (ontoState.activeNamedView) {
            const returnBtn = document.createElement('button');
            returnBtn.className = 'btn tree-add-btn';
            returnBtn.title = 'Return to Original View';
            returnBtn.innerHTML = `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px;">
                <polyline points="9,14 4,9 9,4"/>
                <path d="M20,20v-7a4,4 0 0,0-4-4H4"/>
              </svg>
            `;
            returnBtn.style.marginLeft = '8px';
            returnBtn.style.fontSize = '12px';
            returnBtn.style.padding = '2px 6px';
            returnBtn.style.minWidth = '20px';
            returnBtn.style.height = '20px';
            returnBtn.style.color = '#60a5fa';
            returnBtn.onclick = (e) => {
              e.stopPropagation();
              restoreOriginalState();
            };

            viewsRow.appendChild(returnBtn);
          }

          // Add + button for creating new views
          const addViewBtn = document.createElement('button');
          addViewBtn.className = 'btn tree-add-btn';
          addViewBtn.title = 'Save Current View';
          addViewBtn.textContent = '+';
          addViewBtn.style.marginLeft = '8px';
          addViewBtn.style.fontSize = '12px';
          addViewBtn.style.padding = '2px 6px';
          addViewBtn.style.minWidth = '20px';
          addViewBtn.style.height = '20px';
          addViewBtn.onclick = (e) => {
            e.stopPropagation();
            createNamedView();
          };

          viewsRow.appendChild(addViewBtn);
        }

        items.push(viewsSection);
      }

      const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
      items.forEach(i => ul.appendChild(i));
      // Root level
      const rootItem = document.createElement('li'); rootItem.setAttribute('role', 'treeitem'); rootItem.setAttribute('aria-expanded', 'true');
      const row = document.createElement('div'); row.className = 'onto-node-row';
      const twist = document.createElement('span'); twist.className = 'onto-twist'; twist.onclick = (e) => { e.stopPropagation(); rootItem.setAttribute('aria-expanded', rootItem.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'); };
      const text = document.createElement('span'); text.className = 'onto-node-label';
      (function () {
        try {
          const labels = loadOntologyLabelMap(activeProject);
          let modelName = 'Ontology';
          const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
          const scopedName = localStorage.getItem(`onto_model_name__${pid}`) || '';
          if (scopedName.trim()) modelName = scopedName.trim();
          else if (activeOntologyIri) {
            modelName = (labels[activeOntologyIri] && String(labels[activeOntologyIri]).trim()) || (activeOntologyIri.split('/').pop() || 'Ontology');
          }
          text.textContent = modelName;
        } catch (_) { text.textContent = 'Ontology'; }
      })();
      // Add visibility toggle button to the ontology root node
      const visibilityBtn = document.createElement('button');
      visibilityBtn.className = 'iconbtn';
      visibilityBtn.id = 'ontoVisibilityToggle';
      visibilityBtn.title = 'Toggle Visibility';
      visibilityBtn.style.marginLeft = 'auto';
      visibilityBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
          <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
          <circle cx="12" cy="12" r="3" />
        </svg>
      `;

      // Add click event listener for visibility toggle
      visibilityBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        showVisibilityMenu();
      });

      row.appendChild(twist); row.appendChild(text); row.appendChild(visibilityBtn); rootItem.appendChild(row); rootItem.appendChild(ul);
      // (Do not delete projects here; project deletion is handled in the main tree top node in renderTree)
      root.innerHTML = '';
      root.appendChild(rootItem);

      // Imports node specific to current ontology
      try {
        const importsKey = 'onto_imports__' + encodeURIComponent(activeOntologyIri || '');
        const imports = JSON.parse(localStorage.getItem(importsKey) || '[]');
        const importsRoot = document.createElement('li'); importsRoot.setAttribute('role', 'treeitem'); importsRoot.setAttribute('aria-expanded', 'true');
        const row = document.createElement('div'); row.className = 'onto-node-row';
        const tw = document.createElement('span'); tw.className = 'onto-twist';
        const lbl = document.createElement('span'); lbl.className = 'onto-node-label'; lbl.textContent = 'Imports';

        // Add + button for adding reference ontologies
        const addBtn = document.createElement('button');
        addBtn.className = 'btn tree-add-btn';
        addBtn.title = 'Add Reference Ontology';
        addBtn.textContent = '+';
        addBtn.style.marginLeft = '8px';
        addBtn.style.fontSize = '12px';
        addBtn.style.padding = '2px 6px';
        addBtn.style.minWidth = '20px';
        addBtn.style.height = '20px';
        addBtn.onclick = async (e) => {
          e.stopPropagation();
          console.log('➕ Add Reference Ontology button clicked');
          await showReferenceOntologySelector();
        };

        // Add collapse/expand all button (hidden for now)
        const collapseBtn = document.createElement('button');
        collapseBtn.className = 'btn tree-add-btn';
        collapseBtn.title = 'Collapse/Expand All Imports';
        collapseBtn.textContent = '⊞';
        collapseBtn.style.marginLeft = '4px';
        collapseBtn.style.fontSize = '12px';
        collapseBtn.style.padding = '2px 6px';
        collapseBtn.style.minWidth = '20px';
        collapseBtn.style.height = '20px';
        collapseBtn.style.display = 'none'; // Hidden for now
        collapseBtn.onclick = (e) => {
          e.stopPropagation();
          toggleAllImportsCollapse();
        };

        row.appendChild(tw);
        row.appendChild(lbl);
        row.appendChild(addBtn);
        row.appendChild(collapseBtn);
        importsRoot.appendChild(row);

        const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
        function removeImport(iri) {
          try {
            console.log('🔍 Removing import:', iri);
            const key = 'onto_imports__' + encodeURIComponent(activeOntologyIri || '');
            const curr = new Set(JSON.parse(localStorage.getItem(key) || '[]'));
            if (curr.has(iri)) {
              curr.delete(iri);
              localStorage.setItem(key, JSON.stringify(Array.from(curr)));
              console.log('🔍 Import removed, refreshing tree');
              refreshOntologyTree();
            }
          } catch (err) {
            console.error('🔍 Error removing import:', err);
          }
        }
        async function friendlyImportName(iri) {
          try {
            const q = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?label WHERE { GRAPH <${iri}> { <${iri}> a owl:Ontology . OPTIONAL { <${iri}> rdfs:label ?label } } }`;
            const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
            if (!res.ok) throw new Error('sparql');
            const json = await res.json();
            const b = json.results && json.results.bindings && json.results.bindings[0];
            const lbl = b && b.label && b.label.value;
            return (lbl && lbl.trim()) || (iri.split('/').pop() || iri);
          } catch (_) { return iri.split('/').pop() || iri; }
        }
        async function importEquivCount(importIri) {
          try {
            if (!ontoState.cy) {
              console.log('🔍 No cytoscape instance for equivalence counting');
              return 0;
            }
            const norm = s => String(s || '').trim().toLowerCase();

            // Get base classes from current Cytoscape graph (local storage)
            const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type') || 'class') === 'class' && !n.hasClass('imported'));
            console.log('🔍 Base classes found:', baseClasses.length);
            const baseByLabel = new Map();
            baseClasses.forEach(n => {
              const label = n.data('label') || n.id();
              const normalized = norm(label);
              baseByLabel.set(normalized, n);
              console.log('🔍 Base class details - ID:', n.id(), 'Label:', label, 'Normalized:', normalized);
            });
            console.log('🔍 Base classes by label:', Array.from(baseByLabel.keys()));

            // Get imported classes from local storage for the imported ontology
            const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
            const importKey = `onto_graph__${pid}__` + encodeURIComponent(importIri);
            let importData = localStorage.getItem(importKey);

            // TEMPORARY: Clear cached data with generic labels to force fresh reload
            if (importData) {
              const cachedData = JSON.parse(importData);
              const hasGenericLabels = cachedData.nodes && cachedData.nodes.some(node =>
                node.data && node.data.label && node.data.label.match(/^Class \d+$/)
              );
              if (hasGenericLabels) {
                console.log('🔍 Clearing cached data with generic labels to force fresh reload');
                localStorage.removeItem(importKey);
                importData = null;
              }
            }

            if (!importData) {
              console.log('🔍 No local storage data found for import, attempting to load from API:', importIri);
              try {
                // Try to load the imported ontology data from API
                const token = localStorage.getItem(tokenKey);
                const apiUrl = `/api/ontology/?graph=${encodeURIComponent(importIri)}`;
                const response = await fetch(apiUrl, {
                  headers: token ? { 'Authorization': `Bearer ${token}` } : {}
                });

                if (response.ok) {
                  const ontologyData = await response.json();
                  console.log('🔍 Loaded imported ontology from API:', ontologyData);
                  console.log('🔍 API response structure - classes:', ontologyData.classes);
                  console.log('🔍 API response structure - object_properties:', ontologyData.object_properties);
                  console.log('🔍 API response data property:', ontologyData.data);
                  if (ontologyData.data) {
                    console.log('🔍 Data.classes:', ontologyData.data.classes);
                    console.log('🔍 Data.object_properties:', ontologyData.data.object_properties);
                    console.log('🔍 Full data structure:', JSON.stringify(ontologyData.data, null, 2));
                  }

                  // Convert to Cytoscape format and save to local storage
                  // Use a simpler conversion since we don't have rich metadata
                  // The API response has the data nested in a 'data' property
                  const actualOntologyData = ontologyData.data || ontologyData;
                  console.log('🔍 Actual ontology data being passed to convertOntologyToCytoscape:', actualOntologyData);
                  console.log('🔍 actualOntologyData.classes:', actualOntologyData.classes);
                  const cytoscapeData = convertOntologyToCytoscape(actualOntologyData);
                  console.log('🔍 Converted cytoscape data:', cytoscapeData);
                  const storageData = {
                    nodes: cytoscapeData.nodes || [],
                    edges: cytoscapeData.edges || [],
                    timestamp: Date.now(),
                    source: 'api'
                  };

                  localStorage.setItem(importKey, JSON.stringify(storageData));
                  importData = JSON.stringify(storageData);
                  console.log('🔍 Saved imported ontology data to local storage');
                } else {
                  console.log('🔍 Failed to load imported ontology from API:', response.status);
                  return 0;
                }
              } catch (err) {
                console.error('🔍 Error loading imported ontology:', err);
                return 0;
              }
            } else {
              // Check if cached data is empty and force reload
              const cachedData = JSON.parse(importData);
              if (cachedData.nodes && cachedData.nodes.length === 0 && cachedData.edges && cachedData.edges.length === 0) {
                console.log('🔍 Cached data is empty, forcing reload from API:', importIri);
                try {
                  const token = localStorage.getItem(tokenKey);
                  const apiUrl = `/api/ontology/?graph=${encodeURIComponent(importIri)}`;
                  const response = await fetch(apiUrl, {
                    headers: token ? { 'Authorization': `Bearer ${token}` } : {}
                  });

                  if (response.ok) {
                    const ontologyData = await response.json();
                    console.log('🔍 Reloaded imported ontology from API:', ontologyData);
                    console.log('🔍 Reload API response structure - classes:', ontologyData.classes);
                    console.log('🔍 Reload API response structure - object_properties:', ontologyData.object_properties);

                    // Convert to Cytoscape format and save to local storage
                    // The API response has the data nested in a 'data' property
                    const actualOntologyData = ontologyData.data || ontologyData;
                    console.log('🔍 Reload actual ontology data being passed to convertOntologyToCytoscape:', actualOntologyData);
                    console.log('🔍 Reload actualOntologyData.classes:', actualOntologyData.classes);
                    const cytoscapeData = convertOntologyToCytoscape(actualOntologyData);
                    console.log('🔍 Reload converted cytoscape data:', cytoscapeData);
                    const storageData = {
                      nodes: cytoscapeData.nodes || [],
                      edges: cytoscapeData.edges || [],
                      timestamp: Date.now(),
                      source: 'api'
                    };

                    localStorage.setItem(importKey, JSON.stringify(storageData));
                    importData = JSON.stringify(storageData);
                    console.log('🔍 Reloaded and saved imported ontology data to local storage');
                  } else {
                    console.log('🔍 Failed to reload imported ontology from API:', response.status);
                  }
                } catch (err) {
                  console.error('🔍 Error reloading imported ontology:', err);
                }
              }
            }

            const importOntology = JSON.parse(importData);
            const importNodes = importOntology.nodes || [];
            const importClasses = importNodes.filter(node => (node.data && node.data.type === 'class') || !node.data?.type);
            console.log('🔍 Import classes found in local storage:', importClasses.length);

            const matched = new Set();
            importClasses.forEach(node => {
              const label = node.data?.label || node.data?.id || node.id;
              const key = norm(label);
              console.log('🔍 Checking match:', key, 'in base classes:', baseByLabel.has(key));
              console.log('🔍 Import class details - ID:', node.data?.id || node.id, 'Label:', label, 'Key:', key);
              if (baseByLabel.has(key)) {
                matched.add(node.data?.id || node.id);
                console.log('🔍 ✅ MATCH FOUND for:', key);
              } else {
                console.log('🔍 ❌ No match for:', key, 'Available base classes:', Array.from(baseByLabel.keys()));
              }
            });
            console.log('🔍 Matched classes:', matched.size);
            return matched.size;
          } catch (err) {
            console.error('🔍 Error in importEquivCount:', err);
            return 0;
          }
        }
        const visibleSet = loadVisibleImports(activeOntologyIri);
        imports.forEach(async g => {
          const li = document.createElement('li'); li.setAttribute('role', 'treeitem'); li.dataset.importIri = g;
          const r = document.createElement('div'); r.className = 'onto-node-row'; r.tabIndex = 0;
          const cb = document.createElement('input'); cb.type = 'checkbox'; cb.style.marginRight = '6px'; cb.checked = visibleSet.has(g);
          const t = document.createElement('span'); t.className = 'onto-twist';
          const l = document.createElement('span'); l.className = 'onto-node-label';
          const name = await friendlyImportName(g);
          const cnt = await importEquivCount(g);
          l.textContent = `${name}${cnt ? ` (${cnt})` : ''}`;
          cb.addEventListener('change', async () => {
            try {
              console.log('🔍 Checkbox changed for import:', g, 'checked:', cb.checked);
              const vis = loadVisibleImports(activeOntologyIri);
              if (cb.checked) vis.add(g); else vis.delete(g);
              saveVisibleImports(activeOntologyIri, vis);
              console.log('🔍 Visible imports updated:', Array.from(vis));
              await overlayImportsRefresh();
            } catch (err) {
              console.error('🔍 Error handling import checkbox change:', err);
              // Revert the checkbox state if there was an error
              cb.checked = !cb.checked;
            }
          });
          // Add collapse/expand button (hidden for now)
          const collapseBtn = document.createElement('button');
          collapseBtn.className = 'btn tree-add-btn';
          collapseBtn.title = 'Collapse/Expand Import';
          collapseBtn.textContent = ontoState.collapsedImports.has(g) ? '⊞' : '⊟';
          collapseBtn.style.marginLeft = '8px';
          collapseBtn.style.fontSize = '12px';
          collapseBtn.style.padding = '2px 6px';
          collapseBtn.style.minWidth = '20px';
          collapseBtn.style.height = '20px';
          collapseBtn.style.display = 'none'; // Hidden for now
          collapseBtn.onclick = (e) => {
            e.stopPropagation();
            toggleImportCollapse(g);
            // Update button text
            collapseBtn.textContent = ontoState.collapsedImports.has(g) ? '⊞' : '⊟';
          };

          r.onclick = (e) => { Array.from(ul.querySelectorAll('.onto-node-row')).forEach(n => n.classList.remove('selected')); r.classList.add('selected'); };
          r.onkeydown = (e) => { const key = e.key || e.code; if (key === 'Delete' || key === 'Backspace') { e.preventDefault(); removeImport(g); } };
          r.appendChild(cb); r.appendChild(t); r.appendChild(l); r.appendChild(collapseBtn);
          li.appendChild(r); ul.appendChild(li);
        });
        importsRoot.appendChild(ul);
        root.appendChild(importsRoot);
        // Enable drop to import
        row.addEventListener('dragover', (e) => { e.preventDefault(); });
        row.addEventListener('drop', async (e) => {
          e.preventDefault();
          const draggedIri = e.dataTransfer.getData('text/graph-iri');
          if (!draggedIri) return;
          const list = new Set(imports);
          if (!list.has(draggedIri)) { list.add(draggedIri); localStorage.setItem(importsKey, JSON.stringify(Array.from(list))); refreshOntologyTree(); }
          // Overlay imported classes (placeholder: we only list; loading remote triples is OW-2)
        });
      } catch (_) { }
    }

    // (empty-state banner removed)

    // Attribute templates for different object types
    const attributeTemplates = {
      class: {
        // Standard ontological properties
        comment: { type: 'textarea', label: 'Comment (rdfs:comment)', placeholder: 'Description of the class' },
        definition: { type: 'textarea', label: 'Definition (skos:definition)', placeholder: 'Formal definition of the class' },
        example: { type: 'textarea', label: 'Example (skos:example)', placeholder: 'Usage example' },
        identifier: { type: 'text', label: 'Identifier (dc:identifier)', placeholder: 'Unique identifier' },
        subclassOf: { type: 'text', label: 'Subclass of (rdfs:subClassOf)', placeholder: 'Parent class IRI' },
        equivalentClass: { type: 'text', label: 'Equivalent Class (owl:equivalentClass)', placeholder: 'Equivalent class IRI' },
        disjointWith: { type: 'text', label: 'Disjoint With (owl:disjointWith)', placeholder: 'Disjoint class IRI' },
        // Metadata properties
        creator: { type: 'text', label: 'Creator (dc:creator)', placeholder: 'Created by', readonly: true },
        created_date: { type: 'date', label: 'Created Date (dc:created)', placeholder: 'Creation date', readonly: true },
        created_timestamp: { type: 'text', label: 'Created Timestamp', placeholder: 'ISO timestamp', readonly: true },
        last_modified_by: { type: 'text', label: 'Last Modified By (dc:contributor)', placeholder: 'Modified by', readonly: true },
        last_modified_date: { type: 'date', label: 'Last Modified Date (dcterms:modified)', placeholder: 'Modification date', readonly: true },
        last_modified_timestamp: { type: 'text', label: 'Last Modified Timestamp', placeholder: 'ISO timestamp', readonly: true },
        // Custom properties
        priority: { type: 'select', label: 'Priority (odras:priority)', options: ['High', 'Medium', 'Low'], placeholder: 'Select priority' },
        status: { type: 'select', label: 'Status (odras:status)', options: ['Draft', 'Review', 'Approved', 'Deprecated'], placeholder: 'Select status' }
      },
      objectProperty: {
        // Standard ontological properties
        comment: { type: 'textarea', label: 'Comment (rdfs:comment)', placeholder: 'Description of the property' },
        definition: { type: 'textarea', label: 'Definition (skos:definition)', placeholder: 'Formal definition of the property' },
        example: { type: 'textarea', label: 'Example (skos:example)', placeholder: 'Usage example' },
        identifier: { type: 'text', label: 'Identifier (dc:identifier)', placeholder: 'Unique identifier' },
        domain: { type: 'text', label: 'Domain (rdfs:domain)', placeholder: 'Source class IRI' },
        range: { type: 'text', label: 'Range (rdfs:range)', placeholder: 'Target class IRI' },
        inverseOf: { type: 'text', label: 'Inverse Of (owl:inverseOf)', placeholder: 'Inverse property IRI' },
        subPropertyOf: { type: 'text', label: 'Sub Property Of (rdfs:subPropertyOf)', placeholder: 'Parent property IRI' },
        equivalentProperty: { type: 'text', label: 'Equivalent Property (owl:equivalentProperty)', placeholder: 'Equivalent property IRI' },
        propertyType: { type: 'text', label: 'Property Type (rdf:type)', placeholder: 'Property characteristics (e.g., TransitiveProperty)' },
        // Metadata properties
        creator: { type: 'text', label: 'Creator (dc:creator)', placeholder: 'Created by', readonly: true },
        created_date: { type: 'date', label: 'Created Date (dc:created)', placeholder: 'Creation date', readonly: true },
        created_timestamp: { type: 'text', label: 'Created Timestamp', placeholder: 'ISO timestamp', readonly: true },
        last_modified_by: { type: 'text', label: 'Last Modified By (dc:contributor)', placeholder: 'Modified by', readonly: true },
        last_modified_date: { type: 'date', label: 'Last Modified Date (dcterms:modified)', placeholder: 'Modification date', readonly: true },
        last_modified_timestamp: { type: 'text', label: 'Last Modified Timestamp', placeholder: 'ISO timestamp', readonly: true },
        // Custom properties
        functional: { type: 'checkbox', label: 'Functional', placeholder: 'Is this a functional property?' },
        inverse_functional: { type: 'checkbox', label: 'Inverse Functional', placeholder: 'Is this inverse functional?' }
      },
      dataProperty: {
        // Standard ontological properties
        comment: { type: 'textarea', label: 'Comment (rdfs:comment)', placeholder: 'Description of the property' },
        definition: { type: 'textarea', label: 'Definition (skos:definition)', placeholder: 'Formal definition of the property' },
        example: { type: 'textarea', label: 'Example (skos:example)', placeholder: 'Usage example' },
        identifier: { type: 'text', label: 'Identifier (dc:identifier)', placeholder: 'Unique identifier' },
        domain: { type: 'text', label: 'Domain (rdfs:domain)', placeholder: 'Source class IRI' },
        range: { type: 'select', label: 'Range (rdfs:range)', options: ['xsd:string', 'xsd:integer', 'xsd:float', 'xsd:boolean', 'xsd:dateTime'], placeholder: 'Data type' },
        subPropertyOf: { type: 'text', label: 'Sub Property Of (rdfs:subPropertyOf)', placeholder: 'Parent property IRI' },
        equivalentProperty: { type: 'text', label: 'Equivalent Property (owl:equivalentProperty)', placeholder: 'Equivalent property IRI' },
        // Metadata properties
        creator: { type: 'text', label: 'Creator (dc:creator)', placeholder: 'Created by', readonly: true },
        created_date: { type: 'date', label: 'Created Date (dc:created)', placeholder: 'Creation date', readonly: true },
        created_timestamp: { type: 'text', label: 'Created Timestamp', placeholder: 'ISO timestamp', readonly: true },
        last_modified_by: { type: 'text', label: 'Last Modified By (dc:contributor)', placeholder: 'Modified by', readonly: true },
        last_modified_date: { type: 'date', label: 'Last Modified Date (dcterms:modified)', placeholder: 'Modification date', readonly: true },
        last_modified_timestamp: { type: 'text', label: 'Last Modified Timestamp', placeholder: 'ISO timestamp', readonly: true },
        // Custom properties
        functional: { type: 'checkbox', label: 'Functional', placeholder: 'Is this a functional property?' }
      },
      note: {
        noteType: { type: 'select', label: 'Note Type (dc:type)', options: ['Note', 'Warning', 'Issue', 'Todo', 'Info', 'Success', 'Question'], placeholder: 'Select note type' },
        content: { type: 'textarea', label: 'Content (rdfs:comment)', placeholder: 'Note content' },
        // Metadata properties
        creator: { type: 'text', label: 'Creator (dc:creator)', placeholder: 'Created by', readonly: true },
        created_date: { type: 'date', label: 'Created Date (dc:created)', placeholder: 'Creation date', readonly: true },
        created_timestamp: { type: 'text', label: 'Created Timestamp', placeholder: 'ISO timestamp', readonly: true },
        last_modified_by: { type: 'text', label: 'Last Modified By (dc:contributor)', placeholder: 'Modified by', readonly: true },
        last_modified_date: { type: 'date', label: 'Last Modified Date (dcterms:modified)', placeholder: 'Modification date', readonly: true },
        last_modified_timestamp: { type: 'text', label: 'Last Modified Timestamp', placeholder: 'ISO timestamp', readonly: true },
        // Legacy fields for backward compatibility
        author: { type: 'text', label: 'Author', placeholder: 'Note author', readonly: true }
      },
      model: {
        // Standard ontological properties
        comment: { type: 'textarea', label: 'Comment (rdfs:comment)', placeholder: 'Description of the ontology' },
        definition: { type: 'textarea', label: 'Definition (skos:definition)', placeholder: 'Formal definition of the ontology' },
        version: { type: 'text', label: 'Version (owl:versionInfo)', placeholder: 'Ontology version' },
        namespace: { type: 'text', label: 'Namespace', placeholder: 'Base namespace URI' },
        imports: { type: 'textarea', label: 'Imports (owl:imports)', placeholder: 'Enter ontology URIs (one per line):\nhttps://example.com/ontology1\nhttps://example.com/ontology2', rows: 4 }
      }
    };

    // Get current username synchronously for metadata
    function getCurrentUsername() {
      try {
        // First try the simple username storage (most reliable)
        const username = localStorage.getItem('odras_user');
        if (username && typeof username === 'string' && username.trim() !== '') {
          return username.trim();
        }

        // Try the full user object
        const userObj = localStorage.getItem('user');
        if (userObj) {
          const user = JSON.parse(userObj);
          if (user.username && typeof user.username === 'string') {
            return user.username;
          }
        }

        // Fallback to parsing the userMenu text
        const userMenu = document.querySelector('#userMenu');
        if (userMenu && userMenu.textContent) {
          const menuText = userMenu.textContent.trim();
          // Remove " (admin)" suffix if present
          const cleanUsername = menuText.replace(/\s*\(admin\)\s*$/, '').trim();
          if (cleanUsername && cleanUsername !== '') {
            return cleanUsername;
          }
        }

        return 'system';
      } catch (e) {
        console.error('Error getting current username:', e);
        return 'system';
      }
    }

    // Ontology metadata management functions
    function getCurrentTimestamp() {
      return new Date().toISOString();
    }

    function getCurrentDate() {
      return new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
    }

    function addCreationMetadata(attrs = {}) {
      const currentUser = getCurrentUsername();
      const timestamp = getCurrentTimestamp();

      return {
        ...attrs,
        creator: currentUser,
        created_date: getCurrentDate(),
        created_timestamp: timestamp,
        last_modified_by: currentUser,
        last_modified_date: getCurrentDate(),
        last_modified_timestamp: timestamp
      };
    }

    function updateModificationMetadata(attrs = {}) {
      const currentUser = getCurrentUsername();
      const timestamp = getCurrentTimestamp();

      return {
        ...attrs,
        last_modified_by: currentUser,
        last_modified_date: getCurrentDate(),
        last_modified_timestamp: timestamp
      };
    }

    // Named views persistence
    // Load named views from backend API instead of localStorage
    async function loadNamedViews(baseIri) {
      if (!baseIri) return [];

      try {
        const response = await authenticatedFetch(`/api/ontology/named-views?graph=${encodeURIComponent(baseIri)}`);
        if (response.ok) {
          const result = await response.json();
          return result.data || [];
        } else {
          console.warn('Failed to load named views from backend, falling back to empty array');
          return [];
        }
      } catch (error) {
        console.warn('Error loading named views from backend:', error);
        return [];
      }
    }

    // Save named views to backend API instead of localStorage  
    async function saveNamedViews(baseIri, views) {
      if (!baseIri) return;

      try {
        const response = await authenticatedFetch(`/api/ontology/named-views?graph=${encodeURIComponent(baseIri)}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(views || [])
        });

        if (response.ok) {
          const result = await response.json();
          console.log('✅ Named views saved to backend:', result.message);
        } else {
          console.error('Failed to save named views to backend:', response.status, response.statusText);
        }
      } catch (error) {
        console.error('Error saving named views to backend:', error);
      }
    }

    // Named view data structure functions
    function captureCurrentView(name) {
      if (!ontoState.cy || !activeOntologyIri) return null;

      const currentUser = getCurrentUsername();
      const timestamp = getCurrentTimestamp();

      // Capture individual node positions for complete layout snapshot
      const nodePositions = {};
      ontoState.cy.nodes().forEach(node => {
        nodePositions[node.id()] = {
          x: node.position().x,
          y: node.position().y
        };
      });

      return {
        id: `view_${Date.now()}`,
        name: name,
        creator: currentUser,
        created_date: getCurrentDate(),
        created_timestamp: timestamp,
        // Complete canvas state (layout snapshot)
        zoom: ontoState.cy.zoom(),
        pan: ontoState.cy.pan(),
        nodePositions: nodePositions, // Individual node positions for true snapshot
        // Visibility state
        visibilityState: { ...ontoState.visibilityState },
        elementVisibility: { ...ontoState.elementVisibility },
        collapsedImports: Array.from(ontoState.collapsedImports),
        // Import visibility state - which imports are visible (checked in tree)
        visibleImports: Array.from(loadVisibleImports(activeOntologyIri))
      };
    }

    function restoreView(view) {
      if (!ontoState.cy || !view) return;

      // Restore visibility states
      ontoState.visibilityState = { ...view.visibilityState };
      ontoState.elementVisibility = { ...view.elementVisibility };
      ontoState.collapsedImports = new Set(view.collapsedImports || []);

      // Restore import visibility - set which imports should be visible
      if (view.visibleImports && activeOntologyIri) {
        const visibleImportsSet = new Set(view.visibleImports);
        saveVisibleImports(activeOntologyIri, visibleImportsSet);
      }

      // Apply visibility to canvas
      updateCanvasVisibility();

      // Refresh imports overlay to apply import visibility changes
      overlayImportsRefresh().then(() => {
        // Restore individual node positions for complete layout snapshot
        if (view.nodePositions) {
          ontoState.cy.nodes().forEach(node => {
            const savedPosition = view.nodePositions[node.id()];
            if (savedPosition) {
              node.position({
                x: savedPosition.x,
                y: savedPosition.y
              });
            }
          });
          console.log('🔍 Restored node positions from named view');
        }

        // After positions are restored, restore canvas position and zoom
        ontoState.cy.animate({
          zoom: view.zoom || 1,
          pan: view.pan || { x: 0, y: 0 }
        }, {
          duration: 500
        });
      });

      // Refresh tree to reflect all visibility changes
      refreshOntologyTree();

      // Save current states to localStorage
      if (activeOntologyIri) {
        saveVisibilityState(activeOntologyIri, ontoState.visibilityState);
        saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
        saveCollapsedImports(activeOntologyIri, ontoState.collapsedImports);
      }

      // Mark this view as active and refresh tree to show indicator
      ontoState.activeNamedView = view.id;
      refreshOntologyTree();
    }

    function restoreOriginalState() {
      if (!ontoState.beforeViewState) return;

      // Restore the state from before any named view was applied
      const beforeState = ontoState.beforeViewState;

      // Restore visibility states
      ontoState.visibilityState = { ...beforeState.visibilityState };
      ontoState.elementVisibility = { ...beforeState.elementVisibility };
      ontoState.collapsedImports = new Set(beforeState.collapsedImports || []);

      // Restore import visibility
      if (beforeState.visibleImports && activeOntologyIri) {
        const visibleImportsSet = new Set(beforeState.visibleImports);
        saveVisibleImports(activeOntologyIri, visibleImportsSet);
      }

      // Apply visibility to canvas
      updateCanvasVisibility();

      // Refresh imports overlay
      overlayImportsRefresh().then(() => {
        // Restore individual node positions for original state
        if (beforeState.nodePositions) {
          ontoState.cy.nodes().forEach(node => {
            const savedPosition = beforeState.nodePositions[node.id()];
            if (savedPosition) {
              node.position({
                x: savedPosition.x,
                y: savedPosition.y
              });
            }
          });
          console.log('🔍 Restored original node positions');
        }

        // Restore canvas position and zoom
        ontoState.cy.animate({
          zoom: beforeState.zoom || 1,
          pan: beforeState.pan || { x: 0, y: 0 }
        }, {
          duration: 500
        });
      });

      // Refresh tree
      refreshOntologyTree();

      // Save restored states to localStorage
      if (activeOntologyIri) {
        saveVisibilityState(activeOntologyIri, ontoState.visibilityState);
        saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
        saveCollapsedImports(activeOntologyIri, ontoState.collapsedImports);
      }

      // Clear the active view state
      ontoState.activeNamedView = null;
      ontoState.beforeViewState = null;
    }

    // Named view management functions
    async function createNamedView() {
      if (!activeOntologyIri) return;

      const name = prompt('Enter a name for this view:');
      if (!name || name.trim() === '') return;

      const view = captureCurrentView(name.trim());
      if (!view) return;

      const views = await loadNamedViews(activeOntologyIri);
      views.push(view);
      await saveNamedViews(activeOntologyIri, views);

      refreshOntologyTree();
      console.log('🔍 Created named view:', name, 'with visible imports:', view.visibleImports);
    }

    async function renameNamedView(viewId) {
      if (!activeOntologyIri) return;

      const views = await loadNamedViews(activeOntologyIri);
      const view = views.find(v => v.id === viewId);
      if (!view) return;

      const newName = prompt('Enter new name for view:', view.name);
      if (!newName || newName.trim() === '' || newName.trim() === view.name) return;

      view.name = newName.trim();
      await saveNamedViews(activeOntologyIri, views);

      await refreshOntologyTree();
      console.log('🔍 Renamed view to:', newName);
    }

    async function deleteNamedView(viewId) {
      if (!activeOntologyIri) return;

      const views = await loadNamedViews(activeOntologyIri);
      const view = views.find(v => v.id === viewId);
      if (!view) return;

      if (!confirm(`Delete view "${view.name}"?`)) return;

      const updatedViews = views.filter(v => v.id !== viewId);
      await saveNamedViews(activeOntologyIri, updatedViews);

      await refreshOntologyTree();
      console.log('🔍 Deleted view:', view.name);
    }

    // Note type styling configuration
    function getNoteTypeStyle(noteType) {
      const styles = {
        'Note': {
          backgroundColor: '#2a1f0a',
          borderColor: '#8b5a1e',
          textColor: '#f5e6cc',
          symbol: '📝'
        },
        'Warning': {
          backgroundColor: '#2d1b0f',
          borderColor: '#d97706',
          textColor: '#fbbf24',
          symbol: '⚠️'
        },
        'Issue': {
          backgroundColor: '#2d0f0f',
          borderColor: '#dc2626',
          textColor: '#fca5a5',
          symbol: '❗'
        },
        'Todo': {
          backgroundColor: '#1e1b2d',
          borderColor: '#7c3aed',
          textColor: '#c4b5fd',
          symbol: '✅'
        },
        'Info': {
          backgroundColor: '#0f1a2d',
          borderColor: '#2563eb',
          textColor: '#93c5fd',
          symbol: 'ℹ️'
        },
        'Success': {
          backgroundColor: '#0f2d1a',
          borderColor: '#16a34a',
          textColor: '#86efac',
          symbol: '✨'
        },
        'Question': {
          backgroundColor: '#2d1a0f',
          borderColor: '#ea580c',
          textColor: '#fdba74',
          symbol: '❓'
        }
      };

      return styles[noteType] || styles['Note'];
    }

    function getTypeDisplayName(type) {
      const typeMap = {
        'class': 'Class',
        'objectProperty': 'Object Property',
        'dataProperty': 'Data Property',
        'note': 'Note',
        'model': 'Model'
      };
      return typeMap[type] || 'Class';
    }

    function updatePropertiesPanelFromSelection() {
      const form = qs('#ontoPropsForm'); if (!form || !ontoState.cy) return;
      const sel = ontoState.cy.$(':selected');
      const nameEl = qs('#propName');
      const typeValueEl = qs('#propTypeValue');

      let currentAttrs = {};
      let objectType = 'class';

      if (sel.length === 1 && sel[0].isNode()) {
        const n = sel[0];
        const isImported = n.hasClass('imported');
        nameEl.value = n.data('label') || n.id();
        nameEl.disabled = isImported; // Disable name editing for imported elements
        const nodeType = n.data('type') || 'class';
        typeValueEl.textContent = getTypeDisplayName(nodeType) + (isImported ? ' (Imported)' : '');
        currentAttrs = n.data('attrs') || {};
        objectType = nodeType;

        // Show positioning section for nodes
        const positioningSection = qs('#positioningSection');
        if (positioningSection) {
          positioningSection.style.display = 'block';
          updatePositionInputs(); // Populate current position
        }

        // Lazy load additional metadata for imported ontologies
        if (activeOntologyIri && activeOntologyIri.includes('/onto/') && !currentAttrs.definition) {
          loadAdditionalMetadataForElement(n.id(), activeOntologyIri);
        }
      } else if (sel.length === 1 && sel[0].isEdge()) {
        const e = sel[0];
        nameEl.value = e.data('predicate') || e.id();
        const edgeType = e.data('type') || 'objectProperty';
        typeValueEl.textContent = getTypeDisplayName(edgeType);
        currentAttrs = e.data('attrs') || {};

        // Show/hide SHACL constraints section based on edge type
        const shaclSection = qs('#shaclConstraintsSection');
        if (shaclSection) {
          if (edgeType === 'objectProperty' || edgeType === 'dataProperty') {
            shaclSection.style.display = 'block';

            // Show/hide appropriate subsections
            const multiplicitySubsection = qs('#multiplicitySubsection');
            const datatypeSubsection = qs('#datatypeSubsection');
            const enumerationSubsection = qs('#enumerationSubsection');

            if (edgeType === 'objectProperty') {
              // Object properties: show multiplicity and enumeration, hide datatype
              if (multiplicitySubsection) multiplicitySubsection.style.display = 'block';
              if (datatypeSubsection) datatypeSubsection.style.display = 'none';
              if (enumerationSubsection) enumerationSubsection.style.display = 'block';
              updateMultiplicityFields(e);
              updateEnumerationFields(e);
            } else if (edgeType === 'dataProperty') {
              // Datatype properties: show datatype and enumeration, hide multiplicity
              if (multiplicitySubsection) multiplicitySubsection.style.display = 'none';
              if (datatypeSubsection) datatypeSubsection.style.display = 'block';
              if (enumerationSubsection) enumerationSubsection.style.display = 'block';
              updateDatatypeFields(e);
              updateEnumerationFields(e);
            }

            // Always update constraint summary
            updateAllConstraintsDisplay(e);
          } else {
            shaclSection.style.display = 'none';
          }
        }

        // Hide positioning section for edges
        const positioningSection = qs('#positioningSection');
        if (positioningSection) {
          positioningSection.style.display = 'none';
        }

        // Lazy load additional metadata for imported ontologies
        if (activeOntologyIri && activeOntologyIri.includes('/onto/') && !currentAttrs.definition) {
          loadAdditionalMetadataForElement(e.id(), activeOntologyIri);
        }
        objectType = edgeType;
      } else {
        // Hide SHACL constraints section when no edge is selected
        const shaclSection = qs('#shaclConstraintsSection');
        if (shaclSection) {
          shaclSection.style.display = 'none';
        }

        // Hide positioning section when no node is selected
        const positioningSection = qs('#positioningSection');
        if (positioningSection) {
          positioningSection.style.display = 'none';
        }

        const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
        // FIXED: Make model metadata ontology-specific, not just project-specific
        const ontologyKey = activeOntologyIri ? activeOntologyIri.split('/').pop() : 'default';
        const modelNameKey = `onto_model_name__${pid}__${ontologyKey}`;
        const modelAttrsKey = `onto_model_attrs__${pid}__${ontologyKey}`;

        nameEl.value = localStorage.getItem(modelNameKey) || 'Ontology Model';
        typeValueEl.textContent = getTypeDisplayName('model');
        objectType = 'model';
        try {
          currentAttrs = JSON.parse(localStorage.getItem(modelAttrsKey) || '{}');

          // POPULATE IMPORTS: Read current imports from localStorage and add to attributes
          if (activeOntologyIri) {
            const importsKey = 'onto_imports__' + encodeURIComponent(activeOntologyIri);
            try {
              const imports = JSON.parse(localStorage.getItem(importsKey) || '[]');
              if (imports && imports.length > 0) {
                // Clean up imports and format properly (one per line)
                const cleanImports = imports.map(imp => {
                  // Remove any Turtle syntax artifacts
                  let cleanImp = String(imp).trim();
                  if (cleanImp.startsWith('@')) cleanImp = cleanImp.substring(1);
                  if (cleanImp.startsWith('<')) cleanImp = cleanImp.slice(1, -1);
                  return cleanImp;
                }).filter(imp => imp.length > 0);

                currentAttrs.imports = cleanImports.join('\n');
                console.log(`📋 Loaded ${cleanImports.length} clean imports:`, cleanImports);
              } else {
                currentAttrs.imports = '';
              }
            } catch (_) {
              currentAttrs.imports = '';
            }
          }
        } catch (_) { currentAttrs = {}; }
      }

      // Update attribute editor
      const isImportedElement = (sel.length === 1 && sel[0].hasClass('imported'));
      updateAttributeEditor(objectType, currentAttrs, isImportedElement);

      // Update element IRI display
      updateElementIriDisplay();
    }

    // Update multiplicity fields in properties panel
    function updateMultiplicityFields(edge) {
      const minCountInput = qs('#propMinCount');
      const maxCountInput = qs('#propMaxCount');
      const displayEl = qs('#multiplicityDisplay');

      if (!minCountInput || !maxCountInput || !displayEl) return;

      // Get multiplicity data from edge
      const minCount = edge.data('minCount');
      const maxCount = edge.data('maxCount');

      // Populate input fields
      minCountInput.value = minCount !== null && minCount !== undefined ? minCount : '';
      maxCountInput.value = maxCount !== null && maxCount !== undefined ? maxCount : '';

      // Update display
      updateMultiplicityDisplay();
    }

    // Update multiplicity display based on current input values
    function updateMultiplicityDisplay() {
      const minCountInput = qs('#propMinCount');
      const maxCountInput = qs('#propMaxCount');
      const displayEl = qs('#multiplicityDisplay');

      if (!minCountInput || !maxCountInput || !displayEl) return;

      const minVal = minCountInput.value ? parseInt(minCountInput.value) : null;
      const maxVal = maxCountInput.value ? parseInt(maxCountInput.value) : null;

      let display = 'No constraints';

      if (minVal !== null || maxVal !== null) {
        if (minVal === 1 && maxVal === 1) display = '(1)';
        else if (minVal === 0 && maxVal === null) display = '(0..*)';
        else if (minVal === 1 && maxVal === null) display = '(1..*)';
        else if (minVal === 0 && maxVal === 1) display = '(0..1)';
        else if (minVal !== null && maxVal !== null && minVal === maxVal) display = `(${minVal})`;
        else if (minVal !== null && maxVal !== null) display = `(${minVal}..${maxVal})`;
        else if (minVal !== null) display = `(${minVal}..*)`;
        else if (maxVal !== null) display = `(0..${maxVal})`;
      }

      displayEl.textContent = display;
    }

    // Update datatype constraint fields in properties panel
    function updateDatatypeFields(edge) {
      const datatypeSelect = qs('#propDatatypeConstraint');
      const displayEl = qs('#datatypeDisplay');

      if (!datatypeSelect || !displayEl) return;

      // Get datatype constraint from edge data
      const datatypeConstraint = edge.data('datatypeConstraint');

      // Populate select field
      datatypeSelect.value = datatypeConstraint || '';

      // Update display
      updateDatatypeDisplay();
    }

    // Update datatype display based on current selection
    function updateDatatypeDisplay() {
      const datatypeSelect = qs('#propDatatypeConstraint');
      const displayEl = qs('#datatypeDisplay');

      if (!datatypeSelect || !displayEl) return;

      const selectedType = datatypeSelect.value;

      if (selectedType) {
        displayEl.textContent = `Datatype: ${selectedType}`;
        displayEl.style.color = 'var(--accent)';
      } else {
        displayEl.textContent = 'No datatype constraint';
        displayEl.style.color = 'var(--muted)';
      }
    }

    // Update enumeration fields in properties panel
    function updateEnumerationFields(edge) {
      const enumerationTextarea = qs('#propEnumerationValues');
      const displayEl = qs('#enumerationDisplay');

      if (!enumerationTextarea || !displayEl) return;

      // Get enumeration values from edge data
      const enumerationValues = edge.data('enumerationValues');

      // Populate textarea (one value per line)
      if (enumerationValues && Array.isArray(enumerationValues)) {
        enumerationTextarea.value = enumerationValues.join('\\n');
      } else {
        enumerationTextarea.value = '';
      }

      // Update display
      updateEnumerationDisplay();
    }

    // Update enumeration display based on current values
    function updateEnumerationDisplay() {
      const enumerationTextarea = qs('#propEnumerationValues');
      const displayEl = qs('#enumerationDisplay');

      if (!enumerationTextarea || !displayEl) return;

      const values = enumerationTextarea.value.split('\\n').filter(v => v.trim()).map(v => v.trim());

      if (values.length > 0) {
        displayEl.textContent = `Values: {${values.join(', ')}}`;
        displayEl.style.color = 'var(--accent)';
      } else {
        displayEl.textContent = 'No enumeration constraint';
        displayEl.style.color = 'var(--muted)';
      }
    }

    // Update all constraints summary display
    function updateAllConstraintsDisplay(edge) {
      const displayEl = qs('#allConstraintsDisplay');
      if (!displayEl) return;

      const constraints = [];

      // Multiplicity
      const minCount = edge.data('minCount');
      const maxCount = edge.data('maxCount');
      if (minCount !== null && minCount !== undefined || maxCount !== null && maxCount !== undefined) {
        let multiplicity = '';
        if (minCount === 1 && maxCount === 1) multiplicity = '(1)';
        else if (minCount === 0 && !maxCount) multiplicity = '(0..*)';
        else if (minCount === 1 && !maxCount) multiplicity = '(1..*)';
        else if (minCount === 0 && maxCount === 1) multiplicity = '(0..1)';
        else if (minCount !== null && maxCount !== null && minCount === maxCount) multiplicity = `(${minCount})`;
        else if (minCount !== null && maxCount !== null) multiplicity = `(${minCount}..${maxCount})`;
        else if (minCount !== null) multiplicity = `(${minCount}..*)`;
        else if (maxCount !== null) multiplicity = `(0..${maxCount})`;

        if (multiplicity) constraints.push(`Multiplicity: ${multiplicity}`);
      }

      // Datatype
      const datatypeConstraint = edge.data('datatypeConstraint');
      if (datatypeConstraint) {
        constraints.push(`Datatype: ${datatypeConstraint}`);
      }

      // Enumeration
      const enumerationValues = edge.data('enumerationValues');
      if (enumerationValues && Array.isArray(enumerationValues) && enumerationValues.length > 0) {
        const valuesList = enumerationValues.slice(0, 3).join(', ');
        const suffix = enumerationValues.length > 3 ? `... (+${enumerationValues.length - 3} more)` : '';
        constraints.push(`Enumeration: {${valuesList}${suffix}}`);
      }

      if (constraints.length > 0) {
        displayEl.innerHTML = constraints.join('<br>');
        displayEl.style.color = 'var(--text)';
      } else {
        displayEl.textContent = 'No constraints defined';
        displayEl.style.color = 'var(--muted)';
      }
    }

    // Apply multiplicity preset
    function applyMultiplicityPreset(preset) {
      const minCountInput = qs('#propMinCount');
      const maxCountInput = qs('#propMaxCount');

      if (!minCountInput || !maxCountInput) return;

      switch (preset) {
        case 'none':
          minCountInput.value = '';
          maxCountInput.value = '';
          break;
        case '1':
          minCountInput.value = '1';
          maxCountInput.value = '1';
          break;
        case '0..1':
          minCountInput.value = '0';
          maxCountInput.value = '1';
          break;
        case '0..*':
          minCountInput.value = '0';
          maxCountInput.value = '';
          break;
        case '1..*':
          minCountInput.value = '1';
          maxCountInput.value = '';
          break;
      }

      updateMultiplicityDisplay();
      applyMultiplicityToEdge();
    }

    // Apply enumeration preset
    function applyEnumerationPreset(preset) {
      const enumerationTextarea = qs('#propEnumerationValues');

      if (!enumerationTextarea) return;

      let values = '';
      switch (preset) {
        case 'requirement-status':
          values = 'Draft\\nReviewed\\nApproved\\nImplemented';
          break;
        case 'criticality':
          values = 'Low\\nMedium\\nHigh\\nCritical';
          break;
        case 'risk-level':
          values = 'Negligible\\nLow\\nMedium\\nHigh\\nCatastrophic';
          break;
        case 'priority':
          values = 'Low\\nMedium\\nHigh\\nUrgent';
          break;
        case 'custom':
          const customValues = prompt('Enter enumeration values (one per line):', 'Value1\\nValue2\\nValue3');
          if (customValues) {
            values = customValues;
          }
          break;
      }

      if (values) {
        enumerationTextarea.value = values;
        updateEnumerationDisplay();
        applyEnumerationToEdge();
      }
    }

    // Apply datatype constraint to edge
    function applyDatatypeToEdge() {
      if (!ontoState.cy) return;

      const sel = ontoState.cy.$(':selected');
      if (sel.length !== 1 || !sel[0].isEdge()) return;

      const edge = sel[0];
      const datatypeSelect = qs('#propDatatypeConstraint');

      if (!datatypeSelect) return;

      const datatypeConstraint = datatypeSelect.value || null;

      console.log(`🎯 Applying datatype constraint: ${datatypeConstraint}`);

      // Update edge data
      edge.data('datatypeConstraint', datatypeConstraint);

      // Update modification metadata
      const currentAttrs = edge.data('attrs') || {};
      const updatedAttrs = updateModificationMetadata(currentAttrs);
      edge.data('attrs', updatedAttrs);

      // Save to backend
      saveShaclConstraintsToBackend(edge);

      // Update displays
      updateAllConstraintsDisplay(edge);
      persistOntologyToLocalStorage();
    }

    // Apply enumeration constraint to edge
    function applyEnumerationToEdge() {
      if (!ontoState.cy) return;

      const sel = ontoState.cy.$(':selected');
      if (sel.length !== 1 || !sel[0].isEdge()) return;

      const edge = sel[0];
      const enumerationTextarea = qs('#propEnumerationValues');

      if (!enumerationTextarea) return;

      const values = enumerationTextarea.value.split('\\n').filter(v => v.trim()).map(v => v.trim());
      const enumerationValues = values.length > 0 ? values : null;

      console.log(`🎯 Applying enumeration constraint:`, enumerationValues);

      // Update edge data
      edge.data('enumerationValues', enumerationValues);

      // Update modification metadata
      const currentAttrs = edge.data('attrs') || {};
      const updatedAttrs = updateModificationMetadata(currentAttrs);
      edge.data('attrs', updatedAttrs);

      // Save to backend
      saveShaclConstraintsToBackend(edge);

      // Update displays
      updateAllConstraintsDisplay(edge);
      persistOntologyToLocalStorage();
    }

    // Apply multiplicity changes to the selected edge
    function applyMultiplicityToEdge() {
      if (!ontoState.cy) {
        console.log('❌ No Cytoscape instance available');
        return;
      }

      const sel = ontoState.cy.$(':selected');
      if (sel.length !== 1 || !sel[0].isEdge()) {
        console.log('❌ No edge selected or multiple items selected');
        return;
      }

      const edge = sel[0];
      const minCountInput = qs('#propMinCount');
      const maxCountInput = qs('#propMaxCount');

      if (!minCountInput || !maxCountInput) {
        console.log('❌ Multiplicity input fields not found');
        return;
      }

      const minCount = minCountInput.value ? parseInt(minCountInput.value) : null;
      const maxCount = maxCountInput.value ? parseInt(maxCountInput.value) : null;

      console.log(`🎯 Applying multiplicity to edge: min=${minCount}, max=${maxCount}`);

      // Update edge multiplicity using our existing function
      updateEdgeMultiplicity(edge, minCount, maxCount);
    }

    function updateAttributeEditor(objectType, currentAttrs, isReadOnly = false) {
      const container = qs('#propAttrsContainer');
      if (!container) return;

      container.innerHTML = '';

      if (isReadOnly) {
        // Show read-only message for imported elements
        const readOnlyMsg = document.createElement('div');
        readOnlyMsg.style.cssText = `
          padding: 12px;
          background: var(--panel-2);
          border: 1px solid var(--border);
          border-radius: 6px;
          text-align: center;
          color: var(--muted);
          font-style: italic;
          margin-bottom: 8px;
        `;
        readOnlyMsg.innerHTML = '🔒 Imported elements are read-only<br><small>Properties cannot be modified</small>';
        container.appendChild(readOnlyMsg);
      }

      const template = attributeTemplates[objectType] || {};

      // Add template attributes
      Object.entries(template).forEach(([key, config]) => {
        const attrDiv = createAttributeField(key, config, currentAttrs[key] || '', isReadOnly);
        container.appendChild(attrDiv);
      });

      // Add any custom attributes not in template
      Object.entries(currentAttrs).forEach(([key, value]) => {
        if (!template[key]) {
          const attrDiv = createAttributeField(key, { type: 'text', label: key }, value, isReadOnly);
          container.appendChild(attrDiv);
        }
      });

      // Disable save button for imported elements
      const saveBtn = qs('#propSaveBtn');
      if (saveBtn) {
        saveBtn.disabled = isReadOnly;
        saveBtn.style.opacity = isReadOnly ? '0.5' : '1';
        saveBtn.title = isReadOnly ? 'Cannot save changes to imported elements' : 'Save changes';
      }

      // Disable add and reset buttons for imported elements
      const addBtn = qs('#addAttrBtn');
      const resetBtn = qs('#resetAttrsBtn');
      if (addBtn) {
        addBtn.disabled = isReadOnly;
        addBtn.style.opacity = isReadOnly ? '0.5' : '1';
        addBtn.title = isReadOnly ? 'Cannot add attributes to imported elements' : 'Add custom attribute';
      }
      if (resetBtn) {
        resetBtn.disabled = isReadOnly;
        resetBtn.style.opacity = isReadOnly ? '0.5' : '1';
        resetBtn.title = isReadOnly ? 'Cannot reset attributes of imported elements' : 'Reset to template';
      }
    }

    function createAttributeField(key, config, value, isReadOnly = false) {
      const div = document.createElement('div');
      div.style.display = 'grid';
      div.style.gridTemplateColumns = '1fr auto';
      div.style.gap = '8px';
      div.style.alignItems = 'center';

      const label = document.createElement('label');
      label.textContent = config.label || key;
      label.style.fontSize = '12px';
      label.style.color = '#9ca3af';

      const inputContainer = document.createElement('div');
      inputContainer.style.display = 'flex';
      inputContainer.style.gap = '4px';

      let input;
      if (config.type === 'select') {
        input = document.createElement('select');
        input.style.width = '100%';
        input.style.background = '#0b1220';
        input.style.color = '#e5e7eb';
        input.style.border = '1px solid var(--border)';
        input.style.borderRadius = '4px';
        input.style.padding = '4px';
        input.style.fontSize = '12px';

        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = config.placeholder || 'Select...';
        input.appendChild(defaultOption);

        if (config.options) {
          config.options.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option;
            opt.textContent = option;
            if (value === option) opt.selected = true;
            input.appendChild(opt);
          });
        }
      } else if (config.type === 'checkbox') {
        input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = value === true || value === 'true';
      } else if (config.type === 'textarea') {
        input = document.createElement('textarea');
        input.rows = config.rows || 3;

        // Special handling for imports field to ensure clean display
        let displayValue = value || '';
        if (key === 'imports') {
          // Clean up any Turtle syntax that might have leaked in
          displayValue = displayValue.replace(/^@/, '').replace(/\\\\n/g, '\n');
        }

        input.value = displayValue;
        input.style.width = '100%';
        input.style.background = '#0b1220';
        input.style.color = '#e5e7eb';
        input.style.border = '1px solid var(--border)';
        input.style.borderRadius = '4px';
        input.style.padding = '4px';
        input.style.fontSize = '12px';
        input.style.resize = 'vertical';
      } else if (config.type === 'date') {
        input = document.createElement('input');
        input.type = 'date';
        input.value = value || '';
      } else {
        input = document.createElement('input');
        input.type = config.type || 'text';
        input.value = value || '';
        input.placeholder = config.placeholder || '';
      }

      if (input.type !== 'checkbox' && input.type !== 'textarea') {
        input.style.width = '100%';
        input.style.background = '#0b1220';
        input.style.color = '#e5e7eb';
        input.style.border = '1px solid var(--border)';
        input.style.borderRadius = '4px';
        input.style.padding = '4px';
        input.style.fontSize = '12px';
      }

      // Make input read-only for imported elements or readonly fields
      if (isReadOnly || config.readonly) {
        input.disabled = true;
        input.style.opacity = '0.6';
        input.style.cursor = 'not-allowed';
        input.title = config.readonly ? 'This field is read-only metadata' : 'This field cannot be edited for imported elements';
      }

      input.dataset.attrKey = key;
      input.dataset.attrType = config.type || 'text';

      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.textContent = '×';
      deleteBtn.style.background = '#dc2626';
      deleteBtn.style.color = 'white';
      deleteBtn.style.border = 'none';
      deleteBtn.style.borderRadius = '4px';
      deleteBtn.style.width = '24px';
      deleteBtn.style.height = '24px';
      deleteBtn.style.fontSize = '14px';
      deleteBtn.style.cursor = 'pointer';
      deleteBtn.title = 'Remove attribute';

      // Only show delete button for custom attributes (not in template)
      let objectType = 'class';
      if (ontoState.cy) {
        const sel = ontoState.cy.$(':selected');
        if (sel.length === 1) {
          objectType = sel[0].data('type') || 'class';
        } else {
          objectType = 'model';
        }
      }
      const template = attributeTemplates[objectType] || {};
      if (template[key]) {
        deleteBtn.style.display = 'none';
      }

      deleteBtn.onclick = () => {
        if (!isReadOnly) {
          div.remove();
        }
      };

      // Disable delete button for read-only fields
      if (isReadOnly) {
        deleteBtn.disabled = true;
        deleteBtn.style.opacity = '0.3';
        deleteBtn.style.cursor = 'not-allowed';
        deleteBtn.title = 'Cannot delete attributes of imported elements';
      }

      inputContainer.appendChild(input);
      inputContainer.appendChild(deleteBtn);

      div.appendChild(label);
      div.appendChild(inputContainer);

      return div;
    }

    function getCurrentAttributes() {
      const container = qs('#propAttrsContainer');
      if (!container) return {};

      const attrs = {};
      const inputs = container.querySelectorAll('input, select, textarea');

      inputs.forEach(input => {
        const key = input.dataset.attrKey;
        const type = input.dataset.attrType;

        if (key) {
          let value;
          if (type === 'checkbox') {
            value = input.checked;
          } else if (type === 'select' && input.value === '') {
            value = null; // Don't include empty selects
          } else {
            value = input.value.trim();
            if (value === '') value = null; // Don't include empty strings
          }

          if (value !== null) {
            attrs[key] = value;
          }
        }
      });

      return attrs;
    }

    function getModelNamespace() {
      // Get model namespace from active ontology IRI (proper project-scoped URI)
      if (activeOntologyIri) {
        console.log('🔧 getModelNamespace using activeOntologyIri:', activeOntologyIri);
        return activeOntologyIri;
      }

      // Try to get from stored attributes using ontology-specific keys
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';

      // FIXED: Use ontology-specific localStorage keys consistently
      const ontologyKey = activeOntologyIri ? activeOntologyIri.split('/').pop() : 'default';
      const modelAttrsKey = `onto_model_attrs__${pid}__${ontologyKey}`;

      try {
        const modelAttrs = JSON.parse(localStorage.getItem(modelAttrsKey) || '{}');
        if (modelAttrs.namespace && !modelAttrs.namespace.endsWith('/ontology')) {
          console.log('🔧 getModelNamespace using stored namespace:', modelAttrs.namespace);
          return modelAttrs.namespace;
        }
        // If the stored namespace is the old hardcoded one, update it
        if (modelAttrs.graphIri) {
          console.log('🔧 getModelNamespace updating stored namespace to use graphIri:', modelAttrs.graphIri);
          modelAttrs.namespace = modelAttrs.graphIri;
          localStorage.setItem(modelAttrsKey, JSON.stringify(modelAttrs));
          return modelAttrs.graphIri;
        }
      } catch (_) { }

      // Use installation configuration as fallback (but this is wrong for project-scoped ontologies)
      const fallback = INSTALLATION_CONFIG.baseUri + '/ontology';
      console.log('⚠️ getModelNamespace using hardcoded fallback (this should not happen):', fallback);
      return fallback;
    }

    function updateElementIriDisplay() {
      const iriEl = qs('#ontoElementIri');
      const container = qs('#ontoElementIriContainer');
      const copyBtn = qs('#ontoCopyIriBtn');
      if (!iriEl || !container) return;

      // Only show container if we have a canvas
      if (!ontoState.cy) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';

      const sel = ontoState.cy.$(':selected');
      if (sel.length === 1) {
        const element = sel[0];
        const elementId = element.id();
        const elementType = element.data('type') || (element.isNode() ? 'class' : 'objectProperty');
        const isImported = element.hasClass('imported');
        const importSource = element.data('importSource');

        let iri = '';
        let namespace = '';

        if (isImported && importSource) {
          // For imported elements, use their original IRI and show the import source
          const originalIri = element.data('iri');
          console.log('🔍 Imported element selected:', {
            elementId,
            elementLabel: element.data('label'),
            originalIri,
            importSource,
            elementData: element.data()
          });

          if (originalIri && originalIri !== elementId && !originalIri.includes('Class')) {
            iri = originalIri;
            namespace = importSource;
          } else {
            // Fallback: construct IRI using import source as namespace
            const elementLabel = element.data('label') || elementId;
            const sluggedLabel = slugId(elementLabel) || elementId;
            iri = `${importSource}#${sluggedLabel}`;
            namespace = importSource;
          }

          iriEl.textContent = iri;
          iriEl.title = `IRI: ${iri}\nType: ${elementType}\nImported from: ${importSource}\nClick to copy`;
          iriEl.style.color = '#fbbf24'; // Different color for imported elements
          iriEl.style.opacity = '1';
        } else {
          // For local elements, use model namespace as before
          const modelNamespace = getModelNamespace();
          const elementLabel = element.data('label') || elementId;
          const sluggedLabel = slugId(elementLabel) || elementId;

          iri = `${modelNamespace}#${sluggedLabel}`;
          namespace = modelNamespace;

          iriEl.textContent = iri;
          iriEl.title = `IRI: ${iri}\nType: ${elementType}\nModel Namespace: ${namespace}\nClick to copy`;
          iriEl.style.color = '#60a5fa';
          iriEl.style.opacity = '1';
        }

        // Show copy button
        if (copyBtn) {
          copyBtn.style.display = 'inline-block';
          copyBtn.onclick = () => copyIriToClipboard(iri);
        }

        // Add click handler to IRI text
        iriEl.onclick = () => copyIriToClipboard(iri);
      } else {
        // Show current namespace when no element is selected, but only if there's an active ontology
        if (activeOntologyIri) {
          const modelNamespace = getModelNamespace();
          iriEl.textContent = modelNamespace;
          iriEl.title = `Current Model Namespace: ${modelNamespace}\nClick to copy namespace`;
          iriEl.style.color = '#60a5fa';
          iriEl.style.opacity = '1';
          iriEl.onclick = () => copyIriToClipboard(modelNamespace);

          // Show copy button for namespace
          if (copyBtn) {
            copyBtn.style.display = 'inline-block';
            copyBtn.onclick = () => copyIriToClipboard(modelNamespace);
          }
        } else {
          // No active ontology - show "No element selected"
          iriEl.textContent = 'No element selected';
          iriEl.title = 'No element selected';
          iriEl.style.color = '#9aa4b2';
          iriEl.style.opacity = '0.7';
          iriEl.onclick = null;

          // Hide copy button when no element is selected
          if (copyBtn) {
            copyBtn.style.display = 'none';
          }
        }
      }
    }

    // General clipboard copy function
    function copyToClipboard(text, showToast = true) {
      try {
        navigator.clipboard.writeText(text).then(() => {
          if (showToast && typeof toast === 'function') {
            toast(`Copied: ${text.length > 50 ? text.substring(0, 50) + '...' : text}`);
          }
        }).catch(err => {
          console.error('Failed to copy to clipboard:', err);
          if (showToast && typeof toast === 'function') {
            toast('Failed to copy to clipboard', true);
          }
        });
      } catch (err) {
        console.error('Clipboard not available:', err);
        if (showToast && typeof toast === 'function') {
          toast('Clipboard not available', true);
        }
      }
    }

    function copyIriToClipboard(iri) {
      try {
        navigator.clipboard.writeText(iri).then(() => {
          // Show temporary feedback
          const copyBtn = qs('#ontoCopyIriBtn');
          if (copyBtn) {
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            copyBtn.style.background = '#10b981';
            setTimeout(() => {
              copyBtn.textContent = originalText;
              copyBtn.style.background = '';
            }, 1000);
          }
        }).catch(() => {
          // Fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = iri;
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);

          const copyBtn = qs('#ontoCopyIriBtn');
          if (copyBtn) {
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            copyBtn.style.background = '#10b981';
            setTimeout(() => {
              copyBtn.textContent = originalText;
              copyBtn.style.background = '';
            }, 1000);
          }
        });
      } catch (error) {
        console.warn('Failed to copy IRI to clipboard:', error);
      }
    }

    function persistOntologyToLocalStorage() {
      if (!ontoState.cy) return;
      if (ontoState.suspendAutosave) return;
      try {
        const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({ data: n.data(), position: n.position() }));
        const edges = ontoState.cy.edges().filter(e => !e.hasClass('imported')).map(e => ({ data: e.data() }));
        if (activeOntologyIri) {
          const storageData = {
            nodes,
            edges,
            timestamp: Date.now(),
            source: 'local' // Mark that this data was saved locally
          };
          localStorage.setItem(storageKeyForGraph(activeOntologyIri), JSON.stringify(storageData));

          // Layout is now saved separately with its own debounced handler
          // No longer automatically saving layout here to prevent excessive server calls
        }
      } catch (_) { }
    }

    async function saveLayoutToServer(graphIri, nodes, edges) {
      try {
        console.log('💾 Saving layout to server for:', graphIri);

        const pan = ontoState.cy.pan();
        const zoom = ontoState.cy.zoom();

        const layoutData = {
          nodes: nodes.map(n => ({
            iri: n.data.id,
            x: n.position.x,
            y: n.position.y
          })),
          edges: edges.map(e => ({
            iri: e.data.id
          })),
          zoom: zoom,
          pan: { x: pan.x, y: pan.y }
        };

        console.log('💾 Layout data:', {
          nodeCount: layoutData.nodes.length,
          edgeCount: layoutData.edges.length,
          zoom: layoutData.zoom,
          pan: layoutData.pan
        });

        const response = await authenticatedFetch(`/api/ontology/layout?graph=${encodeURIComponent(graphIri)}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(layoutData)
        });

        console.log('💾 Layout save response status:', response.status);
        console.log('💾 Layout save response ok:', response.ok);

        if (!response.ok) {
          console.warn('❌ Failed to save layout to server:', response.status);
        } else {
          console.log('✅ Layout saved to server successfully!');
        }
      } catch (error) {
        console.warn('Error saving layout to server:', error);
      }
    }

    async function loadLayoutFromServer(graphIri) {
      try {
        // First check if we have a recent layout in localStorage
        const localLayoutKey = `onto_layout_${encodeURIComponent(graphIri)}`;
        const localLayout = localStorage.getItem(localLayoutKey);

        if (localLayout) {
          try {
            const layoutData = JSON.parse(localLayout);
            // Check if local layout is recent (within last 30 seconds)
            if (layoutData.timestamp && (Date.now() - layoutData.timestamp) < 30000) {
              console.log('📍 Using recent layout from localStorage (saved within last 30 seconds)');

              // Apply node positions from local storage
              if (layoutData.nodes) {
                layoutData.nodes.forEach(nodeLayout => {
                  const node = ontoState.cy.$(`#${nodeLayout.iri}`);
                  if (node.length > 0) {
                    node.position({ x: nodeLayout.x, y: nodeLayout.y });
                  }
                });
              }

              // Apply zoom and pan
              if (layoutData.zoom && layoutData.pan) {
                ontoState.cy.zoom(layoutData.zoom);
                ontoState.cy.pan(layoutData.pan);
              }

              return true;
            }
          } catch (e) {
            console.warn('Error parsing local layout:', e);
          }
        }

        // If no recent local layout, load from server
        const response = await authenticatedFetch(`/api/ontology/layout?graph=${encodeURIComponent(graphIri)}`);

        if (response.ok) {
          const result = await response.json();
          const layoutData = result.data;

          if (layoutData && layoutData.nodes && layoutData.nodes.length > 0) {
            // Apply node positions
            layoutData.nodes.forEach(nodeLayout => {
              const node = ontoState.cy.$(`#${nodeLayout.iri}`);
              if (node.length > 0) {
                node.position({ x: nodeLayout.x, y: nodeLayout.y });
              }
            });

            // Apply zoom and pan
            if (layoutData.zoom && layoutData.pan) {
              ontoState.cy.zoom(layoutData.zoom);
              ontoState.cy.pan(layoutData.pan);
            }

            console.log('Layout loaded from server');
            return true;
          }
        } else if (response.status !== 404) {
          console.warn('Failed to load layout from server:', response.status);
        }
      } catch (error) {
        console.warn('Error loading layout from server:', error);
      }
      return false;
    }

    // graphKeyForActive not used; per-project keys are used via storageKeyForGraph
    function attrsFromModel() {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';

      // FIXED: Use ontology-specific localStorage keys consistently
      const ontologyKey = activeOntologyIri ? activeOntologyIri.split('/').pop() : 'default';
      const modelAttrsKey = `onto_model_attrs__${pid}__${ontologyKey}`;

      try { return JSON.parse(localStorage.getItem(modelAttrsKey) || '{}'); } catch (_) { return {}; }
    }
    function loadOntologyLabelMap(project) {
      const pid = project?.id || project?.project_id || (activeProject && (activeProject.id || activeProject.project_id)) || 'default';
      try { return JSON.parse(localStorage.getItem(`onto_label_map__${pid}`) || '{}'); } catch (_) { return {}; }
    }
    function saveOntologyLabel(graphIri, label) {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      try { const m = loadOntologyLabelMap(activeProject); m[graphIri] = label; localStorage.setItem(`onto_label_map__${pid}`, JSON.stringify(m)); } catch (_) { }
    }
    function storageKeyForGraph(iri) {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      return `onto_graph__${pid}__` + encodeURIComponent(iri);
    }
    function saveGraphToLocal(graphIri) {
      try {
        const nodes = ontoState.cy ? ontoState.cy.nodes().jsons() : [];
        const edges = ontoState.cy ? ontoState.cy.edges().jsons() : [];
        const storageData = {
          nodes,
          edges,
          timestamp: Date.now(),
          source: 'local' // Mark that this data was saved locally
        };
        localStorage.setItem(storageKeyForGraph(graphIri), JSON.stringify(storageData));
      } catch (_) { }
    }
    function loadGraphFromLocal(graphIri) {
      try {
        const json = localStorage.getItem(storageKeyForGraph(graphIri));
        if (!json) return;
        const data = JSON.parse(json);
        if (!ontoState.cy) return;
        ontoState.cy.elements().remove();
        ontoState.cy.add(data.nodes || []);
        ontoState.cy.add(data.edges || []);
        // Ensure all loaded elements have attrs property
        ensureAttributesExist();
        // After loading, ensure nextId is advanced beyond existing ClassNNN
        recomputeNextId();
        requestAnimationFrame(() => { ontoState.cy.fit(); });
      } catch (_) { }
    }

    async function fetchRichMetadata(graphIri) {
      try {
        console.log('🔍 fetchRichMetadata called for:', graphIri);

        // Optimized SPARQL queries - fetch only essential metadata first
        // We'll fetch labels and basic info first, then load other metadata on demand
        const qClasses = `
          PREFIX owl: <http://www.w3.org/2002/07/owl#>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX dc11: <http://purl.org/dc/elements/1.1/>
          PREFIX dcterms: <http://purl.org/dc/terms/>
          PREFIX obo: <http://purl.obolibrary.org/obo/>
          SELECT ?c ?label ?comment ?definition ?example ?identifier ?subclassOf ?equivalentClass WHERE {
            GRAPH <${graphIri}> {
              ?c a owl:Class .
              OPTIONAL { ?c rdfs:label ?label }
              OPTIONAL { ?c rdfs:comment ?comment }
              OPTIONAL { ?c skos:definition ?definition }
              OPTIONAL { ?c skos:example ?example }
              OPTIONAL { ?c dc11:identifier ?identifier }
              OPTIONAL { ?c rdfs:subClassOf ?subclassOf }
              OPTIONAL { ?c owl:equivalentClass ?equivalentClass }
            }
          }`;

        const qProps = `
          PREFIX owl: <http://www.w3.org/2002/07/owl#>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX dc11: <http://purl.org/dc/elements/1.1/>
          PREFIX dcterms: <http://purl.org/dc/terms/>
          SELECT ?p ?label ?comment ?definition ?example ?identifier ?domain ?range ?inverseOf ?subPropertyOf ?equivalentProperty ?propertyType WHERE {
            GRAPH <${graphIri}> {
              ?p a owl:ObjectProperty .
              OPTIONAL { ?p rdfs:label ?label }
              OPTIONAL { ?p rdfs:comment ?comment }
              OPTIONAL { ?p skos:definition ?definition }
              OPTIONAL { ?p skos:example ?example }
              OPTIONAL { ?p dc11:identifier ?identifier }
              OPTIONAL { ?p rdfs:domain ?domain }
              OPTIONAL { ?p rdfs:range ?range }
              OPTIONAL { ?p owl:inverseOf ?inverseOf }
              OPTIONAL { ?p rdfs:subPropertyOf ?subPropertyOf }
              OPTIONAL { ?p owl:equivalentProperty ?equivalentProperty }
              OPTIONAL { ?p a ?propertyType }
            }
          }`;

        const classesRes = await authenticatedFetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qClasses }) });
        const propsRes = await authenticatedFetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qProps }) });
        const classesJson = classesRes.ok ? await classesRes.json() : { results: { bindings: [] } };
        const propsJson = propsRes.ok ? await propsRes.json() : { results: { bindings: [] } };

        // Enhanced class processing with rich metadata
        const classes = (classesJson.results?.bindings || []).map(b => {
          const iri = b.c.value;
          const label = (b.label && b.label.value) || (iri.includes('#') ? iri.split('#').pop() : iri.split('/').pop());
          const attrs = {};

          // Store all available metadata
          if (b.comment && b.comment.value) attrs.comment = b.comment.value;
          if (b.definition && b.definition.value) attrs.definition = b.definition.value;
          if (b.example && b.example.value) attrs.example = b.example.value;
          if (b.identifier && b.identifier.value) attrs.identifier = b.identifier.value;
          if (b.subclassOf && b.subclassOf.value) attrs.subclassOf = b.subclassOf.value;
          if (b.equivalentClass && b.equivalentClass.value) attrs.equivalentClass = b.equivalentClass.value;

          return { iri, label, attrs };
        });

        // Enhanced property processing with rich metadata
        const properties = [];
        (propsJson.results?.bindings || []).forEach(b => {
          const p = b.p.value;
          const label = (b.label && b.label.value) || (p.includes('#') ? p.split('#').pop() : p.split('/').pop());
          const attrs = {};

          // Store all available metadata
          if (b.comment && b.comment.value) attrs.comment = b.comment.value;
          if (b.definition && b.definition.value) attrs.definition = b.definition.value;
          if (b.example && b.example.value) attrs.example = b.example.value;
          if (b.identifier && b.identifier.value) attrs.identifier = b.identifier.value;
          if (b.domain && b.domain.value) attrs.domain = b.domain.value;
          if (b.range && b.range.value) attrs.range = b.range.value;
          if (b.inverseOf && b.inverseOf.value) attrs.inverseOf = b.inverseOf.value;
          if (b.subPropertyOf && b.subPropertyOf.value) attrs.subPropertyOf = b.subPropertyOf.value;
          if (b.equivalentProperty && b.equivalentProperty.value) attrs.equivalentProperty = b.equivalentProperty.value;
          if (b.propertyType && b.propertyType.value) attrs.propertyType = b.propertyType.value;

          properties.push({ iri: p, label, attrs });
        });

        return { classes, properties };
      } catch (error) {
        console.error('Failed to fetch rich metadata:', error);
        return { classes: [], properties: [] };
      }
    }

    function convertOntologyToCytoscape(ontologyData) {
      // Convert API ontology format to Cytoscape format
      const nodes = [];
      const edges = [];

      // Create nodes for classes
      const classes = ontologyData.classes || [];
      const classNameToId = {}; // Map class names to IDs

      classes.forEach((cls, index) => {
        // Use the original URI as ID if available, otherwise fall back to simple ID
        const classId = cls.iri || `Class${index + 1}`;
        classNameToId[cls.name] = classId;

        // Arrange in a grid layout
        const row = Math.floor(index / 4);
        const col = index % 4;

        const node = {
          data: {
            id: classId,
            iri: cls.iri || classId, // Preserve original URI
            label: cls.label || cls.name,
            type: 'class'
          },
          position: {
            x: 150 + (col * 200),
            y: 100 + (row * 150)
          }
        };
        nodes.push(node);
      });

      // Create edges for object properties
      let edgeId = 1;
      const objectProps = ontologyData.object_properties || [];
      objectProps.forEach(prop => {
        if (prop.domain && prop.range && classNameToId[prop.domain] && classNameToId[prop.range]) {
          // Format multiplicity constraints for display  
          const minCount = prop.min_count;
          const maxCount = prop.max_count;
          let multiplicity = '';
          if (minCount !== null && minCount !== undefined || maxCount !== null && maxCount !== undefined) {
            if (minCount === 1 && maxCount === 1) multiplicity = ' (1)';
            else if (minCount === 0 && (maxCount === null || maxCount === undefined)) multiplicity = ' (0..*)';
            else if (minCount === 1 && (maxCount === null || maxCount === undefined)) multiplicity = ' (1..*)';
            else if (minCount === 0 && maxCount === 1) multiplicity = ' (0..1)';
            else if (minCount !== null && minCount !== undefined && maxCount !== null && maxCount !== undefined && minCount === maxCount)
              multiplicity = ` (${minCount})`;
            else if (minCount !== null && minCount !== undefined && maxCount !== null && maxCount !== undefined)
              multiplicity = ` (${minCount}..${maxCount})`;
            else if (minCount !== null && minCount !== undefined) multiplicity = ` (${minCount}..*)`;
            else if (maxCount !== null && maxCount !== undefined) multiplicity = ` (0..${maxCount})`;
          }

          const displayLabel = prop.label || prop.name;

          const edge = {
            data: {
              id: `e${edgeId}`,
              source: classNameToId[prop.domain],
              target: classNameToId[prop.range],
              predicate: prop.name,
              label: displayLabel,  // Clean relationship name in middle
              type: 'objectProperty',
              minCount: minCount,       // Store multiplicity data
              maxCount: maxCount,
              multiplicityDisplay: multiplicity.trim(),  // Store formatted multiplicity
              attrs: {}
            }
          };
          edges.push(edge);
          edgeId++;
        }
      });

      // Create data property nodes and connect them to their domain classes
      let dpId = 1;
      const dataProps = ontologyData.datatype_properties || [];
      dataProps.forEach(prop => {
        if (prop.domain && classNameToId[prop.domain]) {
          const dataPropertyId = `DP${dpId}`;

          // Create data property node
          const domainClassId = classNameToId[prop.domain];
          const domainNode = nodes.find(n => n.data.id === domainClassId);
          let dpX = 150, dpY = 100; // fallback position

          if (domainNode) {
            // Position data property near its domain class
            dpX = domainNode.position.x + 180;
            dpY = domainNode.position.y + (dpId % 3 - 1) * 60; // stagger vertically
          }

          const dpNode = {
            data: {
              id: dataPropertyId,
              label: prop.label || prop.name,
              type: 'dataProperty'
            },
            position: {
              x: dpX,
              y: dpY
            }
          };
          nodes.push(dpNode);

          // Create edge connecting class to data property
          const dpEdge = {
            data: {
              id: `edp${dpId}`,
              source: domainClassId,
              target: dataPropertyId,
              predicate: prop.name,
              type: 'objectProperty', // UI uses objectProperty type for visual connection
              attrs: {}
            }
          };
          edges.push(dpEdge);

          dpId++;
        }
      });

      return { nodes, edges };
    }

    function convertOntologyToCytoscapeWithMetadata(ontologyData, richMetadata) {
      // Convert API ontology format to Cytoscape format with rich metadata
      const nodes = [];
      const edges = [];

      // Create a map of URI to rich metadata
      const classMetadataMap = {};
      richMetadata.classes.forEach(cls => {
        classMetadataMap[cls.iri] = cls;
      });

      const propertyMetadataMap = {};
      richMetadata.properties.forEach(prop => {
        propertyMetadataMap[prop.iri] = prop;
      });

      // Create nodes for classes
      const classes = ontologyData.classes || [];
      const classNameToId = {}; // Map class names to simple IDs

      classes.forEach((cls, index) => {
        // Use the original URI as ID if available, otherwise fall back to simple ID
        const classId = cls.iri || `Class${index + 1}`;
        classNameToId[cls.name] = classId;

        // Get rich metadata for this class
        const richClass = classMetadataMap[cls.uri] || {};
        const displayLabel = richClass.label || cls.label || cls.name;

        // Arrange in a circular layout for better initial positioning
        const totalClasses = classes.length;
        const angle = (2 * Math.PI * index) / totalClasses;
        const radius = Math.max(200, totalClasses * 25);
        const centerX = 400;
        const centerY = 300;

        const node = {
          data: {
            id: classId,
            iri: cls.iri || classId, // Preserve original URI
            label: displayLabel,
            type: 'class',
            attrs: richClass.attrs || {}
          },
          position: {
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle)
          }
        };
        nodes.push(node);
      });

      // Create edges for object properties
      let edgeId = 1;
      const objectProps = ontologyData.object_properties || [];
      objectProps.forEach(prop => {
        if (prop.domain && prop.range && classNameToId[prop.domain] && classNameToId[prop.range]) {
          // Get rich metadata for this property
          const richProp = propertyMetadataMap[prop.uri] || {};
          const displayLabel = richProp.label || prop.label || prop.name;

          // Format multiplicity constraints for display
          const minCount = prop.min_count;
          const maxCount = prop.max_count;
          let multiplicity = '';
          if (minCount !== null && minCount !== undefined || maxCount !== null && maxCount !== undefined) {
            if (minCount === 1 && maxCount === 1) multiplicity = ' (1)';
            else if (minCount === 0 && (maxCount === null || maxCount === undefined)) multiplicity = ' (0..*)';
            else if (minCount === 1 && (maxCount === null || maxCount === undefined)) multiplicity = ' (1..*)';
            else if (minCount === 0 && maxCount === 1) multiplicity = ' (0..1)';
            else if (minCount !== null && minCount !== undefined && maxCount !== null && maxCount !== undefined && minCount === maxCount)
              multiplicity = ` (${minCount})`;
            else if (minCount !== null && minCount !== undefined && maxCount !== null && maxCount !== undefined)
              multiplicity = ` (${minCount}..${maxCount})`;
            else if (minCount !== null && minCount !== undefined) multiplicity = ` (${minCount}..*)`;
            else if (maxCount !== null && maxCount !== undefined) multiplicity = ` (0..${maxCount})`;
          }

          const edge = {
            data: {
              id: `e${edgeId}`,
              source: classNameToId[prop.domain],
              target: classNameToId[prop.range],
              predicate: displayLabel,  // Base predicate name
              label: displayLabel,      // Clean relationship name in middle
              type: 'objectProperty',
              minCount: minCount,       // Store multiplicity data
              maxCount: maxCount,
              multiplicityDisplay: multiplicity.trim(),  // Store formatted multiplicity
              attrs: richProp.attrs || {}
            }
          };
          edges.push(edge);
          edgeId++;
        }
      });

      // Create data property nodes and connect them to their domain classes
      let dpId = 1;
      const dataProps = ontologyData.datatype_properties || [];
      dataProps.forEach(prop => {
        if (prop.domain && classNameToId[prop.domain]) {
          const dataPropertyId = `DP${dpId}`;

          // Get rich metadata for this property
          const richProp = propertyMetadataMap[prop.uri] || {};
          const displayLabel = richProp.label || prop.label || prop.name;

          // Create data property node
          const domainClassId = classNameToId[prop.domain];
          const domainNode = nodes.find(n => n.data.id === domainClassId);
          let dpX = 150, dpY = 100; // fallback position

          if (domainNode) {
            // Position data property near its domain class
            dpX = domainNode.position.x + 180;
            dpY = domainNode.position.y + (dpId % 3 - 1) * 60; // stagger vertically
          }

          const dpNode = {
            data: {
              id: dataPropertyId,
              label: displayLabel,
              type: 'dataProperty',
              attrs: richProp.attrs || {}
            },
            position: {
              x: dpX,
              y: dpY
            }
          };
          nodes.push(dpNode);

          // Create edge connecting class to data property
          const dpEdge = {
            data: {
              id: `edp${dpId}`,
              source: domainClassId,
              target: dataPropertyId,
              predicate: prop.name,
              type: 'objectProperty', // UI uses objectProperty type for visual connection
              attrs: {}
            }
          };
          edges.push(dpEdge);

          dpId++;
        }
      });

      return { nodes, edges };
    }

    function convertCytoscapeToOntology() {
      // Convert current Cytoscape canvas to ontology JSON format
      if (!ontoState.cy) return null;

      const ontologyData = {
        metadata: {
          name: "Ontology from Canvas",
          namespace: activeOntologyIri || `${INSTALLATION_CONFIG.baseUri}/default`,
          created: new Date().toISOString()
        },
        classes: [],
        object_properties: [],
        datatype_properties: []
      };

      // Process nodes
      ontoState.cy.nodes().forEach(node => {
        const data = node.data();
        const type = data.type || 'class';

        if (type === 'class') {
          const attrs = data.attrs || {};

          // Build comprehensive class data with all attributes
          const classData = {
            name: data.id,
            label: data.label || data.id,
            comment: attrs.comment || data.comment || '',
            // Standard ontological properties
            definition: attrs.definition || '',
            example: attrs.example || '',
            identifier: attrs.identifier || '',
            subclassOf: attrs.subclassOf || '',
            equivalentClass: attrs.equivalentClass || '',
            disjointWith: attrs.disjointWith || '',
            // Metadata properties
            creator: attrs.creator || '',
            created_date: attrs.created_date || '',
            last_modified_by: attrs.last_modified_by || '',
            last_modified_date: attrs.last_modified_date || '',
            // Custom properties
            priority: attrs.priority || '',
            status: attrs.status || ''
          };

          // Remove empty attributes to keep JSON clean
          Object.keys(classData).forEach(key => {
            if (classData[key] === '' || classData[key] === null || classData[key] === undefined) {
              delete classData[key];
            }
          });

          ontologyData.classes.push(classData);
        } else if (type === 'dataProperty') {
          const attrs = data.attrs || {};

          // Build comprehensive data property data with all attributes
          const propData = {
            name: data.id,
            label: data.label || data.id,
            comment: attrs.comment || data.comment || '',
            domain: data.domain || '',
            range: data.range || 'string',
            // Standard ontological properties
            definition: attrs.definition || '',
            example: attrs.example || '',
            identifier: attrs.identifier || '',
            subPropertyOf: attrs.subPropertyOf || '',
            equivalentProperty: attrs.equivalentProperty || '',
            // Metadata properties
            creator: attrs.creator || '',
            created_date: attrs.created_date || '',
            last_modified_by: attrs.last_modified_by || '',
            last_modified_date: attrs.last_modified_date || '',
            // Custom properties
            functional: attrs.functional || false
          };

          // Remove empty attributes to keep JSON clean
          Object.keys(propData).forEach(key => {
            if (propData[key] === '' || propData[key] === null || propData[key] === undefined || propData[key] === false) {
              delete propData[key];
            }
          });

          ontologyData.datatype_properties.push(propData);
        }
      });

      // Process edges
      ontoState.cy.edges().forEach(edge => {
        const data = edge.data();
        const sourceType = ontoState.cy.$(`#${data.source}`).data('type') || 'class';
        const targetType = ontoState.cy.$(`#${data.target}`).data('type') || 'class';

        if (sourceType === 'class' && targetType === 'class') {
          const attrs = data.attrs || {};

          // Build comprehensive object property data with all attributes
          const propData = {
            name: data.id,
            label: data.predicate || data.id,
            comment: attrs.comment || data.comment || '',
            domain: data.source,
            range: data.target,
            // Standard ontological properties
            definition: attrs.definition || '',
            example: attrs.example || '',
            identifier: attrs.identifier || '',
            inverseOf: attrs.inverseOf || '',
            subPropertyOf: attrs.subPropertyOf || '',
            equivalentProperty: attrs.equivalentProperty || '',
            propertyType: attrs.propertyType || '',
            // Metadata properties
            creator: attrs.creator || '',
            created_date: attrs.created_date || '',
            last_modified_by: attrs.last_modified_by || '',
            last_modified_date: attrs.last_modified_date || '',
            // Custom properties
            functional: attrs.functional || false,
            inverse_functional: attrs.inverse_functional || false
          };

          // Remove empty attributes to keep JSON clean
          Object.keys(propData).forEach(key => {
            if (propData[key] === '' || propData[key] === null || propData[key] === undefined || propData[key] === false) {
              delete propData[key];
            }
          });

          ontologyData.object_properties.push(propData);
        } else if (sourceType === 'note' && (targetType === 'class' || targetType === 'dataProperty') && data.predicate === 'note_for') {
          // Handle note annotations - add note content as comment on target element
          const noteNode = ontoState.cy.$(`#${data.source}`);
          const targetNode = ontoState.cy.$(`#${data.target}`);

          if (noteNode.length && targetNode.length) {
            // Get ALL note attributes for rich context
            const noteAttrs = noteNode.data('attrs') || {};
            let noteText = noteNode.data('label') || '';

            // Use content from attributes if available (richer than just label)
            if (noteAttrs.content) {
              noteText = noteAttrs.content;
            }

            // Build comprehensive note annotation with all metadata
            const noteType = noteAttrs.noteType || 'Note';
            const creator = noteAttrs.creator || 'Unknown';
            const createdDate = noteAttrs.created_date || '';

            // Create rich note annotation
            let fullNoteText = noteType !== 'Note' ? `[${noteType}] ${noteText}` : noteText;

            // Add metadata for DAS context
            const noteMetadata = [];
            if (creator) noteMetadata.push(`by ${creator}`);
            if (createdDate) noteMetadata.push(`on ${createdDate}`);

            if (noteMetadata.length > 0) {
              fullNoteText += ` (${noteMetadata.join(', ')})`;
            }

            const targetId = data.target;

            // Find the target class/property in our ontology data and add the note as a rich annotation
            if (targetType === 'class') {
              const targetClass = ontologyData.classes.find(cls => cls.name === targetId);
              if (targetClass) {
                // Add as structured note data for DAS to understand note context
                if (!targetClass.notes) targetClass.notes = [];
                targetClass.notes.push({
                  type: noteType,
                  content: noteText,
                  creator: creator,
                  created_date: createdDate,
                  full_text: fullNoteText
                });

                // Also append to comment for backward compatibility
                const existingComment = targetClass.comment || '';
                targetClass.comment = existingComment ? `${existingComment}\nNote: ${fullNoteText}` : fullNoteText;
              }
            } else if (targetType === 'dataProperty') {
              const targetProp = ontologyData.datatype_properties.find(prop => prop.name === targetId);
              if (targetProp) {
                // Add as structured note data for DAS to understand note context
                if (!targetProp.notes) targetProp.notes = [];
                targetProp.notes.push({
                  type: noteType,
                  content: noteText,
                  creator: creator,
                  created_date: createdDate,
                  full_text: fullNoteText
                });

                // Also append to comment for backward compatibility
                const existingComment = targetProp.comment || '';
                targetProp.comment = existingComment ? `${existingComment}\nNote: ${fullNoteText}` : fullNoteText;
              }
            }
          }
        }
      });

      return ontologyData;
    }

    async function loadGraphFromLocalOrAPI(graphIri) {
      try {
        console.log('🔍 loadGraphFromLocalOrAPI called for:', graphIri);

        // Load collapsed imports state for this ontology
        ontoState.collapsedImports = loadCollapsedImports(graphIri);

        // Load visibility state for this ontology
        ontoState.visibilityState = loadVisibilityState(graphIri);

        // Load individual element visibility for this ontology
        ontoState.elementVisibility = loadElementVisibility(graphIri);

        // Check if this is an imported ontology by looking for the pattern in the graph IRI
        const isImportedOntology = graphIri.includes('/onto/') && !graphIri.includes('#layout');

        // First, try to load from local storage for ALL ontologies (including imported ones)
        const json = localStorage.getItem(storageKeyForGraph(graphIri));
        if (json) {
          console.log('🔍 Loading from local storage:', json.substring(0, 200) + '...');
          const data = JSON.parse(json);
          if (data && (data.nodes || data.edges) && data.nodes?.length > 0) {
            if (!ontoState.cy) return;
            ontoState.cy.elements().remove();
            ontoState.cy.add(data.nodes || []);
            ontoState.cy.add(data.edges || []);
            // Ensure all loaded elements have attrs property
            ensureAttributesExist();
            recomputeNextId();

            // Try to load layout from server
            await loadLayoutFromServer(graphIri);

            // Apply saved visibility states
            updateCanvasVisibility();

            console.log('✅ Graph loaded from local storage, preserving current state');
            console.log('📊 Data source:', data.source || 'unknown', 'Timestamp:', data.timestamp ? new Date(data.timestamp).toLocaleString() : 'unknown');
            return;
          }
        }

        // Only fetch from API if local storage is empty or invalid
        if (isImportedOntology) {
          console.log('🔍 No local storage found for imported ontology, fetching from API for rich metadata');
          // Show loading indicator for imported ontologies
          showOntologyLoadingIndicator();
        } else {
          console.log('🔍 No local storage found, fetching from API');
        }

        // If local storage is empty, fetch from API
        console.log('Loading ontology from API:', graphIri);

        // Update progress: Fetching basic ontology data
        if (isImportedOntology) {
          updateOntologyLoadingProgress('Fetching ontology data...', 20);
        }

        const token = localStorage.getItem(tokenKey);
        const apiUrl = `/api/ontology/?graph=${encodeURIComponent(graphIri)}`;
        const response = await fetch(apiUrl, {
          headers: token ? { 'Authorization': `Bearer ${token}` } : {}
        });

        if (response.ok) {
          const result = await response.json();
          const ontologyData = result.data;

          if (ontologyData) {
            console.log('🔍 Loading ontology data from API:', ontologyData);

            // Update progress: Fetching rich metadata
            if (isImportedOntology) {
              updateOntologyLoadingProgress('Fetching rich metadata...', 40);
            }

            // Fetch rich metadata using the same queries as fetchImportGraphSnapshot
            const richMetadata = await fetchRichMetadata(graphIri);
            console.log('🔍 Rich metadata fetched:', richMetadata);

            // Update progress: Converting to graph format
            if (isImportedOntology) {
              updateOntologyLoadingProgress('Converting to graph format...', 60);
            }

            // Convert ontology JSON to Cytoscape format with rich metadata
            const cytoscapeData = convertOntologyToCytoscapeWithMetadata(ontologyData, richMetadata);
            console.log('🔍 Cytoscape data with metadata:', cytoscapeData);

            // Update progress: Loading graph
            if (isImportedOntology) {
              updateOntologyLoadingProgress('Loading graph...', 80);
            }

            if (!ontoState.cy) return;
            ontoState.cy.elements().remove();
            ontoState.cy.add(cytoscapeData.nodes || []);
            ontoState.cy.add(cytoscapeData.edges || []);
            recomputeNextId();

            // Save to local storage for future use with timestamp
            const storageData = {
              nodes: cytoscapeData.nodes || [],
              edges: cytoscapeData.edges || [],
              timestamp: Date.now(),
              source: 'api' // Mark that this data came from API with rich metadata
            };
            localStorage.setItem(storageKeyForGraph(graphIri), JSON.stringify(storageData));

            // Update progress: Loading layout
            if (isImportedOntology) {
              updateOntologyLoadingProgress('Loading layout...', 90);
            }

            // Try to load layout from server, fallback to fit if no layout
            const layoutLoaded = await loadLayoutFromServer(graphIri);
            if (!layoutLoaded) {
              requestAnimationFrame(() => { ontoState.cy.fit(); });
            }

            // Apply saved visibility states
            updateCanvasVisibility();

            // Complete loading
            if (isImportedOntology) {
              updateOntologyLoadingProgress('Complete!', 100);
              setTimeout(() => {
                hideOntologyLoadingIndicator();
                // Apply a nice layout after loading
                setTimeout(() => {
                  runAdvancedLayout('cose'); // Use force-directed layout for imported ontologies
                }, 200);
              }, 500);
            }

            console.log('Ontology loaded from API with', cytoscapeData.nodes?.length || 0, 'nodes and', cytoscapeData.edges?.length || 0, 'edges');
          }
        } else {
          console.error('Failed to load ontology from API:', response.status, response.statusText);
          if (isImportedOntology) {
            hideOntologyLoadingIndicator();
          }
        }

        // Refresh overlay imports to restore visible imported ontologies
        await overlayImportsRefresh();

        // Apply saved visibility states
        updateCanvasVisibility();

      } catch (err) {
        console.error('Error loading ontology:', err);
        // Hide loading indicator on error
        hideOntologyLoadingIndicator();
      }
    }

    // Ontology toolbar events and import handling
    (function () {
      document.addEventListener('click', async (e) => {
        if (e.target === qs('#ontoLayoutBtn')) {
          const selectedLayout = qs('#ontoLayoutSelector').value;
          runAdvancedLayout(selectedLayout);
        } else if (e.target === qs('#ontoQuickCoseBtn')) {
          runAdvancedLayout('cose');
        } else if (e.target === qs('#ontoQuickDagreBtn')) {
          runAdvancedLayout('dagre');
        } else if (e.target === qs('#ontoForceRefreshBtn')) {
          if (activeOntologyIri) {
            // Clear local storage and force reload from API
            localStorage.removeItem(storageKeyForGraph(activeOntologyIri));
            loadGraphFromLocalOrAPI(activeOntologyIri);
          }
        } else if (e.target === qs('#ontoClearCacheBtn')) {
          // Clear all ontology localStorage and reload page
          if (confirm('Clear all cached ontology data? This will reload the page and fetch everything fresh from the server.')) {
            console.log('🧹 Clearing ontology localStorage cache...');

            // Clear all ontology-related localStorage
            Object.keys(localStorage).forEach(key => {
              if (key.includes('onto_')) {
                localStorage.removeItem(key);
                console.log('🧹 Removed:', key);
              }
            });

            console.log('🧹 Cache cleared, reloading page...');
            location.reload();
          }
        } else if (e.target === qs('#ontoFitBtn')) {
          try { if (ontoState.cy) ontoState.cy.fit(undefined, 20); } catch (_) { }
        } else if (e.target === qs('#ontoFullscreenBtn')) {
          try {
            // Use browser fullscreen instead of element fullscreen
            // Auto-hide main tree view for more screen real estate
            const treePanel = qs('#treePanel');
            const wasTreeCollapsed = treePanel?.classList.contains('tree-dock-collapsed');

            if (!document.fullscreenElement) {
              // Entering fullscreen - hide tree if not already collapsed
              if (treePanel && !wasTreeCollapsed) {
                treePanel.classList.add('tree-dock-collapsed');
                // Store that we auto-collapsed it
                treePanel.setAttribute('data-auto-collapsed', 'true');
              }
              document.documentElement.requestFullscreen?.();
            } else {
              // Exiting fullscreen - restore tree if we auto-collapsed it
              if (treePanel && treePanel.getAttribute('data-auto-collapsed') === 'true') {
                treePanel.classList.remove('tree-dock-collapsed');
                treePanel.removeAttribute('data-auto-collapsed');
              }
              document.exitFullscreen?.();
            }
          } catch (_) { }
        } else if (e.target === qs('#ontoSaveBtn')) {
          try {
            if (!activeOntologyIri) { alert('Select an ontology to save.'); return; }
            if (!ontoState.cy) { alert('No ontology data to save.'); return; }

            console.log('💾 Starting ontology save operation...');
            console.log('💾 Active ontology IRI:', activeOntologyIri);

            // Convert current canvas to ontology JSON format
            const ontologyData = convertCytoscapeToOntology();
            console.log('💾 Converted ontology data:', ontologyData);
            console.log('💾 Number of nodes:', ontologyData.nodes?.length || 0);
            console.log('💾 Number of edges:', ontologyData.edges?.length || 0);

            // Save ontology data to server
            console.log('💾 Sending ontology data to server...');
            console.warn('🔥 USING DEPRECATED API: PUT /api/ontology/ - Consider migrating to Turtle save. See docs/architecture/MULTI_ENDPOINT_ONTOLOGY_ISSUE.md');
            const response = await authenticatedFetch(`/api/ontology/?graph=${encodeURIComponent(activeOntologyIri)}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(ontologyData)
            });

            console.log('💾 Server response status:', response.status);
            console.log('💾 Server response ok:', response.ok);

            if (response.ok) {
              console.log('✅ Ontology data saved successfully!');

              // Also save layout data
              console.log('💾 Saving layout data...');
              const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({ data: n.data(), position: n.position() }));
              const edges = ontoState.cy.edges().filter(e => !e.hasClass('imported')).map(e => ({ data: e.data() }));
              console.log('💾 Layout nodes:', nodes.length);
              console.log('💾 Layout edges:', edges.length);

              await saveLayoutToServer(activeOntologyIri, nodes, edges);
              console.log('✅ Layout data saved successfully!');
              console.log('🎉 Complete save operation successful!');

              alert('Ontology and layout saved successfully!');
            } else {
              const errorData = await response.json().catch(() => ({}));
              console.error('❌ Save failed:', errorData);
              console.error('❌ Response status:', response.status);
              console.error('❌ Response text:', await response.text().catch(() => 'Could not read response text'));
              alert('Save failed: ' + (errorData.detail || response.status));
            }
          } catch (err) {
            console.error('❌ Save error:', err);
            alert('Save error: ' + err.message);
          }
        } else if (e.target.closest && e.target.closest('#ontoLinkIdenticalBtn')) {
          // Preview: count equivalent class links that will be saved (no UI edges yet)
          try {
            if (!activeOntologyIri || !ontoState.cy) return;
            const pairs = await computeLinkedByPairs(activeOntologyIri);
            if (pairs.length) alert(`Will save ${pairs.length} owl:equivalentClass links on Save.`);
            else alert('No identical classes found');
          } catch (err) { console.error(err); alert('Link check failed'); }
        } else if (e.target === qs('#ontoExportBtn')) {
          await exportOntologyJSON();
        } else if (e.target === qs('#ontoImportBtn')) {
          const inp = qs('#ontoImportFile'); if (inp) inp.click();
        } else if (e.target === qs('#treeToggle') || e.target.closest('#treeToggle')) {
          // Main tree dock toggle
          const treePanel = qs('#treePanel');
          if (!treePanel) return;
          const collapsed = treePanel.classList.toggle('tree-dock-collapsed');
          try { localStorage.setItem('main_tree_collapsed', collapsed ? '1' : '0'); } catch (_) { }
        } else if (e.target === qs('#ontoTreeToggle') || e.target === qs('#ontoTreeToggleIcon')) {
          const sec = qs('#wb-ontology');
          if (!sec) return;
          const collapsed = sec.classList.toggle('onto-tree-collapsed');
          // CSS rotation handles the chevron direction automatically
          try { localStorage.setItem('onto_tree_collapsed', collapsed ? '1' : '0'); } catch (_) { }
          requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
        } else if (e.target === qs('#ontoPropsToggle') || e.target.closest('#ontoPropsToggle')) {
          const sec = qs('#wb-ontology');
          if (!sec) return;
          const collapsed = sec.classList.toggle('onto-props-collapsed');
          // CSS rotation handles the chevron direction automatically
          try { localStorage.setItem('onto_props_collapsed', collapsed ? '1' : '0'); } catch (_) { }
          // Wait for reflow before resizing Cytoscape so it fits the new grid
          requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
        } else if (e.target === qs('#propSaveBtn')) {
          // Save properties
          try {
            if (!ontoState.cy) return;
            const sel = ontoState.cy.$(':selected');
            const nameEl = qs('#propName');
            const attrs = getCurrentAttributes();

            if (sel.length === 1 && sel[0].isNode()) {
              const n = sel[0];
              n.data('label', nameEl.value.trim() || n.data('label'));
              // Type is read-only, don't change it

              // Add modification metadata to attributes
              const updatedAttrs = updateModificationMetadata(attrs);
              n.data('attrs', updatedAttrs);

              // Force canvas refresh for notes to update styling
              if (n.data('type') === 'note') {
                n.style('background-color', getNoteTypeStyle(attrs.noteType || 'Note').backgroundColor);
                n.style('border-color', getNoteTypeStyle(attrs.noteType || 'Note').borderColor);
                n.style('color', getNoteTypeStyle(attrs.noteType || 'Note').textColor);
              }
            } else if (sel.length === 1 && sel[0].isEdge()) {
              const ed = sel[0];
              ed.data('predicate', nameEl.value.trim() || ed.data('predicate'));
              // Type is read-only, don't change it

              // Add modification metadata to attributes
              const updatedAttrs = updateModificationMetadata(attrs);
              ed.data('attrs', updatedAttrs);
            } else {
              // Model-level metadata save
              const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
              const modelName = nameEl.value.trim() || 'Ontology Model';

              // FIXED: Make model metadata ontology-specific, not just project-specific
              const ontologyKey = activeOntologyIri ? activeOntologyIri.split('/').pop() : 'default';
              const modelNameKey = `onto_model_name__${pid}__${ontologyKey}`;
              const modelAttrsKey = `onto_model_attrs__${pid}__${ontologyKey}`;

              // HANDLE IMPORTS: Save imports field to separate localStorage key
              if (attrs.imports !== undefined && activeOntologyIri) {
                const importsKey = 'onto_imports__' + encodeURIComponent(activeOntologyIri);
                try {
                  // Parse imports from textarea (one per line, filter empty lines and clean syntax)
                  const rawImports = attrs.imports || '';
                  const importLines = rawImports.split(/[\n\r]+/)
                    .map(line => {
                      let clean = line.trim();
                      // Remove Turtle syntax artifacts
                      if (clean.startsWith('@')) clean = clean.substring(1);
                      if (clean.startsWith('<') && clean.endsWith('>')) clean = clean.slice(1, -1);
                      return clean;
                    })
                    .filter(line => line.length > 0 && line.startsWith('http'));

                  // Save imports to their specific localStorage key
                  localStorage.setItem(importsKey, JSON.stringify(importLines));
                  console.log(`📋 Updated imports for ${activeOntologyIri}:`, importLines);

                  // Remove imports from attrs since it's stored separately
                  delete attrs.imports;
                } catch (_) {
                  console.log('⚠️ Error processing imports field');
                }
              }

              // Save to localStorage with ontology-specific keys
              localStorage.setItem(modelNameKey, modelName);
              localStorage.setItem(modelAttrsKey, JSON.stringify(attrs));

              // SAVE TO BACKEND RDF STORE
              if (activeOntologyIri) {
                console.log('💾 Saving model-level metadata to RDF store...');
                saveModelMetadataToBackend(activeOntologyIri, modelName, attrs);
              } else {
                console.log('⚠️ No active ontology IRI for saving model metadata');
              }
            }
            refreshOntologyTree();
            persistOntologyToLocalStorage();
            const st = qs('#propSaveStatus'); if (st) { st.textContent = 'Saved'; setTimeout(() => { const s = qs('#propSaveStatus'); if (s) s.textContent = ''; }, 1000); }
          } catch (_) {
            const st = qs('#propSaveStatus'); if (st) { st.textContent = 'Error'; setTimeout(() => { const s = qs('#propSaveStatus'); if (s) s.textContent = ''; }, 1200); }
          }
        } else if (e.target === qs('#addAttrBtn')) {
          // Add custom attribute
          const key = prompt('Enter attribute name:');
          if (key && key.trim()) {
            const container = qs('#propAttrsContainer');
            if (container) {
              const attrDiv = createAttributeField(key.trim(), { type: 'text', label: key.trim() }, '');
              container.appendChild(attrDiv);
            }
          }
        } else if (e.target === qs('#resetAttrsBtn')) {
          // Reset to template
          let objectType = 'class';
          if (ontoState.cy) {
            const sel = ontoState.cy.$(':selected');
            if (sel.length === 1) {
              objectType = sel[0].data('type') || 'class';
            } else {
              objectType = 'model';
            }
          }
        } else if (e.target.hasAttribute('data-multiplicity')) {
          // Handle multiplicity preset buttons
          const preset = e.target.getAttribute('data-multiplicity');
          applyMultiplicityPreset(preset);
        } else if (e.target.hasAttribute('data-enumeration')) {
          // Handle enumeration preset buttons
          const preset = e.target.getAttribute('data-enumeration');
          applyEnumerationPreset(preset);
          updateAttributeEditor(objectType, {});
        }
      });
      // Add input event listeners for all constraint fields
      const minCountInput = qs('#propMinCount');
      const maxCountInput = qs('#propMaxCount');
      const datatypeSelect = qs('#propDatatypeConstraint');
      const enumerationTextarea = qs('#propEnumerationValues');

      if (minCountInput) {
        minCountInput.addEventListener('input', () => {
          updateMultiplicityDisplay();
          applyMultiplicityToEdge();
        });
      }
      if (maxCountInput) {
        maxCountInput.addEventListener('input', () => {
          updateMultiplicityDisplay();
          applyMultiplicityToEdge();
        });
      }
      if (datatypeSelect) {
        datatypeSelect.addEventListener('change', () => {
          updateDatatypeDisplay();
          applyDatatypeToEdge();
        });
      }
      if (enumerationTextarea) {
        enumerationTextarea.addEventListener('input', () => {
          updateEnumerationDisplay();
          applyEnumerationToEdge();
        });
      }

      // Add input event listeners for precise positioning
      const posXInput = qs('#propPosX');
      const posYInput = qs('#propPosY');
      if (posXInput) {
        posXInput.addEventListener('input', applyPositionFromInputs);
        posXInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            applyPositionFromInputs();
            posXInput.blur();
          }
        });
      }
      if (posYInput) {
        posYInput.addEventListener('input', applyPositionFromInputs);
        posYInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            applyPositionFromInputs();
            posYInput.blur();
          }
        });
      }

      // CAD-like keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // Only handle shortcuts when ontology workbench is active
        const isOntologyActive = document.querySelector('#wb-ontology.workbench.active');
        if (!isOntologyActive || !ontoState.cy) return;

        // Prevent shortcuts when typing in inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        const isCtrl = e.ctrlKey || e.metaKey;
        const isShift = e.shiftKey;

        switch (e.key.toLowerCase()) {
          case 's':
            if (isCtrl) {
              // Ctrl+S already handled by existing save
            } else if (!isCtrl) {
              // S alone = toggle snap-to-grid (like CAD tools)
              e.preventDefault();
              toggleSnapToGrid();
            }
            break;

          case 'z':
            if (isCtrl && !isShift) {
              // Ctrl+Z = Undo
              e.preventDefault();
              performUndo();
            } else if (isCtrl && isShift) {
              // Ctrl+Shift+Z = Redo (alternative)
              e.preventDefault();
              performRedo();
            }
            break;

          case 'y':
            if (isCtrl) {
              // Ctrl+Y = Redo
              e.preventDefault();
              performRedo();
            }
            break;

          case 'c':
            if (isCtrl) {
              // Ctrl+C = Copy
              e.preventDefault();
              copySelectedElements();
            }
            break;

          case 'v':
            if (isCtrl) {
              // Ctrl+V = Paste
              e.preventDefault();
              pasteElements();
            }
            break;

          case 'a':
            if (isCtrl) {
              // Ctrl+A = Select all
              e.preventDefault();
              if (ontoState.cy) {
                ontoState.cy.elements().select();
                showTemporaryMessage(`Selected all elements`);
              }
            }
            break;

          case 'escape':
            // Escape = Clear selection (like CAD)
            if (ontoState.cy) {
              ontoState.cy.$(':selected').unselect();
              showTemporaryMessage('Selection cleared');
            }
            break;

          case 'f':
            if (isCtrl) {
              // Ctrl+F = Zoom to fit selected elements (like CAD zoom to selection)
              e.preventDefault();
              zoomToSelection();
            } else {
              // F = Fit to view (like CAD fit all)
              ontoState.cy.fit(undefined, 20);
              showTemporaryMessage('Fit to view');
            }
            break;

          case '1':
            if (isCtrl) {
              // Ctrl+1 = 1:1 zoom (100%)
              e.preventDefault();
              zoomTo100Percent();
            }
            break;

          // Alignment shortcuts (like CAD align tools)
          case 'l':
            if (isCtrl) {
              e.preventDefault();
              alignElements('left');
            }
            break;
          case 'r':
            if (isCtrl) {
              e.preventDefault();
              alignElements('right');
            }
            break;
          case 'm':
            if (isCtrl) {
              e.preventDefault();
              alignElements('center');
            }
            break;
          case 't':
            if (isCtrl) {
              e.preventDefault();
              alignElements('top');
            }
            break;
          case 'b':
            if (isCtrl) {
              e.preventDefault();
              alignElements('bottom');
            }
            break;
          case 'h':
            if (isCtrl && isShift) {
              e.preventDefault();
              alignElements('distribute-horizontal');
            }
            break;
          case 'v':
            if (isCtrl && isShift) {
              e.preventDefault();
              alignElements('distribute-vertical');
            }
            break;
        }
      });

      // Keep Cytoscape sized correctly in fullscreen and update button title
      document.addEventListener('fullscreenchange', () => {
        const btn = qs('#ontoFullscreenBtn');
        if (btn) btn.title = document.fullscreenElement ? 'Exit fullscreen' : 'Enter fullscreen';

        // Handle auto-collapsed tree restoration when exiting fullscreen via F11 or other methods
        if (!document.fullscreenElement) {
          const treePanel = qs('#treePanel');
          if (treePanel && treePanel.getAttribute('data-auto-collapsed') === 'true') {
            treePanel.classList.remove('tree-dock-collapsed');
            treePanel.removeAttribute('data-auto-collapsed');
          }
        }

        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      const header = qs('#ontoTreeHeader');
      if (header) header.addEventListener('dblclick', (e) => {
        const toggleBtn = qs('#ontoTreeToggle');
        if (toggleBtn) toggleBtn.click();
      });
      const propsHeader = qs('#ontoPropsHeader');
      if (propsHeader) propsHeader.addEventListener('dblclick', (e) => {
        const toggleBtn = qs('#ontoPropsToggle');
        if (toggleBtn) toggleBtn.click();
      });

      // Visibility toggle button (now handled in renderOntologyTree where button is created)

      // Type is now read-only, no event listener needed
      const fileInput = () => qs('#ontoImportFile');
      document.addEventListener('change', async (e) => {
        if (e.target === fileInput()) {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          try {
            const text = await file.text();
            const json = JSON.parse(text);
            await importOntologyJSON(json);
          } catch (_) {
            alert('Invalid ontology JSON');
          } finally {
            e.target.value = '';
          }
        }
      });
    })();

    window.addEventListener('resize', () => { if (ontoState.cy) ontoState.cy.resize(); });

    function getSampleProject() {
      return {
        id: 'demo',
        name: 'Sample Project',
        ontology: {
          base: { id: 'BASE-ONTO', name: 'Base Ontology', versions: ['1.0', '1.1'] },
          systems: {
            base: { id: 'SYS-BASE', name: 'Systems Ontology', versions: ['0.1', '0.2'] },
            imports: [
              { id: 'GEO', name: 'Geo Ontology', versions: ['2023-09', '2024-02'] },
              { id: 'RELY', name: 'Reliability Ontology', versions: ['1.0'] },
              { id: 'ORG', name: 'Organization Ontology', versions: ['0.9'] }
            ]
          }
        },
        requirements: [
          { id: 'R-001', title: 'The system shall ingest documents and extract requirements.' },
          { id: 'R-002', title: 'The system should support ontology-based tagging of entities.' },
          { id: 'R-003', title: 'The system must store outputs in RDF, GraphDB, and Vector Store.' }
        ],
        documents: {
          requirements: [
            { id: 'RD-01', name: 'Concept of Operations.pdf' },
            { id: 'RD-02', name: 'Capabilities Development Document.docx' }
          ],
          knowledge: [
            { id: 'KD-01', name: 'Requirements Development Instructions.md' },
            { id: 'KD-02', name: 'Industry Spec MIL-STD-961E.pdf' }
          ]
        },
        artifacts: [
          { id: 'ART-01', name: 'White Paper - Initial Draft.md' },
          { id: 'ART-02', name: 'System Architecture Diagram.png' }
        ]
      };
    }

    function toggleNode(li) {
      const exp = li.getAttribute('aria-expanded');
      if (exp === null) return;
      li.setAttribute('aria-expanded', exp === 'true' ? 'false' : 'true');
    }

    function selectNode(li) {
      qsa('.node-row').forEach(r => r.classList.remove('selected'));
      const row = li.querySelector('.node-row');
      if (row) row.classList.add('selected');
    }

    function highlightTreeItem(elementId, elementType) {
      // Clear current tree selection
      qsa('.node-row').forEach(r => r.classList.remove('selected'));

      // Find the corresponding tree item
      let treeItem = null;
      if (elementType === 'node') {
        treeItem = qs(`li[data-node-id="${elementId}"]`);
      } else if (elementType === 'edge') {
        treeItem = qs(`li[data-edge-id="${elementId}"]`);
      }

      if (treeItem) {
        const row = treeItem.querySelector('.node-row');
        if (row) {
          row.classList.add('selected');
          // Scroll the tree item into view
          row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }
    }

    function toggleVisibility(type) {
      if (ontoState.visibilityState.hasOwnProperty(type)) {
        ontoState.visibilityState[type] = !ontoState.visibilityState[type];

        // Save visibility state
        if (activeOntologyIri) {
          saveVisibilityState(activeOntologyIri, ontoState.visibilityState);
        }

        updateCanvasVisibility();
        refreshOntologyTree();
      }
    }

    function updateCanvasVisibility() {
      if (!ontoState.cy) return;

      console.log('🔍 Updating canvas visibility:', ontoState.visibilityState);

      // Update node visibility based on type and visibility state
      ontoState.cy.nodes().forEach(node => {
        const nodeType = node.data('type') || 'class';
        const isImported = node.hasClass('imported');
        const nodeId = node.id();

        let shouldShow = true;

        if (isImported) {
          shouldShow = ontoState.visibilityState.imported;
        } else if (nodeType === 'class') {
          shouldShow = ontoState.visibilityState.classes;
        } else if (nodeType === 'dataProperty') {
          shouldShow = ontoState.visibilityState.dataProperties;
        } else if (nodeType === 'note') {
          shouldShow = ontoState.visibilityState.notes;
        }

        // If global visibility is enabled, check individual element visibility
        // If global visibility is disabled, hide all elements of this type regardless of individual settings
        if (shouldShow && ontoState.elementVisibility.hasOwnProperty(nodeId)) {
          shouldShow = ontoState.elementVisibility[nodeId];
        }

        if (shouldShow) {
          node.show();
        } else {
          node.hide();
        }
      });

      // Update edge visibility
      ontoState.cy.edges().forEach(edge => {
        const shouldShow = ontoState.visibilityState.edges;
        if (shouldShow) {
          edge.show();
        } else {
          edge.hide();
        }
      });
    }

    function showVisibilityMenu() {
      const menu = document.createElement('div');
      menu.className = 'visibility-menu';
      menu.style.cssText = `
        position: fixed;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        min-width: 200px;
      `;

      const types = [
        { key: 'classes', label: 'Classes' },
        { key: 'dataProperties', label: 'Data Properties' },
        { key: 'notes', label: 'Notes' },
        { key: 'edges', label: 'Relationships' },
        { key: 'imported', label: 'Imported Elements' }
      ];

      // Add Show All / Hide All buttons
      const showAllBtn = document.createElement('div');
      showAllBtn.style.cssText = `
        display: flex;
        align-items: center;
        padding: 6px 8px;
        cursor: pointer;
        border-radius: 4px;
        border-bottom: 1px solid var(--border);
        margin-bottom: 4px;
      `;
      showAllBtn.innerHTML = '<span style="color: var(--text); font-weight: bold;">Show All Classes</span>';
      showAllBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (!ontoState.cy) return;
        ontoState.cy.nodes().forEach(node => {
          if (node.data('type') === 'class' || node.data('type') === 'note') {
            node.show();
          }
        });
        refreshOntologyTree();
      });
      menu.appendChild(showAllBtn);

      const hideAllBtn = document.createElement('div');
      hideAllBtn.style.cssText = `
        display: flex;
        align-items: center;
        padding: 6px 8px;
        cursor: pointer;
        border-radius: 4px;
        margin-bottom: 4px;
      `;
      hideAllBtn.innerHTML = '<span style="color: var(--text); font-weight: bold;">Hide All Classes</span>';
      hideAllBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (!ontoState.cy) return;
        ontoState.cy.nodes().forEach(node => {
          if (node.data('type') === 'class' || node.data('type') === 'note') {
            node.hide();
          }
        });
        refreshOntologyTree();
      });
      menu.appendChild(hideAllBtn);

      types.forEach(type => {
        const item = document.createElement('div');
        item.style.cssText = `
          display: flex;
          align-items: center;
          padding: 6px 8px;
          cursor: pointer;
          border-radius: 4px;
        `;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = ontoState.visibilityState[type.key];
        checkbox.style.marginRight = '8px';

        const label = document.createElement('span');
        label.textContent = type.label;
        label.style.color = 'var(--text)';

        item.appendChild(checkbox);
        item.appendChild(label);

        item.addEventListener('click', (e) => {
          e.stopPropagation();
          checkbox.checked = !checkbox.checked;
          toggleVisibility(type.key);
        });

        menu.appendChild(item);
      });

      // Position menu near the button
      const button = qs('#ontoVisibilityToggle');
      const rect = button.getBoundingClientRect();
      menu.style.left = (rect.left - 200) + 'px';
      menu.style.top = (rect.bottom + 4) + 'px';

      document.body.appendChild(menu);

      // Close menu when clicking outside
      const closeMenu = (e) => {
        if (!menu.contains(e.target) && e.target !== button) {
          document.body.removeChild(menu);
          document.removeEventListener('click', closeMenu);
        }
      };

      setTimeout(() => {
        document.addEventListener('click', closeMenu);
      }, 100);
    }

    function toggleImportCollapse(importIri) {
      if (!ontoState.cy || !activeOntologyIri) return;

      const isCollapsed = ontoState.collapsedImports.has(importIri);

      if (isCollapsed) {
        // Expand: show all imported nodes and their edges, remove pseudo-node
        ontoState.collapsedImports.delete(importIri);
        const importedNodes = ontoState.cy.nodes(`[importSource="${importIri}"]`).filter(n => !n.data('isPseudo'));
        const importedEdges = ontoState.cy.edges(`[importSource="${importIri}"]`).filter(e => !e.data('isPseudo'));
        const pseudoNode = ontoState.cy.nodes(`#pseudo-import-${CSS.escape(importIri)}`);
        const pseudoEdges = ontoState.cy.edges(`[importSource="${importIri}"][isPseudo="true"]`);

        // Remove pseudo-node and its pseudo-edges
        pseudoNode.remove();
        pseudoEdges.remove();

        // Show all original imported nodes and edges
        importedNodes.show();
        importedEdges.show();
        console.log('🔍 Expanded import:', importIri, importedNodes.length, 'nodes,', importedEdges.length, 'edges');
      } else {
        // Collapse: create pseudo-node and hide all imported nodes, but maintain equivalence edges
        ontoState.collapsedImports.add(importIri);
        const importedNodes = ontoState.cy.nodes(`[importSource="${importIri}"]`).filter(n => !n.data('isPseudo'));
        const importedEdges = ontoState.cy.edges(`[importSource="${importIri}"]`).filter(e => !e.data('isPseudo'));

        if (importedNodes.length > 0) {
          // Get import name from localStorage or use IRI tail
          const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(activeOntologyIri || '')) || '[]');
          const importData = imports.find(imp => imp.iri === importIri);
          const importName = importData?.label || importIri.split('/').pop() || importIri;

          // Calculate center position of imported nodes
          const bbox = importedNodes.boundingBox();
          const centerX = bbox.x1 + (bbox.w / 2);
          const centerY = bbox.y1 + (bbox.h / 2);

          // Create pseudo-node representing the entire import
          const pseudoNodeId = `pseudo-import-${CSS.escape(importIri)}`;
          const pseudoNode = ontoState.cy.add({
            group: 'nodes',
            data: {
              id: pseudoNodeId,
              label: importName,
              type: 'import',
              importSource: importIri,
              isPseudo: true,
              attrs: {}
            },
            position: { x: centerX, y: centerY },
            classes: 'imported pseudo-import'
          });

          // Add position saving for pseudo-node
          pseudoNode.on('free', () => {
            const pseudoPositions = loadPseudoNodePositions(activeOntologyIri);
            pseudoPositions[pseudoNodeId] = { x: pseudoNode.position('x'), y: pseudoNode.position('y') };
            savePseudoNodePositions(activeOntologyIri, pseudoPositions);
          });

          // Hide all imported nodes
          importedNodes.hide();

          // Create equivalence edges from pseudo-node to base ontology classes
          const equivalenceEdges = importedEdges.filter(edge => {
            const source = edge.source();
            const target = edge.target();
            const isEquivalence = edge.data('predicate') === 'equivalentClass';
            const connectsToBase = !source.hasClass('imported') || !target.hasClass('imported');
            return isEquivalence && connectsToBase;
          });

          // Create new equivalence edges from pseudo-node to base classes
          equivalenceEdges.forEach(edge => {
            const baseNode = edge.source().hasClass('imported') ? edge.target() : edge.source();
            const equivEdgeId = `pseudo-equiv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

            ontoState.cy.add({
              group: 'edges',
              data: {
                id: equivEdgeId,
                source: pseudoNodeId,
                target: baseNode.id(),
                predicate: 'equivalentClass',
                type: 'objectProperty',
                importSource: importIri,
                isPseudo: true,
                attrs: {}
              },
              classes: 'imported imported-equivalence pseudo-equivalence'
            });
          });

          // Hide original edges
          importedEdges.hide();

          console.log('🔍 Collapsed import:', importIri, 'created pseudo-node with', equivalenceEdges.length, 'equivalence edges');
        }
      }

      // Save the collapsed state
      saveCollapsedImports(activeOntologyIri, ontoState.collapsedImports);

      // Update the tree to reflect the change
      refreshOntologyTree();
    }

    function toggleAllImportsCollapse() {
      if (!ontoState.cy || !activeOntologyIri) return;

      const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(activeOntologyIri || '')) || '[]');
      const allCollapsed = imports.every(imp => ontoState.collapsedImports.has(imp));

      if (allCollapsed) {
        // Expand all
        imports.forEach(imp => {
          ontoState.collapsedImports.delete(imp);
          const importedNodes = ontoState.cy.nodes(`[importSource="${imp}"]`).filter(n => !n.data('isPseudo'));
          const importedEdges = ontoState.cy.edges(`[importSource="${imp}"]`).filter(e => !e.data('isPseudo'));
          const pseudoNode = ontoState.cy.nodes(`#pseudo-import-${CSS.escape(imp)}`);
          const pseudoEdges = ontoState.cy.edges(`[importSource="${imp}"][isPseudo="true"]`);

          // Remove pseudo-node and its pseudo-edges
          pseudoNode.remove();
          pseudoEdges.remove();

          // Show all original imported nodes and edges
          importedNodes.show();
          importedEdges.show();
        });
        console.log('🔍 Expanded all imports');
      } else {
        // Collapse all
        imports.forEach(imp => {
          ontoState.collapsedImports.add(imp);
          const importedNodes = ontoState.cy.nodes(`[importSource="${imp}"]`).filter(n => !n.data('isPseudo'));
          const importedEdges = ontoState.cy.edges(`[importSource="${imp}"]`).filter(e => !e.data('isPseudo'));

          if (importedNodes.length > 0) {
            // Get import name from localStorage or use IRI tail
            const importData = imports.find(importData => importData.iri === imp);
            const importName = importData?.label || imp.split('/').pop() || imp;

            // Calculate center position of imported nodes
            const bbox = importedNodes.boundingBox();
            const centerX = bbox.x1 + (bbox.w / 2);
            const centerY = bbox.y1 + (bbox.h / 2);

            // Create pseudo-node representing the entire import
            const pseudoNodeId = `pseudo-import-${CSS.escape(imp)}`;
            const pseudoNode = ontoState.cy.add({
              group: 'nodes',
              data: {
                id: pseudoNodeId,
                label: importName,
                type: 'import',
                importSource: imp,
                isPseudo: true,
                attrs: {}
              },
              position: { x: centerX, y: centerY },
              classes: 'imported pseudo-import'
            });

            // Add position saving for pseudo-node
            pseudoNode.on('free', () => {
              const pseudoPositions = loadPseudoNodePositions(activeOntologyIri);
              pseudoPositions[pseudoNodeId] = { x: pseudoNode.position('x'), y: pseudoNode.position('y') };
              savePseudoNodePositions(activeOntologyIri, pseudoPositions);
            });

            // Hide all imported nodes
            importedNodes.hide();

            // Create equivalence edges from pseudo-node to base ontology classes
            const equivalenceEdges = importedEdges.filter(edge => {
              const source = edge.source();
              const target = edge.target();
              const isEquivalence = edge.data('predicate') === 'equivalentClass';
              const connectsToBase = !source.hasClass('imported') || !target.hasClass('imported');
              return isEquivalence && connectsToBase;
            });

            // Create new equivalence edges from pseudo-node to base classes
            equivalenceEdges.forEach(edge => {
              const baseNode = edge.source().hasClass('imported') ? edge.target() : edge.source();
              const equivEdgeId = `pseudo-equiv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

              ontoState.cy.add({
                group: 'edges',
                data: {
                  id: equivEdgeId,
                  source: pseudoNodeId,
                  target: baseNode.id(),
                  predicate: 'equivalentClass',
                  type: 'objectProperty',
                  importSource: imp,
                  isPseudo: true,
                  attrs: {}
                },
                classes: 'imported imported-equivalence pseudo-equivalence'
              });
            });

            // Hide original edges
            importedEdges.hide();
          }
        });
        console.log('🔍 Collapsed all imports');
      }

      // Save the collapsed state
      saveCollapsedImports(activeOntologyIri, ontoState.collapsedImports);

      // Update the tree to reflect the change
      refreshOntologyTree();
    }

    function handleKey(e, li) {
      const LEFT = 37, UP = 38, RIGHT = 39, DOWN = 40, ENTER = 13, SPACE = 32;
      const exp = li.getAttribute('aria-expanded');
      switch (e.keyCode) {
        case LEFT:
          if (exp === 'true') { toggleNode(li); } else { focusParent(li); }
          e.preventDefault(); break;
        case RIGHT:
          if (exp === 'false') { toggleNode(li); } else { focusFirstChild(li); }
          e.preventDefault(); break;
        case UP:
          focusPrev(li); e.preventDefault(); break;
        case DOWN:
          focusNext(li); e.preventDefault(); break;
        case ENTER:
        case SPACE:
          selectNode(li); handleTreeSelection(li).catch(console.error); e.preventDefault(); break;
      }
    }

    function focusParent(li) {
      const parentLi = li.parentElement.closest('li[role="treeitem"]');
      if (parentLi) (parentLi.querySelector('.node-row') || parentLi).focus();
    }
    function focusFirstChild(li) {
      const child = li.querySelector('ul[role="group"] > li[role="treeitem"] .node-row');
      if (child) child.focus();
    }
    function visibleTreeItems() {
      const acc = [];
      function addVisible(container) {
        const items = Array.from(container.children).filter(n => n.matches('li[role="treeitem"]'));
        items.forEach(li => {
          acc.push(li);
          const exp = li.getAttribute('aria-expanded');
          if (exp === 'true') {
            const group = li.querySelector('ul[role="group"]');
            if (group) addVisible(group);
          }
        });
      }
      addVisible(qs('#treeRoot'));
      return acc;
    }
    function focusPrev(li) {
      const list = visibleTreeItems();
      const idx = list.indexOf(li);
      if (idx > 0) (list[idx - 1].querySelector('.node-row') || list[idx - 1]).focus();
    }
    function focusNext(li) {
      const list = visibleTreeItems();
      const idx = list.indexOf(li);
      if (idx >= 0 && idx < list.length - 1) (list[idx + 1].querySelector('.node-row') || list[idx + 1]).focus();
    }

    // Boot
    initAuth();

    // Global error handler for unhandled authentication errors
    window.addEventListener('unhandledrejection', (event) => {
      if (event.reason && event.reason.message === 'Authentication required') {
        console.warn('Unhandled authentication error, redirecting to login...');
        handleAuthFailure();
        event.preventDefault(); // Prevent the error from being logged to console
      }
    });

    // Add toast notification system if it doesn't exist
    if (!window.toast) {
      window.toast = function (message, isError = false) {
        // Create a simple toast notification
        const toast = document.createElement('div');
        toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${isError ? 'var(--err)' : 'var(--ok)'};
          color: white;
          padding: 12px 16px;
          border-radius: 6px;
          z-index: 10000;
          font-size: 14px;
          max-width: 300px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        toast.textContent = message;
        document.body.appendChild(toast);

        // Auto-remove after 3 seconds
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 3000);
      };
    }

    // Per-project restore happens inside renderTree; avoid global restore that can clobber state
    // Save shortcut Ctrl/Cmd+S
    document.addEventListener('keydown', async (e) => {
      const isSave = (e.key === 's' || e.key === 'S') && (e.ctrlKey || e.metaKey);
      if (!isSave) return;
      e.preventDefault();
      try {
        if (!activeOntologyIri) { alert('Select an ontology to save.'); return; }

        console.log('💾 Starting keyboard shortcut save (Ctrl+S)...');
        console.log('💾 Active ontology IRI:', activeOntologyIri);

        const ttl = toTurtle(activeOntologyIri);
        console.log('💾 Generated Turtle data length:', ttl.length);
        console.log('💾 Turtle data preview:', ttl.substring(0, 200) + '...');

        console.log('💾 Sending Turtle data to Fuseki...');
        const res = await fetch(`/api/ontology/save?graph=${encodeURIComponent(activeOntologyIri)}`, { method: 'POST', headers: { 'Content-Type': 'text/turtle' }, body: ttl });

        console.log('💾 Fuseki response status:', res.status);
        console.log('💾 Fuseki response ok:', res.ok);

        const json = await res.json().catch(() => ({}));
        if (res.ok) {
          console.log('✅ Ontology saved to Fuseki successfully!');

          // Also save layout data when using Ctrl+S
          if (ontoState.cy) {
            console.log('💾 Saving layout data...');
            const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({ data: n.data(), position: n.position() }));
            const edges = ontoState.cy.edges().filter(e => !e.hasClass('imported')).map(e => ({ data: e.data() }));

            console.log('💾 Layout nodes:', nodes.length);
            console.log('💾 Layout edges:', edges.length);

            await saveLayoutToServer(activeOntologyIri, nodes, edges);
            console.log('✅ Layout data saved successfully!');
          }

          console.log('🎉 Complete save operation successful!');
          alert('Ontology and layout saved successfully!');
        } else {
          console.error('❌ Fuseki save failed:', json);
          console.error('❌ Response status:', res.status);
          alert('Save failed: ' + (json.detail || res.status));
        }
      } catch (err) {
        console.error('❌ Keyboard shortcut save error:', err);
        alert('Save error: ' + err.message);
      }
    }, false);

    // Delete selected canvas entities (nodes/edges) for current ontology only
    function performDelete() {
      if (!(qs('#wb-ontology') && qs('#wb-ontology').classList.contains('active'))) return false;
      if (!ontoState.cy) return false;
      const sel = ontoState.cy.$(':selected');
      if (!sel || sel.length === 0) return false;
      ontoState.cy.remove(sel);
      refreshOntologyTree();
      persistOntologyToLocalStorage();
      return true;
    }
    function handleDeleteKey(e) {
      const key = e.key || e.code;
      const tgt = e.target;
      const isTyping = tgt && (tgt.tagName === 'INPUT' || tgt.tagName === 'TEXTAREA' || tgt.isContentEditable);
      const inline = qs('#ontoInlineEdit');
      const inlineVisible = inline ? (getComputedStyle(inline).display !== 'none') : false;
      if (isTyping || inlineVisible) return;
      if ((key === 'Delete' || key === 'Backspace') && ontoState.cy) {
        const ok = performDelete();
        if (ok) { e.preventDefault(); e.stopPropagation(); }
      }
    }
    document.addEventListener('keydown', handleDeleteKey, false);
    window.addEventListener('keydown', handleDeleteKey, true);
    // Keyup fallback in case keydown is intercepted by browser/OS
    document.addEventListener('keyup', handleDeleteKey, false);
    // Toolbar delete
    document.addEventListener('click', (e) => {
      if (e.target === qs('#ontoDeleteBtn')) {
        performDelete();
      }
    });

    // Files workbench state + helpers
    const filesState = { initialized: false, lastFiles: [], staged: [], library: [], sortBy: 'name', sortDir: 'asc' };
    function toast(msg, isError = false) {
      const el = qs('#filesToast'); if (!el) return;
      el.textContent = msg || '';
      el.style.color = isError ? '#ef4444' : '#9aa4b2';
      if (!msg) return;
      setTimeout(() => { if (el.textContent === msg) el.textContent = ''; }, 3000);
    }

    // Check if file has been processed into knowledge asset
    async function getKnowledgeProcessingStatus(fileId) {
      try {
        const headers = window.authHeader ? window.authHeader() : {};
        if (!headers.Authorization) {
          return ``; // Don't show status badge if not logged in
        }

        // Get current project ID
        const projectId = window.currentProjectId ? window.currentProjectId() : null;
        if (!projectId) {
          return ``; // Don't show status badge if no project
        }

        // Check if knowledge asset exists for this file
        const response = await fetch(`/api/knowledge/assets?project_id=${projectId}`, {
          headers
        });

        if (!response.ok) {
          return `<span style="background:rgba(239, 68, 68, 0.2); border:1px solid #ef4444; border-radius:6px; padding:2px 6px; font-size:12px; color:#ef4444;" title="Error checking knowledge status">Error</span>`;
        }

        const data = await response.json();
        const assets = data.assets || [];

        // Find asset with matching source_file_id
        const matchingAsset = assets.find(asset => asset.source_file_id === fileId);

        if (matchingAsset) {
          if (matchingAsset.status === 'active') {
            return `<span style="background:rgba(34, 197, 94, 0.2); border:1px solid #22c55e; border-radius:6px; padding:2px 6px; font-size:12px; color:#22c55e;" title="Successfully processed for knowledge">Processed</span>`;
          } else if (matchingAsset.status === 'processing') {
            return `<span style="background:rgba(245, 158, 11, 0.2); border:1px solid #f59e0b; border-radius:6px; padding:2px 6px; font-size:12px; color:#f59e0b;" title="Processing in progress">Processing</span>`;
          } else {
            return `<span style="background:rgba(239, 68, 68, 0.2); border:1px solid #ef4444; border-radius:6px; padding:2px 6px; font-size:12px; color:#ef4444;" title="Processing failed">Failed</span>`;
          }
        } else {
          // No knowledge asset found - file not processed yet
          return `<span style="background:var(--panel-2); border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--muted);" title="Not processed for knowledge">Pending</span>`;
        }

      } catch (error) {
        console.error('Error checking knowledge status:', error);
        return `<span style="background:var(--panel-2); border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--muted);" title="Error checking status">Unknown</span>`;
      }
    }
    function renderFilesList(items, projectId = null) {
      const list = qs('#filesList'); if (!list) return;
      list.innerHTML = '';
      const arr = Array.isArray(items) ? items : [];
      if (!arr.length) {
        const div = document.createElement('div');
        div.className = 'muted';
        div.textContent = 'No files yet. Upload or import to begin.';
        list.appendChild(div);
        return;
      }

      // Get current project ID if not provided
      if (!projectId) {
        try {
          projectId = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : localStorage.getItem('active_project_id');
        } catch (_) {
          projectId = '';
        }
      }
      const toBadge = (text) => `<span style="border:1px solid var(--border); padding:2px 6px; border-radius:6px; font-size:12px;">${text}</span>`;

      // Get status badges including file status and knowledge processing status
      const getStatusBadges = (fileStatus, fileId) => {
        // Check if this file is currently being reprocessed
        const isReprocessing = window.reprocessingFiles && window.reprocessingFiles.has(fileId);

        let fileStatusText = fileStatus;
        let fileStatusStyle = 'border:1px solid var(--border); padding:2px 6px; border-radius:6px; font-size:12px;';

        if (isReprocessing) {
          fileStatusText = 'Processing...';
          fileStatusStyle = 'background:#f59e0b; color:#fbbf24; border:1px solid #f59e0b; padding:2px 6px; border-radius:6px; font-size:12px; font-weight:500;';
        }

        const fileStatusBadge = `<span id="file-status-${fileId}" style="${fileStatusStyle}" title="${isReprocessing ? 'Reprocessing file to regenerate knowledge asset...' : ''}">${fileStatusText}</span>`;
        const knowledgeStatusId = `knowledge-status-${fileId}`;
        // Knowledge processing badge with styling consistent with visibility badges
        const knowledgeStatusBadge = `<span id="${knowledgeStatusId}" style="background:var(--panel-2); border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--muted);" title="Checking knowledge processing status...">Checking</span>`;
        return `<div style="display:flex; gap:4px; flex-wrap:wrap;">${fileStatusBadge} ${knowledgeStatusBadge}</div>`;
      };
      const getVisibilityBadge = (visibility, fileProjectId, currentProjectId) => {
        const isPublic = visibility === 'public';
        const isFromOtherProject = fileProjectId !== currentProjectId;

        if (isPublic) {
          const badgeText = isFromOtherProject ? '🌐 Shared' : '🌐 Public';
          return `<span style="background:rgba(37, 99, 235, 0.2); border:1px solid var(--accent); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--accent);" title="Available to all projects">${badgeText}</span>`;
        } else {
          return `<span style="background:var(--panel-2); border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--muted);" title="Only available in this project">🔒 Private</span>`;
        }
      };

      const getActionButtons = (meta, id, currentProjectId) => {
        const isSharedFile = meta.visibility === 'public' && meta.project_id !== currentProjectId;
        const username = localStorage.getItem('odras_user') || '';
        const isAdminUser = username === 'admin';

        let buttons = [];

        // Base button style for compact icon buttons
        const iconButtonStyle = 'background:transparent; border:1px solid var(--border); border-radius:6px; padding:6px; margin:0 2px; cursor:pointer; color:var(--text); transition:all 0.2s; display:inline-flex; align-items:center; justify-content:center;';
        const iconButtonHover = 'onmouseover="this.style.background=\'var(--panel-2)\'; this.style.borderColor=\'var(--accent)\';" onmouseout="this.style.background=\'transparent\'; this.style.borderColor=\'var(--border)\';"';

        // URL/Link button - always available
        buttons.push(`<button class="btn" data-action="url" data-id="${id}" title="Get file URL" style="${iconButtonStyle}" ${iconButtonHover}>
            <svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/>
            </svg>
          </button>`);

        // Admin visibility toggle - only for admin users
        const visibilityIcon = meta.visibility === 'public' ?
          '<svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3.707 2.293a1 1 0 00-1.414 1.414l14 14a1 1 0 001.414-1.414l-1.473-1.473A10.014 10.014 0 0019.542 10C18.268 5.943 14.478 3 10 3a9.958 9.958 0 00-4.512 1.074l-1.78-1.781zm4.261 4.26l1.514 1.515a2.003 2.003 0 012.45 2.45l1.514 1.514a4 4 0 00-5.478-5.478z" clip-rule="evenodd"/><path d="M12.454 16.697L9.75 13.992a4 4 0 01-3.742-3.741L2.335 6.578A9.98 9.98 0 00.458 10c1.274 4.057 5.065 7 9.542 7 .847 0 1.669-.105 2.454-.303z"/></svg>' :
          '<svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor"><path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/><path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"/></svg>';

        buttons.push(`<button class="btn admin-only" data-action="toggle-visibility" data-id="${id}" data-visibility="${meta.visibility || 'private'}" title="Toggle visibility (Admin)" style="${iconButtonStyle} display:none;" ${iconButtonHover}>
            ${visibilityIcon}
          </button>`);

        // Reprocess button - for regenerating knowledge assets
        if (!isSharedFile || isAdminUser) {
          buttons.push(`<button class="btn" data-action="reprocess" data-id="${id}" title="Reprocess file to regenerate knowledge asset" style="${iconButtonStyle}" ${iconButtonHover}>
              <svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"/>
              </svg>
            </button>`);
        }

        // Delete button - disabled for shared files for non-admin users
        if (!isSharedFile || isAdminUser) {
          buttons.push(`<button class="btn" data-action="delete" data-id="${id}" title="Delete file" style="${iconButtonStyle} color:#ef4444;" onmouseover="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.borderColor='#ef4444';" onmouseout="this.style.background='transparent'; this.style.borderColor='var(--border)'; this.style.color='#ef4444';">
              <svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" clip-rule="evenodd"/>
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
              </svg>
            </button>`);
        } else {
          buttons.push(`<button class="btn" data-action="delete" data-id="${id}" disabled title="Cannot delete shared files" style="${iconButtonStyle} opacity:0.5; cursor:not-allowed; color:var(--muted);">
              <svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" clip-rule="evenodd"/>
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
              </svg>
            </button>`);
        }

        return `<div style="display:flex; align-items:center; justify-content:flex-end;">${buttons.join('')}</div>`;
      };

      const getIRIDisplay = (iri) => {
        if (!iri) {
          return '<span class="muted" style="font-size:10px;">—</span>';
        }

        return `
            <div style="display:flex; align-items:center; justify-content:center; gap:4px;">
              <button onclick="copyToClipboard('${iri}')"
                      style="background:transparent; border:1px solid var(--border); border-radius:4px; padding:4px 6px; cursor:pointer; color:var(--accent); font-size:11px; transition:all 0.2s;"
                      onmouseover="this.style.background='var(--panel-2)'; this.style.borderColor='var(--accent)';"
                      onmouseout="this.style.background='transparent'; this.style.borderColor='var(--border)';"
                      title="Copy IRI: ${iri}">
                🔗 Copy
              </button>
              <button onclick="showIRIDetails('${iri}')"
                      style="background:transparent; border:1px solid var(--border); border-radius:4px; padding:4px 6px; cursor:pointer; color:var(--muted); font-size:11px; transition:all 0.2s;"
                      onmouseover="this.style.background='var(--panel-2)'; this.style.borderColor='var(--accent)'; this.style.color='var(--text)';"
                      onmouseout="this.style.background='transparent'; this.style.borderColor='var(--border)'; this.style.color='var(--muted)';"
                      title="View IRI details">
                ℹ️
              </button>
            </div>
          `;
      };

      const getEditableDocTypeBadge = (docType, fileId, currentProjectId, meta) => {
        const isSharedFile = meta.visibility === 'public' && meta.project_id !== currentProjectId;
        const username = localStorage.getItem('odras_user') || '';
        const isAdminUser = username === 'admin';
        const canEdit = !isSharedFile || isAdminUser;

        const colors = {
          'requirements': { bg: 'rgba(239, 68, 68, 0.2)', border: '#ef4444', color: '#f87171' },
          'knowledge': { bg: 'rgba(34, 197, 94, 0.2)', border: '#22c55e', color: '#4ade80' },
          'reference': { bg: 'rgba(168, 85, 247, 0.2)', border: '#a855f7', color: '#c084fc' },
          'specification': { bg: 'rgba(59, 130, 246, 0.2)', border: '#3b82f6', color: '#60a5fa' },
          'unknown': { bg: 'var(--panel-2)', border: 'var(--border)', color: 'var(--muted)' }
        };

        const style = colors[docType] || colors['unknown'];
        const cursor = canEdit ? 'pointer' : 'default';
        const title = canEdit ? 'Click to change document type' : (isSharedFile ? 'Cannot edit shared files' : '');

        return `<span
            class="doc-type-badge${canEdit ? ' editable-doc-type' : ''}"
            data-file-id="${fileId}"
            data-current-type="${docType}"
            style="background:${style.bg}; border:1px solid ${style.border}; color:${style.color}; padding:2px 6px; border-radius:6px; font-size:12px; cursor:${cursor};"
            title="${title}"
            ${canEdit ? 'onclick="editDocType(this)"' : ''}
          >${docType.charAt(0).toUpperCase() + docType.slice(1)}</span>`;
      };
      const rows = arr.map(meta => {
        const name = meta.filename || meta.name || 'file';
        const id = meta.file_id || meta.id || '';
        const tags = meta.tags || {};
        const status = tags.status || 'new';
        const size = meta.size || 0;
        const sizeStr = size ? `${size}` : '';
        const created = meta.created_at ? new Date(meta.created_at).toLocaleString() : '';
        return `<tr>
          <td style="width:32px; text-align:center;"><input type="checkbox" class="file-select" data-id="${id}" /></td>
          <td><div style="display:flex; flex-direction:column;"><span style="font-weight:600;">${name}</span><span class="muted" style="font-size:12px;">${id}</span></div></td>
          <td>${getEditableDocTypeBadge(tags.docType || 'unknown', id, projectId, meta)}</td>
          <td>${getStatusBadges(status, id)}</td>
          <td>${getVisibilityBadge(meta.visibility || 'private', meta.project_id, projectId)}</td>
          <td style="font-size:11px; max-width:200px;">${getIRIDisplay(meta.iri)}</td>
          <td style="text-align:right;">${sizeStr}</td>
          <td class="muted" style="font-size:12px;">${created}</td>
          <td style="text-align:right;">
            ${getActionButtons(meta, id, projectId)}
          </td>
        </tr>`;
      }).join('');
      list.innerHTML = `
        <div style="overflow:auto;">
          <table style="width:100%; border-collapse:separate; border-spacing:0 6px;">
            <thead>
              <tr>
                <th style="width:32px;"><input type="checkbox" id="filesSelectAll" /></th>
                <th data-sort="name" style="cursor:pointer;">Name</th>
                <th data-sort="type" style="cursor:pointer;">Type</th>
                <th data-sort="status" style="cursor:pointer;">Status</th>
                <th data-sort="visibility" style="cursor:pointer;">Visibility</th>
                <th style="width:120px; text-align:center;">IRI</th>
                <th data-sort="size" style="text-align:right; cursor:pointer;">Size</th>
                <th>Uploaded</th>
                <th style="text-align:right;">Actions</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>`;
      // Sorting handlers
      const thead = list.querySelector('thead');
      if (thead) thead.addEventListener('click', (e) => {
        const th = e.target.closest('[data-sort]'); if (!th) return;
        const key = th.getAttribute('data-sort');
        if (filesState.sortBy === key) filesState.sortDir = (filesState.sortDir === 'asc' ? 'desc' : 'asc');
        else { filesState.sortBy = key; filesState.sortDir = 'asc'; }
        // Re-sort current state
        try { renderFilesList(sortItems(filesState.library)); } catch (_) { }
      });
      const selAll = list.querySelector('#filesSelectAll');
      if (selAll) selAll.addEventListener('change', () => {
        list.querySelectorAll('.file-select').forEach(cb => { cb.checked = selAll.checked; });

        // Clear preview when deselecting all
        if (!selAll.checked) {
          clearFilePreview();
        }
      });
      // Update "Select All" state based on individual checkboxes
      function updateSelectAllState() {
        const selAll = list.querySelector('#filesSelectAll');
        if (!selAll) return;

        const allCheckboxes = list.querySelectorAll('.file-select');
        const checkedBoxes = list.querySelectorAll('.file-select:checked');

        if (checkedBoxes.length === 0) {
          selAll.checked = false;
          selAll.indeterminate = false;
          clearFilePreview(); // Clear preview when no files are selected
        } else if (checkedBoxes.length === allCheckboxes.length) {
          selAll.checked = true;
          selAll.indeterminate = false;
        } else {
          selAll.checked = false;
          selAll.indeterminate = true;
        }
      }

      // Handle individual checkbox clicks (without interfering with row clicks)
      list.querySelectorAll('.file-select').forEach(cb => {
        cb.addEventListener('click', async (e) => {
          e.stopPropagation(); // Prevent row click from firing
          const id = cb.getAttribute('data-id');
          console.log('🔲 Checkbox clicked for file:', id, 'checked:', cb.checked);

          // Update Select All state
          updateSelectAllState();

          // Update preview based on selection
          if (cb.checked && id) {
            await updateFilePreview(id);
          } else {
            clearFilePreview();
          }
        });
      });

      // Click to select and preview (but not on checkboxes or buttons)
      list.querySelectorAll('tbody tr').forEach(tr => {
        tr.addEventListener('click', async (e) => {
          if (e.target.closest('button')) return;
          if (e.target.closest('.file-select')) return; // Don't interfere with checkbox clicks
          const cb = tr.querySelector('.file-select');
          const id = cb ? cb.getAttribute('data-id') : '';
          if (!id) return;
          // Toggle checkbox state instead of always setting to true
          cb.checked = !cb.checked;
          console.log('🔲 Row clicked, toggled checkbox for file:', id, 'checked:', cb.checked);

          // Update Select All state
          updateSelectAllState();

          if (cb.checked) {
            await updateFilePreview(id);
          } else {
            clearFilePreview();
          }
        });
      });
      // Delegate actions
      list.onclick = async (e) => {
        const btn = e.target.closest('button[data-action]');
        if (!btn) return;
        const id = btn.getAttribute('data-id');
        const action = btn.getAttribute('data-action');
        if (!id) return;
        if (action === 'delete') {
          await showEnhancedDeleteDialog(id);
        }
        if (action === 'reprocess') {
          if (!confirm('Reprocess this file to regenerate knowledge asset?')) return;
          console.log('🔄 Starting reprocess for file:', id);
          const ok = await reprocessFileViaApi(id);
          console.log('🔄 Reprocess result:', ok);
          if (ok) {
            toast('File reprocessing started - this may take a few moments');

            // Show immediate status change in main file status badge
            const fileStatusElement = document.getElementById(`file-status-${id}`);
            if (fileStatusElement) {
              fileStatusElement.textContent = 'Processing...';
              fileStatusElement.style.background = '#f59e0b';
              fileStatusElement.style.color = '#fbbf24';
              fileStatusElement.style.border = '1px solid #f59e0b';
              fileStatusElement.style.fontWeight = '500';
              fileStatusElement.title = 'Reprocessing file to regenerate knowledge asset...';
            }

            // Reload library after a short delay to show updated status
            setTimeout(async () => {
              await window.loadLibraryFromApi();
              // Also update processing status in knowledge management
              if (typeof updateProcessingStatus === 'function') {
                updateProcessingStatus();
              }
            }, 2000);

            // Track that this file is being reprocessed
            if (!window.reprocessingFiles) window.reprocessingFiles = new Set();
            window.reprocessingFiles.add(id);

            // Check status periodically until processing is complete
            const checkProcessingComplete = async (attempts = 0) => {
              if (attempts > 12) { // Max 2 minutes
                window.reprocessingFiles.delete(id);
                toast('Reprocessing taking longer than expected - check knowledge assets manually');
                await window.loadLibraryFromApi();
                return;
              }

              await window.loadLibraryFromApi();

              // Update processing status in knowledge management
              if (typeof updateProcessingStatus === 'function') {
                updateProcessingStatus();
              }

              // Check if processing is actually complete by querying jobs endpoint
              try {
                const jobsResponse = await fetch('/api/knowledge/jobs', {
                  headers: { ...authHeader() }
                });

                if (jobsResponse.ok) {
                  const jobs = await jobsResponse.json();
                  const activeReprocessing = jobs.find(job =>
                    job.job_type === 'reprocessing' &&
                    job.status === 'running' &&
                    job.metadata &&
                    job.metadata.file_id === id
                  );

                  if (!activeReprocessing) {
                    // No active reprocessing job found - processing is complete
                    window.reprocessingFiles.delete(id);
                    toast('Reprocessing completed! Knowledge asset updated.');
                    await window.loadLibraryFromApi(); // Final refresh
                    return;
                  }
                }
              } catch (error) {
                console.warn('Could not check job status:', error);
                // Fallback to heuristic check
                const knowledgeStatusElement = document.getElementById(`knowledge-status-${id}`);
                if (knowledgeStatusElement && knowledgeStatusElement.textContent.includes('✅')) {
                  window.reprocessingFiles.delete(id);
                  toast('Reprocessing completed! Knowledge asset updated.');
                  return;
                }
              }

              // Continue checking
              setTimeout(() => checkProcessingComplete(attempts + 1), 10000);
            };

            // Start checking after initial delay
            setTimeout(() => checkProcessingComplete(), 15000);

          } else {
            toast('Reprocess failed', true);
          }
        }
        if (action === 'toggle-visibility') {
          // Check admin status synchronously for immediate response
          const username = localStorage.getItem('odras_user') || '';
          const isAdminUser = username === 'admin';

          console.log('👑 Checking admin access - username:', username, 'isAdmin:', isAdminUser);

          if (!isAdminUser) {
            toast('Admin access required', true);
            return;
          }

          const currentVisibility = btn.getAttribute('data-visibility') || 'private';
          const newVisibility = currentVisibility === 'public' ? 'private' : 'public';
          const confirmText = `Make this file ${newVisibility}?\n\n${newVisibility === 'public' ? 'Public files are available to all projects.' : 'Private files are only visible in their project.'}`;

          if (!confirm(confirmText)) return;

          console.log('👑 Admin toggling file visibility:', id, 'from', currentVisibility, 'to', newVisibility);
          toast('Updating visibility...');

          try {
            const formData = new FormData();
            formData.append('visibility', newVisibility);

            console.log('👑 Making API call to /api/files/' + id + '/visibility with visibility:', newVisibility);

            const response = await fetch(`/api/files/${id}/visibility`, {
              method: 'PUT',
              headers: { ...window.authHeader() },
              body: formData
            });

            console.log('👑 API response status:', response.status, response.statusText);

            const result = await response.json();
            console.log('👑 API response data:', result);

            if (result.success) {
              toast(`File is now ${newVisibility}`);
              console.log('👑 Refreshing library to show updated visibility');
              await window.loadLibraryFromApi(); // Refresh to show updated visibility
            } else {
              console.error('👑 API returned error:', result);
              toast('Visibility update failed: ' + (result.error || result.message || 'Unknown error'), true);
            }
          } catch (error) {
            console.error('👑 Visibility update error:', error);
            toast('Network error updating visibility', true);
          }
        } else if (action === 'url') {
          const url = await getFileUrlViaApi(id);
          if (url) { try { await navigator.clipboard.writeText(url); toast('URL copied'); } catch (_) { window.open(url, '_blank'); } }
        } else if (action === 'ingest') {
          // Individual ingest action removed - knowledge processing is now streamlined
          toast('✅ This file is already processed for knowledge!', false);
        }
      };
      // Bulk buttons
      try {
        const bulkDelete = qs('#filesBulkDeleteBtn');
        const bulkProcess = qs('#filesBulkProcessBtn');
        // bulkIngest button removed - knowledge processing is now automatic
        const selectedIds = () => Array.from(list.querySelectorAll('.file-select:checked')).map(c => c.getAttribute('data-id'));
        if (bulkDelete) bulkDelete.onclick = async () => {
          const ids = selectedIds(); if (!ids.length) { toast('No files selected', true); return; }
          if (!confirm(`Delete ${ids.length} file(s)?`)) return;
          console.log('🗑️  Starting bulk delete for files:', ids);
          let ok = 0; for (const id of ids) { if (await deleteStoredFileViaApi(id)) ok++; }
          console.log('🗑️  Bulk delete completed:', ok, 'of', ids.length);
          toast(`Deleted ${ok}/${ids.length}`);
          console.log('🗑️  Refreshing library after bulk delete');
          await window.loadLibraryFromApi();
          console.log('🗑️  Bulk delete library refresh completed');
        };
        if (bulkProcess) bulkProcess.onclick = async () => {
          const ids = selectedIds(); if (!ids.length) { toast('No files selected', true); return; }
          let ok = 0; for (const id of ids) { if (await processFileViaApi(id)) ok++; }
          toast(`Started ${ok}/${ids.length}`);
        };
        // bulkIngest removed - all uploaded files now automatically processed for knowledge
      } catch (_) { }

      // Update knowledge processing status badges asynchronously
      setTimeout(async () => {
        const statusElements = list.querySelectorAll('[id^="knowledge-status-"]');
        for (const element of statusElements) {
          const fileId = element.id.replace('knowledge-status-', '');
          try {
            const status = await getKnowledgeProcessingStatus(fileId);
            element.outerHTML = status;
          } catch (error) {
            console.error('Error updating knowledge status for file', fileId, error);
            element.outerHTML = `<span style="background:var(--panel-2); border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--muted);" title="Error checking status">Unknown</span>`;
          }
        }
      }, 100); // Small delay to ensure DOM is ready
    }
    function renderStagedList() {
      const list = qs('#stagedList'); if (!list) return;
      const docTypeSelector = qs('#stagedDocTypeSelector');
      const knowledgeOptions = qs('#knowledgeProcessingOptions');

      list.innerHTML = '';

      if (!filesState.staged.length) {
        const div = document.createElement('div'); div.className = 'muted'; div.textContent = 'No staged files.'; list.appendChild(div);
        // Hide options when no files are staged
        if (docTypeSelector) docTypeSelector.style.display = 'none';
        if (knowledgeOptions) knowledgeOptions.style.display = 'none';
        return;
      }

      // Show options when files are staged
      if (docTypeSelector) docTypeSelector.style.display = 'block';
      if (knowledgeOptions) knowledgeOptions.style.display = 'block';
      filesState.staged.forEach((f, idx) => {
        const row = document.createElement('div');
        row.className = 'card';
        row.style.display = 'grid';
        row.style.gridTemplateColumns = '1fr auto auto auto';
        row.style.alignItems = 'center';
        row.style.padding = '8px';
        row.style.gap = '8px';

        // File info
        const left = document.createElement('div');
        left.innerHTML = `<strong>${f.name}</strong> <span class="muted">${f.size} bytes</span>`;

        // Individual document type selector
        const typeSelect = document.createElement('select');
        typeSelect.style.background = '#0b1220';
        typeSelect.style.color = '#e5e7eb';
        typeSelect.style.border = '1px solid var(--border)';
        typeSelect.style.borderRadius = '6px';
        typeSelect.style.padding = '4px 8px';
        typeSelect.style.fontSize = '12px';
        typeSelect.style.minWidth = '100px';

        const docTypes = ['unknown', 'requirements', 'knowledge', 'reference', 'specification', 'analysis_template', 'document', 'code', 'data'];
        docTypes.forEach(type => {
          const option = document.createElement('option');
          option.value = type;
          option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
          if (type === (f.docType || 'unknown')) {
            option.selected = true;
          }
          typeSelect.appendChild(option);
        });

        // Update file object when type changes
        typeSelect.onchange = () => {
          f.docType = typeSelect.value;
          toast(`Set "${f.name}" type to "${typeSelect.value}"`);
        };

        // Actions
        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.gap = '4px';

        const up = document.createElement('button');
        up.className = 'btn';
        up.textContent = 'Upload';
        up.style.fontSize = '12px';
        up.style.padding = '4px 8px';
        up.onclick = async () => {
          // Ensure docType is set before upload
          if (!f.docType) f.docType = typeSelect.value || 'unknown';
          const ok = await (window.odrasUploadOne ? window.odrasUploadOne(f) : Promise.resolve(false));
          if (ok) {
            toast('Uploaded 1/1');
            filesState.staged.splice(idx, 1);
            renderStagedList();
            try { if (window.odrasLoadLibrary) await window.odrasLoadLibrary(); } catch (_) { }
          } else {
            toast('Upload failed', true);
          }
        };

        const rem = document.createElement('button');
        rem.className = 'btn';
        rem.textContent = '✕';
        rem.style.fontSize = '12px';
        rem.style.padding = '4px 8px';
        rem.style.background = '#dc2626';
        rem.style.color = '#f87171';
        rem.title = 'Remove from staging';
        rem.onclick = () => {
          filesState.staged.splice(idx, 1);
          renderStagedList();
        };

        actions.appendChild(up);
        actions.appendChild(rem);

        row.appendChild(left);
        row.appendChild(typeSelect);
        row.appendChild(actions);
        list.appendChild(row);
      });
    }
    function previewSelectedFiles(fileList) {
      const el = qs('#uploadPreview'); if (!el) return;
      if (!fileList || !fileList.length) { el.textContent = ''; return; }
      const names = Array.from(fileList).map(f => `${f.name} (${f.size} bytes)`).join(', ');
      el.textContent = `Selected: ${names}`;
    }
    function ensureFilesInitialized() {
      if (filesState.initialized) return;
      filesState.initialized = true;
      const input = qs('#fileUploadInput');
      const choose = qs('#fileChooseBtn');
      const drop = qs('#fileDropZone');
      const urlInput = qs('#fileUrlInput');
      const urlBtn = qs('#fileUrlImportBtn');
      const refreshBtn = qs('#filesRefreshBtn');
      const includePublicCheckbox = qs('#filesIncludePublic');
      const docType = qs('#filesDocType');
      const statusSel = qs('#filesStatus');
      const tags = qs('#filesTags');
      function authHeader() {
        try {
          const t = localStorage.getItem('odras_token');
          if (!t) {
            return {};
          }
          // Always return the token if it exists - let the server validate it
          // The isAuthenticated flag is only used for UI state, not for API calls
          return { Authorization: 'Bearer ' + t };
        } catch (_) {
          return {};
        }
      }
      function currentProjectId() {
        try { const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : localStorage.getItem('active_project_id'); return pid || ''; } catch (_) { return ''; }
      }
      // Expose currentProjectId globally for use in other scopes
      window.currentProjectId = currentProjectId;
      async function uploadOne(fileMeta) {
        console.log('🔼 Starting upload for:', fileMeta.name, fileMeta.size, 'bytes');

        const pid = currentProjectId();
        console.log('📁 Project ID for upload:', pid);
        console.log('📁 activeProject:', window.activeProject);
        console.log('📁 localStorage project_id:', localStorage.getItem('active_project_id'));
        if (!pid) {
          console.error('❌ No project selected');
          toast('Select a project first', true);
          return false;
        }

        const headers = { ...authHeader() };
        console.log('🔐 Auth headers:', headers.Authorization ? 'Present' : 'Missing');
        if (!headers.Authorization) {
          console.error('❌ No auth token');
          toast('Login required', true);
          return false;
        }

        const fd = new FormData();
        fd.append('file', fileMeta);
        fd.append('project_id', pid);

        // Always include knowledge processing options (automatic now)
        const embeddingModel = qs('#embeddingModel')?.value || 'all-MiniLM-L6-v2';
        const chunkingStrategy = qs('#chunkingStrategy')?.value || '';  // Empty = auto-detect

        fd.append('embedding_model', embeddingModel);
        fd.append('chunking_strategy', chunkingStrategy);

        console.log('📝 Processing:', embeddingModel, chunkingStrategy || 'smart-default');

        try {
          const t = (tags && tags.value || '').trim();
          const list = t ? t.split(',').map(s => s.trim()).filter(Boolean) : [];
          // Use document type from staged file if available, otherwise fall back to filter dropdown
          const selectedDocType = fileMeta.docType || (docType && docType.value) || 'unknown';
          const tagObj = { docType: selectedDocType, status: 'new' };
          if (list.length) tagObj.userTags = list;
          fd.append('tags', JSON.stringify(tagObj));
          console.log('🏷️  Tags with document type:', tagObj);
        } catch (e) {
          console.warn('⚠️  Tags error:', e);
        }

        try {
          console.log('📤 Making upload request to /api/files/upload');
          const res = await fetch('/api/files/upload', { method: 'POST', headers, body: fd });
          console.log('📥 Upload response status:', res.status, res.statusText);

          const js = await res.json().catch((e) => {
            console.error('❌ Failed to parse response JSON:', e);
            return {};
          });
          console.log('📄 Upload response data:', js);

          if (!res.ok || js.success === false) {
            const errorMsg = js.error || js.detail || 'upload failed';
            console.error('❌ Upload failed:', errorMsg);
            toast(`Upload failed: ${errorMsg}`, true);
            throw new Error(errorMsg);
          }

          console.log('✅ Upload successful, file_id:', js.file_id);
          toast(`Uploaded: ${fileMeta.name}`, false);
          return true;
        } catch (err) {
          console.error('❌ Upload exception:', err);
          toast(`Upload error: ${err.message}`, true);
          return false;
        }
      }
      // Expose for other handlers defined outside this scope
      try { window.odrasUploadOne = uploadOne; } catch (_) { }
      async function loadLibraryFromApi() {
        const pid = currentProjectId();
        console.log('📚 Loading library for project:', pid);
        console.log('📚 activeProject:', window.activeProject);
        console.log('📚 localStorage project_id:', localStorage.getItem('active_project_id'));
        if (!pid) {
          console.log('📚 No project ID, clearing library');
          renderFilesList([], '');
          return;
        }


        const includePublicCheckbox = qs('#filesIncludePublic');
        const includePublic = includePublicCheckbox ? includePublicCheckbox.checked : false;

        try {
          const url = `/api/files?project_id=${pid}${includePublic ? '&include_public=true' : ''}`;
          console.log('📚 Fetching files from', url);
          const res = await fetch(url, { headers: { ...authHeader() } });
          console.log('📚 Files API response status:', res.status, res.statusText);

          const js = await res.json();
          console.log('📚 Files API response data:', js);
          console.log('📚 Individual files:', js.files);

          let items = js && js.files ? js.files : [];
          console.log('📚 Raw files count:', items.length);

          // Client-side filters
          const wantType = (docType && docType.value) || '';
          const wantStatus = (statusSel && statusSel.value) || '';
          const tagFilter = (tags && tags.value || '').trim().toLowerCase();
          console.log('📚 Filters - Type:', wantType, 'Status:', wantStatus, 'Tags:', tagFilter);

          const filtered = items.filter(m => {
            const t = m.tags || {};
            const okType = !wantType || (t.docType || 'unknown') === wantType;
            const okStatus = !wantStatus || (t.status || 'new') === wantStatus;
            const okTags = !tagFilter || JSON.stringify(t).toLowerCase().includes(tagFilter);
            return okType && okStatus && okTags;
          });

          console.log('📚 Filtered files count:', filtered.length);
          if (filtered.length > 0) {
            console.log('📚 Sample file:', filtered[0]);
          } else {
            console.log('📚 No files after filtering. Original count:', items.length);
            console.log('📚 Filter settings - Type:', wantType, 'Status:', wantStatus, 'Tags:', tagFilter);
            if (items.length > 0) {
              console.log('📚 Sample raw file:', items[0]);
            }
          }

          filesState.library = filtered;
          renderFilesList(sortItems(filtered), pid);
          console.log('📚 Library updated and rendered');

          // Show admin buttons if user is admin
          toggleAdminButtons();
        } catch (e) {
          console.error('📚 Library loading failed:', e);
          renderFilesList([], pid);

          // Show admin buttons if user is admin (even on error)
          toggleAdminButtons();
        }
      }
      // Show/hide admin buttons after rendering list
      async function toggleAdminButtons() {
        try {
          const adminStatus = await isAdmin();
          console.log('👑 Admin status:', adminStatus);

          document.querySelectorAll('.admin-only').forEach(btn => {
            btn.style.display = adminStatus ? 'inline-block' : 'none';
          });
        } catch (error) {
          console.error('👑 Error checking admin status:', error);
          // Hide admin buttons on error
          document.querySelectorAll('.admin-only').forEach(btn => {
            btn.style.display = 'none';
          });
        }
      }
      // Expose functions globally for staged-list handlers and other components
      try {
        window.odrasLoadLibrary = loadLibraryFromApi;
        window.loadLibraryFromApi = loadLibraryFromApi; // Also expose without prefix for internal use
        window.authHeader = authHeader; // Expose auth header function globally
        window.authenticatedFetch = authenticatedFetch; // Expose authenticated fetch globally
        window.handleAuthFailure = handleAuthFailure; // Expose auth failure handler globally
        window.editDocType = editDocType; // Expose document type editor globally
      } catch (_) { }

      // Document type inline editor
      async function editDocType(badgeElement) {
        const fileId = badgeElement.getAttribute('data-file-id');
        const currentType = badgeElement.getAttribute('data-current-type');

        // Create inline dropdown
        const select = document.createElement('select');
        select.style.cssText = 'background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:4px; padding:2px 4px; font-size:12px;';

        const options = ['unknown', 'requirements', 'knowledge', 'reference', 'specification'];
        options.forEach(type => {
          const option = document.createElement('option');
          option.value = type;
          option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
          option.selected = type === currentType;
          select.appendChild(option);
        });

        // Replace badge with dropdown temporarily
        const originalHTML = badgeElement.outerHTML;
        badgeElement.parentNode.replaceChild(select, badgeElement);
        select.focus();

        // Handle selection
        const handleChange = async (newType) => {
          if (newType === currentType) {
            // No change, restore original badge
            select.parentNode.innerHTML = originalHTML;
            return;
          }

          try {
            // Update file tags on server
            const response = await fetch(`/api/files/${fileId}/tags`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
                ...window.authHeader()
              },
              body: JSON.stringify({ tags: { docType: newType } })
            });

            const result = await response.json();
            if (result.success) {
              toast(`Document type changed to "${newType}"`);
              // Refresh library to show updated badge
              window.loadLibraryFromApi();
            } else {
              throw new Error(result.error || 'Update failed');
            }
          } catch (error) {
            console.error('Error updating document type:', error);
            toast(`Failed to update document type: ${error.message}`, true);
            // Restore original badge on error
            select.parentNode.innerHTML = originalHTML;
          }
        };

        // Handle dropdown events
        select.addEventListener('change', () => handleChange(select.value));
        select.addEventListener('blur', () => handleChange(select.value));
        select.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleChange(select.value);
          } else if (e.key === 'Escape') {
            e.preventDefault();
            // Restore original badge
            select.parentNode.innerHTML = originalHTML;
          }
        });
      }
      function sortItems(items) {
        const arr = Array.from(items || []);
        const dir = filesState.sortDir === 'desc' ? -1 : 1;
        const key = filesState.sortBy || 'name';
        const get = (m) => {
          const tags = m.tags || {};
          if (key === 'name') return (m.filename || '').toLowerCase();
          if (key === 'type') return (tags.docType || '').toLowerCase();
          if (key === 'status') return (tags.status || '').toLowerCase();
          if (key === 'size') return Number(m.size || 0);
          return (m.filename || '').toLowerCase();
        };
        arr.sort((a, b) => { const av = get(a), bv = get(b); if (av < bv) return -1 * dir; if (av > bv) return 1 * dir; return 0; });
        return arr;
      }
      if (input) {
        input.addEventListener('change', (e) => {
          const files = e.target.files;
          previewSelectedFiles(files);
          filesState.lastFiles = Array.from(files || []);
          filesState.staged.push(...filesState.lastFiles);
          renderStagedList();
          const n = filesState.lastFiles.length; if (n) toast(`${n} file(s) staged. Click Upload next to a file or Upload All.`); else toast('No files selected', true);
          try { input.value = ''; } catch (_) { }
        });
      }
      if (choose && input) {
        choose.addEventListener('click', () => { try { input.value = ''; } catch (_) { }; input.click(); });
      }
      if (drop) {
        ;['dragenter', 'dragover'].forEach(ev => drop.addEventListener(ev, (e) => {
          e.preventDefault();
          drop.style.background = 'rgba(37, 99, 235, 0.2)';
          drop.style.borderColor = 'var(--accent)';
          drop.style.color = 'var(--accent)';
        }));
        ;['dragleave', 'drop'].forEach(ev => drop.addEventListener(ev, (e) => {
          e.preventDefault();
          drop.style.background = 'rgba(15, 22, 40, 0.3)';
          drop.style.borderColor = 'var(--border)';
          drop.style.color = '#9aa4b2';
        }));
        drop.addEventListener('drop', (e) => {
          const dt = e.dataTransfer; const files = dt && dt.files ? dt.files : [];
          previewSelectedFiles(files);
          filesState.lastFiles = Array.from(files || []);
          filesState.staged.push(...filesState.lastFiles);
          renderStagedList();
          const n = filesState.lastFiles.length; if (n) toast(`${n} file(s) staged. Click Upload All to upload.`);
        });
        drop.addEventListener('click', () => { if (input) { try { input.value = ''; } catch (_) { }; input.click(); } });
        drop.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); if (input) input.click(); } });
      }

      // Refresh button and Include Public Files checkbox handlers
      if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
          console.log('🔄 Manual library refresh triggered');
          window.loadLibraryFromApi();
        });
      }

      if (includePublicCheckbox) {
        // Restore checkbox state from localStorage
        const savedState = localStorage.getItem('files_include_public');
        if (savedState !== null) {
          includePublicCheckbox.checked = savedState === 'true';
          console.log('🌐 Restored "Include public files" state:', includePublicCheckbox.checked);
        }

        includePublicCheckbox.addEventListener('change', () => {
          console.log('🌐 Include public files changed:', includePublicCheckbox.checked);
          // Save checkbox state to localStorage
          localStorage.setItem('files_include_public', includePublicCheckbox.checked.toString());
          console.log('🌐 Saved "Include public files" state to localStorage');
          window.loadLibraryFromApi(); // Refresh library with new visibility setting
        });
      }

      // Auto-refresh Files Workbench when project changes
      let lastProjectId = window.currentProjectId ? window.currentProjectId() : '';
      setInterval(() => {
        const newProjectId = window.currentProjectId ? window.currentProjectId() : '';
        if (newProjectId !== lastProjectId) {
          console.log('🔄 Project changed from', lastProjectId, 'to', newProjectId);
          lastProjectId = newProjectId;
          // Only refresh if we're currently viewing the Files Workbench
          const filesSection = qs('#wb-files');
          if (filesSection && filesSection.style.display !== 'none') {
            console.log('🔄 Auto-refreshing Files Workbench for new project');
            window.loadLibraryFromApi();
          }
        }
      }, 1000); // Check every second
      if (urlBtn && urlInput) {
        urlBtn.addEventListener('click', async () => {
          const u = (urlInput.value || '').trim();
          const el = qs('#uploadPreview');
          if (!u) { toast('Please enter a URL', true); if (el) el.textContent = ''; return; }
          try { new URL(u); } catch (_) { toast('Invalid URL', true); return; }
          const pid = window.currentProjectId ? window.currentProjectId() : ''; if (!pid) { toast('Select a project first', true); return; }
          const fd = new FormData(); fd.append('url', u); fd.append('project_id', pid);
          try {
            const res = await fetch('/api/files/import-url', {
              method: 'POST',
              headers: { 'Authorization': `Bearer ${localStorage.getItem('odras_token')}` },
              body: fd
            });
            const js = await res.json().catch(() => ({}));
            if (!res.ok || js.success === false) throw new Error(js.detail || js.error || 'Import failed');
            if (el) el.textContent = `Imported URL: ${u}`;
            toast('Imported URL');
            loadLibraryFromApi();
          } catch (e) {
            toast('Import failed', true);
          }
        });
      }
      const uploadAll = qs('#filesUploadAllBtn');
      const clearStaged = qs('#filesClearStagedBtn');
      const setStagedDocTypeBtn = qs('#setStagedDocType');

      if (clearStaged) clearStaged.addEventListener('click', () => { filesState.staged = []; renderStagedList(); previewSelectedFiles([]); });

      // Handle document type selector for staged files
      if (setStagedDocTypeBtn) {
        setStagedDocTypeBtn.addEventListener('click', () => {
          const selectedType = qs('#stagedDocType')?.value || 'unknown';

          // Add docType property to all staged files
          filesState.staged.forEach(file => {
            file.docType = selectedType;
          });

          toast(`Set document type to "${selectedType}" for ${filesState.staged.length} staged file(s)`);

          // Update hint text
          const hint = qs('#stagedDocTypeHint');
          if (hint) {
            hint.textContent = `${filesState.staged.length} file(s) will be uploaded as "${selectedType}"`;
          }
        });
      }

      // Knowledge processing is now automatic - no checkbox needed
      const knowledgeProcessingConfig = qs('#knowledgeProcessingConfig');

      if (knowledgeProcessingConfig) {
        // Always show config since processing is automatic
        knowledgeProcessingConfig.style.display = 'grid';
        console.log('⚙️ Knowledge processing ready');
      }
      if (uploadAll) uploadAll.addEventListener('click', async () => {
        if (!filesState.staged.length) { toast('Nothing to upload', true); return; }
        const total = filesState.staged.length; let ok = 0; const keep = [];
        for (const f of filesState.staged) { const res = await (window.odrasUploadOne ? window.odrasUploadOne(f) : Promise.resolve(false)); if (res) ok++; else keep.push(f); }
        const failed = total - ok;
        toast(`Uploaded ${ok}/${total}${failed ? ` (failed ${failed})` : ''}`);
        filesState.staged = keep; renderStagedList(); previewSelectedFiles(keep);
        try { if (window.odrasLoadLibrary) await window.odrasLoadLibrary(); } catch (_) { }
      });
      const triggerRefresh = () => {
        loadLibraryFromApi();
        try { refreshRunsPanel(); } catch (_) { }
      };
      if (refreshBtn) refreshBtn.addEventListener('click', triggerRefresh);
      if (docType) docType.addEventListener('change', triggerRefresh);
      if (statusSel) statusSel.addEventListener('change', triggerRefresh);
      if (tags) tags.addEventListener('keyup', (e) => { if (e.key === 'Enter') triggerRefresh(); });
      // Initial empty list
      loadLibraryFromApi();
      renderStagedList();

      // Ingest params modal handlers
      const modal = qs('#ingestParamsModal');
      const btnClose = qs('#ingestParamsCloseBtn');
      const btnCancel = qs('#ingestParamsCancelBtn');
      const btnStart = qs('#ingestParamsStartBtn');
      const inputChunk = qs('#ing_chunk_size');
      const inputOverlap = qs('#ing_chunk_overlap');
      const inputModel = qs('#ing_model_id');
      const inputBatch = qs('#ing_batch_size');
      const chkHeadings = qs('#ing_respect_headings');
      const chkJoin = qs('#ing_join_short');
      const chkSplit = qs('#ing_split_code');
      const chkNorm = qs('#ing_normalize');
      let modalCtx = { projectId: '', fileIds: [] };

      // Load embedding models from API and populate selector
      async function loadEmbeddingModels() {
        try {
          const response = await fetch('/api/embedding-models/');
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.models && inputModel) {
              // Clear existing options
              inputModel.innerHTML = '';

              // Add models from API
              data.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = `${model.name} (${model.dimensions} dim)`;
                if (model.status === 'deprecated') {
                  option.textContent += ' [DEPRECATED]';
                  option.disabled = true;
                }
                if (model.id === 'all-MiniLM-L6-v2') {
                  option.selected = true; // Default selection
                }
                inputModel.appendChild(option);
              });
            }
          }
        } catch (error) {
          console.warn('Failed to load embedding models:', error);
          // Fall back to hardcoded options if API fails
        }
      }

      function openIngestParamsModal(projectId, fileIds) {
        // Modal disabled - knowledge processing is now automatic
        toast('✅ Knowledge processing is automatic! No configuration needed.', false);
        return; // Early return - don't show modal
        modalCtx = { projectId, fileIds };
        loadEmbeddingModels(); // Load latest models when modal opens
        if (modal) modal.style.display = 'flex';
      }
      function closeIngestParamsModal() { if (modal) modal.style.display = 'none'; }
      if (btnClose) btnClose.addEventListener('click', closeIngestParamsModal);
      if (btnCancel) btnCancel.addEventListener('click', closeIngestParamsModal);
      if (modal) modal.addEventListener('click', (e) => { if (e.target === modal) closeIngestParamsModal(); });
      if (btnStart) btnStart.addEventListener('click', async () => {
        const pid = modalCtx.projectId; const ids = modalCtx.fileIds;
        if (!pid || !ids || !ids.length) { closeIngestParamsModal(); return; }
        const sizeTokens = parseInt((inputChunk && inputChunk.value) || '350', 10);
        const overlapTokens = parseInt((inputOverlap && inputOverlap.value) || '50', 10);
        const modelId = (inputModel && inputModel.value) || 'all-MiniLM-L6-v2';
        const batchSize = parseInt((inputBatch && inputBatch.value) || '64', 10);
        const params = {
          chunking: {
            strategy: 'semantic',
            sizeTokens,
            overlapTokens,
            respectHeadings: !!(chkHeadings && chkHeadings.checked),
            joinShortParagraphs: !!(chkJoin && chkJoin.checked),
            splitCodeBlocks: !!(chkSplit && chkSplit.checked)
          },
          embedding: {
            modelId,
            normalize: !!(chkNorm && chkNorm.checked),
            batchSize
          }
        };
        // Optimistically mark status=processing for selected files
        try {
          await Promise.all(ids.map(async (fid) => {
            await fetch(`/api/files/${encodeURIComponent(fid)}/tags`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('odras_token')}`
              },
              body: JSON.stringify({ tags: { status: 'processing' } })
            });
          }));
        } catch (_) { }
        closeIngestParamsModal();
        const res = await startWorkflowStartApi('ingestion_pipeline', pid, ids, params);
        if (res.ok) { toast('Ingestion started'); try { refreshRunsPanel(); } catch (_) { } } else { toast(`Ingestion failed: ${res.error}`, true); }
      });
      // Expose for bulk handler
      // Modal functionality disabled since knowledge processing is now automatic
      window.openIngestParamsModal = openIngestParamsModal;
    }

    // Runs panel
    async function loadRecentRuns() {
      try { const res = await fetch('/api/runs'); const js = await res.json(); return (js && js.runs) ? js.runs : []; } catch (_) { return []; }
    }
    async function refreshRunsPanel() {
      const pane = qs('#fileRunsContent'); if (!pane) return;
      const runs = await loadRecentRuns();
      if (!runs.length) { pane.textContent = 'No runs yet.'; return; }
      const rows = runs.slice(-10).reverse().map(r => {
        const name = r.filename || r.processKey || 'run';
        const status = r.status || 'started';
        const url = r.camunda_url || '';
        const when = r.started_at ? new Date(r.started_at).toLocaleString() : '';
        const link = url ? `<a href="${url}" target="_blank">Open</a>` : '';
        return `<div style="display:flex; justify-content:space-between; gap:8px; align-items:center;">
          <span>${name}</span>
          <span class="muted">${status}</span>
          <span>${link}</span>
        </div>`;
      }).join('');
      pane.innerHTML = rows;
    }
    // Initial runs load
    try { refreshRunsPanel(); } catch (_) { }
    async function deleteStoredFileViaApi(fileId) {
      console.log('🗑️  Deleting file:', fileId);
      try {
        const res = await fetch(`/api/files/${encodeURIComponent(fileId)}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('odras_token')}`
          }
        });
        console.log('🗑️  Delete response:', res.status, res.statusText);

        if (res.ok) {
          console.log('🗑️  Delete successful');
          return true;
        } else {
          console.error('🗑️  Delete failed:', res.status);
          return false;
        }
      } catch (e) {
        console.error('🗑️  Delete error:', e);
        return false;
      }
    }
    async function getFileUrlViaApi(fileId) {
      try {
        const res = await fetch(`/api/files/${encodeURIComponent(fileId)}/url`, {
          headers: { 'Authorization': `Bearer ${localStorage.getItem('odras_token')}` }
        });
        const js = await res.json();
        return (js && js.url) ? js.url : (js && js.success && js.file_id ? js.url : null);
      } catch (_) { return null; }
    }
    async function processFileViaApi(fileId) {
      try {
        const fd = new FormData();
        const res = await fetch(`/api/files/${encodeURIComponent(fileId)}/process`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${localStorage.getItem('odras_token')}` },
          body: fd
        });
        return res.ok;
      } catch (_) { return false; }
    }

    async function reprocessFileViaApi(fileId) {
      console.log('🔄 Reprocessing file:', fileId);
      try {
        // Call the file processing endpoint to regenerate knowledge asset
        const fd = new FormData();
        fd.append('processing_type', 'extract_requirements');
        fd.append('iterations', '10');

        const res = await fetch(`/api/files/${encodeURIComponent(fileId)}/process`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${localStorage.getItem('odras_token')}` },
          body: fd
        });

        console.log('🔄 Reprocess response:', res.status, res.statusText);

        if (res.ok) {
          const result = await res.json();
          console.log('🔄 Reprocess workflow started:', result);
          return true;
        } else {
          console.error('🔄 Reprocess failed:', res.status);
          return false;
        }
      } catch (e) {
        console.error('🔄 Reprocess error:', e);
        return false;
      }
    }
    function clearFilePreview() {
      console.log('👁️  Clearing file preview');
      const pane = qs('#filePreviewContent');
      const metaPane = qs('#fileMetaContent');

      if (pane) {
        pane.innerHTML = '<div class="muted" style="padding:20px; text-align:center;">Select a file to preview.</div>';
      }

      if (metaPane) {
        metaPane.innerHTML = '';
      }

      // Hide/clear preview controls data
      const controls = qs('#previewControls');
      if (controls) {
        controls.removeAttribute('data-file-id');
        controls.removeAttribute('data-filename');
        controls.removeAttribute('data-url');
      }

      // Clear current preview data
      currentPreviewData = { fileId: '', filename: '', url: '' };
    }

    async function updateFilePreview(fileId) {
      console.log('👁️  Starting preview for file:', fileId);
      try {
        const url = await getFileUrlViaApi(fileId);
        console.log('👁️  Got file URL:', url);

        const pane = qs('#filePreviewContent');
        const metaPane = qs('#fileMetaContent');

        if (!pane) {
          console.error('👁️  Preview pane not found');
          return;
        }

        if (!url) {
          console.log('👁️  No URL available, showing unavailable message');
          pane.textContent = 'Preview unavailable.';
          if (metaPane) metaPane.textContent = '';
          return;
        }

        // Get file metadata from the current library state
        const fileMetadata = filesState.library.find(f => f.file_id === fileId);
        console.log('👁️  File metadata:', fileMetadata);

        // Use metadata for extension and content type
        const filename = fileMetadata ? fileMetadata.filename : '';
        const metaContentType = fileMetadata ? fileMetadata.content_type : '';

        // Extract extension from filename instead of URL
        const ext = filename ? filename.toLowerCase().split('.').pop() || '' : '';
        console.log('👁️  File extension from metadata:', ext, 'from filename:', filename);

        // Use metadata content type, fallback to HEAD request
        let contentType = metaContentType || '';
        if (!contentType) {
          console.log('👁️  No content type in metadata, trying HEAD request...');
          try {
            const head = await fetch(url, { method: 'HEAD' });
            contentType = head.headers.get('Content-Type') || '';
            console.log('👁️  HEAD request successful, content type:', contentType);
          } catch (e) {
            console.log('👁️  HEAD request failed (expected for presigned URLs):', e.message);
          }
        } else {
          console.log('👁️  Using content type from metadata:', contentType);
        }

        // Render enhanced metadata
        try {
          if (metaPane) {
            const size = fileMetadata ? fileMetadata.size : 0;
            const sizeStr = size > 1024 * 1024 ? `${(size / (1024 * 1024)).toFixed(1)} MB` : size > 1024 ? `${(size / 1024).toFixed(1)} KB` : `${size} bytes`;
            const tags = fileMetadata ? fileMetadata.tags || {} : {};
            const docType = tags.docType || 'unknown';
            const status = tags.status || 'new';

            metaPane.innerHTML = `<div style="display:grid; gap:4px; font-size:12px;">
              <div><strong>Filename:</strong> ${filename || 'Unknown'}</div>
              <div><strong>Type:</strong> ${docType} (${contentType || ext || 'unknown'})</div>
              <div><strong>Size:</strong> ${sizeStr}</div>
              <div><strong>Status:</strong> ${status}</div>
              <div><strong>Actions:</strong> <a href="${url}" target="_blank" style="color:var(--accent);">Open</a></div>
          </div>`;
          }
        } catch (e) {
          console.error('👁️  Metadata render error:', e);
        }
        // PDF preview (with multiple rendering options)
        if (ext === 'pdf' || (contentType && contentType.includes('pdf'))) {
          console.log('👁️  Rendering PDF preview for URL:', url);

          // Create container with fallback structure
          const pdfContainer = `
            <div style="border:1px solid var(--border); border-radius:6px; overflow:hidden;">
              <div id="pdf-iframe-${fileId}" style="width:100%; height:500px; display:block;">
                <iframe src="${url}#toolbar=0&navpanes=0" style="width:100%; height:100%; border:none;"></iframe>
              </div>

              <div id="pdf-fallback-${fileId}" style="display:none; padding:40px; text-align:center; background:var(--panel-2);">
                <div style="margin-bottom:16px; color:var(--muted);">
                  <svg style="width:48px; height:48px; margin-bottom:12px;" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                  </svg>
                  <br/>
                  <strong>PDF Document</strong>
                  <br/>
                  <small>Click to open in new tab</small>
                </div>
                <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">
                  <a href="${url}" target="_blank" class="btn" style="text-decoration:none;">
                    📄 Open PDF
                  </a>
                  <button class="btn" onclick="navigator.clipboard.writeText('${url}').then(()=>this.textContent='✓ Copied').catch(()=>this.textContent='Copy failed');">
                    📋 Copy URL
                  </button>
                </div>
              </div>
            </div>
          `;

          pane.innerHTML = pdfContainer;

          // Add proper event handling after DOM insertion
          setTimeout(() => {
            const iframe = pane.querySelector(`#pdf-iframe-${fileId} iframe`);
            const fallbackDiv = pane.querySelector(`#pdf-fallback-${fileId}`);
            const iframeContainer = pane.querySelector(`#pdf-iframe-${fileId}`);

            if (iframe && fallbackDiv && iframeContainer) {
              // Set up error handling
              iframe.onerror = () => {
                console.error('👁️ PDF iframe failed to load');
                iframeContainer.style.display = 'none';
                fallbackDiv.style.display = 'block';
              };

              iframe.onload = () => {
                console.log('👁️ PDF iframe onload triggered');
                // Check if it actually loaded a PDF or just showed source
                setTimeout(() => {
                  try {
                    // If we can't access contentDocument, assume it's working (CORS blocked)
                    iframe.contentDocument;
                    console.log('👁️ PDF iframe content accessible - might be showing source');
                    // For now, assume PDF is working if no error occurs
                  } catch (e) {
                    console.log('👁️ PDF iframe CORS blocked - PDF is likely rendering correctly');
                  }
                }, 1000);
              };

              // Check after 3 seconds if iframe seems to be working
              setTimeout(() => {
                try {
                  // Simple heuristic: if iframe is still visible, assume it's working
                  if (iframeContainer.style.display !== 'none') {
                    console.log('👁️ PDF iframe appears to be working');
                  }
                } catch (e) {
                  console.log('👁️ PDF iframe error check failed:', e);
                }
              }, 3000);
            }
          }, 100);

          return;
        }

        // Image inline (with size constraints)
        if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'].includes(ext) || (contentType && contentType.startsWith('image/'))) {
          console.log('👁️  Rendering image preview');
          pane.innerHTML = `<div style="text-align:center; padding:10px;">
            <img src="${url}" alt="preview" style="max-width:100%; max-height:300px; height:auto; border-radius:6px; box-shadow:0 2px 8px rgba(0,0,0,0.1);" />
          </div>`;
          return;
        }

        // CSV table (full content with responsive styling)
        if (ext === 'csv' || (contentType && contentType.includes('csv'))) {
          console.log('👁️  Rendering CSV preview');
          try {
            const res = await fetch(url);
            if (!res.ok) throw new Error('Fetch failed');
            const text = await res.text();
            const lines = text.split(/\r?\n/).filter(line => line.trim()); // Show all rows, filter empty lines
            const cells = lines.map(l => l.split(',').map(x => x.replace(/&/g, '&amp;').replace(/</g, '&lt;'))); // No cell content limits
            const header = cells.shift() || [];
            const rows = cells.map(row => `<tr>${row.map(c => `<td style="padding:4px 8px; border-bottom:1px solid var(--border); font-size:12px; word-wrap:break-word; max-width:200px;">${c}</td>`).join('')}</tr>`).join('');
            pane.innerHTML = `<div style="max-height:600px; overflow:auto; border:1px solid var(--border); border-radius:6px;">
              <table style="width:100%; border-collapse:collapse; font-size:12px;">
                <thead style="position:sticky; top:0; background:var(--panel);">
                  <tr>${header.map(h => `<th style="padding:6px 8px; text-align:left; border-bottom:2px solid var(--border); font-weight:600; word-wrap:break-word; max-width:200px;">${h}</th>`).join('')}</tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>
            </div>`;
          } catch (e) {
            console.error('👁️  CSV preview error:', e);
            pane.textContent = 'CSV preview unavailable.';
          }
          return;
        }

        // Markdown preview (full content with styling)
        if (['md', 'markdown'].includes(ext) || (contentType && contentType.includes('markdown'))) {
          console.log('👁️  Rendering Markdown preview');
          try {
            const res = await fetch(url);
            if (!res.ok) throw new Error('Fetch failed');
            const text = await res.text();
            const html = renderBasicMarkdown(text);
            pane.innerHTML = `<div style="max-height:600px; overflow:auto; padding:10px; border:1px solid var(--border); border-radius:6px; background:var(--panel-2); font-size:13px; line-height:1.5;">
              ${html}
            </div>`;
          } catch (e) {
            console.error('👁️  Markdown preview error:', e);
            pane.textContent = 'Markdown preview unavailable.';
          }
          return;
        }

        // Fallback text preview (full content with styling)
        console.log('👁️  Rendering fallback text preview');
        try {
          const res = await fetch(url, { method: 'GET' });
          if (!res.ok) throw new Error('Fetch failed');
          const buf = await res.arrayBuffer();
          const bytes = new Uint8Array(buf); // Load full file content
          let text = '';
          try {
            text = new TextDecoder('utf-8', { fatal: false }).decode(bytes);
          } catch (_) {
            pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--muted);">Binary file - preview not available<br/><small>Use "Open" link to download</small></div>';
            return;
          }

          const safe = (s) => String(s || '').replace(/[&<>]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[c]));

          if (text) {
            pane.innerHTML = `<div style="max-height:600px; overflow:auto; border:1px solid var(--border); border-radius:6px; background:var(--panel-2);">
              <pre style="white-space:pre-wrap; margin:0; padding:12px; font-size:12px; line-height:1.4; font-family:'Monaco','Menlo','Ubuntu Mono',monospace;">${safe(text)}</pre>
            </div>`;
          } else {
            pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--muted);">Empty file or unsupported format</div>';
          }
        } catch (e) {
          console.error('👁️  Text preview error:', e);
          pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--err);">Preview unavailable<br/><small>Use "Open" link to access file</small></div>';
        }
      } catch (e) {
        console.error('👁️  Preview function error:', e);
        const pane = qs('#filePreviewContent');
        if (pane) pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--err);">Preview error occurred</div>';
      }

      // Store current file info in preview controls for fullscreen/popout
      const controls = qs('#previewControls');
      if (controls) {
        // Store current file info for fullscreen/popout
        controls.setAttribute('data-file-id', fileId);
        controls.setAttribute('data-filename', filename || 'document');
        controls.setAttribute('data-url', url || '');
        console.log('👁️  Controls configured with:', { fileId, filename, url });
      }
    }

    // Fullscreen and popout functionality
    let currentPreviewData = { fileId: '', filename: '', url: '' };

    function openFullscreenPreview() {
      const pane = qs('#filePreviewContent');
      const modal = qs('#previewFullscreenModal');
      const fullscreenContent = qs('#fullscreenPreviewContent');
      const title = qs('#fullscreenPreviewTitle');
      const controls = qs('#previewControls');

      if (!pane || !modal || !fullscreenContent) {
        console.error('👁️  Missing elements for fullscreen');
        return;
      }

      // Get current file data
      if (controls) {
        currentPreviewData.fileId = controls.getAttribute('data-file-id') || '';
        currentPreviewData.filename = controls.getAttribute('data-filename') || 'Document';
        currentPreviewData.url = controls.getAttribute('data-url') || '';
      }

      // Clone content structure but regenerate with full height
      const originalHTML = pane.innerHTML;

      // For PDFs and iframes, recreate with full height instead of constrained height
      if (originalHTML.includes('<iframe') && originalHTML.includes('pdf')) {
        const url = currentPreviewData.url;
        fullscreenContent.innerHTML = `
          <div style="width:100%; height:100%; border:none;">
            <iframe src="${url}#toolbar=0&navpanes=0" style="width:100%; height:100%; border:none;"></iframe>
          </div>
        `;
      } else {
        // For other content, just clone but remove height constraints
        let fullscreenHTML = originalHTML;
        // Remove any height constraints from the cloned content
        fullscreenHTML = fullscreenHTML.replace(/max-height:\s*\d+px/gi, 'max-height: 100%');
        fullscreenHTML = fullscreenHTML.replace(/height:\s*\d+px/gi, 'height: auto');
        fullscreenContent.innerHTML = fullscreenHTML;
      }

      if (title) title.textContent = `${currentPreviewData.filename} - Preview`;

      // Show modal
      modal.style.display = 'block';
      document.body.style.overflow = 'hidden'; // Prevent body scroll

      console.log('👁️  Opened fullscreen preview for:', currentPreviewData.filename);
    }

    function closeFullscreenPreview() {
      const modal = qs('#previewFullscreenModal');
      if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = ''; // Restore body scroll
        console.log('👁️  Closed fullscreen preview');
      }
    }

    function popoutPreview() {
      console.log('👁️  Popout requested with data:', currentPreviewData);

      if (!currentPreviewData.url) {
        // Try to get URL from controls if not in currentPreviewData
        const controls = qs('#previewControls');
        if (controls) {
          currentPreviewData.url = controls.getAttribute('data-url') || '';
          console.log('👁️  Retrieved URL from controls:', currentPreviewData.url);
        }
      }

      if (!currentPreviewData.url) {
        console.error('👁️  No URL available for popout');
        alert('Cannot open file in new window - no URL available');
        return;
      }

      const filename = currentPreviewData.filename || 'Document';
      const url = currentPreviewData.url;

      console.log('👁️  Opening URL in new window:', url);

      try {
        // Open in new window with proper window features
        const popup = window.open(url, '_blank', 'width=1000,height=800,scrollbars=yes,resizable=yes,toolbar=yes,menubar=no,status=yes');
        if (popup) {
          // Set title after a brief delay to ensure content loads
          setTimeout(() => {
            try {
              popup.document.title = filename;
            } catch (e) {
              // CORS may prevent title setting, that's ok
              console.log('👁️  Could not set popup title (CORS)');
            }
          }, 1000);
          console.log('👁️  Successfully opened preview in new window');
        } else {
          console.error('👁️  Popup was blocked');
          // Fallback: try to open in new tab
          const fallback = window.open(url, '_blank');
          if (fallback) {
            console.log('👁️  Fallback: opened in new tab');
          } else {
            console.error('👁️  Both popup and fallback blocked');
            alert('Popup blocked. Please allow popups for this site or use the "Open" link in metadata.');
          }
        }
      } catch (e) {
        console.error('👁️  Error opening popup:', e);
        alert('Error opening new window: ' + e.message);
      }
    }

    // Initialize preview controls
    try {
      const fullscreenBtn = qs('#previewFullscreenBtn');
      const popoutBtn = qs('#previewPopoutBtn');
      const fullscreenCloseBtn = qs('#fullscreenCloseBtn');
      const fullscreenPopoutBtn = qs('#fullscreenPopoutBtn');
      const fullscreenModal = qs('#previewFullscreenModal');

      if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', openFullscreenPreview);
      }
      if (popoutBtn) {
        popoutBtn.addEventListener('click', popoutPreview);
      }
      if (fullscreenCloseBtn) fullscreenCloseBtn.addEventListener('click', closeFullscreenPreview);
      if (fullscreenPopoutBtn) fullscreenPopoutBtn.addEventListener('click', popoutPreview);

      // Close fullscreen on ESC key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && fullscreenModal && fullscreenModal.style.display === 'block') {
          closeFullscreenPreview();
        }
      });

      // Close fullscreen on modal background click
      if (fullscreenModal) {
        fullscreenModal.addEventListener('click', (e) => {
          if (e.target === fullscreenModal) {
            closeFullscreenPreview();
          }
        });
      }

    } catch (e) {
      console.error('👁️  Preview controls initialization failed:', e);
    }

    // Controls will show automatically when a file is selected for preview

    // Admin check function - checks if current user has admin role
    async function isAdmin() {
      const username = localStorage.getItem('odras_user') || '';
      const isAdminUser = username === 'admin';

      console.log('👑 Checking admin status - username:', username, 'isAdmin:', isAdminUser);
      return isAdminUser;
    }

    // Function to update admin UI elements visibility based on user admin status
    function updateAdminUIVisibility(isAdmin) {
      console.log('🔧 Updating admin UI visibility, isAdmin:', isAdmin);

      // Hide/show admin icon in left toolbar
      const adminIcon = document.querySelector('.icon[data-wb="admin"]');
      if (adminIcon) {
        adminIcon.style.display = isAdmin ? 'grid' : 'none';
      }

      // Hide/show Event Manager icon (admin only)
      const eventManagerIcon = document.querySelector('.icon[data-wb="events"]');
      if (eventManagerIcon) {
        eventManagerIcon.style.display = isAdmin ? 'grid' : 'none';
      }

      // Hide/show RAG configuration section (admin only)
      const ragConfigSection = document.getElementById('ragConfig');
      if (ragConfigSection) {
        ragConfigSection.parentElement.style.display = isAdmin ? 'block' : 'none';
      }

      // If admin workbench is currently active but user is not admin, switch to ontology workbench
      const adminWorkbench = document.querySelector('#wb-admin');
      if (!isAdmin && adminWorkbench && adminWorkbench.classList.contains('active')) {
        console.log('🔄 Switching from admin workbench to ontology workbench');
        // Remove active class from admin workbench
        adminWorkbench.classList.remove('active');
        // Remove active class from admin icon
        if (adminIcon) {
          adminIcon.classList.remove('active');
        }
        // Activate ontology workbench
        const ontologyIcon = document.querySelector('.icon[data-wb="ontology"]');
        const ontologyWorkbench = document.querySelector('#wb-ontology');
        if (ontologyIcon && ontologyWorkbench) {
          ontologyIcon.classList.add('active');
          ontologyWorkbench.classList.add('active');
          // Update URL hash
          const url = new URL(window.location);
          url.hash = 'wb=ontology';
          window.history.replaceState({}, '', url);
          // Update localStorage
          localStorage.setItem('active_workbench', 'ontology');
        }
      }

      // Load configurations if user is admin and admin workbench is active
      if (isAdmin && adminWorkbench && adminWorkbench.classList.contains('active')) {
        loadRagConfig();
        loadFileProcessingConfig(); // Load file processing config too
      }
    }
    function renderBasicMarkdown(src) {
      const esc = (s) => String(s || '').replace(/[&<>]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[c]));
      let s = esc(src);
      s = s.replace(/^######\s+(.*)$/gm, '<h6>$1</h6>')
        .replace(/^#####\s+(.*)$/gm, '<h5>$1</h5>')
        .replace(/^####\s+(.*)$/gm, '<h4>$1</h4>')
        .replace(/^###\s+(.*)$/gm, '<h3>$1</h3>')
        .replace(/^##\s+(.*)$/gm, '<h2>$1</h2>')
        .replace(/^#\s+(.*)$/gm, '<h1>$1</h1>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.+?)\*/g, '<em>$1</em>')
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        .replace(/\n\n/g, '<br/><br/>');
      return `<div>${s}</div>`;
    }
    // Ensure file handlers are bound even if Files workbench is the initial active view
    try { setTimeout(() => { try { ensureFilesInitialized(); } catch (_) { } }, 0); } catch (_) { }

    // DAS dock: state, toggle, docking, resize, persistence
    (function () {
      const storageKey = 'odras_das_state';
      const panel = document.getElementById('dasPanel');
      const resizerX = document.getElementById('dasResizerX');
      const resizerY = document.getElementById('dasResizerY');
      const transcript = document.getElementById('dasTranscript');
      const promptInput = document.getElementById('dasPrompt');
      const sendBtn = document.getElementById('dasSendBtn');
      if (!panel) return;

      // Auto-expand textarea functionality
      function autoExpandTextarea(textarea) {
        textarea.style.height = 'auto';
        const newHeight = Math.min(textarea.scrollHeight, 120); // Max height of 120px
        textarea.style.height = newHeight + 'px';
      }

      // Set up auto-expand for the textarea
      if (promptInput) {
        promptInput.addEventListener('input', function () {
          autoExpandTextarea(this);
        });

        // Also expand on paste
        promptInput.addEventListener('paste', function () {
          setTimeout(() => autoExpandTextarea(this), 0);
        });
      }
      let state = { open: false, dock: 'right', width: 420, height: Math.max(300, Math.round(window.innerHeight * 0.4)) };
      try { const saved = JSON.parse(localStorage.getItem(storageKey) || '{}'); state = { ...state, ...saved }; } catch (_) { }
      function applyState() {
        panel.classList.remove('das-dock-left', 'das-dock-right', 'das-dock-bottom');
        if (state.open) panel.classList.add('active'); else panel.classList.remove('active');
        const dockCls = state.dock === 'left' ? 'das-dock-left' : (state.dock === 'bottom' ? 'das-dock-bottom' : 'das-dock-right');
        panel.classList.add(dockCls);
        document.documentElement.style.setProperty('--das-w', state.width + 'px');
        document.documentElement.style.setProperty('--das-h', state.height + 'px');
        // Body classes to shift layout
        document.body.classList.remove('das-open-left', 'das-open-right', 'das-open-bottom');
        if (state.open) {
          if (state.dock === 'left') document.body.classList.add('das-open-left');
          else if (state.dock === 'bottom') document.body.classList.add('das-open-bottom');
          else document.body.classList.add('das-open-right');
        }
      }
      function persist() { try { localStorage.setItem(storageKey, JSON.stringify(state)); } catch (_) { } }
      function toggleOpen() { state.open = !state.open; applyState(); persist(); }
      function setDock(pos) { state.dock = pos; applyState(); persist(); }

      // Function to close and clean DAS dock (for logout/session expiry)
      function closeDASAndClean() {
        console.log('🔒 Closing and cleaning DAS dock due to logout/session expiry');

        // Close the dock
        state.open = false;
        applyState();
        persist();

        // Clear DAS-related state
        currentProjectThreadId = null;
        isProcessing = false;

        // Clear transcript
        if (transcript) {
          transcript.innerHTML = '';
        }

        // Clear prompt input
        if (promptInput) {
          promptInput.value = '';
        }

        // Update status
        updateDASStatus('Disconnected');

        // Stop LLM health monitoring
        stopLLMHealthMonitoring();

        // Clear any DAS-related localStorage entries for the current session
        try {
          // Note: We don't clear the dock state (position, size) as that's user preference
          // Only clear session-specific data
          const keysToCheck = Object.keys(localStorage);
          keysToCheck.forEach(key => {
            if (key.startsWith('das_session_') || key.startsWith('das_thread_')) {
              localStorage.removeItem(key);
            }
          });
        } catch (e) {
          console.warn('Failed to clear DAS session data:', e);
        }

        console.log('✅ DAS dock closed and cleaned');
      }

      // Make closeDASAndClean available globally for logout functions
      window.closeDASAndClean = closeDASAndClean;
      // Resize handlers
      (function () {
        let dragging = false; let startX = 0; let startY = 0; let startW = 0; let startH = 0;
        function onMove(e) {
          if (!dragging) return;
          if (state.dock === 'bottom') {
            const dy = e.clientY - startY;
            const h = Math.max(200, startH - dy);
            state.height = h;
          } else {
            const dx = e.clientX - startX;
            let w = startW;
            if (state.dock === 'right') w = Math.max(260, startW - dx);
            if (state.dock === 'left') w = Math.max(260, startW + dx);
            state.width = w;
          }
          applyState();
        }
        function endDrag() {
          if (!dragging) return;
          dragging = false; persist();
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', endDrag);
        }
        function startDragX(e) { dragging = true; startX = e.clientX; startW = state.width; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', endDrag); e.preventDefault(); }
        function startDragY(e) { dragging = true; startY = e.clientY; startH = state.height; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', endDrag); e.preventDefault(); }
        if (resizerX) resizerX.addEventListener('mousedown', startDragX);
        if (resizerY) resizerY.addEventListener('mousedown', startDragY);
      })();
      // DAS functionality
      let currentProjectThreadId = null;
      let isProcessing = false;
      let llmStatusInterval = null;
      let llmInitialized = false;
      let dasInitializing = false;

      // Check LLM health status
      async function checkLLMHealth() {
        // Get status dot elements
        const mainDot = document.getElementById('llmStatusDot');
        const dockDot = document.getElementById('llmStatusDockDot');

        const dots = [mainDot, dockDot].filter(Boolean);

        if (dots.length === 0) {
          console.warn('No LLM status dot elements found');
          return;
        }

        try {
          // Set checking state (amber)
          dots.forEach(dot => {
            dot.style.background = '#f59e0b'; // --warn color
            dot.title = 'LLM Status: Checking...';
          });

          // Note: /api/das/llm/health doesn't exist, so just set as healthy
          // DAS functionality will be checked when actually used
          const isHealthy = true;

          if (isHealthy) {
            dots.forEach(dot => {
              dot.style.background = 'var(--ok)'; // Green
              dot.title = 'LLM Status: Ready';
            });
            console.log('LLM health check: Healthy');
          } else {
            dots.forEach(dot => {
              dot.style.background = 'var(--err)'; // Red
              dot.title = `LLM Status: Unhealthy - ${data.error || 'Unknown error'}`;
            });
            console.warn('LLM health check: Unhealthy', data);
          }
        } catch (error) {
          dots.forEach(dot => {
            dot.style.background = 'var(--err)'; // Red
            dot.title = `LLM Status: Error - ${error.message}`;
          });
          console.error('LLM health check failed:', error);
        }
      }

      // Start LLM health monitoring
      function startLLMHealthMonitoring() {
        // Check immediately
        checkLLMHealth();

        // Check every 30 seconds
        llmStatusInterval = setInterval(checkLLMHealth, 30000);
      }

      // Stop LLM health monitoring
      function stopLLMHealthMonitoring() {
        if (llmStatusInterval) {
          clearInterval(llmStatusInterval);
          llmStatusInterval = null;
        }
      }

      // Initialize DAS project thread with proper server-side discovery
      async function initializeDASProjectThread() {
        if (dasInitializing) {
          console.log('⚠️ DAS initialization already in progress, skipping duplicate call');
          return;
        }

        try {
          dasInitializing = true;
          const projectId = getCurrentProjectId();
          if (!projectId) {
            updateDASStatus('No Project');
            addMessageToTranscript('system', 'Please select a project to start DAS conversation.');
            return;
          }

          updateDASStatus('Connecting...');

          // Use DAS2 server-side project thread discovery (no localStorage dependency)
          const response = await fetch(`/api/das2/project/${projectId}/thread`, {
            method: 'GET',
            headers: { ...authHeader() }
          });

          if (response.ok) {
            const data = await response.json();
            currentProjectThreadId = data.project_thread_id;

            updateDASStatus('Ready');

            // Load RAG configuration for DAS
            await loadRagConfigForDAS();

            // Load conversation history for this project (with delay to ensure UI is ready)
            setTimeout(async () => {
              await loadProjectThreadHistoryByProject(projectId);
            }, 200);

            // Determine if this is a new or existing thread
            const historyResponse = await fetch(`/api/das2/project/${projectId}/history`, {
              method: 'GET',
              headers: { ...authHeader() }
            });

            if (historyResponse.ok) {
              const historyData = await historyResponse.json();
              const history = historyData.history || [];

              if (history.length === 0) {
                addMessageToTranscript('system', 'DAS project thread ready. How can I help you with this project?');
              } else {
                addMessageToTranscript('system', 'DAS project thread restored with conversation history. How can I continue helping you?');
              }
            } else {
              addMessageToTranscript('system', 'DAS project thread ready. How can I help you today?');
            }

          } else if (response.status === 404) {
            // No project thread exists - this is expected if project hasn't been created yet
            updateDASStatus('Not Available');
            addMessageToTranscript('system', 'DAS is not yet available for this project. Project threads are created when projects are created. Please create a project to start using DAS.');
            // Disable DAS input
            const promptInput = document.getElementById('das-prompt-input');
            const sendBtn = document.getElementById('das-send-btn');
            if (promptInput) promptInput.disabled = true;
            if (sendBtn) sendBtn.disabled = true;
          } else {
            const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
            updateDASStatus('Error');
            addMessageToTranscript('error', `Failed to initialize DAS: ${error.detail}`);
          }
        } catch (error) {
          updateDASStatus('Error');
          addMessageToTranscript('error', 'Error connecting to DAS: ' + error.message);
        } finally {
          dasInitializing = false;
        }
      }

      // Load project thread history by project ID (new approach)
      async function loadProjectThreadHistoryByProject(projectId) {
        try {
          console.log(`Loading project thread history for project: ${projectId}`);

          const response = await fetch(`/api/das2/project/${projectId}/history`, {
            method: 'GET',
            headers: { ...authHeader() }
          });

          if (response.ok) {
            const data = await response.json();
            const history = data.history || [];

            console.log(`Received ${history.length} conversation entries from server`);

            // Debug: log structure of first entry if available
            if (history.length > 0) {
              console.log('📋 Sample conversation entry structure:', Object.keys(history[0]));
              console.log('📋 Sample conversation entry:', history[0]);
            }

            // Ensure transcript element exists
            const transcript = document.getElementById('dasTranscript');
            if (!transcript) {
              console.error('DAS transcript element not found - cannot load history');
              return;
            }

            // Clear current transcript
            transcript.innerHTML = '';

            // Load history messages
            let loadedCount = 0;
            for (const entry of history) {
              // Handle new backend format: each entry has user_message and das_response
              if (entry.user_message) {
                addMessageToTranscript('user', entry.user_message);
                loadedCount++;
              }
              if (entry.das_response) {
                addMessageToTranscript('das', entry.das_response, entry.metadata || {});
                loadedCount++;
              }

              // Fallback: handle legacy format for compatibility
              if (entry.type === 'user' && entry.message) {
                addMessageToTranscript('user', entry.message);
                loadedCount++;
              } else if (entry.type === 'das' && entry.message) {
                addMessageToTranscript('das', entry.message, entry.metadata || {});
                loadedCount++;
              }
            }

            console.log(`✅ Loaded ${loadedCount} messages into DAS transcript for project ${projectId}`);

            // Scroll to bottom to show latest messages
            transcript.scrollTop = transcript.scrollHeight;

          } else {
            console.log(`No conversation history found for project ${projectId} (${response.status})`);
          }
        } catch (error) {
          console.error('Error loading project thread history:', error);
        }
      }

      // Legacy function - kept for compatibility
      async function loadProjectThreadHistory() {
        const projectId = getCurrentProjectId();
        if (projectId) {
          await loadProjectThreadHistoryByProject(projectId);
        }
      }

      // Reinitialize DAS dock for a new project (called when user switches projects)
      async function reinitializeDASForProject(newProjectId) {
        try {
          console.log('🔄 [REINIT] Starting DAS dock reinitialize for project:', newProjectId);

          // Check if DAS dock is open
          const dasDock = document.getElementById('dasPanel');
          const isDockOpen = dasDock && dasDock.classList.contains('active');
          const bodyHasDasOpen = document.body.classList.contains('das-open-left') ||
            document.body.classList.contains('das-open-right') ||
            document.body.classList.contains('das-open-bottom');

          console.log('🔄 [REINIT] DAS dock element found:', !!dasDock);
          console.log('🔄 [REINIT] DAS dock has active class:', isDockOpen);
          console.log('🔄 [REINIT] Body has das-open class:', bodyHasDasOpen);

          if (!dasDock || !isDockOpen) {
            console.log('🔄 [REINIT] DAS dock not open, skipping reinitialization');
            return;
          }

          console.log('🔄 [REINIT] Resetting DAS state for new project...');

          // Reset DAS state for new project
          currentProjectThreadId = null;
          dasInitializing = false;

          console.log('🔄 [REINIT] Current state reset - currentProjectThreadId:', currentProjectThreadId, 'dasInitializing:', dasInitializing);

          // Clear current transcript
          const transcript = document.getElementById('dasTranscript');
          if (transcript) {
            console.log('🔄 [REINIT] Clearing transcript...');
            transcript.innerHTML = '';
            addMessageToTranscript('system', `Switching to project ${newProjectId}...`);
          }

          // Update status
          updateDASStatus('Switching projects...');
          console.log('🔄 [REINIT] Status updated, waiting for project data to settle...');

          // Wait a moment for project data to settle
          setTimeout(async () => {
            try {
              console.log('🔄 [REINIT] Initializing DAS for new project:', newProjectId);
              await initializeDASProjectThread();
              console.log('🔄 [REINIT] DAS initialization completed successfully');
            } catch (error) {
              console.error('🔄 [REINIT] Failed to reinitialize DAS for new project:', error);
              updateDASStatus('Error');
              addMessageToTranscript('error', `Failed to switch to new project: ${error.message}`);
            }
          }, 500);

        } catch (error) {
          console.error('🔄 [REINIT] Error reinitializing DAS dock:', error);
        }
      }

      // Make reinitializeDASForProject globally available
      window.reinitializeDASForProject = reinitializeDASForProject;

      // Edit and retry functionality (global scope)
      window.editLastMessage = function (originalMessage, messageElement) {
        console.log('🔧 Edit button clicked for message:', originalMessage);

        // If messageElement not provided, find it by the button that was clicked
        if (!messageElement) {
          // Find the message element by looking for the button that was clicked
          const clickedButton = event.target.closest('.das-edit-btn');
          console.log('🔍 Found clicked button:', clickedButton);

          if (clickedButton) {
            messageElement = clickedButton.closest('.das-user-message');
            console.log('🔍 Found message element:', messageElement);
          }
        }

        if (!messageElement) {
          console.error('❌ Could not find message element');
          return;
        }

        const messageContainer = messageElement.querySelector('.das-user-message-container');
        console.log('🔍 Found message container:', messageContainer);

        if (!messageContainer) {
          console.error('❌ Could not find message container');
          return;
        }

        // Store reference to the message element for later cleanup
        messageContainer.setAttribute('data-original-message', originalMessage);
        messageElement.setAttribute('data-editing', 'true');

        // Replace with edit interface
        messageContainer.innerHTML = `
          <div><strong>You:</strong> <em>(editing)</em></div>
          <textarea class="das-edit-input" rows="2">${originalMessage}</textarea>
          <div class="das-edit-controls">
            <button class="save-btn" onclick="window.saveEditedMessage(this)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" width="14" height="14">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                <polyline points="17,21 17,13 7,13 7,21"/>
                <polyline points="7,3 7,8 15,8"/>
              </svg>
              Save & Retry
            </button>
            <button class="cancel-btn" onclick="window.cancelEdit(this)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" width="14" height="14">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
              Cancel
            </button>
          </div>
        `;

        // Focus the textarea
        const textarea = messageContainer.querySelector('.das-edit-input');
        if (textarea) {
          textarea.focus();
          textarea.select();
        }
      }

      window.saveEditedMessage = async function (button) {
        console.log('💾 Save & Retry clicked');
        const messageContainer = button.closest('.das-user-message-container');
        const textarea = messageContainer.querySelector('.das-edit-input');
        const newMessage = textarea.value.trim();

        console.log('📝 New message:', newMessage);
        if (!newMessage) return;

        try {
          // Find the message being edited
          const editedMessageElement = button.closest('.das-user-message');
          const transcript = document.getElementById('dasTranscript');
          const allMessages = Array.from(transcript.querySelectorAll('.card'));

          // Find the index of the message being edited
          const editedIndex = allMessages.indexOf(editedMessageElement);
          console.log(`🔍 Editing message at index ${editedIndex}, removing ${allMessages.length - editedIndex} messages`);

          // Remove ALL messages from the edited point onward (including the edited message)
          for (let i = allMessages.length - 1; i >= editedIndex; i--) {
            allMessages[i].remove();
            console.log(`🗑️ Removed message at index ${i}`);
          }

          // Calculate how many conversation entries to remove from the project thread
          // Each user message + DAS response = 1 conversation entry
          const conversationsToRemove = Math.ceil((allMessages.length - editedIndex) / 2);

          // Remove conversation entries from the project thread
          const projectId = getCurrentProjectId();
          if (projectId && conversationsToRemove > 0) {
            try {
              // Call DAS2 delete endpoint for each conversation pair
              for (let i = 0; i < conversationsToRemove; i++) {
                const deleteResponse = await fetch(`/api/das2/project/${projectId}/conversation/last`, {
                  method: 'DELETE',
                  headers: { ...authHeader() }
                });

                if (deleteResponse.ok) {
                  const result = await deleteResponse.json();
                  console.log(`✅ Deleted conversation entry ${i + 1}/${conversationsToRemove}:`, result.message);
                } else {
                  console.warn(`⚠️ Failed to delete conversation entry ${i + 1}/${conversationsToRemove}:`, deleteResponse.status);
                }
              }
            } catch (error) {
              console.error('Error deleting conversation entries:', error);
            }
          }

          // Send the edited message as a fresh start
          await sendDASMessage(newMessage);

        } catch (error) {
          console.error('Error during edit and retry:', error);
          // Still try to send the new message even if cleanup failed
          await sendDASMessage(newMessage);
        }
      }

      window.cancelEdit = function (button) {
        console.log('❌ Cancel edit clicked');
        const messageContainer = button.closest('.das-user-message-container');
        const messageElement = button.closest('.das-user-message');

        // Get original message from data attribute
        const originalMessage = messageContainer.getAttribute('data-original-message') || 'Message';

        // Restore original message with edit button using new layout
        messageContainer.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 6px;">
            <strong>You:</strong>
            <button class="das-edit-btn" onclick="window.editLastMessage('${originalMessage.replace(/'/g, "\\'")}')">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" width="14" height="14">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            </button>
          </div>
          <div class="das-user-message-text">${originalMessage}</div>
        `;

        // Remove editing flag
        messageElement.removeAttribute('data-editing');
      }

      // Send message to DAS
      async function sendDASMessage(message) {
        if (isProcessing || !message.trim()) return;

        isProcessing = true;
        updateDASStatus('Processing...');
        sendBtn.disabled = true;

        // Add user message to transcript
        addMessageToTranscript('user', message);

        // Add progress indicator with animated ellipsis
        const progressId = 'das-progress-' + Date.now();
        addMessageToTranscript('progress', '<span id="' + progressId + '" class="das-progress">DAS is thinking<span class="ellipsis-dots">...</span></span>');

        // Start ellipsis animation
        let ellipsisCount = 0;
        const ellipsisInterval = setInterval(() => {
          const ellipsisElement = document.querySelector('#' + progressId + ' .ellipsis-dots');
          if (ellipsisElement) {
            ellipsisCount = (ellipsisCount + 1) % 4;
            ellipsisElement.textContent = '.'.repeat(ellipsisCount);
          }
        }, 500);

        // Helper function to clean up progress indicator
        const cleanupProgress = () => {
          clearInterval(ellipsisInterval);
          const progressElement = document.getElementById(progressId);
          if (progressElement && progressElement.parentElement) {
            progressElement.parentElement.remove();
          }
        };

        try {
          console.log('Sending DAS message:', message);

          // Get current context for DAS
          const currentContext = {
            project_id: getCurrentProjectId(),
            ontology_id: activeOntologyIri ? activeOntologyIri.split('/').pop() : null,
            workbench: getCurrentWorkbench() || 'ontology'
          };

          console.log('DAS Context:', currentContext);

          // Add connection timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 second timeout

          const response = await fetch('/api/das2/chat/stream', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', ...authHeader() },
            body: JSON.stringify({
              message: message,
              project_thread_id: currentProjectThreadId,
              ...currentContext  // ← Include project context
            }),
            signal: controller.signal
          });

          clearTimeout(timeoutId); // Clear timeout if request succeeds

          console.log('DAS Stream Response received, status:', response.status);

          if (response.ok) {
            // Don't remove progress indicator yet - wait for first content

            // Create streaming response container (but don't show it yet)
            const streamContainer = document.createElement('div');
            streamContainer.className = 'card';
            streamContainer.innerHTML = '<strong>DAS:</strong><br><div class="streaming-text das-markdown"></div>';
            streamContainer.style.display = 'none'; // Hide initially

            // Add to transcript
            const transcript = document.getElementById('dasTranscript');
            transcript.appendChild(streamContainer);

            const streamingText = streamContainer.querySelector('.streaming-text');
            let fullResponse = '';
            let metadata = {};
            let firstContentReceived = false;

            // Handle streaming response
            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            try {
              while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value);
                const lines = chunk.split('\n');

                for (const line of lines) {
                  if (line.startsWith('data: ')) {
                    try {
                      const data = JSON.parse(line.slice(6));

                      if (data.type === 'content') {
                        // On first content, remove progress indicator and show stream container
                        if (!firstContentReceived) {
                          cleanupProgress();
                          streamContainer.style.display = 'block';
                          firstContentReceived = true;
                        }

                        // Stream content
                        fullResponse += data.content;

                        // For streaming, use inline markdown rendering to keep cursor inline
                        try {
                          // Use marked with inline-only parsing to avoid paragraph wrapping
                          const renderer = new marked.Renderer();
                          renderer.paragraph = (text) => text; // Don't wrap in <p> tags

                          const parsed = marked.parse(fullResponse, { renderer });
                          streamingText.innerHTML = parsed + '<span class="streaming-cursor">▊</span>';
                        } catch (e) {
                          // Fallback to plain text if markdown parsing fails during streaming
                          streamingText.innerHTML = fullResponse + '<span class="streaming-cursor">▊</span>';
                        }

                        // Store metadata
                        if (data.metadata) {
                          metadata = { ...metadata, ...data.metadata };
                        }

                        // Scroll to bottom
                        streamContainer.scrollIntoView({ behavior: 'smooth' });
                      } else if (data.type === 'done') {
                        // If we never received content, ensure progress is removed
                        if (!firstContentReceived) {
                          cleanupProgress();
                          streamContainer.style.display = 'block';
                        }

                        // Store done metadata if any
                        if (data.metadata) {
                          metadata = { ...metadata, ...data.metadata };
                        }

                        // Streaming complete - convert to final format with CONSISTENT emoji sources
                        streamContainer.innerHTML = `
                          <strong>DAS:</strong><br>
                          <div class="das-markdown">${marked.parse(fullResponse)}</div>
                          ${metadata.sources && metadata.sources.length > 0 ? `
                            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border);">
                              <div class="muted" style="font-size: 0.9em;">📚 Sources (${metadata.sources.length}):</div>
                              ${metadata.sources.map(source => {
                          const relevanceScore = source.relevance_score ? ` (${Math.round(source.relevance_score * 100)}% match)` : '';
                          return `<div style="font-size: 0.8em; margin-left: 8px;">• <strong>${source.title || 'Unknown'}</strong> (${source.document_type || 'document'})${relevanceScore}</div>`;
                        }).join('')}
                            </div>
                          ` : ''}
                        `;
                        updateDASStatus('Ready');
                        break;
                      } else if (data.type === 'error') {
                        // Handle streaming error
                        if (!firstContentReceived) {
                          cleanupProgress();
                        }
                        addMessageToTranscript('error', 'Error: ' + (data.message || 'Unknown error'));
                        updateDASStatus('Error');
                        break;
                      }
                    } catch (e) {
                      console.warn('Failed to parse streaming data:', e, line);
                    }
                  }
                }
              }
            } finally {
              reader.releaseLock();
            }
          } else {
            console.log('DAS Response error, status:', response.status);

            // Stop ellipsis animation and remove progress indicator
            cleanupProgress();

            const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
            console.log('DAS Error response:', error);
            addMessageToTranscript('error', 'Error: ' + (error.detail || 'Failed to get response'));
            updateDASStatus('Error');
          }
        } catch (error) {
          console.log('DAS Network error:', error);

          // Stop ellipsis animation and remove progress indicator
          cleanupProgress();

          addMessageToTranscript('error', 'Network error: ' + error.message);
          updateDASStatus('Error');
        } finally {
          isProcessing = false;
          sendBtn.disabled = false;
          promptInput.focus();
        }
      }

      // Add message to transcript
      function addMessageToTranscript(type, message, metadata = {}) {
        const div = document.createElement('div');
        div.className = 'card';

        let content = '';
        let useMarkdown = false;

        if (type === 'user') {
          div.className = 'card das-user-message';  // Add specific class for user messages
          content = `
            <div class="das-user-message-container">
              <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 6px;">
                <strong>You:</strong>
                <button class="das-edit-btn" onclick="window.editLastMessage('${escapeHtml(message).replace(/'/g, "\\'")}')">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" width="14" height="14">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                    <path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                  </svg>
                </button>
              </div>
              <div class="das-user-message-text">${escapeHtml(message)}</div>
            </div>
          `;
        } else if (type === 'das') {
          content = `<strong>DAS:</strong> `;
          if (metadata.confidence) {
            content += `<span class="muted">(${metadata.confidence} confidence)</span><br><br>`;
          }
          // Use markdown for DAS responses
          useMarkdown = true;
          content += `<div class="das-markdown">${marked.parse(message)}</div>`;
        } else if (type === 'progress') {
          // Progress indicator without DAS label
          content = message;
        } else if (type === 'system') {
          content = `<em class="muted">${escapeHtml(message)}</em>`;
        } else if (type === 'error') {
          content = `<span style="color: #ef4444;">Error: ${escapeHtml(message)}</span>`;
        }

        if (!useMarkdown) {
          div.innerHTML = content;
        } else {
          div.innerHTML = content;
        }

        // Add sources if available (for DAS responses)
        if (type === 'das' && metadata.sources && metadata.sources.length > 0) {
          const sourcesDiv = document.createElement('div');
          sourcesDiv.className = 'das-sources';

          const sourcesTitle = document.createElement('div');
          sourcesTitle.className = 'sources-title';
          sourcesTitle.textContent = `📚 Sources (${metadata.sources.length}):`;
          sourcesDiv.appendChild(sourcesTitle);

          metadata.sources.forEach((source, index) => {
            const sourceItem = document.createElement('div');
            sourceItem.className = 'source-item';

            const sourceTitle = source.title || 'Knowledge Base';
            const docType = source.document_type || 'document';
            const relevanceScore = source.relevance_score ? ` (${Math.round(source.relevance_score * 100)}% match)` : '';

            sourceItem.innerHTML = `• <strong>${sourceTitle}</strong> (${docType})${relevanceScore}`;

            sourcesDiv.appendChild(sourceItem);
          });

          div.appendChild(sourcesDiv);
        }

        // Add suggestions if available (for other types of responses)
        if (metadata.suggestions && metadata.suggestions.length > 0) {
          const suggestionsDiv = document.createElement('div');
          suggestionsDiv.className = 'das-suggestions';
          suggestionsDiv.style.marginTop = '8px';

          metadata.suggestions.forEach(suggestion => {
            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.style.margin = '2px';
            btn.style.fontSize = '12px';

            // Handle different suggestion formats
            let buttonText, tooltipText, messageToSend;

            if (typeof suggestion === 'string') {
              // Simple string format
              buttonText = suggestion;
              tooltipText = suggestion;
              messageToSend = suggestion;
            } else if (suggestion.title) {
              // Object format with title/description
              buttonText = suggestion.title || 'Suggestion';
              tooltipText = suggestion.description || suggestion.title || 'Click to use this suggestion';
              // Use title as the message, or action if available, or description as fallback
              messageToSend = suggestion.action || suggestion.title || suggestion.description || suggestion.text;
            } else if (suggestion.text) {
              // Alternative object format with text field
              buttonText = suggestion.text;
              tooltipText = suggestion.text;
              messageToSend = suggestion.text;
            } else {
              // Fallback for unknown format
              buttonText = 'Suggestion';
              tooltipText = 'Click to use this suggestion';
              messageToSend = JSON.stringify(suggestion);
            }

            btn.textContent = buttonText;
            btn.title = tooltipText;
            btn.onclick = () => {
              if (messageToSend && typeof messageToSend === 'string' && messageToSend.trim()) {
                sendDASMessage(messageToSend);
              } else {
                console.warn('Invalid suggestion message:', messageToSend);
              }
            };
            suggestionsDiv.appendChild(btn);
          });

          div.appendChild(suggestionsDiv);
        }

        transcript.appendChild(div);

        // Apply syntax highlighting to code blocks if this is a DAS message
        if (type === 'das' && window.hljs) {
          const codeBlocks = div.querySelectorAll('pre code');
          codeBlocks.forEach(block => {
            hljs.highlightElement(block);
          });
        }

        // Scroll to bottom to show new message
        const transcriptContainer = transcript.parentElement;
        transcriptContainer.scrollTop = transcriptContainer.scrollHeight;
      }

      // Helper function to escape HTML
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Test function for markdown rendering (can be called from browser console)
      window.testMarkdownRendering = function () {
        const testMessage = `# Markdown Test

This is a **bold** statement and this is *italic* text.

## Code Example

Here's some \`inline code\` and a code block:

\`\`\`python
def hello_world():
    print("Hello, World!")
    return "Success"
\`\`\`

## List Example

- Item 1
- Item 2
- Item 3

## Table Example

| Feature | Status |
|---------|--------|
| Markdown | ✅ Working |
| Code Highlighting | ✅ Working |
| Tables | ✅ Working |

> This is a blockquote with important information.

[Link example](https://example.com)`;

        addMessageToTranscript('das', testMessage, { confidence: '95%' });
        console.log('Markdown test message added to transcript');
      };

      // Update DAS status
      function updateDASStatus(status) {
        const statusEl = document.getElementById('dasStatus');
        if (statusEl) {
          statusEl.textContent = status;
        }
      }

      // Get current project ID using existing system
      function getCurrentProjectId() {
        return currentProjectId(); // Use the existing function
      }

      // Get current workbench from URL or localStorage
      function getCurrentWorkbench() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('wb') || localStorage.getItem('active_workbench') || 'ontology';
      }

      // Start LLM health monitoring when DOM is ready
      function initializeLLMMonitoring() {
        if (llmInitialized) {
          console.log('LLM monitoring already initialized, skipping...');
          return;
        }

        console.log('Initializing LLM monitoring...');
        const mainDot = document.getElementById('llmStatusDot');
        const dockDot = document.getElementById('llmStatusDockDot');

        if (!mainDot && !dockDot) {
          console.warn('LLM status elements not found, retrying in 1 second...');
          setTimeout(initializeLLMMonitoring, 1000);
          return;
        }

        console.log('LLM status elements found, starting monitoring...');
        llmInitialized = true;
        try {
          startLLMHealthMonitoring();
        } catch (error) {
          console.error('Error starting LLM monitoring:', error);
        }
      }

      // Try multiple initialization methods
      function tryInitializeLLM() {
        console.log('Attempting to initialize LLM monitoring...');
        try {
          initializeLLMMonitoring();
        } catch (error) {
          console.error('Error in LLM initialization:', error);
          // Retry after a delay
          setTimeout(tryInitializeLLM, 2000);
        }
      }

      // Multiple initialization attempts
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', tryInitializeLLM);
      } else {
        tryInitializeLLM();
      }

      // Also try after a delay as backup
      setTimeout(tryInitializeLLM, 1000);

      // Manual test function for debugging (only available via console)
      window.testLLMStatus = function () {
        console.log('Manual LLM status test...');
        const mainDot = document.getElementById('llmStatusDot');
        const dockDot = document.getElementById('llmStatusDockDot');

        const dots = [mainDot, dockDot];

        dots.forEach((dot, index) => {
          if (dot) {
            console.log(`Dot ${index + 1} found:`, dot);
            console.log(`Dot ${index + 1} position:`, dot.getBoundingClientRect());
            console.log(`Dot ${index + 1} visibility:`, window.getComputedStyle(dot).visibility);
            console.log(`Dot ${index + 1} display:`, window.getComputedStyle(dot).display);
            dot.style.background = 'var(--ok)';
            dot.title = 'Manual test - LLM Status: Healthy';
            console.log(`Dot ${index + 1} updated successfully`);
          } else {
            console.error(`Dot ${index + 1} not found!`);
          }
        });
      };

      // Removed automatic test - function only available via console for debugging

      // Initialize DAS when panel opens
      if (sendBtn && promptInput && transcript) {
        // Initialize session when DAS panel is first opened
        let sessionInitialized = false;

        const originalToggleOpen = toggleOpen;
        toggleOpen = function () {
          originalToggleOpen();
          if (state.open) {
            // DAS thread initialization now happens in loadProjectInfo()
            // Just ensure we have a thread when dock opens
            if (!currentProjectThreadId) {
              initializeDASProjectThread();
            }
          }
          // Note: LLM health monitoring continues running regardless of dock state
        };

        sendBtn.addEventListener('click', () => {
          const text = (promptInput.value || '').trim();
          if (!text) return;
          sendDASMessage(text);
          promptInput.value = '';
          // Reset textarea to single line height
          promptInput.style.height = 'auto';
          promptInput.rows = 1;
        });

        promptInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            sendBtn.click();
          }
        });
      }
      // Keyboard shortcuts: Alt+Shift+K toggle; Alt+Shift+Arrows to dock
      const onKey = (e) => {
        // Two toggles: Alt+Shift+D or Ctrl+Alt+D to avoid browser collisions
        const toggleCombo = ((e.altKey && e.shiftKey && (e.key === 'D' || e.key === 'd')) || (e.ctrlKey && e.altKey && (e.key === 'D' || e.key === 'd')));
        if (toggleCombo) {
          e.preventDefault();
          // Check if user is logged in by checking if main view is visible
          const mainView = qs('#mainView');
          const authView = qs('#authView');
          const isLoggedIn = mainView && mainView.style.display !== 'none';
          const isLoginVisible = authView && authView.style.display === 'grid';

          if (isLoggedIn && !isLoginVisible) {
            console.log('✅ DAS toggle allowed - calling toggleOpen()');
            toggleOpen();
          } else {
            console.log('🔒 DAS keyboard shortcut blocked: Not authenticated');
          }
          return;
        }
        if (!state.open) return;
        const isAltShift = e.altKey && e.shiftKey;
        if (!isAltShift) return;
        if (e.key === 'ArrowLeft') { e.preventDefault(); setDock('left'); }
        else if (e.key === 'ArrowRight') { e.preventDefault(); setDock('right'); }
        else if (e.key === 'ArrowDown') { e.preventDefault(); setDock('bottom'); }
      };
      // Listen high in the stack to avoid being swallowed by focused elements
      window.addEventListener('keydown', onKey, true);
      // Initialize
      applyState();

      // If dock is already open after page load, ensure DAS thread is initialized
      if (state.open) {
        // Wait for project data to be loaded before initializing DAS
        const checkProjectReady = () => {
          const projectId = getCurrentProjectId();

          // Wait for both project ID and activeProject to be ready
          if (projectId && (window.activeProject || localStorage.getItem('active_project_id')) && !currentProjectThreadId) {
            console.log('🔧 DAS dock initializing for project:', projectId);
            initializeDASProjectThread();
          } else if (!projectId) {
            console.log('⚠️ DAS dock open but no project ID available yet, waiting...');
            // Retry in 1 second if no project ID
            setTimeout(checkProjectReady, 1000);
          }
        };

        // Initial delay to let page load, then check if ready
        setTimeout(checkProjectReady, 800);
      }

      // Note: DAS initialization now happens only when user opens DAS dock or when project is created
      // No automatic initialization on page load to prevent spurious thread creation
    })();

    async function startWorkflowStartApi(processKey, projectId, fileIds, params) {
      try {
        const res = await fetch('/api/workflows/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...authHeader() },
          body: JSON.stringify({ processKey, projectId, fileIds, params })
        });
        const js = await res.json().catch(() => ({}));
        if (!res.ok || js.success === false) return { ok: false, error: (js && (js.detail || js.error)) || 'failed' };
        return { ok: true, runId: js.runId, url: js.camunda_url };
      } catch (e) { return { ok: false, error: String(e) }; }
    }

    // ========================================
    // KNOWLEDGE MANAGEMENT FUNCTIONALITY
    // ========================================

    async function loadKnowledgeAssets() {
      try {
        // Check if user is authenticated before making the request
        if (!isAuthenticated) {
          console.log('🧠 User not authenticated, skipping knowledge assets load');
          return;
        }

        console.log('🧠 Loading knowledge assets...');
        const response = await fetch('/api/knowledge/assets', {
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to load knowledge assets: ${response.status}`);
        }

        const data = await response.json();
        console.log('🧠 Loaded knowledge assets:', data);

        await displayKnowledgeAssets(data.assets || []);
        updateProcessingStatus();

      } catch (error) {
        console.error('❌ Error loading knowledge assets:', error);
        const listElement = document.getElementById('knowledgeAssetsList');
        if (listElement) {
          listElement.innerHTML = `
            <div class="muted" style="padding:20px; text-align:center; color:var(--err);">
              Error loading knowledge assets: ${error.message}<br/>
              <button class="btn" onclick="loadKnowledgeAssets()" style="margin-top:8px;">Try Again</button>
            </div>
          `;
        }
      }
    }

    async function displayKnowledgeAssets(assets) {
      const listElement = document.getElementById('knowledgeAssetsList');
      if (!listElement) return;

      if (!assets || assets.length === 0) {
        listElement.innerHTML = `
          <div class="muted" style="padding:20px; text-align:center;">
            No knowledge assets yet.<br/>
            <small>Upload and process documents to begin building your knowledge base.</small>
          </div>
        `;
        return;
      }

      // Check if current user is admin
      const currentUser = await getCurrentUser();
      const isAdmin = currentUser && currentUser.is_admin;

      const assetsHtml = assets.map(asset => {
        const stats = asset.processing_stats || {};
        const chunkCount = stats.chunk_count || 0;
        const tokenCount = stats.token_count || 0;
        const createdDate = new Date(asset.created_at).toLocaleDateString();

        // Public asset indicator
        const publicIndicator = asset.is_public ?
          `<span style="background:#0f2f1f; color:#10b981; padding:2px 6px; border-radius:3px; font-size:10px; font-weight:600; margin-left:8px;">PUBLIC</span>` : '';

        // Orphaned asset indicator
        const isOrphaned = asset.traceability_status === 'orphaned' || !asset.source_file_id;
        const orphanedIndicator = isOrphaned ?
          `<span style="background:#4c1d1d; color:#f87171; padding:2px 6px; border-radius:3px; font-size:10px; font-weight:600; margin-left:8px;" title="Source file was deleted">📎 ORPHANED</span>` : '';

        // Archived asset indicator
        const archivedIndicator = asset.traceability_status === 'archived' ?
          `<span style="background:#3d2f0f; color:#fbbf24; padding:2px 6px; border-radius:3px; font-size:10px; font-weight:600; margin-left:8px;">📦 ARCHIVED</span>` : '';

        // Action buttons
        const actionButtons = `
          <div class="asset-actions" style="display:flex; justify-content:space-between; align-items:center; margin-top:8px; padding-top:8px; border-top:1px solid var(--border);">
            <div style="display:flex; gap:6px;">
              <button class="btn" style="background:transparent; border:1px solid var(--border); border-radius:6px; padding:6px; margin:0 2px; cursor:pointer; color:var(--text); transition:all 0.2s; display:inline-flex; align-items:center; justify-content:center;"
                      onclick="event.stopPropagation(); viewAssetContent('${asset.id}')" title="View Content"
                      onmouseover="this.style.background='var(--panel-2)'; this.style.borderColor='var(--accent)';"
                      onmouseout="this.style.background='transparent'; this.style.borderColor='var(--border)';">
                <svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor">
                  <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
                  <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"/>
                </svg>
              </button>
              ${isAdmin ? `
                <button class="btn" style="background:transparent; border:1px solid var(--border); border-radius:6px; padding:6px; margin:0 2px; cursor:pointer; color:var(--text); transition:all 0.2s; display:inline-flex; align-items:center; justify-content:center;"
                        onclick="event.stopPropagation(); toggleAssetPublic('${asset.id}', ${!asset.is_public})"
                        title="${asset.is_public ? 'Make Private' : 'Make Public'}"
                        onmouseover="this.style.background='var(--panel-2)'; this.style.borderColor='var(--accent)';"
                        onmouseout="this.style.background='transparent'; this.style.borderColor='var(--border)';">
                  <svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor">
                    ${asset.is_public ?
              '<path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"/>' :
              '<path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z"/>'
            }
                  </svg>
                </button>
              ` : ''}
            </div>
            <button class="btn" style="background:transparent; border:1px solid var(--border); border-radius:6px; padding:6px; margin:0 2px; cursor:pointer; color:#ef4444; transition:all 0.2s; display:inline-flex; align-items:center; justify-content:center;"
                    onclick="event.stopPropagation(); deleteAsset('${asset.id}', '${asset.title}')" title="Delete Asset"
                    onmouseover="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.borderColor='#ef4444';"
                    onmouseout="this.style.background='transparent'; this.style.borderColor='var(--border)'; this.style.color='#ef4444';">
              <svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" clip-rule="evenodd"/>
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
              </svg>
            </button>
          </div>
        `;

        return `
          <div class="knowledge-asset-card" style="background:#0b1220; border:1px solid var(--border); border-radius:6px; padding:12px; margin-bottom:8px; cursor:pointer;"
               onclick="selectKnowledgeAsset('${asset.id}')">
            <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:8px;">
              <div style="flex:1;">
                <h4 style="margin:0 0 4px 0; color:var(--accent); display:flex; align-items:center; flex-wrap:wrap;">
                  ${asset.title === 'unknown' ? (stats.filename || 'Untitled Asset') : asset.title}
                  ${publicIndicator}
                  ${orphanedIndicator}
                  ${archivedIndicator}
                </h4>
                <div style="font-size:12px; color:var(--muted);">
                  ${asset.document_type} • ${createdDate}
                  ${asset.is_public && asset.made_public_by ? ` • Made public by ${asset.made_public_by}` : ''}
                </div>
                ${asset.iri ? `
                  <div style="font-size:10px; color:var(--muted); margin-top:4px; font-family:monospace;">
                    <span style="color:var(--accent); cursor:pointer;" onclick="copyToClipboard('${asset.iri}')" title="Click to copy IRI">
                      🔗 ${asset.iri.length > 60 ? asset.iri.substring(0, 60) + '...' : asset.iri}
                    </span>
                  </div>
                ` : ''}
              </div>
              <div style="text-align:right; font-size:11px; color:var(--muted);">
                <div>${chunkCount} chunk${chunkCount !== 1 ? 's' : ''}</div>
                <div>${tokenCount} tokens</div>
              </div>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center; font-size:11px;">
              <span class="status-badge status-${asset.status}" style="
                padding:2px 6px; border-radius:3px; font-weight:500;
                ${asset.status === 'active' ? 'background:#0f3d2c; color:#10b981;' : ''}
                ${asset.status === 'processing' ? 'background:#3d2f0f; color:#f59e0b;' : ''}
                ${asset.status === 'failed' ? 'background:#3d0f0f; color:#ef4444;' : ''}
              ">
                ${asset.status.toUpperCase()}
              </span>
              <div style="color:var(--muted);">
                Model: ${stats.embedding_model || 'N/A'}
              </div>
            </div>
            ${actionButtons}
          </div>
        `;
      }).join('');

      listElement.innerHTML = `
        <div style="margin-bottom:12px; font-size:12px; color:var(--muted);">
          Showing ${assets.length} knowledge asset${assets.length !== 1 ? 's' : ''}
          ${isAdmin ? '<span style="color:var(--accent);"> (Admin View)</span>' : ''}
        </div>
        ${assetsHtml}
      `;
    }

    async function selectKnowledgeAsset(assetId) {
      try {
        console.log('🧠 Loading knowledge asset details:', assetId);

        // Highlight selected asset
        document.querySelectorAll('.knowledge-asset-card').forEach(card => {
          card.style.borderColor = 'var(--border)';
        });
        event.target.closest('.knowledge-asset-card').style.borderColor = 'var(--accent)';

        const response = await fetch(`/api/knowledge/assets/${assetId}?include_chunks=true`, {
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to load asset details: ${response.status}`);
        }

        const asset = await response.json();
        displayKnowledgeAssetDetails(asset);

      } catch (error) {
        console.error('❌ Error loading asset details:', error);
        const detailsElement = document.getElementById('knowledgeDetailsContent');
        if (detailsElement) {
          detailsElement.innerHTML = `
            <div style="padding:20px; text-align:center; color:var(--err);">
              Error loading asset details: ${error.message}
            </div>
          `;
        }
      }
    }

    function displayKnowledgeAssetDetails(asset) {
      const detailsElement = document.getElementById('knowledgeDetailsContent');
      if (!detailsElement) return;

      const stats = asset.processing_stats || {};
      const chunks = asset.chunks || [];

      const detailsHtml = `
        <div style="padding:4px 0;">
          <h4 style="margin:0 0 12px 0; color:var(--accent);">
            ${asset.title === 'unknown' ? (stats.filename || 'Untitled Asset') : asset.title}
          </h4>

          <div style="display:grid; gap:12px; margin-bottom:16px;">
            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">DOCUMENT TYPE</div>
              <div style="font-size:13px;">${asset.document_type}</div>
            </div>

            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">PROCESSING STATS</div>
              <div style="font-size:12px;">
                • ${stats.chunk_count || 0} chunks<br/>
                • ${stats.token_count || 0} tokens<br/>
                • ${stats.embedding_model || 'N/A'} model<br/>
                • ${stats.chunking_strategy || 'N/A'} strategy
              </div>
            </div>

            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">FILE INFO</div>
              <div style="font-size:12px;">
                • Size: ${stats.original_size || 0} bytes<br/>
                • Type: ${stats.content_type || 'N/A'}<br/>
                • Extracted: ${stats.extracted_text_length || 0} chars
              </div>
            </div>

            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">TIMESTAMPS</div>
              <div style="font-size:12px;">
                Created: ${new Date(asset.created_at).toLocaleString()}<br/>
                Updated: ${new Date(asset.updated_at).toLocaleString()}
              </div>
            </div>

            ${asset.is_public ? `
              <div>
                <div style="font-size:11px; color:var(--muted); font-weight:600;">PUBLIC ACCESS</div>
                <div style="font-size:12px;">
                  <span style="color:#10b981; font-weight:600;">✓ Public Asset</span><br/>
                  ${asset.made_public_at ? `Made public: ${new Date(asset.made_public_at).toLocaleString()}<br/>` : ''}
                  ${asset.made_public_by ? `By: ${asset.made_public_by}` : ''}
                </div>
              </div>
            ` : `
              <div>
                <div style="font-size:11px; color:var(--muted); font-weight:600;">ACCESS</div>
                <div style="font-size:12px; color:var(--muted);">
                  🔒 Project Only
                </div>
              </div>
            `}
          </div>

          ${chunks.length > 0 ? `
            <div style="margin-top:16px;">
              <div style="font-size:11px; color:var(--muted); font-weight:600; margin-bottom:8px;">
                CONTENT CHUNKS (${chunks.length})
              </div>
              <div style="max-height:300px; overflow-y:auto; background:#0b1220; border:1px solid var(--border); border-radius:4px;">
                ${chunks.map((chunk, i) => `
                  <div style="padding:8px; border-bottom:1px solid var(--border);" title="Chunk ${chunk.sequence_number}">
                    <div style="font-size:10px; color:var(--muted); margin-bottom:4px;">
                      #${chunk.sequence_number} • ${chunk.token_count} tokens • ${chunk.chunk_type}
                    </div>
                    <div style="font-size:11px; line-height:1.4; max-height:60px; overflow:hidden;">
                      ${chunk.content.length > 200 ? chunk.content.substring(0, 200) + '...' : chunk.content}
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
          ` : ''}
        </div>
      `;

      detailsElement.innerHTML = detailsHtml;
    }

    async function updateProcessingStatus() {
      try {
        const response = await fetch('/api/knowledge/jobs', {
          headers: { ...authHeader() }
        });

        if (response.ok) {
          const jobs = await response.json();
          const statusElement = document.getElementById('knowledgeProcessingStatus');

          if (statusElement && Array.isArray(jobs)) {
            const activeJobs = jobs.filter(job => job.status === 'running');

            if (activeJobs.length > 0) {
              const jobsHtml = activeJobs.map(job => `
                <div style="margin-bottom:8px;">
                  <div style="font-size:12px; color:var(--accent);">
                    ${job.job_type} - ${job.progress_percent}%
                  </div>
                  <div style="background:#0b1220; border-radius:3px; height:6px; overflow:hidden;">
                    <div style="background:var(--accent); height:100%; width:${job.progress_percent}%; transition:width 0.3s;"></div>
                  </div>
                </div>
              `).join('');

              statusElement.innerHTML = jobsHtml;
            } else {
              statusElement.innerHTML = '<div class="muted">No processing jobs running</div>';
            }
          }
        }
      } catch (error) {
        console.error('Error updating processing status:', error);
      }
    }

    // Initialize knowledge management when the page loads
    function initializeKnowledgeManagement() {
      console.log('🧠 Initializing Knowledge Management...');

      // Bind refresh button
      const refreshBtn = document.getElementById('knowledgeRefreshBtn');
      if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
          console.log('🧠 Refresh button clicked');
          loadKnowledgeAssets();
        });
      }

      // Add query button event listener
      const queryBtn = document.getElementById('knowledgeQueryBtn');
      if (queryBtn) {
        queryBtn.addEventListener('click', () => {
          console.log('🔍 Query button clicked');
          showRAGQueryInterface();
        });
      }

      // Only load knowledge assets if user is authenticated
      const knowledgeWorkbench = document.getElementById('wb-knowledge');
      if (knowledgeWorkbench && !knowledgeWorkbench.style.display && isAuthenticated) {
        loadKnowledgeAssets();
      }

      // Also load when switching to knowledge workbench (only if authenticated)
      const observer = new MutationObserver(() => {
        if (knowledgeWorkbench && knowledgeWorkbench.style.display !== 'none' && isAuthenticated) {
          loadKnowledgeAssets();
        }
      });

      // Load admin data if admin workbench is already active on page load
      setTimeout(() => {
        if (document.querySelector('#wb-admin.workbench.active')) {
          loadPrefixes();
          loadDomains();
          loadUsers(); // Load user management data
          loadRagConfig(); // Load RAG configuration
          // Only load namespaces if user is authenticated
          const token = localStorage.getItem('odras_token');
          if (token) {
            loadNamespaces();
          }
        }
      }, 100);

      if (knowledgeWorkbench) {
        observer.observe(knowledgeWorkbench, { attributes: true, attributeFilter: ['style'] });
      }
    }

    // Auto-initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeKnowledgeManagement);
    } else {
      initializeKnowledgeManagement();
    }

    // Helper function to get current user info
    async function getCurrentUser() {
      try {
        const token = localStorage.getItem(tokenKey);
        if (!token) return null;

        const response = await fetch('/api/auth/me', {
          headers: { Authorization: 'Bearer ' + token }
        });
        if (response.ok) {
          return await response.json();
        }
        return null;
      } catch (error) {
        console.error('Error getting current user:', error);
        return null;
      }
    }

    // Function to view full asset content
    async function viewAssetContent(assetId) {
      try {
        console.log('🧠 Loading asset content:', assetId);

        const response = await fetch(`/api/knowledge/assets/${assetId}/content`, {
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to load content: ${response.status}`);
        }

        const contentData = await response.json();
        showContentModal(contentData);

      } catch (error) {
        console.error('❌ Error loading asset content:', error);
        alert('Error loading content: ' + error.message);
      }
    }

    // Function to show content in a modal
    function showContentModal(contentData) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center;
        z-index: 10000; padding: 20px;
      `;

      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px;
                    width: 90%; max-width: 1000px; height: 80vh; display: flex; flex-direction: column;">
          <div style="padding: 16px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0; color: var(--accent);">${contentData.title}</h3>
            <button onclick="this.closest('.content-modal').remove()" style="
              background: transparent; border: none; color: var(--muted); font-size: 24px; cursor: pointer;
            ">&times;</button>
          </div>
          <div style="padding: 16px; overflow-y: auto; flex: 1;">
            <div style="margin-bottom: 16px; font-size: 12px; color: var(--muted);">
              📄 ${contentData.document_type} • ${contentData.total_chunks} chunks • ${contentData.total_tokens} tokens
            </div>
            <div style="line-height: 1.6; white-space: pre-wrap; font-family: ui-monospace, monospace; font-size: 13px;">
              ${contentData.content}
            </div>
          </div>
        </div>
      `;

      modal.className = 'content-modal';
      document.body.appendChild(modal);

      // Close on backdrop click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }

    // Function to delete an asset
    async function deleteAsset(assetId, assetTitle) {
      const displayTitle = assetTitle === 'unknown' ? 'Untitled Asset' : assetTitle;

      if (!confirm(`Are you sure you want to delete "${displayTitle}"?\\n\\nThis will permanently remove the asset and all its chunks.`)) {
        return;
      }

      try {
        console.log('🧠 Deleting asset:', assetId);

        const response = await fetch(`/api/knowledge/assets/${assetId}`, {
          method: 'DELETE',
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to delete asset: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ Asset deleted successfully:', result);

        // Refresh the assets list
        loadKnowledgeAssets();

        // Clear details panel
        const detailsElement = document.getElementById('knowledgeDetailsContent');
        if (detailsElement) {
          detailsElement.innerHTML = `
            <div class="muted" style="padding:20px; text-align:center;">
              Select a knowledge asset to view details
            </div>
          `;
        }

        alert('Asset deleted successfully');

      } catch (error) {
        console.error('❌ Error deleting asset:', error);
        alert('Error deleting asset: ' + error.message);
      }
    }

    // Function to toggle asset public status (admin only)
    async function toggleAssetPublic(assetId, makePublic) {
      const action = makePublic ? 'make public' : 'make private';

      if (!confirm(`Are you sure you want to ${action} this knowledge asset?\\n\\n${makePublic ? 'Public assets can be viewed by all users across all projects.' : 'Private assets are only visible within their project.'}`)) {
        return;
      }

      try {
        console.log(`🧠 ${makePublic ? 'Making public' : 'Making private'} asset:`, assetId);

        const response = await fetch(`/api/knowledge/assets/${assetId}/public`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            ...authHeader()
          },
          body: JSON.stringify({ is_public: makePublic })
        });

        if (!response.ok) {
          throw new Error(`Failed to update asset: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ Asset visibility updated:', result);

        // Refresh the assets list
        loadKnowledgeAssets();

        const status = makePublic ? 'public' : 'private';
        alert(`Asset is now ${status}`);

      } catch (error) {
        console.error('❌ Error updating asset visibility:', error);
        alert('Error updating asset: ' + error.message);
      }
    }

    // ========================================
    // RAG QUERY FUNCTIONALITY
    // ========================================

    async function showRAGQueryInterface() {
      try {
        console.log('🔍 Showing RAG query interface...');

        const detailsContent = document.getElementById('knowledgeDetailsContent');
        if (!detailsContent) return;

        detailsContent.innerHTML = `
          <div style="height:100%; display:flex; flex-direction:column; min-height:0;">
            <!-- Query Input -->
            <div style="margin-bottom:16px; flex-shrink:0;">
              <div style="font-size:14px; font-weight:600; margin-bottom:8px;">Ask your knowledge base:</div>
              <div style="display:flex; flex-direction:column; gap:8px;">
                <textarea id="ragQueryInput" placeholder="What are the main requirements for navigation systems?"
                  style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:10px; width:100%; height:80px; resize:vertical; font-family:inherit; font-size:13px;">
                </textarea>
                <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                  <button class="btn" id="ragQueryBtn" style="background:#059669; border-color:#059669;">🔍 Ask</button>
                  <button class="btn" id="ragSuggestionsBtn">💡 Suggestions</button>
                  <select id="ragStyleSelect" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:4px; padding:4px 8px; font-size:12px;">
                    <option value="comprehensive">📖 Comprehensive</option>
                    <option value="concise">⚡ Concise</option>
                    <option value="technical">🔧 Technical</option>
                  </select>
                  <label style="display:flex; align-items:center; gap:4px; font-size:12px; color:#9ca3af;">
                    <input type="checkbox" id="ragUseWorkflow" style="margin:0;">
                    <span>🔄 Use Workflow</span>
                  </label>
                  <div class="muted" style="font-size:11px; margin-left:auto;" id="ragStatus"></div>
                </div>
              </div>
            </div>

            <!-- Query Response -->
            <div style="flex:1; border:1px solid var(--border); border-radius:6px; background:#0f1419; overflow:hidden; display:flex; flex-direction:column; min-height:0;">
              <div style="background:var(--accent-subtle); padding:8px 12px; border-bottom:1px solid var(--border); font-size:12px; font-weight:600; color:var(--accent); display:flex; justify-content:space-between; align-items:center; flex-shrink:0;">
                <span>💬 Response</span>
                <div id="ragMetadata" class="muted" style="font-size:10px;"></div>
              </div>
              <div id="ragResponseContent" style="flex:1; padding:16px; overflow-y:auto; line-height:1.5; min-height:0;">
                <div class="muted" style="text-align:center; padding:40px 20px;">
                  Enter a question above and click "Ask" to query your knowledge base.<br/>
                  <small>Powered by AI retrieval and generation</small>
                </div>
              </div>
            </div>
          </div>
        `;

        // Add event listeners
        document.getElementById('ragQueryBtn')?.addEventListener('click', executeRAGQuery);
        document.getElementById('ragSuggestionsBtn')?.addEventListener('click', loadQuerySuggestions);

        // Load suggestions immediately
        loadQuerySuggestions();

      } catch (error) {
        console.error('Error showing RAG interface:', error);
      }
    }

    async function executeRAGQuery() {
      try {
        const queryInput = document.getElementById('ragQueryInput');
        const styleSelect = document.getElementById('ragStyleSelect');
        const useWorkflowCheckbox = document.getElementById('ragUseWorkflow');
        const statusDiv = document.getElementById('ragStatus');
        const responseContent = document.getElementById('ragResponseContent');
        const metadataDiv = document.getElementById('ragMetadata');

        if (!queryInput || !queryInput.value.trim()) {
          alert('Please enter a question to ask your knowledge base.');
          return;
        }

        const question = queryInput.value.trim();
        const responseStyle = styleSelect?.value || 'comprehensive';

        // HARDCODED FOR TESTING: Always use BPMN workflow
        const useWorkflow = true;

        console.log('🔍 DAS RAG Query - HARDCODED BPMN MODE:', {
          question: question,
          useWorkflow: useWorkflow,
          endpoint: '/api/knowledge/query-workflow'
        });

        // Show loading state
        statusDiv.textContent = 'Processing via BPMN workflow...';
        responseContent.innerHTML = `
          <div style="display:flex; align-items:center; justify-content:center; padding:40px;">
            <div style="display:flex; flex-direction:column; align-items:center; gap:16px;">
              <div class="loading-spinner" style="width:24px; height:24px; border:2px solid var(--border); border-top:2px solid var(--accent); border-radius:50%; animation:spin 1s linear infinite;"></div>
              <div class="muted">${useWorkflow ? 'Running RAG workflow...' : 'Analyzing your knowledge base...'}</div>
            </div>
          </div>
        `;

        console.log('🔍 Executing RAG query:', { question, responseStyle, useWorkflow });

        // Execute RAG query - use workflow endpoint if checkbox is checked
        const endpoint = useWorkflow ? '/api/knowledge/query-workflow' : '/api/knowledge/query';
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: {
            ...authHeader(),
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            question: question,
            response_style: responseStyle,
            max_chunks: 5,
            similarity_threshold: 0.5,  // More permissive threshold
            include_metadata: true
          })
        });

        if (!response.ok) {
          throw new Error(`RAG query failed: ${response.status}`);
        }

        const data = await response.json();
        console.log('🔍 RAG response:', data);

        // Display response
        displayRAGResponse(data);

      } catch (error) {
        console.error('RAG query error:', error);
        const statusDiv = document.getElementById('ragStatus');
        const responseContent = document.getElementById('ragResponseContent');

        statusDiv.textContent = 'Query failed';
        responseContent.innerHTML = `
          <div style="padding:20px; text-align:center; color:#ef4444;">
            <div style="font-weight:600; margin-bottom:8px;">❌ Query Failed</div>
            <div class="muted">${error.message}</div>
            <button class="btn" onclick="executeRAGQuery()" style="margin-top:12px;">🔄 Retry</button>
          </div>
        `;
      }
    }

    function displayRAGResponse(data) {
      const responseContent = document.getElementById('ragResponseContent');
      const metadataDiv = document.getElementById('ragMetadata');
      const statusDiv = document.getElementById('ragStatus');

      if (!data.success) {
        responseContent.innerHTML = `
          <div style="padding:20px; text-align:center; color:#ef4444;">
            <div style="font-weight:600; margin-bottom:8px;">❌ Error</div>
            <div class="muted">${data.error || 'Unknown error occurred'}</div>
          </div>
        `;
        statusDiv.textContent = 'Error';
        return;
      }

      // Update metadata
      const confidence = data.confidence;
      const confidenceIcon = confidence === 'high' ? '🟢' : confidence === 'medium' ? '🟡' : confidence === 'low' ? '🟠' : '⚪';
      const confidenceText = confidence || 'n/a';
      const chunksFound = data.chunks_found || 0;

      metadataDiv.innerHTML = `
        ${confidenceIcon} ${confidenceText} confidence • ${chunksFound} sources • ${data.model_used}
      `;
      statusDiv.textContent = `${chunksFound} sources found`;

      // Display main response
      let responseHTML = `
        <div style="margin-bottom:20px; padding:16px; background:#0a0e13; border-radius:6px; border-left:3px solid #059669;">
          <div style="line-height:1.6; white-space:pre-wrap;">${escapeHtml(data.response)}</div>
        </div>
      `;

      // Add sources if available
      if (data.sources && data.sources.length > 0) {
        responseHTML += `
          <div style="margin-top:16px;">
            <div style="font-size:12px; font-weight:600; color:var(--muted); margin-bottom:8px; padding-bottom:4px; border-bottom:1px solid var(--border);">📚 SOURCES</div>
        `;

        data.sources.forEach((source, index) => {
          const relevanceScore = Math.round(source.relevance_score * 100);
          responseHTML += `
            <div style="margin-bottom:8px; padding:8px; background:#0b1220; border-radius:4px; border-left:2px solid var(--accent-subtle);">
              <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:4px;">
                <div style="font-size:12px; font-weight:600; color:var(--accent);">${escapeHtml(source.title)}</div>
                <div style="font-size:10px; color:var(--muted);">${relevanceScore}% relevant</div>
              </div>
              <div style="font-size:11px; color:var(--muted);">${escapeHtml(source.document_type)} • Asset ID: ${source.asset_id}</div>
            </div>
          `;
        });

        responseHTML += `</div>`;
      }

      responseContent.innerHTML = responseHTML;
    }

    async function loadQuerySuggestions() {
      try {
        console.log('💡 Loading query suggestions...');

        const response = await fetch('/api/knowledge/query/suggestions', {
          headers: authHeader()
        });

        if (!response.ok) {
          throw new Error(`Failed to load suggestions: ${response.status}`);
        }

        const data = await response.json();
        console.log('💡 Query suggestions:', data);

        // Update query input placeholder with a random suggestion
        const queryInput = document.getElementById('ragQueryInput');
        if (queryInput && data.suggestions && data.suggestions.length > 0) {
          const randomSuggestion = data.suggestions[Math.floor(Math.random() * data.suggestions.length)];
          queryInput.placeholder = randomSuggestion;
        }

      } catch (error) {
        console.error('Failed to load query suggestions:', error);
      }
    }

    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Make functions globally available
    window.loadKnowledgeAssets = loadKnowledgeAssets;
    window.selectKnowledgeAsset = selectKnowledgeAsset;
    window.viewAssetContent = viewAssetContent;
    window.deleteAsset = deleteAsset;
    window.toggleAssetPublic = toggleAssetPublic;
    window.showRAGQueryInterface = showRAGQueryInterface;

    // Namespace Management Functions
    async function loadNamespaces() {
      console.log('🔄 Loading namespaces...');
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.error('No auth token found for namespaces');
          return;
        }

        const response = await fetch('/api/admin/namespaces/', {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const namespaces = await response.json();
        console.log('✅ Loaded namespaces:', namespaces.length);
        renderNamespaceList(namespaces);
      } catch (error) {
        console.error('Error loading namespaces:', error);
        document.getElementById('namespaceList').innerHTML =
          `<div style="color: var(--err); text-align: center;">Error loading namespaces: ${error.message}</div>`;
      }
    }

    function renderNamespaceList(namespaces) {
      const container = document.getElementById('namespaceList');

      if (namespaces.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: var(--muted);">No namespaces found</div>';
        return;
      }

      const html = namespaces.map(ns => {
        const statusColor = ns.status === 'released' ? 'var(--success)' :
          ns.status === 'deprecated' ? 'var(--warning)' : 'var(--muted)';
        const statusIcon = ns.status === 'released' ? '✓' :
          ns.status === 'deprecated' ? '⚠' : '📝';

        return `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px; background: var(--panel-2); ${ns.status !== 'released' ? 'opacity: 0.8;' : ''}">
          <div>
            <div style="font-weight: 600; color: var(--text); display: flex; align-items: center; gap: 8px;">
              ${ns.name}
              <span style="font-size: 0.8em; color: ${statusColor}; font-weight: normal;">
                ${statusIcon} ${ns.status.toUpperCase()}
              </span>
            </div>
            <div style="font-size: 0.9em; color: var(--muted);">
              Type: ${ns.type} | Prefix: ${ns.prefix}
            </div>
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Path: ${ns.path} | Owners: ${ns.owners.join(', ')}
            </div>
            ${ns.description ? `<div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">${ns.description}</div>` : ''}
          </div>
          <div style="display: flex; gap: 8px;">
            <button class="btn" onclick="viewNamespaceDetails('${ns.id}')" style="font-size: 0.8em;">View</button>
            <button class="btn" onclick="editNamespace('${ns.id}')" style="font-size: 0.8em;">Edit</button>
            <button class="btn" onclick="viewNamespaceOntologies('${ns.id}', '${ns.name}')" style="font-size: 0.8em; background: var(--accent); color: white; border-color: var(--accent);">View Ontologies</button>
            <button class="btn" onclick="deleteNamespace('${ns.id}', '${ns.name}')" style="font-size: 0.8em; background: var(--err); color: white; border-color: var(--err);">Delete</button>
          </div>
        </div>
      `;
      }).join('');

      container.innerHTML = html;
    }

    function showCreateNamespaceModal() {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; align-items: center;
        justify-content: center; z-index: 1000;
      `;

      modal.innerHTML = `
        <div>
          <h3>Create New Namespace</h3>

          <div style="margin-bottom: 16px;">
            <label>Prefixes (select in order):</label>
            <div id="nsPrefixSelector" style="border: 1px solid var(--border); border-radius: 4px; padding: 8px; height: 150px; background: var(--panel-2); overflow-y: auto; overflow-x: hidden;">
              <div style="text-align: center; color: var(--muted);">Loading prefixes...</div>
            </div>
            <div id="selectedNsPrefixes" style="margin-top: 8px; font-size: 0.9em; color: var(--text);">
              Selected (in order): <span id="selectedNsPrefixList">None</span>
            </div>
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Select prefixes in the order you want them to appear in the namespace path, or <a href="#" onclick="showCreatePrefixModal(); this.closest('.modal').remove();">create a new one</a>
            </div>
          </div>

          <div style="margin-bottom: 16px;">
            <label>Type:</label>
            <select id="nsType" onchange="updateNamespaceFields()">
              <option value="core">Core</option>
              <option value="service">Service</option>
              <option value="domain">Domain</option>
              <option value="program">Program</option>
              <option value="project">Project</option>
              <option value="industry">Industry</option>
              <option value="vocab">Vocabulary</option>
              <option value="shapes">Shapes</option>
              <option value="align">Alignment</option>
            </select>
          </div>

          <div style="margin-bottom: 16px;">
            <label>Name (auto-generated):</label>
            <input type="text" id="nsName" readonly style="background: var(--panel-2); color: var(--muted);" />
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Name is automatically generated as prefix-type
            </div>
          </div>

          <div style="margin-bottom: 16px;">
            <label>Path (auto-generated):</label>
            <input type="text" id="nsPath" readonly style="background: var(--panel-2); color: var(--muted);" />
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Path is automatically generated based on prefix and type
            </div>
          </div>

          <div style="margin-bottom: 16px;">
            <label>Description:</label>
            <textarea id="nsDescription" placeholder="Optional description"></textarea>
          </div>

          <div style="margin-bottom: 20px;">
            <label>Owners (comma-separated emails):</label>
            <input type="text" id="nsOwners" placeholder="admin@organization.mil, user@example.com" />
          </div>

          <div class="button-group">
            <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="createNamespace()" style="background: var(--accent); color: white; border-color: var(--accent);">Create</button>
          </div>
        </div>
      `;

      modal.className = 'modal';
      document.body.appendChild(modal);

      // Reset selection order and load prefixes
      selectedPrefixOrder = [];
      loadPrefixesForNamespaceSelector();
      updateNamespaceFields();
    }

    async function createNamespace() {
      try {
        const name = document.getElementById('nsName').value.trim();
        const type = document.getElementById('nsType').value;
        const path = document.getElementById('nsPath').value.trim();
        const description = document.getElementById('nsDescription').value.trim();
        const owners = document.getElementById('nsOwners').value.trim().split(',').map(o => o.trim()).filter(o => o);

        // Use the ordered prefixes
        const selectedPrefixes = selectedPrefixOrder;

        if (!name || !path || selectedPrefixes.length === 0) {
          alert('Please fill in all required fields and select at least one prefix');
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }

        // Use the compound name as the prefix identifier (matches the name pattern)
        const prefixString = selectedPrefixes.join('-');
        const prefix = `${prefixString}-${type}`;

        const response = await fetch('/api/admin/namespaces/', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name,
            type,
            path,
            prefix,
            description: description || null,
            owners
          })
        });

        if (!response.ok) {
          const error = await response.text();
          throw new Error(`HTTP ${response.status}: ${error}`);
        }

        const newNamespace = await response.json();
        console.log('Created namespace:', newNamespace);

        // Close modal and refresh list
        document.querySelector('.modal').remove();
        await loadNamespaces();

        toast('Namespace created successfully!');
      } catch (error) {
        console.error('Error creating namespace:', error);
        alert(`Error creating namespace: ${error.message}`);
      }
    }

    async function viewNamespaceDetails(namespaceId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.error('No auth token found');
          return;
        }

        const response = await fetch(`/api/admin/namespaces/${namespaceId}`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const namespace = await response.json();

        // Create a detailed view modal
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1000;
        `;

        modal.innerHTML = `
          <div style="
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
          ">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
              <h3 style="margin: 0; color: var(--text);">Namespace Details</h3>
              <button onclick="this.closest('.modal').remove()" style="
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: var(--muted);
                padding: 0;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
              ">×</button>
            </div>

            <div style="display: grid; gap: 16px;">
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Name:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">${namespace.name}</div>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Type:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">${namespace.type}</div>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Path:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text); font-family: monospace;">${namespace.path}</div>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Prefix:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text); font-family: monospace;">${namespace.prefix}</div>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Status:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">
                  <span style="
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 0.8em;
                    font-weight: 600;
                    background: ${namespace.status === 'released' ? 'var(--success)' : 'var(--warning)'};
                    color: white;
                  ">${namespace.status.toUpperCase()}</span>
                </div>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Owners:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">
                  ${namespace.owners.map(owner => `<div style="margin-bottom: 4px;">${owner}</div>`).join('')}
                </div>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Description:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">${namespace.description || 'No description provided'}</div>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Created:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">${new Date(namespace.created_at).toLocaleString()}</div>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Updated:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">${new Date(namespace.updated_at).toLocaleString()}</div>
              </div>
            </div>

            <div class="button-group">
              <button onclick="this.closest('.modal').remove()" class="btn" style="background: var(--muted);">Close</button>
              <button onclick="editNamespace('${namespaceId}'); this.closest('.modal').remove();" class="btn" style="background: var(--accent); color: white; border-color: var(--accent);">Edit</button>
            </div>
          </div>
        `;

        modal.className = 'modal';
        document.body.appendChild(modal);

      } catch (error) {
        console.error('Error loading namespace details:', error);
        alert(`Error loading namespace details: ${error.message}`);
      }
    }

    async function editNamespace(namespaceId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.error('No auth token found');
          return;
        }

        // First, get the current namespace data
        const response = await fetch(`/api/admin/namespaces/${namespaceId}`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const namespace = await response.json();

        // Create an edit modal
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1000;
        `;

        modal.innerHTML = `
          <div style="
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
          ">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
              <h3 style="margin: 0; color: var(--text);">Edit Namespace</h3>
              <button onclick="this.closest('.modal').remove()" style="
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: var(--muted);
                padding: 0;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
              ">×</button>
            </div>

            <form id="editNamespaceForm" style="display: grid; gap: 16px;">
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Name:</label>
                <input type="text" id="editName" value="${namespace.name}" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                " readonly>
                <small style="color: var(--muted); font-size: 0.8em;">Name cannot be changed after creation</small>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Type:</label>
                <input type="text" id="editType" value="${namespace.type}" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                " readonly>
                <small style="color: var(--muted); font-size: 0.8em;">Type cannot be changed after creation</small>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Path:</label>
                <input type="text" id="editPath" value="${namespace.path}" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                " readonly>
                <small style="color: var(--muted); font-size: 0.8em;">Path cannot be changed after creation</small>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Prefix:</label>
                <input type="text" id="editPrefix" value="${namespace.prefix}" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                " readonly>
                <small style="color: var(--muted); font-size: 0.8em;">Prefix cannot be changed after creation</small>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Status:</label>
                <select id="editStatus" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                ">
                  <option value="draft" ${namespace.status === 'draft' ? 'selected' : ''}>Draft</option>
                  <option value="released" ${namespace.status === 'released' ? 'selected' : ''}>Released</option>
                  <option value="deprecated" ${namespace.status === 'deprecated' ? 'selected' : ''}>Deprecated</option>
                </select>
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Owners (comma-separated emails):</label>
                <input type="text" id="editOwners" value="${namespace.owners.join(', ')}" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                " placeholder="admin@organization.mil, user@domain.mil">
              </div>

              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Description:</label>
                <textarea id="editDescription" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                  min-height: 80px;
                  resize: vertical;
                " placeholder="Enter namespace description...">${namespace.description || ''}</textarea>
              </div>
            </form>

            <div class="button-group">
              <button onclick="this.closest('.modal').remove()" class="btn" style="background: var(--muted);">Cancel</button>
              <button onclick="updateNamespace('${namespaceId}')" class="btn" style="background: var(--accent); color: white; border-color: var(--accent);">Save Changes</button>
            </div>
          </div>
        `;

        modal.className = 'modal';
        document.body.appendChild(modal);

      } catch (error) {
        console.error('Error loading namespace for edit:', error);
        alert(`Error loading namespace: ${error.message}`);
      }
    }

    async function updateNamespace(namespaceId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.error('No auth token found');
          return;
        }

        const form = document.getElementById('editNamespaceForm');
        const owners = document.getElementById('editOwners').value.split(',').map(email => email.trim()).filter(email => email);

        const updateData = {
          status: document.getElementById('editStatus').value,
          owners: owners,
          description: document.getElementById('editDescription').value
        };

        const response = await fetch(`/api/admin/namespaces/${namespaceId}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(updateData)
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const updatedNamespace = await response.json();
        console.log('Namespace updated:', updatedNamespace);

        // Close modal and refresh list
        document.querySelector('.modal').remove();
        await loadNamespaces();

        // Show success message
        const successDiv = document.createElement('div');
        successDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: var(--success);
          color: white;
          padding: 12px 20px;
          border-radius: 6px;
          z-index: 1001;
          box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        `;
        successDiv.textContent = 'Namespace updated successfully!';
        document.body.appendChild(successDiv);

        setTimeout(() => successDiv.remove(), 3000);

      } catch (error) {
        console.error('Error updating namespace:', error);
        alert(`Error updating namespace: ${error.message}`);
      }
    }

    // Prefix Management Functions
    async function loadPrefixes() {
      console.log('🔄 Loading prefixes...');
      try {
        const response = await fetch('/api/admin/prefixes/?status_filter=all');
        if (response.ok) {
          const prefixes = await response.json();
          console.log('✅ Loaded prefixes:', prefixes.length);
          renderPrefixList(prefixes);
        } else {
          console.error('Failed to load prefixes:', response.status, response.statusText);
          document.getElementById('prefixList').innerHTML =
            `<div style="color: var(--err); text-align: center;">Error loading prefixes: ${response.statusText}</div>`;
        }
      } catch (error) {
        console.error('Error loading prefixes:', error);
        document.getElementById('prefixList').innerHTML =
          `<div style="color: var(--err); text-align: center;">Error loading prefixes: ${error.message}</div>`;
      }
    }

    function renderPrefixList(prefixes) {
      const container = document.getElementById('prefixList');

      if (prefixes.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: var(--muted);">No prefixes found</div>';
        return;
      }

      const html = prefixes.map(prefix => {
        const statusColor = prefix.status === 'active' ? 'var(--success)' :
          prefix.status === 'deprecated' ? 'var(--warning)' : 'var(--muted)';
        const statusIcon = prefix.status === 'active' ? '✓' :
          prefix.status === 'deprecated' ? '⚠' : '📁';

        return `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px; background: var(--panel-2); ${prefix.status !== 'active' ? 'opacity: 0.8;' : ''}">
          <div>
            <div style="font-weight: 600; color: var(--text); display: flex; align-items: center; gap: 8px;">
              ${prefix.prefix}
              <span style="font-size: 0.8em; color: ${statusColor}; font-weight: normal;">
                ${statusIcon} ${prefix.status.toUpperCase()}
              </span>
            </div>
            <div style="font-size: 0.9em; color: var(--muted);">
              ${prefix.description} | Owner: ${prefix.owner}
            </div>
          </div>
          <div style="display: flex; gap: 8px;">
            <button class="btn" onclick="editPrefix('${prefix.id}')" style="font-size: 0.8em;">Edit</button>
            <button class="btn" onclick="deletePrefix('${prefix.id}', '${prefix.prefix}')" style="font-size: 0.8em; background: var(--err); color: white; border-color: var(--err);">Delete</button>
          </div>
        </div>
      `;
      }).join('');

      container.innerHTML = html;
    }

    function showCreatePrefixModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div>
          <h3>Create New Prefix</h3>

          <div style="margin-bottom: 16px;">
            <label>Prefix:</label>
            <input type="text" id="pfxPrefix" placeholder="e.g., dod" oninput="validatePrefix(this)" />
            <div id="prefixValidation" style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Lowercase letters and numbers only, start with letter, 2-20 characters
            </div>
          </div>

          <div style="margin-bottom: 16px;">
            <label>Description:</label>
            <input type="text" id="pfxDescription" placeholder="e.g., Department of Defense" />
          </div>

          <div style="margin-bottom: 20px;">
            <label>Owner:</label>
            <input type="text" id="pfxOwner" placeholder="admin@organization.mil" />
          </div>

          <div class="button-group">
            <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="createPrefix()" style="background: var(--accent); color: white; border-color: var(--accent);">Create</button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);
    }


    function validatePrefix(input) {
      const prefix = input.value.trim();
      const validation = document.getElementById('prefixValidation');

      if (!prefix) {
        validation.textContent = 'Lowercase letters and numbers only, start with letter, 2-20 characters';
        validation.style.color = 'var(--muted)';
        return;
      }

      const isValid = /^[a-z][a-z0-9]{1,19}$/.test(prefix);
      if (isValid) {
        validation.textContent = '✓ Valid prefix format';
        validation.style.color = 'var(--success)';
      } else {
        validation.textContent = '✗ Invalid format - lowercase letters and numbers only, start with letter, 2-20 characters';
        validation.style.color = 'var(--err)';
      }
    }

    async function createPrefix() {
      try {
        const prefix = document.getElementById('pfxPrefix').value.trim();
        const description = document.getElementById('pfxDescription').value.trim();
        const owner = document.getElementById('pfxOwner').value.trim();

        if (!prefix || !description || !owner) {
          alert('Please fill in all fields');
          return;
        }

        // Validate prefix format
        if (!/^[a-z][a-z0-9]{1,19}$/.test(prefix)) {
          alert('Invalid prefix format - lowercase letters and numbers only, start with letter, 2-20 characters');
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }

        const response = await fetch('/api/admin/prefixes/', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            prefix,
            description,
            owner
          })
        });

        if (response.ok) {
          alert('Prefix created successfully');
          document.querySelector('.modal').remove();
          loadPrefixes();
        } else {
          const error = await response.json();
          alert(`Error creating prefix: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error creating prefix:', error);
        alert('Error creating prefix: ' + error.message);
      }
    }

    function showEditPrefixModal(prefix) {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div>
          <h3>Edit Prefix: ${prefix.prefix}</h3>

          <div style="margin-bottom: 16px;">
            <label>Prefix:</label>
            <input type="text" id="editPfxPrefix" value="${prefix.prefix}" readonly style="background: var(--muted); color: var(--text-muted);" />
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Prefix cannot be changed after creation
            </div>
          </div>

          <div style="margin-bottom: 16px;">
            <label>Description:</label>
            <input type="text" id="editPfxDescription" value="${prefix.description}" placeholder="e.g., Department of Defense" />
          </div>

          <div style="margin-bottom: 16px;">
            <label>Owner:</label>
            <input type="text" id="editPfxOwner" value="${prefix.owner}" placeholder="admin@organization.mil" />
          </div>

          <div style="margin-bottom: 20px;">
            <label>Status:</label>
            <select id="editPfxStatus" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);">
              <option value="active" ${prefix.status === 'active' ? 'selected' : ''}>Active</option>
              <option value="deprecated" ${prefix.status === 'deprecated' ? 'selected' : ''}>Deprecated</option>
              <option value="archived" ${prefix.status === 'archived' ? 'selected' : ''}>Archived</option>
            </select>
          </div>

          <div class="button-group">
            <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="updatePrefix('${prefix.id}')" style="background: var(--accent); color: white; border-color: var(--accent);">Update</button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);
    }

    async function updatePrefix(prefixId) {
      try {
        const description = document.getElementById('editPfxDescription').value.trim();
        const owner = document.getElementById('editPfxOwner').value.trim();
        const status = document.getElementById('editPfxStatus').value;

        if (!description || !owner) {
          alert('Please fill in all fields');
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }

        const response = await fetch(`/api/admin/prefixes/${prefixId}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            description,
            owner,
            status
          })
        });

        if (response.ok) {
          alert('Prefix updated successfully');
          document.querySelector('.modal').remove();
          loadPrefixes();
        } else {
          const error = await response.json();
          alert(`Error updating prefix: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error updating prefix:', error);
        alert('Error updating prefix: ' + error.message);
      }
    }

    async function editPrefix(prefixId) {
      try {
        // First, get the current prefix data
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/admin/prefixes/?status_filter=all`, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (!response.ok) {
          throw new Error('Failed to load prefixes');
        }

        const prefixes = await response.json();
        const prefix = prefixes.find(p => p.id === prefixId);

        if (!prefix) {
          alert('Prefix not found');
          return;
        }

        // Show edit modal
        showEditPrefixModal(prefix);

      } catch (error) {
        console.error('Error loading prefix for edit:', error);
        alert('Error loading prefix: ' + error.message);
      }
    }

    async function deletePrefix(prefixId, prefixName) {
      try {
        if (!confirm(`Are you sure you want to delete the prefix "${prefixName}"?\n\nThis action cannot be undone.`)) {
          return;
        }

        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/admin/prefixes/${prefixId}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          alert(`Prefix "${prefixName}" deleted successfully.`);
          loadPrefixes();
        } else {
          const error = await response.json();
          alert(`Error deleting prefix: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error deleting prefix:', error);
        alert('Error deleting prefix: ' + error.message);
      }
    }

    // Load prefixes for namespace creation dropdown
    async function loadPrefixesForNamespace(selectElement) {
      try {
        const response = await fetch('/api/admin/prefixes/');
        if (response.ok) {
          const prefixes = await response.json();

          selectElement.innerHTML = '<option value="">Select a prefix...</option>' +
            prefixes.map(pfx => `<option value="${pfx.prefix}">${pfx.prefix} - ${pfx.description}</option>`).join('');
        } else {
          selectElement.innerHTML = '<option value="">Error loading prefixes</option>';
        }
      } catch (error) {
        console.error('Error loading prefixes:', error);
        selectElement.innerHTML = '<option value="">Error loading prefixes</option>';
      }
    }

    async function loadPrefixesForNamespaceSelector() {
      try {
        const response = await fetch('/api/admin/prefixes/?status_filter=active');
        if (response.ok) {
          const prefixes = await response.json();
          const selector = document.getElementById('nsPrefixSelector');

          if (prefixes.length === 0) {
            selector.innerHTML = '<div style="text-align: center; color: var(--muted);">No active prefixes found. Create some prefixes first.</div>';
            return;
          }

          const html = prefixes.map(prefix => `
            <div id="prefix-${prefix.prefix}" style="display: flex; align-items: flex-start; margin: 6px 0; padding: 8px; border-radius: 4px; background: var(--panel); border: 1px solid var(--border);">
              <input type="checkbox" value="${prefix.prefix}" onchange="updateSelectedNsPrefixes()" style="margin-right: 12px; margin-top: 2px; flex-shrink: 0; width: 16px; height: 16px;">
              <div style="flex: 1; min-width: 0;">
                <div style="font-weight: 600; color: var(--text); margin-bottom: 2px; font-size: 14px;">
                  ${prefix.prefix}
                  <span id="order-${prefix.prefix}" style="margin-left: 8px; font-size: 12px; color: var(--accent); font-weight: bold;"></span>
                </div>
                <div style="color: var(--muted); font-size: 12px; line-height: 1.3;">${prefix.description}</div>
              </div>
            </div>
          `).join('');

          selector.innerHTML = html;
        } else {
          document.getElementById('nsPrefixSelector').innerHTML = '<div style="text-align: center; color: var(--err);">Error loading prefixes</div>';
        }
      } catch (error) {
        console.error('Error loading active prefixes:', error);
        document.getElementById('nsPrefixSelector').innerHTML = '<div style="text-align: center; color: var(--err);">Error loading prefixes</div>';
      }
    }

    // Track selection order
    let selectedPrefixOrder = [];

    function updateSelectedNsPrefixes() {
      const checkboxes = document.querySelectorAll('#nsPrefixSelector input[type="checkbox"]');
      const selectedPrefixes = [];

      // Maintain selection order by checking which were just checked/unchecked
      checkboxes.forEach(checkbox => {
        if (checkbox.checked && !selectedPrefixOrder.includes(checkbox.value)) {
          // Newly selected - add to end
          selectedPrefixOrder.push(checkbox.value);
        } else if (!checkbox.checked && selectedPrefixOrder.includes(checkbox.value)) {
          // Newly unchecked - remove from order
          selectedPrefixOrder = selectedPrefixOrder.filter(p => p !== checkbox.value);
        }
      });

      // Update order indicators
      checkboxes.forEach(checkbox => {
        const orderSpan = document.getElementById(`order-${checkbox.value}`);
        if (orderSpan) {
          if (checkbox.checked) {
            const orderIndex = selectedPrefixOrder.indexOf(checkbox.value) + 1;
            orderSpan.textContent = `#${orderIndex}`;
            orderSpan.style.color = 'var(--accent)';
          } else {
            orderSpan.textContent = '';
          }
        }
      });

      // Update display
      const selectedList = document.getElementById('selectedNsPrefixList');

      if (selectedPrefixOrder.length === 0) {
        selectedList.textContent = 'None';
        selectedList.style.color = 'var(--muted)';
      } else {
        selectedList.textContent = selectedPrefixOrder.join(' / ');
        selectedList.style.color = 'var(--success)';
      }

      // Update namespace fields when selection changes
      updateNamespaceFields();
    }

    // Make namespace functions globally available
    window.loadNamespaces = loadNamespaces;
    window.showCreateNamespaceModal = showCreateNamespaceModal;
    window.createNamespace = createNamespace;
    window.loadPrefixesForNamespaceSelector = loadPrefixesForNamespaceSelector;
    window.updateSelectedNsPrefixes = updateSelectedNsPrefixes;
    window.viewNamespaceDetails = viewNamespaceDetails;
    window.editNamespace = editNamespace;
    window.updateNamespace = updateNamespace;
    window.updateNamespaceFields = updateNamespaceFields;
    window.deleteNamespace = deleteNamespace;


    function showCreateProjectModal() {
      // Prevent duplicate modals - remove any existing ones first
      const existingModals = document.querySelectorAll('.modal');
      if (existingModals.length > 0) {
        console.log('🔧 Removing existing modals before creating new one');
        existingModals.forEach(modal => modal.remove());
      }

      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; align-items: center;
        justify-content: center; z-index: 1000;
      `;

      modal.innerHTML = `
        <div>
          <h3>Create New Project</h3>

          <div style="margin-bottom: 16px;">
            <label>Project Name:</label>
            <input type="text" id="projectName" placeholder="e.g., f35-avionics" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);" />
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Alphanumeric characters, hyphens, and underscores only
            </div>
          </div>

          <div style="margin-bottom: 16px;">
            <label>Namespace:</label>
            <select id="projectNamespace" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);">
              <option value="">Loading namespaces...</option>
            </select>
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Select from available released namespaces
            </div>
          </div>

          <div style="margin-bottom: 16px;">
            <label>Domain:</label>
            <select id="projectDomain" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);">
              <option value="">Loading domains...</option>
            </select>
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Select the functional domain for this project
            </div>
          </div>

          <div style="margin-bottom: 16px;">
            <label>Description (optional):</label>
            <textarea id="projectDescription" placeholder="Brief description of the project..." style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text); height: 80px; resize: vertical;"></textarea>
          </div>

          <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--panel-2); color: var(--text); border-color: var(--border);">Cancel</button>
            <button class="btn" onclick="createProject()" style="background: var(--accent); color: white; border-color: var(--accent);">Create Project</button>
          </div>
        </div>
      `;

      modal.className = 'modal';
      document.body.appendChild(modal);

      // Load released namespaces and active domains
      loadReleasedNamespaces();
      loadActiveDomains();
    }

    async function loadReleasedNamespaces() {
      try {
        console.log('🔧 Loading released namespaces...');
        const response = await fetch('/api/namespaces/released');

        if (response.ok) {
          const namespaces = await response.json();
          console.log('🔧 Loaded namespaces:', namespaces);
          const select = document.getElementById('projectNamespace');

          if (namespaces.length === 0) {
            select.innerHTML = '<option value="">No released namespaces available</option>';
            return;
          }

          select.innerHTML = '<option value="">Select a namespace...</option>' +
            namespaces.map(ns => `<option value="${ns.id}">${ns.path} - ${ns.name}</option>`).join('');
        } else {
          document.getElementById('projectNamespace').innerHTML = '<option value="">Error loading namespaces</option>';
        }
      } catch (error) {
        console.error('Error loading released namespaces:', error);
        document.getElementById('projectNamespace').innerHTML = '<option value="">Error loading namespaces</option>';
      }
    }

    async function loadActiveDomains() {
      try {
        console.log('🔧 Loading active domains...');
        const response = await fetch('/api/domains/active');

        if (response.ok) {
          const domains = await response.json();
          console.log('🔧 Loaded domains:', domains);
          const select = document.getElementById('projectDomain');

          if (domains.length === 0) {
            select.innerHTML = '<option value="">No domains available</option>';
            return;
          }

          select.innerHTML = '<option value="">Select a domain...</option>' +
            domains.map(domain => `<option value="${domain.domain}">${domain.domain} - ${domain.description}</option>`).join('');
        } else {
          document.getElementById('projectDomain').innerHTML = '<option value="">Error loading domains</option>';
        }
      } catch (error) {
        console.error('Error loading active domains:', error);
        document.getElementById('projectDomain').innerHTML = '<option value="">Error loading domains</option>';
      }
    }

    async function createProject() {
      // Declare originalBtnText outside try block to avoid scope issues
      const createBtn = document.querySelector('button[onclick="createProject()"]');
      const originalBtnText = createBtn ? createBtn.innerHTML : 'Create Project';

      try {
        const name = document.getElementById('projectName').value.trim();
        const namespaceId = document.getElementById('projectNamespace').value;
        const domain = document.getElementById('projectDomain').value;
        const description = document.getElementById('projectDescription').value.trim();

        if (!name || !namespaceId) {
          alert('Please fill in project name and select a namespace');
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }

        // Update the Create Project button in the modal
        if (createBtn) {
          createBtn.disabled = true;
          createBtn.style.opacity = '0.8';

          // Fix button width to prevent resizing during animation
          const currentWidth = createBtn.offsetWidth;
          createBtn.style.width = currentWidth + 'px';
          createBtn.style.minWidth = currentWidth + 'px';

          // Dynamic ellipsis animation on the button itself
          let dots = 0;
          const ellipsisInterval = setInterval(() => {
            dots = (dots + 1) % 4;
            createBtn.innerHTML = 'Creating' + '.'.repeat(dots);
          }, 500);

          // Store for cleanup
          createBtn._ellipsisInterval = ellipsisInterval;
        }

        console.log('🔧 Project creation started with progress banner');

        const requestData = {
          name,
          namespace_id: namespaceId,
          domain: domain || null,
          description: description || null
        };

        console.log('🔧 Creating project with data:', requestData);
        console.log('🔧 Token:', token ? 'Present' : 'Missing');

        const response = await fetch('/api/projects', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestData)
        });

        // No banner updates needed - just button ellipsis

        if (response.ok) {
          const newProject = await response.json();

          // Close modal FIRST like the working ontology modal does
          const modals = document.querySelectorAll('.modal');
          modals.forEach(modal => modal.remove());

          const pr = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token } }).then(r => r.json()).catch(() => ({ projects: [] }));
          const raw = pr.projects || [];
          const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' })).filter(p => !!p.id);
          const sel = qs('#projectSelect2');
          if (sel && list.length) {
            sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
            const pid = newProject.id || newProject.project_id || list[list.length - 1].id;
            sel.value = pid;
            try {
              localStorage.setItem('active_project_id', pid);
              updateURL(pid); // Update URL with new project
            } catch (_) { }
            sel.disabled = false;
            // Save current ontology canvas before switching projects
            try { if (ontoState && ontoState.cy && activeOntologyIri) saveGraphToLocal(activeOntologyIri); } catch (_) { }
            const selected = list.find(p => p.id === pid) || list[list.length - 1];
            await renderTree(selected);
            updateNamespaceDisplay(pid);
            // Update project info page if it's active
            if (document.querySelector('#wb-project.workbench.active')) {
              loadProjectInfo();
            }
          }

          alert('Project created successfully!');
        } else {
          const error = await response.json();
          console.error('🔧 Backend error response:', error);
          console.error('🔧 Response status:', response.status);
          document.querySelectorAll('.modal').forEach(modal => modal.remove());
          alert(`Error creating project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error creating project:', error);
        document.querySelectorAll('.modal').forEach(modal => modal.remove());
        alert('Error creating project: ' + error.message);
      } finally {
        // Re-enable the Create Project button and stop ellipsis
        const createBtn = document.querySelector('button[onclick="createProject()"]');
        if (createBtn) {
          // Clear ellipsis animation
          if (createBtn._ellipsisInterval) {
            clearInterval(createBtn._ellipsisInterval);
            createBtn._ellipsisInterval = null;
          }

          // Restore button
          createBtn.disabled = false;
          createBtn.innerHTML = originalBtnText || 'Create Project';
          createBtn.style.opacity = '1';
          createBtn.style.width = '';  // Remove fixed width
          createBtn.style.minWidth = '';  // Remove fixed min-width
        }

        console.log('🔧 Project creation completed, button restored');
      }
    }

    // Update namespace display in bottom toolbar
    async function updateNamespaceDisplay(projectId) {
      const namespaceElement = document.getElementById('currentNamespace');
      if (!namespaceElement) return;

      console.log('🔧 Updating namespace display for project:', projectId);

      if (!projectId) {
        namespaceElement.textContent = 'No project selected';
        return;
      }

      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          namespaceElement.textContent = 'Project selected (no auth)';
          return;
        }

        // Get project with namespace in one query
        const response = await fetch(`/api/projects/${projectId}/namespace`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
          const data = await response.json();
          console.log('🔧 Project namespace data:', data);
          namespaceElement.textContent = `${data.name} → ${data.namespace_path}`;
          namespaceElement.title = `Project: ${data.name} in namespace: ${data.namespace_path}`;
        } else {
          // Fallback: just show project name
          namespaceElement.textContent = `Project → unknown namespace`;
        }
      } catch (error) {
        console.error('🔧 Error updating namespace display:', error);
        namespaceElement.textContent = 'Error loading namespace';
      }
    }

    // Load current project's namespace for ontology creation
    async function loadCurrentProjectNamespace(displayElement) {
      if (!displayElement) return;

      try {
        const currentProjectId = localStorage.getItem('active_project_id');
        if (!currentProjectId) {
          displayElement.textContent = 'No project selected - select a project first';
          displayElement.style.color = 'var(--warning)';
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          displayElement.textContent = 'Authentication required';
          displayElement.style.color = 'var(--err)';
          return;
        }

        // Get project namespace info
        const response = await fetch(`/api/projects/${currentProjectId}/namespace`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
          const data = await response.json();
          if (data.namespace_path && data.namespace_path !== 'no namespace') {
            displayElement.textContent = `${data.namespace_path}/${data.name}`;
            displayElement.style.color = 'var(--text)';
            displayElement.title = `Project: ${data.name} in namespace: ${data.namespace_path}`;
          } else {
            displayElement.textContent = 'Project has no namespace - assign one first';
            displayElement.style.color = 'var(--warning)';
          }
        } else {
          displayElement.textContent = 'Error loading project namespace';
          displayElement.style.color = 'var(--err)';
        }
      } catch (error) {
        console.error('Error loading project namespace:', error);
        displayElement.textContent = 'Error loading namespace';
        displayElement.style.color = 'var(--err)';
      }
    }

    // Make project functions globally available
    window.showCreateProjectModal = showCreateProjectModal;
    window.createProject = createProject;
    window.loadReleasedNamespaces = loadReleasedNamespaces;
    window.loadActiveDomains = loadActiveDomains;
    window.updateNamespaceDisplay = updateNamespaceDisplay;
    window.loadCurrentProjectNamespace = loadCurrentProjectNamespace;
    window.createSimpleOntology = createSimpleOntology;

    // Project Information Functions
    async function loadProjectInfo() {
      const projectInfoCard = document.getElementById('projectInfoCard');
      if (!projectInfoCard) return;

      const currentProjectId = localStorage.getItem('active_project_id');
      if (!currentProjectId) {
        projectInfoCard.innerHTML = `
          <div style="text-align: center; color: var(--muted);">
            <h3>No Project Selected</h3>
            <p>Select a project from the dropdown or create a new one to view project information.</p>
          </div>
        `;
        // Clear DAS when no project
        currentProjectThreadId = null;
        updateDASStatus('No Project');
        return;
      }

      // Note: DAS initialization now happens only when user opens DAS dock
      // No automatic initialization when project loads to prevent spurious thread creation

      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          projectInfoCard.innerHTML = `
            <div style="text-align: center; color: var(--warning);">
              <h3>Authentication Required</h3>
              <p>Please log in to view project information.</p>
            </div>
          `;
          return;
        }

        projectInfoCard.innerHTML = `
          <div style="text-align: center; color: var(--muted);">
            <div>Loading project information...</div>
          </div>
        `;

        // Get project details with namespace info
        const response = await fetch(`/api/projects/${currentProjectId}/namespace`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.status === 403) {
          // Project access denied - clear the project selection and show message
          console.warn('Project access denied, clearing project selection');
          try {
            localStorage.removeItem('active_project_id');
          } catch (error) {
            console.warn('Failed to clear project selection:', error);
          }

          projectInfoCard.innerHTML = `
            <div style="text-align: center; color: var(--warning);">
              <h3>Project Access Denied</h3>
              <p>The selected project is not accessible with your current permissions.</p>
              <p>Please select a different project from the dropdown.</p>
            </div>
          `;
          return;
        }

        if (response.ok) {
          const projectData = await response.json();

          // Get additional project details from main API
          const projectsResponse = await fetch('/api/projects', {
            headers: { 'Authorization': `Bearer ${token}` }
          });

          let fullProjectData = projectData;
          if (projectsResponse.ok) {
            const projectsList = await projectsResponse.json();
            const projects = projectsList.projects || [];
            const currentProject = projects.find(p => (p.id || p.project_id) === currentProjectId);
            if (currentProject) {
              fullProjectData = { ...projectData, ...currentProject };
            }
          }

          renderProjectInfo(fullProjectData);
        } else {
          projectInfoCard.innerHTML = `
            <div style="text-align: center; color: var(--err);">
              <h3>Error Loading Project</h3>
              <p>Could not load project information. Please try again.</p>
            </div>
          `;
        }
      } catch (error) {
        console.error('Error loading project info:', error);
        projectInfoCard.innerHTML = `
          <div style="text-align: center; color: var(--err);">
            <h3>Error</h3>
            <p>Failed to load project information: ${error.message}</p>
          </div>
        `;
      }
    }

    function renderProjectInfo(projectData) {
      const projectInfoCard = document.getElementById('projectInfoCard');
      if (!projectInfoCard) return;

      const createdDate = projectData.created_at ? new Date(projectData.created_at).toLocaleDateString() : 'Unknown';
      const updatedDate = projectData.updated_at ? new Date(projectData.updated_at).toLocaleDateString() : 'Unknown';
      const createdBy = projectData.created_by_username || projectData.created_by || 'Unknown';
      const projectId = projectData.project_id || projectData.id;

      projectInfoCard.innerHTML = `
        <div style="margin-bottom: 32px;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
            <h2 style="margin: 0; color: var(--text); font-size: 1.75rem; font-weight: 600;">
              ${projectData.project_name || projectData.name || 'Project'}
            </h2>
            <span style="font-size: 14px; padding: 6px 12px; background: var(--accent); color: white; border-radius: 16px; font-weight: 500; text-transform: capitalize;">
              ${projectData.status || 'active'}
            </span>
          </div>
          ${projectData.description ? `
            <div style="background: var(--panel-2); padding: 16px; border-radius: 8px; border-left: 4px solid var(--accent);">
              <p style="color: var(--text); margin: 0; line-height: 1.5;">${projectData.description}</p>
            </div>
          ` : ''}
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 32px;">
          <div style="background: var(--panel-2); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
            <h3 style="margin: 0 0 16px 0; color: var(--text); font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; gap: 8px;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                <polyline points="9,22 9,12 15,12 15,22"/>
              </svg>
              Organization
            </h3>
            <div style="display: grid; gap: 12px;">
              <div>
                <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Namespace</label>
                <div style="font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; color: var(--accent); font-weight: 500; background: var(--panel); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border);">
                  ${projectData.namespace_path || 'No namespace assigned'}
                </div>
              </div>
              ${projectData.domain ? `
                <div>
                  <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Domain</label>
                  <div style="color: var(--text); font-weight: 500; background: var(--panel); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border);">
                    ${projectData.domain}
                  </div>
                </div>
              ` : ''}
              <div>
                <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Project ID</label>
                <div style="font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; color: var(--text); font-size: 14px; background: var(--panel); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border); word-break: break-all;">
                  ${projectId}
                </div>
              </div>
            </div>
          </div>

          <div style="background: var(--panel-2); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
            <h3 style="margin: 0 0 16px 0; color: var(--text); font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; gap: 8px;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="16" y1="13" x2="8" y2="13"/>
                <line x1="16" y1="17" x2="8" y2="17"/>
                <polyline points="10,9 9,9 8,9"/>
              </svg>
              Details
            </h3>
            <div style="display: grid; gap: 12px;">
              <div>
                <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Created</label>
                <div style="color: var(--text); font-weight: 500;">${createdDate}</div>
              </div>
              <div>
                <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Last Updated</label>
                <div style="color: var(--text); font-weight: 500;">${updatedDate}</div>
              </div>
              <div>
                <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Created By</label>
                <div style="color: var(--text); font-weight: 500; display: flex; align-items: center; gap: 8px;">
                  <span style="width: 32px; height: 32px; background: var(--accent); color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 14px;">
                    ${createdBy.charAt(0).toUpperCase()}
                  </span>
                  ${createdBy}
                </div>
              </div>
            </div>
          </div>
        </div>

        <div style="margin-bottom: 32px;">
          <h3 style="margin: 0 0 16px 0; color: var(--text); font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; gap: 8px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
            </svg>
            Project URI
          </h3>
          <div style="background: var(--panel-2); padding: 16px; border-radius: 12px; border: 1px solid var(--border);">
            <code style="font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; color: var(--accent); word-break: break-all; font-size: 14px; line-height: 1.4;">
              ${projectData.namespace_path ? `${INSTALLATION_CONFIG.baseUri}/${projectData.namespace_path}/${projectId}/` : 'No namespace assigned'}
            </code>
          </div>
          <div style="font-size: 13px; color: var(--muted); margin-top: 8px; display: flex; align-items: center; gap: 6px;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"/>
              <path d="M12 16v-4"/>
              <path d="M12 8h.01"/>
            </svg>
            Base URI for all project resources (ontologies, files, knowledge assets)
          </div>
        </div>

        <div style="display: flex; gap: 12px; justify-content: flex-end; padding-top: 20px; border-top: 1px solid var(--border);">
          <button class="btn" onclick="editProjectInfo('${projectId}')" style="background: var(--accent); color: white; border-color: var(--accent); padding: 12px 24px; font-weight: 500; display: flex; align-items: center; gap: 8px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
              <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
              <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg>
            Edit Project
          </button>
          <button class="btn" onclick="showProjectActions('${projectId}')" style="background: var(--panel-2); color: var(--text); border-color: var(--border); padding: 12px 24px; font-weight: 500; display: flex; align-items: center; gap: 8px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="3"/>
              <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"/>
            </svg>
            Actions
          </button>
        </div>
      `;
    }

    async function editProjectInfo(projectId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('Please log in to edit projects');
          return;
        }

        // Get current project data
        const response = await fetch(`/api/projects/${projectId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) {
          alert('Error loading project data');
          return;
        }

        const data = await response.json();
        const project = data.project;

        // Create edit modal
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
              <h3>Edit Project</h3>
              <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
            </div>
            <div class="modal-body">
              <form id="editProjectForm">
                <div class="form-group">
                  <label for="editProjectName">Project Name *</label>
                  <input type="text" id="editProjectName" value="${project.name || ''}" required>
                </div>

                <div class="form-group">
                  <label for="editProjectDescription">Description</label>
                  <textarea id="editProjectDescription" rows="3">${project.description || ''}</textarea>
                </div>

                <div class="form-group">
                  <label for="editProjectDomain">Domain</label>
                  <select id="editProjectDomain">
                    <option value="">Select a domain...</option>
                  </select>
                </div>

                <div class="form-group">
                  <label for="editProjectNamespace">Namespace</label>
                  <select id="editProjectNamespace">
                    <option value="">Select a namespace...</option>
                  </select>
                </div>
              </form>
            </div>
            <div class="modal-footer">
              <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--panel-2); color: var(--text); border-color: var(--border);">Cancel</button>
              <button class="btn" onclick="saveProjectEdit('${projectId}')" style="background: var(--accent); color: white; border-color: var(--accent);">Save Changes</button>
            </div>
          </div>
        `;

        document.body.appendChild(modal);

        // Load domains and namespaces
        await loadDomainsForEdit(project.domain);
        await loadNamespacesForEdit(project.namespace_id);

      } catch (error) {
        console.error('Error opening edit modal:', error);
        alert('Error opening edit modal');
      }
    }

    async function loadDomainsForEdit(currentDomain) {
      try {
        console.log('🔧 Loading domains for edit...');
        const response = await fetch('/api/domains/active');

        if (response.ok) {
          const domains = await response.json();
          console.log('🔧 Loaded domains for edit:', domains);
          const select = document.getElementById('editProjectDomain');

          if (domains.length === 0) {
            select.innerHTML = '<option value="">No domains available</option>';
            return;
          }

          select.innerHTML = '<option value="">Select a domain...</option>' +
            domains.map(domain => {
              const selected = domain.domain === currentDomain ? ' selected' : '';
              return `<option value="${domain.domain}"${selected}>${domain.domain} - ${domain.description}</option>`;
            }).join('');
        } else {
          document.getElementById('editProjectDomain').innerHTML = '<option value="">Error loading domains</option>';
        }
      } catch (error) {
        console.error('Error loading domains for edit:', error);
        document.getElementById('editProjectDomain').innerHTML = '<option value="">Error loading domains</option>';
      }
    }

    async function loadNamespacesForEdit(currentNamespaceId) {
      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch('/api/namespaces/released', {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        const namespaces = await response.json();

        const select = document.getElementById('editProjectNamespace');
        select.innerHTML = '<option value="">Select a namespace...</option>';

        namespaces.forEach(ns => {
          const option = document.createElement('option');
          option.value = ns.id;
          option.textContent = `${ns.path} (${ns.name})`;
          if (ns.id === currentNamespaceId) {
            option.selected = true;
          }
          select.appendChild(option);
        });
      } catch (error) {
        console.error('Error loading namespaces:', error);
      }
    }

    async function saveProjectEdit(projectId) {
      try {
        const token = localStorage.getItem('odras_token');
        const form = document.getElementById('editProjectForm');

        const updateData = {
          name: document.getElementById('editProjectName').value.trim(),
          description: document.getElementById('editProjectDescription').value.trim() || null,
          domain: document.getElementById('editProjectDomain').value || null,
          namespace_id: document.getElementById('editProjectNamespace').value || null
        };

        if (!updateData.name) {
          alert('Project name is required');
          return;
        }

        const response = await fetch(`/api/projects/${projectId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(updateData)
        });

        if (response.ok) {
          // Close modal
          document.querySelector('.modal').remove();

          // Reload project info
          loadProjectInfo();

          // Refresh project list and tree to reflect updated name/details
          try { await loadProjects(); } catch (_) { }

          // Update namespace display
          updateNamespaceDisplay(projectId);

          // Verify via API that changes persisted
          try {
            const verifyRes = await fetch(`/api/projects/${projectId}`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            if (verifyRes.ok) {
              const verifyJson = await verifyRes.json();
              const serverProject = verifyJson.project || verifyJson;
              const mismatches = [];
              const expectedName = updateData.name;
              const serverName = (serverProject.name || serverProject.project_name || '').trim();
              if (serverName !== expectedName) mismatches.push(`name: expected "${expectedName}", got "${serverName}"`);
              const expectedDesc = updateData.description || null;
              const serverDesc = (serverProject.description === '' ? null : serverProject.description);
              if ((serverDesc || null) !== expectedDesc) mismatches.push('description');
              const expectedDomain = updateData.domain || null;
              const serverDomain = serverProject.domain || null;
              if ((serverDomain || null) !== expectedDomain) mismatches.push('domain');
              const expectedNs = updateData.namespace_id ? String(updateData.namespace_id) : null;
              const serverNs = serverProject.namespace_id != null ? String(serverProject.namespace_id) : null;
              if (serverNs !== expectedNs) mismatches.push('namespace_id');
              if (mismatches.length) {
                alert('Project saved but verification mismatch for: ' + mismatches.join(', '));
              }
            } else {
              const t = await verifyRes.text().catch(() => String(verifyRes.status));
              alert('Project saved, but verification request failed: ' + t);
            }
          } catch (_) {
            // Non-fatal verification error
          }

          alert('Project updated successfully!');
        } else {
          const error = await response.json();
          alert(`Error updating project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error saving project edit:', error);
        alert('Error saving project changes');
      }
    }

    async function showProjectActions(projectId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('Please log in to perform project actions');
          return;
        }

        // Create actions modal
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
              <h3>Project Actions</h3>
              <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
            </div>
            <div class="modal-body">
              <div style="display: grid; gap: 12px;">
                <button class="btn" onclick="archiveProject('${projectId}')" style="background: var(--warning); color: white; border-color: var(--warning); width: 100%; text-align: left; padding: 12px; display: flex; align-items: flex-start; gap: 12px;">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
                    <polyline points="21,8 21,21 3,21 3,8"/>
                    <rect x="1" y="3" width="22" height="5"/>
                    <line x1="10" y1="12" x2="14" y2="12"/>
                  </svg>
                  <div>
                    <strong>Archive Project</strong><br>
                    <small>Hide project from active list (can be restored later)</small>
                  </div>
                </button>

                <button class="btn" onclick="exportProject('${projectId}')" style="background: var(--accent); color: white; border-color: var(--accent); width: 100%; text-align: left; padding: 12px; display: flex; align-items: flex-start; gap: 12px;">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7,10 12,15 17,10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                  </svg>
                  <div>
                    <strong>Export Project</strong><br>
                    <small>Download project data and ontologies</small>
                  </div>
                </button>

                <button class="btn" onclick="duplicateProject('${projectId}')" style="background: var(--panel-2); color: var(--text); border-color: var(--border); width: 100%; text-align: left; padding: 12px; display: flex; align-items: flex-start; gap: 12px;">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                  </svg>
                  <div>
                    <strong>Duplicate Project</strong><br>
                    <small>Create a copy of this project</small>
                  </div>
                </button>

                <button class="btn" onclick="deleteProject('${projectId}')" style="background: var(--err); color: white; border-color: var(--err); width: 100%; text-align: left; padding: 12px; display: flex; align-items: flex-start; gap: 12px;">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
                    <polyline points="3,6 5,6 21,6"/>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    <line x1="10" y1="11" x2="10" y2="17"/>
                    <line x1="14" y1="11" x2="14" y2="17"/>
                  </svg>
                  <div>
                    <strong>Delete Project</strong><br>
                    <small>Permanently delete project (cannot be undone)</small>
                  </div>
                </button>
              </div>
            </div>
            <div class="modal-footer">
              <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--panel-2); color: var(--text); border-color: var(--border);">Close</button>
            </div>
          </div>
        `;

        document.body.appendChild(modal);

      } catch (error) {
        console.error('Error opening actions modal:', error);
        alert('Error opening project actions');
      }
    }

    async function archiveProject(projectId) {
      if (!confirm('Are you sure you want to archive this project? It will be hidden from your active projects but can be restored later.')) {
        return;
      }

      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/projects/${projectId}/archive`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
          document.querySelector('.modal').remove();
          alert('Project archived successfully!');

          // Reload projects and switch to a different one if needed
          const currentProjectId = localStorage.getItem('active_project_id');
          if (currentProjectId === projectId) {
            // Switch to first available project
            const projectsResponse = await fetch('/api/projects', {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            const projectsData = await projectsResponse.json();
            const projects = projectsData.projects || [];

            if (projects.length > 0) {
              const newProject = projects[0];
              localStorage.setItem('active_project_id', newProject.id || newProject.project_id);
              document.getElementById('projectSelect2').value = newProject.id || newProject.project_id;
              await renderTree(newProject);
              updateNamespaceDisplay(newProject.id || newProject.project_id);
              if (document.querySelector('#wb-project.workbench.active')) {
                loadProjectInfo();
              }
            } else {
              // No projects left, clear selection
              localStorage.removeItem('active_project_id');
              document.getElementById('projectSelect2').value = '';
              document.getElementById('projectSelect2').innerHTML = '<option value="">No projects</option>';
            }
          }
        } else {
          const error = await response.json();
          alert(`Error archiving project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error archiving project:', error);
        alert('Error archiving project');
      }
    }

    async function exportProject(projectId) {
      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/projects/${projectId}/export`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `project-${projectId}-export.zip`;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);

          document.querySelector('.modal').remove();
          alert('Project exported successfully!');
        } else {
          const error = await response.json();
          alert(`Error exporting project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error exporting project:', error);
        alert('Error exporting project');
      }
    }

    async function duplicateProject(projectId) {
      try {
        const token = localStorage.getItem('odras_token');

        // Get current project data
        const projectResponse = await fetch(`/api/projects/${projectId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!projectResponse.ok) {
          alert('Error loading project data for duplication');
          return;
        }

        const projectData = await projectResponse.json();
        const project = projectData.project;

        // Create duplicate with new name
        const duplicateData = {
          name: `${project.name} (Copy)`,
          description: project.description,
          namespace_id: project.namespace_id,
          domain: project.domain
        };

        const createResponse = await fetch('/api/projects', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(duplicateData)
        });

        if (createResponse.ok) {
          const newProjectData = await createResponse.json();
          const newProject = newProjectData.project;

          document.querySelector('.modal').remove();
          alert('Project duplicated successfully!');

          // Switch to the new project
          localStorage.setItem('active_project_id', newProject.project_id);
          document.getElementById('projectSelect2').value = newProject.project_id;
          await renderTree(newProject);
          updateNamespaceDisplay(newProject.project_id);
          if (document.querySelector('#wb-project.workbench.active')) {
            loadProjectInfo();
          }
        } else {
          const error = await createResponse.json();
          alert(`Error duplicating project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error duplicating project:', error);
        alert('Error duplicating project');
      }
    }

    async function deleteProject(projectId) {
      if (!confirm('⚠️ WARNING: This will permanently delete the project and cannot be undone!\n\nAre you absolutely sure you want to delete this project?')) {
        return;
      }

      if (!confirm('This is your final warning. The project will be permanently deleted. Continue?')) {
        return;
      }

      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/projects/${projectId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
          document.querySelector('.modal').remove();
          alert('Project deleted successfully!');

          // Switch to a different project if needed
          const currentProjectId = localStorage.getItem('active_project_id');
          if (currentProjectId === projectId) {
            // Switch to first available project
            const projectsResponse = await fetch('/api/projects', {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            const projectsData = await projectsResponse.json();
            const projects = projectsData.projects || [];

            if (projects.length > 0) {
              const newProject = projects[0];
              localStorage.setItem('active_project_id', newProject.id || newProject.project_id);
              document.getElementById('projectSelect2').value = newProject.id || newProject.project_id;
              await renderTree(newProject);
              updateNamespaceDisplay(newProject.id || newProject.project_id);
              if (document.querySelector('#wb-project.workbench.active')) {
                loadProjectInfo();
              }
            } else {
              // No projects left, clear selection
              localStorage.removeItem('active_project_id');
              document.getElementById('projectSelect2').value = '';
              document.getElementById('projectSelect2').innerHTML = '<option value="">No projects</option>';
            }
          }
        } else {
          const error = await response.json();
          alert(`Error deleting project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error deleting project:', error);
        alert('Error deleting project');
      }
    }

    // Make project info functions globally available
    window.loadProjectInfo = loadProjectInfo;
    window.renderProjectInfo = renderProjectInfo;
    window.editProjectInfo = editProjectInfo;
    window.showProjectActions = showProjectActions;
    window.saveProjectEdit = saveProjectEdit;
    window.archiveProject = archiveProject;
    window.exportProject = exportProject;
    window.duplicateProject = duplicateProject;
    window.deleteProject = deleteProject;

    // Domain Management Functions
    async function loadDomains() {
      console.log('🔄 Loading domains...');
      try {
        const response = await fetch('/api/admin/domains/?status_filter=all', {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('odras_token')}`
          }
        });
        if (response.ok) {
          const domains = await response.json();
          console.log('✅ Loaded domains:', domains.length);
          renderDomainList(domains);
        } else {
          console.error('Failed to load domains:', response.status, response.statusText);
          document.getElementById('domainList').innerHTML =
            `<div style="color: var(--err); text-align: center;">Error loading domains: ${response.statusText}</div>`;
        }
      } catch (error) {
        console.error('Error loading domains:', error);
        document.getElementById('domainList').innerHTML =
          `<div style="color: var(--err); text-align: center;">Error loading domains: ${error.message}</div>`;
      }
    }

    function renderDomainList(domains) {
      const container = document.getElementById('domainList');

      if (domains.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: var(--muted);">No domains found</div>';
        return;
      }

      const html = domains.map(domain => {
        const statusColor = domain.status === 'active' ? 'var(--success)' :
          domain.status === 'deprecated' ? 'var(--warning)' : 'var(--muted)';
        const statusIcon = domain.status === 'active' ? '✓' :
          domain.status === 'deprecated' ? '⚠' : '📁';

        return `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px; background: var(--panel-2); ${domain.status !== 'active' ? 'opacity: 0.8;' : ''}">
          <div>
            <div style="font-weight: 600; color: var(--text); display: flex; align-items: center; gap: 8px;">
              ${domain.domain}
              <span style="font-size: 0.8em; color: ${statusColor}; font-weight: normal;">
                ${statusIcon} ${domain.status.toUpperCase()}
              </span>
            </div>
            <div style="font-size: 0.9em; color: var(--muted);">
              ${domain.description} | Owner: ${domain.owner}
            </div>
          </div>
          <div style="display: flex; gap: 8px;">
            <button class="btn" onclick="editDomain('${domain.id}')" style="font-size: 0.8em;">Edit</button>
            <button class="btn" onclick="deleteDomain('${domain.id}', '${domain.domain}')" style="font-size: 0.8em; background: var(--err); color: white; border-color: var(--err);">Delete</button>
          </div>
        </div>
      `;
      }).join('');

      container.innerHTML = html;
    }

    function showCreateDomainModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div>
          <h3>Create New Domain</h3>

          <div style="margin-bottom: 16px;">
            <label>Domain:</label>
            <input type="text" id="dmDomain" placeholder="e.g., avionics" oninput="validateDomain(this)" />
            <div id="domainValidation" style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Lowercase letters, numbers, and hyphens only, start with letter, 2-50 characters
            </div>
          </div>

          <div style="margin-bottom: 16px;">
            <label>Description:</label>
            <input type="text" id="dmDescription" placeholder="e.g., Aircraft electronics and flight systems" />
          </div>

          <div style="margin-bottom: 20px;">
            <label>Owner:</label>
            <input type="text" id="dmOwner" placeholder="admin@odras.local" />
          </div>

          <div class="button-group">
            <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="createDomain()" style="background: var(--accent); color: white; border-color: var(--accent);">Create</button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);
    }

    function validateDomain(input) {
      const domain = input.value.trim();
      const validation = document.getElementById('domainValidation');

      if (!domain) {
        validation.textContent = 'Lowercase letters, numbers, and hyphens only, start with letter, 2-50 characters';
        validation.style.color = 'var(--muted)';
        return;
      }

      const isValid = /^[a-z][a-z0-9-]{1,49}$/.test(domain);
      if (isValid) {
        validation.textContent = '✓ Valid domain format';
        validation.style.color = 'var(--success)';
      } else {
        validation.textContent = '✗ Invalid format - lowercase letters, numbers, and hyphens only, start with letter, 2-50 characters';
        validation.style.color = 'var(--err)';
      }
    }

    async function createDomain() {
      try {
        const domain = document.getElementById('dmDomain').value.trim();
        const description = document.getElementById('dmDescription').value.trim();
        const owner = document.getElementById('dmOwner').value.trim();

        if (!domain || !description || !owner) {
          alert('Please fill in all fields');
          return;
        }

        // Validate domain format
        if (!/^[a-z][a-z0-9-]{1,49}$/.test(domain)) {
          alert('Invalid domain format - lowercase letters, numbers, and hyphens only, start with letter, 2-50 characters');
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }

        const response = await fetch('/api/admin/domains/', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            domain,
            description,
            owner
          })
        });

        if (response.ok) {
          alert('Domain created successfully');
          document.querySelector('.modal').remove();
          loadDomains();
        } else {
          const error = await response.json();
          alert(`Error creating domain: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error creating domain:', error);
        alert('Error creating domain: ' + error.message);
      }
    }

    async function editDomain(domainId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('Please log in to edit domains');
          return;
        }

        // Get current domain data
        const response = await fetch(`/api/admin/domains/${domainId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) {
          alert('Error loading domain data');
          return;
        }

        const domain = await response.json();

        // Create edit modal
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
              <h3>Edit Domain</h3>
              <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
            </div>
            <div class="modal-body">
              <form id="editDomainForm">
                <div class="form-group">
                  <label for="editDomainName">Domain Name</label>
                  <input type="text" id="editDomainName" value="${domain.domain}" readonly style="background: var(--panel-2); color: var(--muted);">
                  <small style="color: var(--muted);">Domain name cannot be changed after creation</small>
                </div>

                <div class="form-group">
                  <label for="editDomainDescription">Description</label>
                  <textarea id="editDomainDescription" rows="3">${domain.description || ''}</textarea>
                </div>

                <div class="form-group">
                  <label for="editDomainOwner">Owner</label>
                  <input type="email" id="editDomainOwner" value="${domain.owner || ''}">
                </div>

                <div class="form-group">
                  <label for="editDomainStatus">Status</label>
                  <select id="editDomainStatus">
                    <option value="active" ${domain.status === 'active' ? 'selected' : ''}>Active</option>
                    <option value="deprecated" ${domain.status === 'deprecated' ? 'selected' : ''}>Deprecated</option>
                    <option value="archived" ${domain.status === 'archived' ? 'selected' : ''}>Archived</option>
                  </select>
                </div>
              </form>
            </div>
            <div class="modal-footer">
              <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--panel-2); color: var(--text); border-color: var(--border);">Cancel</button>
              <button class="btn" onclick="saveDomainEdit('${domainId}')" style="background: var(--accent); color: white; border-color: var(--accent);">Save Changes</button>
            </div>
          </div>
        `;

        document.body.appendChild(modal);

      } catch (error) {
        console.error('Error opening edit modal:', error);
        alert('Error opening edit modal');
      }
    }

    async function saveDomainEdit(domainId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('Please log in to save domain changes');
          return;
        }

        const updateData = {
          description: document.getElementById('editDomainDescription').value.trim() || null,
          owner: document.getElementById('editDomainOwner').value.trim() || null,
          status: document.getElementById('editDomainStatus').value
        };

        if (!updateData.description) {
          alert('Description is required');
          return;
        }

        const response = await fetch(`/api/admin/domains/${domainId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(updateData)
        });

        if (response.ok) {
          // Close modal and refresh domain list
          document.querySelector('.modal').remove();
          loadDomains();
          alert('Domain updated successfully');
        } else {
          const error = await response.json();
          alert(`Error updating domain: ${error.detail || response.statusText}`);
        }
      } catch (error) {
        console.error('Error saving domain edit:', error);
        alert('Error saving domain changes');
      }
    }

    async function deleteDomain(domainId, domainName) {
      try {
        if (!confirm(`Are you sure you want to delete the domain "${domainName}"?\n\nThis action cannot be undone.`)) {
          return;
        }

        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/admin/domains/${domainId}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          alert(`Domain "${domainName}" deleted successfully.`);
          loadDomains();
        } else {
          const error = await response.json();
          alert(`Error deleting domain: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error deleting domain:', error);
        alert('Error deleting domain: ' + error.message);
      }
    }

    // Make domain functions globally available
    window.loadDomains = loadDomains;
    window.showCreateDomainModal = showCreateDomainModal;
    window.createDomain = createDomain;
    window.editDomain = editDomain;
    window.saveDomainEdit = saveDomainEdit;
    window.deleteDomain = deleteDomain;
    window.validateDomain = validateDomain;

    // Make prefix functions globally available
    window.loadPrefixes = loadPrefixes;
    window.showCreatePrefixModal = showCreatePrefixModal;
    window.createPrefix = createPrefix;
    window.editPrefix = editPrefix;
    window.deletePrefix = deletePrefix;
    window.loadPrefixesForNamespace = loadPrefixesForNamespace;
    window.toggleSection = toggleSection;
    window.showEditPrefixModal = showEditPrefixModal;
    window.updatePrefix = updatePrefix;

    // User Management Functions
    async function loadUsers() {
      console.log('🔄 Loading users...');
      try {
        const token = localStorage.getItem('odras_token');
        const showInactive = document.getElementById('showInactiveUsers')?.checked || false;
        const url = `/api/users/?include_inactive=${showInactive}`;

        const response = await fetch(url, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (response.ok) {
          const users = await response.json();
          console.log('✅ Loaded users:', users.length);
          renderUserList(users);
        } else {
          console.error('Failed to load users:', response.status, response.statusText);
          document.getElementById('userList').innerHTML =
            `<div style="color: var(--err); text-align: center;">Error loading users: ${response.statusText}</div>`;
        }
      } catch (error) {
        console.error('Error loading users:', error);
        document.getElementById('userList').innerHTML =
          `<div style="color: var(--err); text-align: center;">Error loading users: ${error.message}</div>`;
      }
    }

    function renderUserList(users) {
      const container = document.getElementById('userList');

      if (users.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: var(--muted);">No users found</div>';
        return;
      }

      const html = users.map(user => {
        const statusColor = user.is_active ? 'var(--success)' : 'var(--err)';
        const statusText = user.is_active ? 'Active' : 'Inactive';
        const adminBadge = user.is_admin ? '<span style="background: var(--accent); color: white; padding: 2px 6px; border-radius: 4px; font-size: 12px; margin-left: 8px;">ADMIN</span>' : '';
        const createdDate = new Date(user.created_at).toLocaleDateString();

        return `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px; background: var(--bg);">
            <div style="flex: 1;">
              <div style="display: flex; align-items: center; margin-bottom: 4px;">
                <span style="font-weight: bold; color: var(--text);">${user.username}</span>
                ${adminBadge}
                <span style="width: 8px; height: 8px; border-radius: 50%; background: ${statusColor}; margin-left: 12px;"></span>
                <span style="color: ${statusColor}; margin-left: 4px; font-size: 14px;">${statusText}</span>
              </div>
              <div style="color: var(--muted); font-size: 14px;">
                <div>Display Name: ${user.display_name || 'Not set'}</div>
                <div>Created: ${createdDate}</div>
              </div>
            </div>
            <div style="display: flex; gap: 8px;">
              <button class="btn" onclick="editUser('${user.user_id}')" style="padding: 6px 12px; font-size: 12px;">Edit</button>
              <button class="btn" onclick="toggleUserStatus('${user.user_id}', ${user.is_active})" style="padding: 6px 12px; font-size: 12px; background: ${user.is_active ? 'var(--err)' : 'var(--success)'};">
                ${user.is_active ? 'Deactivate' : 'Activate'}
              </button>
            </div>
          </div>
        `;
      }).join('');

      container.innerHTML = html;
    }

    function showCreateUserModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); display: flex; align-items: center;
        justify-content: center; z-index: 1000;
      `;

      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 24px; width: 400px; max-width: 90vw;">
          <h3 style="margin: 0 0 16px 0; color: var(--text);">Create New User</h3>

          <div style="display: grid; gap: 16px;">
            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">Username *</label>
              <input type="text" id="newUserUsername" placeholder="Enter username"
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>

            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">Password *</label>
              <input type="password" id="newUserPassword" placeholder="Enter password (min 8 characters)"
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>

            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">Display Name</label>
              <input type="text" id="newUserDisplayName" placeholder="Enter display name (optional)"
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>

            <div style="display: flex; align-items: center; gap: 8px;">
              <input type="checkbox" id="newUserIsAdmin" style="margin: 0;">
              <label for="newUserIsAdmin" style="color: var(--text); margin: 0;">Admin privileges</label>
            </div>
          </div>

          <div style="display: flex; gap: 12px; margin-top: 20px; justify-content: flex-end;">
            <button class="btn" onclick="document.querySelector('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="createUser()" style="background: var(--accent);">Create User</button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);
    }

    async function createUser() {
      try {
        const username = document.getElementById('newUserUsername').value.trim();
        const password = document.getElementById('newUserPassword').value;
        const displayName = document.getElementById('newUserDisplayName').value.trim();
        const isAdmin = document.getElementById('newUserIsAdmin').checked;

        if (!username || !password) {
          alert('Username and password are required');
          return;
        }

        if (password.length < 8) {
          alert('Password must be at least 8 characters long');
          return;
        }

        const token = localStorage.getItem('odras_token');
        const response = await fetch('/api/users/', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            username: username,
            password: password,
            display_name: displayName || null,
            is_admin: isAdmin
          })
        });

        if (response.ok) {
          document.querySelector('.modal').remove();
          await loadUsers();
          alert('User created successfully!');
        } else {
          const error = await response.text();
          alert(`Error creating user: ${error}`);
        }
      } catch (error) {
        console.error('Error creating user:', error);
        alert(`Error creating user: ${error.message}`);
      }
    }

    function editUser(userId) {
      // For now, just show a simple edit modal
      // In a full implementation, you'd load user details and show an edit form
      const newDisplayName = prompt('Enter new display name:');
      if (newDisplayName !== null) {
        updateUser(userId, { display_name: newDisplayName });
      }
    }

    async function updateUser(userId, updates) {
      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/users/${userId}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(updates)
        });

        if (response.ok) {
          await loadUsers();
          alert('User updated successfully!');
        } else {
          const error = await response.text();
          alert(`Error updating user: ${error}`);
        }
      } catch (error) {
        console.error('Error updating user:', error);
        alert(`Error updating user: ${error.message}`);
      }
    }

    async function toggleUserStatus(userId, currentStatus) {
      const action = currentStatus ? 'deactivate' : 'activate';
      const confirmMessage = `Are you sure you want to ${action} this user?`;

      if (!confirm(confirmMessage)) {
        return;
      }

      try {
        const token = localStorage.getItem('odras_token');
        const url = currentStatus ? `/api/users/${userId}` : `/api/users/${userId}/activate`;
        const method = currentStatus ? 'DELETE' : 'POST';

        const response = await fetch(url, {
          method: method,
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (response.ok) {
          await loadUsers();
          alert(`User ${action}d successfully!`);
        } else {
          const error = await response.text();
          alert(`Error ${action}ing user: ${error}`);
        }
      } catch (error) {
        console.error(`Error ${action}ing user:`, error);
        alert(`Error ${action}ing user: ${error.message}`);
      }
    }

    function showChangePasswordModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); display: flex; align-items: center;
        justify-content: center; z-index: 1000;
      `;

      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 24px; width: 400px; max-width: 90vw;">
          <h3 style="margin: 0 0 16px 0; color: var(--text);">Change Password</h3>

          <div style="display: grid; gap: 16px;">
            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">Current Password *</label>
              <input type="password" id="currentPassword" placeholder="Enter current password"
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>

            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">New Password *</label>
              <input type="password" id="newPassword" placeholder="Enter new password (min 8 characters)"
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>

            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">Confirm New Password *</label>
              <input type="password" id="confirmPassword" placeholder="Confirm new password"
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>
          </div>

          <div style="display: flex; gap: 12px; margin-top: 20px; justify-content: flex-end;">
            <button class="btn" onclick="document.querySelector('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="changePassword()" style="background: var(--accent);">Change Password</button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);
    }

    async function changePassword() {
      try {
        const currentPassword = document.getElementById('currentPassword').value;
        const newPassword = document.getElementById('newPassword').value;
        const confirmPassword = document.getElementById('confirmPassword').value;

        if (!currentPassword || !newPassword || !confirmPassword) {
          alert('All fields are required');
          return;
        }

        if (newPassword.length < 8) {
          alert('New password must be at least 8 characters long');
          return;
        }

        if (newPassword !== confirmPassword) {
          alert('New passwords do not match');
          return;
        }

        const token = localStorage.getItem('odras_token');
        const response = await fetch('/api/users/me/password', {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            old_password: currentPassword,
            new_password: newPassword
          })
        });

        if (response.ok) {
          document.querySelector('.modal').remove();
          alert('Password changed successfully!');
        } else {
          const error = await response.text();
          alert(`Error changing password: ${error}`);
        }
      } catch (error) {
        console.error('Error changing password:', error);
        alert(`Error changing password: ${error.message}`);
      }
    }

    // Make user management functions globally available
    window.loadUsers = loadUsers;
    window.showCreateUserModal = showCreateUserModal;
    window.createUser = createUser;
    window.editUser = editUser;
    window.updateUser = updateUser;
    window.toggleUserStatus = toggleUserStatus;
    window.showChangePasswordModal = showChangePasswordModal;
    window.changePassword = changePassword;

    // Comprehensive Document Management Functions
    async function loadAllDocuments() {
      console.log('🔄 Loading all resources for admin...');
      try {
        const token = localStorage.getItem('odras_token');
        const userFilter = document.getElementById('adminDocUserFilter')?.value || '';
        const typeFilter = document.getElementById('adminDocTypeFilter')?.value || '';
        const resourceTypeFilter = document.getElementById('adminResourceTypeFilter')?.value || 'all';
        const statusFilter = document.getElementById('adminStatusFilter')?.value || '';

        // Load both files and knowledge assets
        const [filesData, knowledgeData] = await Promise.all([
          loadAllFiles(token, userFilter, resourceTypeFilter, statusFilter),
          loadAllKnowledgeAssets(token, userFilter, typeFilter, resourceTypeFilter, statusFilter)
        ]);

        // Combine and analyze data
        const combinedResources = combineAndAnalyzeResources(filesData, knowledgeData);

        await displayComprehensiveResourceList(combinedResources);
        await populateUserFilterFromResources(combinedResources);

      } catch (error) {
        console.error('❌ Error loading resources:', error);
        const listElement = document.getElementById('adminDocumentList');
        if (listElement) {
          listElement.innerHTML = `
            <div style="color: var(--err); text-align: center; padding: 20px;">
              Error loading resources: ${error.message}<br/>
              <button class="btn" onclick="loadAllDocuments()" style="margin-top: 8px;">Try Again</button>
            </div>
          `;
        }
      }
    }

    async function loadAllFiles(token, userFilter, resourceTypeFilter, statusFilter) {
      if (resourceTypeFilter === 'knowledge') return []; // Skip files if only showing knowledge

      try {
        // Use admin endpoint to get ALL files regardless of project membership
        let url = '/api/files/admin/all?limit=1000';
        const response = await fetch(url, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) throw new Error(`Failed to load files: ${response.status}`);

        const data = await response.json();
        return data.files || [];
      } catch (error) {
        console.warn('Failed to load files:', error);
        return [];
      }
    }

    async function loadAllKnowledgeAssets(token, userFilter, typeFilter, resourceTypeFilter, statusFilter) {
      if (resourceTypeFilter === 'files') return []; // Skip knowledge if only showing files

      try {
        let url = '/api/knowledge/admin/assets?limit=1000';
        if (userFilter) url += `&user_id=${encodeURIComponent(userFilter)}`;
        if (typeFilter) url += `&document_type=${encodeURIComponent(typeFilter)}`;

        const response = await fetch(url, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) throw new Error(`Failed to load knowledge assets: ${response.status}`);

        const data = await response.json();
        return data.assets || [];
      } catch (error) {
        console.warn('Failed to load knowledge assets:', error);
        return [];
      }
    }

    function combineAndAnalyzeResources(files, knowledgeAssets) {
      const resources = [];

      // Add files with analysis
      files.forEach(file => {
        const linkedKnowledgeAsset = knowledgeAssets.find(ka => ka.source_file_id === file.file_id);
        const hasKnowledgeAsset = !!linkedKnowledgeAsset;

        resources.push({
          type: 'file',
          id: file.file_id,
          name: file.filename,
          created_at: file.created_at,
          iri: file.iri,
          size: file.size,
          content_type: file.content_type,
          tags: file.tags || {},
          visibility: file.visibility,
          created_by: file.created_by,
          owner_username: file.owner_username,
          owner_display_name: file.owner_display_name,
          status: hasKnowledgeAsset ? 'linked' : 'orphaned',
          analysis: {
            has_knowledge_asset: hasKnowledgeAsset,
            linked_knowledge_asset: linkedKnowledgeAsset,
            is_duplicate: false // Will be determined later
          }
        });
      });

      // Add knowledge assets with analysis
      knowledgeAssets.forEach(asset => {
        const metadata = asset.metadata || {};
        const hasSourceFile = files.some(f => f.file_id === asset.source_file_id);

        let status = 'linked';
        if (asset.traceability_status === 'orphaned' || !asset.source_file_id) {
          status = 'orphaned';
        } else if (!hasSourceFile && asset.source_file_id) {
          status = 'broken';
        }

        resources.push({
          type: 'knowledge_asset',
          id: asset.id,
          name: asset.title,
          created_at: asset.created_at,
          iri: asset.iri,
          document_type: asset.document_type,
          asset_status: asset.status,
          traceability_status: asset.traceability_status,
          is_public: asset.is_public,
          source_file_id: asset.source_file_id,
          owner_username: metadata.owner_username,
          owner_display_name: metadata.owner_display_name,
          status: status,
          analysis: {
            has_source_file: hasSourceFile,
            is_orphaned: status === 'orphaned',
            is_broken: status === 'broken'
          }
        });
      });

      // Detect duplicates by filename/title
      const nameGroups = {};
      resources.forEach(resource => {
        const name = resource.name?.toLowerCase() || 'unnamed';
        if (!nameGroups[name]) nameGroups[name] = [];
        nameGroups[name].push(resource);
      });

      // Mark duplicates
      Object.values(nameGroups).forEach(group => {
        if (group.length > 1) {
          group.forEach(resource => {
            resource.analysis.is_duplicate = true;
            resource.analysis.duplicate_count = group.length;
          });
        }
      });

      return resources;
    }

    async function populateUserFilterFromResources(resources) {
      const filterElement = document.getElementById('adminDocUserFilter');
      if (!filterElement) return;

      // Extract unique users from resources
      const users = new Map();
      resources.forEach(resource => {
        const userId = resource.created_by;
        const username = resource.owner_username;
        const displayName = resource.owner_display_name;

        if (userId && username) {
          users.set(userId, { username, displayName });
        }
      });

      // Keep current selection
      const currentValue = filterElement.value;

      // Clear and repopulate
      filterElement.innerHTML = '<option value="">All Users</option>';

      Array.from(users.entries())
        .sort(([, a], [, b]) => (a.username || '').localeCompare(b.username || ''))
        .forEach(([userId, user]) => {
          const option = document.createElement('option');
          option.value = userId;
          option.textContent = `${user.displayName || user.username} (${user.username})`;
          if (userId === currentValue) option.selected = true;
          filterElement.appendChild(option);
        });
    }

    async function displayComprehensiveResourceList(resources) {
      const listElement = document.getElementById('adminDocumentList');
      if (!listElement) return;

      // Apply filters
      const resourceTypeFilter = document.getElementById('adminResourceTypeFilter')?.value || 'all';
      const statusFilter = document.getElementById('adminStatusFilter')?.value || '';

      let filteredResources = resources;

      if (resourceTypeFilter !== 'all') {
        filteredResources = resources.filter(r => {
          switch (resourceTypeFilter) {
            case 'files': return r.type === 'file';
            case 'knowledge': return r.type === 'knowledge_asset';
            case 'orphaned_files': return r.type === 'file' && r.status === 'orphaned';
            case 'orphaned_knowledge': return r.type === 'knowledge_asset' && r.status === 'orphaned';
            case 'broken_links': return r.status === 'broken';
            default: return true;
          }
        });
      }

      if (statusFilter) {
        filteredResources = filteredResources.filter(r => {
          switch (statusFilter) {
            case 'linked': return r.status === 'linked';
            case 'orphaned': return r.status === 'orphaned';
            case 'broken': return r.status === 'broken';
            case 'duplicate': return r.analysis.is_duplicate;
            default: return true;
          }
        });
      }

      if (!filteredResources || filteredResources.length === 0) {
        listElement.innerHTML = `
          <div style="text-align: center; color: var(--muted); padding: 20px;">
            No resources found with current filters.
          </div>
        `;
        return;
      }

      // Group by status for better organization
      const grouped = {
        linked: filteredResources.filter(r => r.status === 'linked'),
        orphaned: filteredResources.filter(r => r.status === 'orphaned'),
        broken: filteredResources.filter(r => r.status === 'broken'),
        duplicates: filteredResources.filter(r => r.analysis.is_duplicate)
      };

      let html = `
        <div style="margin-bottom: 16px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
          <div style="background: var(--panel-2); border: 1px solid var(--border); border-radius: 6px; padding: 12px; text-align: center;">
            <div style="font-size: 18px; font-weight: bold; color: var(--accent);">${filteredResources.length}</div>
            <div style="font-size: 12px; color: var(--muted);">Total Resources</div>
          </div>
          <div style="background: var(--panel-2); border: 1px solid #22c55e; border-radius: 6px; padding: 12px; text-align: center;">
            <div style="font-size: 18px; font-weight: bold; color: #22c55e;">${grouped.linked.length}</div>
            <div style="font-size: 12px; color: var(--muted);">Linked</div>
          </div>
          <div style="background: var(--panel-2); border: 1px solid #f59e0b; border-radius: 6px; padding: 12px; text-align: center;">
            <div style="font-size: 18px; font-weight: bold; color: #f59e0b;">${grouped.orphaned.length}</div>
            <div style="font-size: 12px; color: var(--muted);">Orphaned</div>
          </div>
          <div style="background: var(--panel-2); border: 1px solid #ef4444; border-radius: 6px; padding: 12px; text-align: center;">
            <div style="font-size: 18px; font-weight: bold; color: #ef4444;">${grouped.broken.length}</div>
            <div style="font-size: 12px; color: var(--muted);">Broken Links</div>
          </div>
          <div style="background: var(--panel-2); border: 1px solid #7c3aed; border-radius: 6px; padding: 12px; text-align: center;">
            <div style="font-size: 18px; font-weight: bold; color: #7c3aed;">${grouped.duplicates.length}</div>
            <div style="font-size: 12px; color: var(--muted);">Duplicates</div>
          </div>
        </div>
      `;

      const resourcesHtml = filteredResources.map(resource => {
        const createdAt = new Date(resource.created_at).toLocaleDateString();
        const isProblematic = resource.status !== 'linked' || resource.analysis.is_duplicate;

        // Status indicators
        let statusBadges = '';
        if (resource.status === 'linked') {
          statusBadges += '<span style="background: #22c55e; color: #10b981; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 4px;">✅ LINKED</span>';
        }
        if (resource.status === 'orphaned') {
          statusBadges += '<span style="background: #f59e0b; color: #fbbf24; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 4px;">📎 ORPHANED</span>';
        }
        if (resource.status === 'broken') {
          statusBadges += '<span style="background: #ef4444; color: #f87171; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 4px;">🔗 BROKEN</span>';
        }
        if (resource.analysis.is_duplicate) {
          statusBadges += `<span style="background: #7c3aed; color: #a78bfa; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 4px;">DUPLICATE (${resource.analysis.duplicate_count})</span>`;
        }
        if (resource.type === 'knowledge_asset' && resource.is_public) {
          statusBadges += '<span style="background: #059669; color: #34d399; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 4px;">PUBLIC</span>';
        }

        // Resource type icon
        const typeIcon = resource.type === 'file' ? '📁' : '📄';
        const typeLabel = resource.type === 'file' ? 'File' : 'Knowledge Asset';

        return `
          <div style="background: ${isProblematic ? '#2d1b1b' : (resource.status === 'linked' ? '#0f2f1f' : 'var(--panel-2)')}; border: 1px solid ${isProblematic ? '#dc2626' : (resource.status === 'linked' ? '#22c55e' : 'var(--border)')}; border-radius: 6px; padding: 12px; margin-bottom: 8px;">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
              <div style="flex: 1;">
                <h4 style="margin: 0 0 4px 0; color: var(--accent); display: flex; align-items: center; gap: 8px;">
                  ${typeIcon} ${resource.name || 'Untitled'}
                  <span style="background: var(--panel); color: var(--muted); padding: 1px 4px; border-radius: 3px; font-size: 10px;">${typeLabel}</span>
                </h4>
                <div style="margin-bottom: 8px;">
                  ${statusBadges}
                </div>
                <div style="font-size: 12px; color: var(--muted); display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px;">
                  <div><strong>ID:</strong> ${resource.id.substring(0, 8)}...</div>
                  <div><strong>Created:</strong> ${createdAt}</div>
                  ${resource.type === 'file' ? `
                    <div><strong>Size:</strong> ${resource.size} bytes</div>
                    <div><strong>Type:</strong> ${resource.content_type}</div>
                  ` : `
                    <div><strong>Doc Type:</strong> ${resource.document_type}</div>
                    <div><strong>Status:</strong> ${resource.asset_status}</div>
                  `}
                  ${resource.owner_username ? `<div><strong>Owner:</strong> ${resource.owner_username}</div>` : ''}
                </div>
                ${resource.iri ? `
                  <div style="font-size: 10px; color: var(--muted); margin-top: 8px; font-family: monospace;">
                    <span style="color: var(--accent); cursor: pointer;" onclick="copyToClipboard('${resource.iri}')" title="Click to copy IRI">
                      🔗 ${resource.iri.length > 80 ? resource.iri.substring(0, 80) + '...' : resource.iri}
                    </span>
                  </div>
                ` : ''}
              </div>
            </div>

            <div style="display: flex; gap: 8px; margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--border);">
              ${resource.type === 'file' ? `
                <button class="btn" style="padding: 4px 8px; font-size: 11px; background: #1e3a8a; color: #60a5fa;"
                        onclick="downloadFile('${resource.id}')" title="Download File">
                  💾 Download
                </button>
                <button class="btn" style="padding: 4px 8px; font-size: 11px; background: #059669; color: #34d399;"
                        onclick="processFileToKnowledge('${resource.id}')" title="Process to Knowledge">
                  🧠 Process
                </button>
              ` : `
                <button class="btn" style="padding: 4px 8px; font-size: 11px; background: #1e3a8a; color: #60a5fa;"
                        onclick="viewAssetContent('${resource.id}')" title="View Content">
                  📄 View
                </button>
              `}
              <button class="btn" style="padding: 4px 8px; font-size: 11px; background: #dc2626; color: #f87171;"
                      onclick="adminDeleteResource('${resource.type}', '${resource.id}', '${resource.name || 'Untitled'}')" title="Delete Resource (Admin)">
                🗑️ Delete
              </button>
              ${resource.iri ? `
                <button class="btn" style="padding: 4px 8px; font-size: 11px; background: #7c3aed; color: #a78bfa;"
                        onclick="showIRIDetails('${resource.iri}')" title="View IRI Details">
                  🔗 IRI
                </button>
              ` : ''}
            </div>
          </div>
        `;
      }).join('');

      listElement.innerHTML = `
        <div style="margin-bottom: 12px; font-size: 12px; color: var(--muted);">
          Showing ${filteredResources.length} resource${filteredResources.length !== 1 ? 's' : ''} (Admin View)
        </div>
        ${html}
        ${resourcesHtml}
      `;
    }

    async function populateUserFilter(assets) {
      const filterElement = document.getElementById('adminDocUserFilter');
      if (!filterElement) return;

      // Extract unique users from assets
      const users = new Map();
      assets.forEach(asset => {
        const metadata = asset.metadata || {};
        const userId = metadata.owner_user_id;
        const username = metadata.owner_username;
        const displayName = metadata.owner_display_name;

        if (userId && username) {
          users.set(userId, { username, displayName });
        }
      });

      // Keep current selection
      const currentValue = filterElement.value;

      // Clear and repopulate
      filterElement.innerHTML = '<option value="">All Users</option>';

      Array.from(users.entries())
        .sort(([, a], [, b]) => a.username.localeCompare(b.username))
        .forEach(([userId, user]) => {
          const option = document.createElement('option');
          option.value = userId;
          option.textContent = `${user.displayName || user.username} (${user.username})`;
          if (userId === currentValue) option.selected = true;
          filterElement.appendChild(option);
        });
    }

    async function adminDeleteAsset(assetId, assetTitle) {
      const displayTitle = assetTitle === 'unknown' ? 'Untitled Asset' : assetTitle;

      if (!confirm(`Are you sure you want to delete "${displayTitle}"?\\n\\nThis will permanently remove the asset and all its chunks. This action cannot be undone.`)) {
        return;
      }

      try {
        console.log('🗑️ Admin deleting asset:', assetId);
        const token = localStorage.getItem('odras_token');

        const response = await fetch(`/api/knowledge/assets/${assetId}/force`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (!response.ok) {
          throw new Error(`Delete failed: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ Asset deleted:', result);

        toast(`Deleted "${displayTitle}"`);

        // Reload the document list
        await loadAllDocuments();

      } catch (error) {
        console.error('❌ Error deleting asset:', error);
        toast(`Failed to delete asset: ${error.message}`, true);
      }
    }

    async function cleanupUnknownAssets(dryRun = true) {
      const action = dryRun ? 'preview' : 'clean up';

      if (!dryRun && !confirm('Are you sure you want to delete all unknown/problematic assets?\\n\\nThis action cannot be undone.')) {
        return;
      }

      try {
        console.log(`🧹 ${dryRun ? 'Previewing' : 'Performing'} cleanup of unknown assets...`);
        const token = localStorage.getItem('odras_token');

        const response = await fetch(`/api/knowledge/admin/cleanup-unknown?dry_run=${dryRun}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (!response.ok) {
          throw new Error(`Cleanup failed: ${response.status}`);
        }

        const result = await response.json();
        console.log('🧹 Cleanup result:', result);

        // Show results
        const resultsDiv = document.getElementById('cleanupResults');
        const contentDiv = document.getElementById('cleanupResultsContent');

        if (resultsDiv && contentDiv) {
          resultsDiv.style.display = 'block';

          let html = `
            <div style="margin-bottom: 12px;">
              <strong>${dryRun ? 'Preview:' : 'Completed:'}</strong>
              ${result.found_count} problematic asset${result.found_count !== 1 ? 's' : ''} found
              ${!dryRun ? `, ${result.deleted_count} deleted` : ''}
            </div>
          `;

          if (result.assets && result.assets.length > 0) {
            html += `
              <div style="max-height: 200px; overflow-y: auto; background: var(--panel); border: 1px solid var(--border); border-radius: 4px; padding: 8px;">
                <div style="font-size: 12px; font-weight: bold; margin-bottom: 8px; color: var(--text);">Assets ${dryRun ? 'to be deleted:' : 'deleted:'}</div>
            `;

            result.assets.forEach(asset => {
              html += `
                <div style="font-size: 11px; color: var(--muted); margin-bottom: 4px; padding: 4px; background: var(--panel-2); border-radius: 3px;">
                  <strong>${asset.title}</strong> (${asset.document_type}) - Owner: ${asset.owner_username || 'Unknown'}
                  ${asset.source_filename ? `<br/>File: ${asset.source_filename}` : ''}
                </div>
              `;
            });

            html += '</div>';
          }

          contentDiv.innerHTML = html;
        }

        toast(`${dryRun ? 'Preview completed' : 'Cleanup completed'}: ${result.found_count} asset${result.found_count !== 1 ? 's' : ''} ${dryRun ? 'found' : 'deleted'}`);

        // Reload documents if we actually deleted something
        if (!dryRun && result.deleted_count > 0) {
          await loadAllDocuments();
        }

      } catch (error) {
        console.error(`❌ Error during cleanup ${action}:`, error);
        toast(`Cleanup ${action} failed: ${error.message}`, true);
      }
    }

    // Make document management functions globally available
    window.loadAllDocuments = loadAllDocuments;
    window.adminDeleteAsset = adminDeleteAsset;
    window.cleanupUnknownAssets = cleanupUnknownAssets;

    // Enhanced File Deletion with Orphaned Asset Management
    async function showEnhancedDeleteDialog(fileId) {
      try {
        console.log('🗑️ Checking knowledge assets for file:', fileId);

        // First, check if file has associated knowledge assets
        const response = await fetch(`/api/files/${fileId}/knowledge-assets`, {
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          // Fallback to simple deletion if check fails
          if (confirm('Delete this file?')) {
            await performFileDeletion(fileId, false);
          }
          return;
        }

        const assetInfo = await response.json();
        console.log('📄 Knowledge asset info:', assetInfo);

        if (!assetInfo.has_knowledge_assets) {
          // No knowledge assets - simple deletion
          if (confirm('Delete this file?\\n\\nThis file has no associated knowledge assets.')) {
            await performFileDeletion(fileId, false);
          }
          return;
        }

        // File has knowledge assets - show enhanced dialog
        showKnowledgeAssetDeletionDialog(fileId, assetInfo);

      } catch (error) {
        console.error('❌ Error checking knowledge assets:', error);
        // Fallback to simple deletion
        if (confirm('Delete this file?\\n\\n(Could not check for knowledge assets)')) {
          await performFileDeletion(fileId, false);
        }
      }
    }

    function showKnowledgeAssetDeletionDialog(fileId, assetInfo) {
      // Create modal
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center;
        z-index: 10000; padding: 20px;
      `;

      const recentCount = assetInfo.assets.filter(a => {
        const ageMs = Date.now() - new Date(a.created_at).getTime();
        return ageMs < (30 * 24 * 60 * 60 * 1000); // 30 days
      }).length;

      const oldCount = assetInfo.asset_count - recentCount;
      const defaultChoice = recentCount > 0 ? 'preserve' : 'delete_both';

      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 12px;
                    width: 90%; max-width: 600px; max-height: 80vh; display: flex; flex-direction: column;">
          <div style="padding: 20px; border-bottom: 1px solid var(--border);">
            <h3 style="margin: 0; color: var(--accent); display: flex; align-items: center; gap: 8px;">
              ⚠️ Delete File with Knowledge Assets
            </h3>
          </div>

          <div style="padding: 20px; overflow-y: auto; flex: 1;">
            <div style="margin-bottom: 16px;">
              <strong>This file has ${assetInfo.asset_count} associated knowledge asset${assetInfo.asset_count !== 1 ? 's' : ''}:</strong>
            </div>

            <div style="background: var(--panel-2); border: 1px solid var(--border); border-radius: 8px; padding: 12px; margin-bottom: 20px; max-height: 200px; overflow-y: auto;">
              ${assetInfo.assets.map(asset => {
        const ageMs = Date.now() - new Date(asset.created_at).getTime();
        const ageDays = Math.floor(ageMs / (24 * 60 * 60 * 1000));
        const isRecent = ageDays <= 30;

        return `
                  <div style="margin-bottom: 8px; padding: 8px; background: var(--panel); border-radius: 6px; border-left: 3px solid ${isRecent ? '#22c55e' : '#f59e0b'};">
                    <div style="font-weight: 500; color: var(--accent);">${asset.title}</div>
                    <div style="font-size: 12px; color: var(--muted);">
                      ${asset.document_type} • Created ${ageDays} day${ageDays !== 1 ? 's' : ''} ago
                      ${isRecent ? '<span style="color: #22c55e;"> (Recent)</span>' : '<span style="color: #f59e0b;"> (Old)</span>'}
                    </div>
                  </div>
                `;
      }).join('')}
            </div>

            <div style="margin-bottom: 20px;">
              <strong>Choose deletion strategy:</strong>
            </div>

            <div style="display: grid; gap: 12px;">
              <label style="display: flex; align-items: start; gap: 12px; padding: 12px; background: var(--panel-2); border: 1px solid var(--border); border-radius: 8px; cursor: pointer;" class="deletion-option ${defaultChoice === 'preserve' ? 'recommended' : ''}">
                <input type="radio" name="deletionStrategy" value="preserve" ${defaultChoice === 'preserve' ? 'checked' : ''} style="margin-top: 2px;">
                <div>
                  <div style="font-weight: 500; color: var(--accent);">📎 Preserve knowledge as orphaned ${defaultChoice === 'preserve' ? '(Recommended)' : ''}</div>
                  <div style="font-size: 12px; color: var(--muted); margin-top: 4px;">
                    Delete the file but keep knowledge assets. They will be marked as "orphaned" but remain searchable by DAS.
                    ${recentCount > 0 ? `<br/><strong>Recommended:</strong> You have ${recentCount} recent asset${recentCount !== 1 ? 's' : ''}.` : ''}
                  </div>
                </div>
              </label>

              <label style="display: flex; align-items: start; gap: 12px; padding: 12px; background: var(--panel-2); border: 1px solid var(--border); border-radius: 8px; cursor: pointer;" class="deletion-option ${defaultChoice === 'delete_both' ? 'recommended' : ''}">
                <input type="radio" name="deletionStrategy" value="delete_both" ${defaultChoice === 'delete_both' ? 'checked' : ''} style="margin-top: 2px;">
                <div>
                  <div style="font-weight: 500; color: #ef4444;">🗑️ Delete both file and knowledge assets ${defaultChoice === 'delete_both' ? '(Recommended)' : ''}</div>
                  <div style="font-size: 12px; color: var(--muted); margin-top: 4px;">
                    Permanently delete the file and all associated knowledge assets. This cannot be undone.
                    ${oldCount === assetInfo.asset_count && oldCount > 0 ? `<br/><strong>Note:</strong> All assets are older than 30 days.` : ''}
                  </div>
                </div>
              </label>
            </div>

            <div style="margin-top: 16px; padding: 12px; background: rgba(59, 130, 246, 0.1); border: 1px solid #3b82f6; border-radius: 8px; font-size: 12px;">
              <strong>💡 About Orphaned Assets:</strong><br/>
              Orphaned knowledge assets remain fully searchable by DAS and can be viewed in Knowledge Management.
              They just lose the link to their original source file.
            </div>
          </div>

          <div style="padding: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: flex-end;">
            <button id="cancelDeleteBtn" style="background: transparent; border: 1px solid var(--border); color: var(--text); padding: 8px 16px; border-radius: 6px; cursor: pointer;">
              Cancel
            </button>
            <button id="confirmDeleteBtn" style="background: #ef4444; border: 1px solid #ef4444; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 500;">
              Delete File
            </button>
          </div>
        </div>
      `;

      // Add recommended styling
      const style = document.createElement('style');
      style.textContent = `
        .deletion-option.recommended {
          border-color: var(--accent) !important;
          background: rgba(59, 130, 246, 0.05) !important;
        }
        .deletion-option:hover {
          border-color: var(--accent);
        }
      `;
      modal.appendChild(style);

      document.body.appendChild(modal);

      // Add event listeners for modal buttons
      const deleteBtn = modal.querySelector('#confirmDeleteBtn');
      if (deleteBtn) {
        deleteBtn.addEventListener('click', () => executeFileDeletion(fileId, modal));
      }

      const cancelBtn = modal.querySelector('#cancelDeleteBtn');
      if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
          modal.remove();
        });
      }

      // Also allow clicking outside modal to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });

      // Add escape key handler
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          modal.remove();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    }

    async function executeFileDeletion(fileId, modal) {
      try {
        const allRadios = modal.querySelectorAll('input[name="deletionStrategy"]');
        const selectedRadio = modal.querySelector('input[name="deletionStrategy"]:checked');
        const selectedStrategy = selectedRadio?.value;

        console.log('🗑️ All radio buttons:', allRadios.length);
        console.log('🗑️ Selected radio:', selectedRadio);
        console.log('🗑️ Selected strategy:', selectedStrategy);

        if (!selectedStrategy) {
          toast('Please select a deletion strategy', true);
          return;
        }

        const deleteKnowledgeAssets = selectedStrategy === 'delete_both';

        console.log(`🗑️ Executing deletion strategy: ${selectedStrategy} for file:`, fileId);

        // Show loading state
        const deleteButton = modal.querySelector('button[onclick*="executeFileDeletion"]');
        if (deleteButton) {
          deleteButton.textContent = 'Deleting...';
          deleteButton.disabled = true;
        }

        const success = await performFileDeletion(fileId, deleteKnowledgeAssets);

        if (success) {
          modal.remove();
        } else {
          // Re-enable button on failure
          if (deleteButton) {
            deleteButton.textContent = 'Delete File';
            deleteButton.disabled = false;
          }
        }

      } catch (error) {
        console.error('❌ Error during file deletion:', error);
        toast('Delete failed: ' + error.message, true);

        // Re-enable button on error
        const deleteButton = modal.querySelector('button[onclick*="executeFileDeletion"]');
        if (deleteButton) {
          deleteButton.textContent = 'Delete File';
          deleteButton.disabled = false;
        }
      }
    }

    async function performFileDeletion(fileId, deleteKnowledgeAssets = false) {
      try {
        const url = `/api/files/${encodeURIComponent(fileId)}${deleteKnowledgeAssets ? '?delete_knowledge_assets=true' : ''}`;

        const response = await fetch(url, {
          method: 'DELETE',
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Delete failed: ${response.status}`);
        }

        const result = await response.json();
        console.log('🗑️ Delete result:', result);

        // Show appropriate success message
        if (result.deletion_strategy === 'preserve_knowledge') {
          toast(`File deleted, ${result.orphaned_assets} knowledge asset(s) preserved as orphaned`);
        } else if (result.deletion_strategy === 'delete_both') {
          toast(`File and ${result.deleted_assets} knowledge asset(s) deleted`);
        } else {
          toast('File deleted successfully');
        }

        // Refresh both file library and knowledge management
        await window.loadLibraryFromApi();
        if (typeof loadKnowledgeAssets === 'function') {
          loadKnowledgeAssets();
        }

        return true;

      } catch (error) {
        console.error('❌ Error deleting file:', error);
        toast('Delete failed: ' + error.message, true);
        return false;
      }
    }

    // Comprehensive Orphaned Resource Management
    async function manageOrphanedAssets() {
      try {
        console.log('📎 Loading all orphaned resources...');
        const token = localStorage.getItem('odras_token');

        // Load both orphaned files and orphaned knowledge assets
        const [filesResponse, knowledgeResponse] = await Promise.all([
          fetch('/api/files/admin/all?limit=1000', { headers: { 'Authorization': `Bearer ${token}` } }),
          fetch('/api/knowledge/admin/assets?limit=1000', { headers: { 'Authorization': `Bearer ${token}` } })
        ]);

        if (!filesResponse.ok || !knowledgeResponse.ok) {
          throw new Error('Failed to load resources');
        }

        const files = (await filesResponse.json()).files || [];
        const knowledgeAssets = (await knowledgeResponse.json()).assets || [];

        // Find orphaned files (files without knowledge assets)
        const orphanedFiles = files.filter(file =>
          !knowledgeAssets.some(ka => ka.source_file_id === file.file_id)
        );

        // Find orphaned knowledge assets (assets without source files)
        const orphanedKnowledge = knowledgeAssets.filter(asset =>
          asset.traceability_status === 'orphaned' ||
          !asset.source_file_id ||
          !files.some(f => f.file_id === asset.source_file_id)
        );

        // Combine for comprehensive orphaned resource management
        const allOrphaned = {
          files: orphanedFiles,
          knowledge: orphanedKnowledge,
          total: orphanedFiles.length + orphanedKnowledge.length
        };

        showComprehensiveOrphanedModal(allOrphaned);

      } catch (error) {
        console.error('❌ Error loading orphaned resources:', error);
        toast(`Failed to load orphaned resources: ${error.message}`, true);
      }
    }

    function showComprehensiveOrphanedModal(allOrphaned) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center;
        z-index: 10000; padding: 20px;
      `;

      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 12px;
                    width: 90%; max-width: 900px; max-height: 80vh; display: flex; flex-direction: column;">
          <div style="padding: 20px; border-bottom: 1px solid var(--border);">
            <h3 style="margin: 0; color: var(--accent); display: flex; align-items: center; gap: 8px;">
              📎 Comprehensive Orphaned Resource Management
            </h3>
            <div style="font-size: 12px; color: var(--muted); margin-top: 4px;">
              ${allOrphaned.total} orphaned resource${allOrphaned.total !== 1 ? 's' : ''} found
              (${allOrphaned.files.length} files, ${allOrphaned.knowledge.length} knowledge assets)
            </div>
          </div>

          <div style="padding: 20px; overflow-y: auto; flex: 1;">
            ${allOrphaned.total === 0 ?
          '<div style="text-align: center; color: var(--muted); padding: 40px;">✅ No orphaned resources found - system is clean!</div>' :
          `
                ${allOrphaned.files.length > 0 ? `
                  <div style="margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: #f59e0b;">📁 Orphaned Files (${allOrphaned.files.length})</h4>
                    <div style="font-size: 12px; color: var(--muted); margin-bottom: 8px;">Files that haven't been processed into knowledge assets</div>
                    <div style="display: grid; gap: 8px;">
                      ${allOrphaned.files.map(file => `
                        <div style="background: var(--panel-2); border: 1px solid #f59e0b; border-radius: 6px; padding: 12px;">
                          <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                              <h5 style="margin: 0 0 4px 0; color: var(--accent);">📁 ${file.filename}</h5>
                              <div style="font-size: 12px; color: var(--muted);">
                                <strong>Size:</strong> ${file.size} bytes •
                                <strong>Type:</strong> ${file.content_type} •
                                <strong>Created:</strong> ${new Date(file.created_at).toLocaleDateString()}
                              </div>
                            </div>
                            <div style="display: flex; gap: 4px;">
                              <button onclick="processFileToKnowledge('${file.file_id}')" style="background: #059669; color: #34d399; border: none; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">🧠 Process</button>
                              <button onclick="downloadFile('${file.file_id}')" style="background: #1e3a8a; color: #60a5fa; border: none; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">💾 Download</button>
                              <button onclick="adminDeleteResource('file', '${file.file_id}', '${file.filename}')" style="background: #dc2626; color: #f87171; border: none; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">🗑️ Delete</button>
                            </div>
                          </div>
                        </div>
                      `).join('')}
                    </div>
                  </div>
                ` : ''}

                ${allOrphaned.knowledge.length > 0 ? `
                  <div style="margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: #f59e0b;">📄 Orphaned Knowledge Assets (${allOrphaned.knowledge.length})</h4>
                    <div style="font-size: 12px; color: var(--muted); margin-bottom: 8px;">Knowledge assets whose source files were deleted</div>
                    <div style="display: grid; gap: 8px;">
                      ${allOrphaned.knowledge.map(asset => `
                        <div style="background: var(--panel-2); border: 1px solid #f59e0b; border-radius: 6px; padding: 12px;">
                          <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                              <h5 style="margin: 0 0 4px 0; color: var(--accent);">📄 ${asset.title}</h5>
                              <div style="font-size: 12px; color: var(--muted);">
                                <strong>Type:</strong> ${asset.document_type} •
                                <strong>Status:</strong> ${asset.traceability_status} •
                                <strong>Created:</strong> ${new Date(asset.created_at).toLocaleDateString()}
                              </div>
                            </div>
                            <div style="display: flex; gap: 4px;">
                              <button onclick="viewAssetContent('${asset.id}')" style="background: #1e3a8a; color: #60a5fa; border: none; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">📄 View</button>
                              <button onclick="adminDeleteResource('knowledge_asset', '${asset.id}', '${asset.title}')" style="background: #dc2626; color: #f87171; border: none; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">🗑️ Delete</button>
                            </div>
                          </div>
                        </div>
                      `).join('')}
                    </div>
                  </div>
                ` : ''}
              `
        }
          </div>

          <div style="padding: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: space-between;">
            <div style="display: flex; gap: 12px;">
              ${allOrphaned.files.length > 0 ? `
                <button onclick="processAllOrphanedFiles()" style="background: #059669; border: 1px solid #059669; color: #34d399; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                  🧠 Process All Files
                </button>
                <button onclick="deleteAllOrphanedFiles()" style="background: #dc2626; border: 1px solid #dc2626; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                  🗑️ Delete All Files
                </button>
              ` : ''}
              ${allOrphaned.knowledge.length > 0 ? `
                <button onclick="archiveAllOrphanedKnowledge()" style="background: #7c3aed; border: 1px solid #7c3aed; color: #a78bfa; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                  📦 Archive All Knowledge
                </button>
              ` : ''}
            </div>
            <button id="closeComprehensiveOrphanedModal" style="background: transparent; border: 1px solid var(--border); color: var(--text); padding: 8px 16px; border-radius: 6px; cursor: pointer;">
              Close
            </button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // Add proper event listeners
      const closeBtn = modal.querySelector('#closeComprehensiveOrphanedModal');
      if (closeBtn) {
        closeBtn.addEventListener('click', () => modal.remove());
      }

      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });

      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          modal.remove();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    }

    function showOrphanedAssetsModal(orphanedAssets) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center;
        z-index: 10000; padding: 20px;
      `;

      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 12px;
                    width: 90%; max-width: 800px; max-height: 80vh; display: flex; flex-direction: column;">
          <div style="padding: 20px; border-bottom: 1px solid var(--border);">
            <h3 style="margin: 0; color: var(--accent); display: flex; align-items: center; gap: 8px;">
              📎 Orphaned Assets Management
            </h3>
            <div style="font-size: 12px; color: var(--muted); margin-top: 4px;">
              ${orphanedAssets.length} orphaned asset${orphanedAssets.length !== 1 ? 's' : ''} found
            </div>
          </div>

          <div style="padding: 20px; overflow-y: auto; flex: 1;">
            ${orphanedAssets.length === 0 ?
          '<div style="text-align: center; color: var(--muted); padding: 40px;">No orphaned assets found.</div>' :
          `<div style="display: grid; gap: 8px;">
                ${orphanedAssets.map(asset => {
            const metadata = asset.metadata || {};
            const ownerUsername = metadata.owner_username || 'Unknown';
            const createdAt = new Date(asset.created_at).toLocaleDateString();
            const orphanedAt = asset.orphaned_at ? new Date(asset.orphaned_at).toLocaleDateString() : 'Unknown';

            return `
                    <div style="background: var(--panel-2); border: 1px solid #f59e0b; border-radius: 6px; padding: 12px;">
                      <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                        <div style="flex: 1;">
                          <h4 style="margin: 0 0 4px 0; color: var(--accent);">${asset.title || 'Untitled'}</h4>
                          <div style="font-size: 12px; color: var(--muted);">
                            <strong>Type:</strong> ${asset.document_type} •
                            <strong>Owner:</strong> ${ownerUsername} •
                            <strong>Created:</strong> ${createdAt} •
                            <strong>Orphaned:</strong> ${orphanedAt}
                          </div>
                        </div>
                        <div style="display: flex; gap: 4px;">
                          <button onclick="viewAssetContent('${asset.id}')" style="background: #1e3a8a; color: #60a5fa; border: none; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">View</button>
                          <button onclick="archiveOrphanedAsset('${asset.id}')" style="background: #7c3aed; color: #a78bfa; border: none; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">Archive</button>
                          <button onclick="adminDeleteAsset('${asset.id}', '${asset.title || 'Untitled'}')" style="background: #dc2626; color: #f87171; border: none; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">Delete</button>
                        </div>
                      </div>
                    </div>
                  `;
          }).join('')}
              </div>`
        }
          </div>

          <div style="padding: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: space-between;">
            <div style="display: flex; gap: 12px;">
              ${orphanedAssets.length > 0 ? `
                <button onclick="archiveAllOrphanedAssets()" style="background: #7c3aed; border: 1px solid #7c3aed; color: #a78bfa; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                  Archive All
                </button>
                <button onclick="deleteAllOrphanedAssets()" style="background: #dc2626; border: 1px solid #dc2626; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                  Delete All
                </button>
              ` : ''}
            </div>
            <button id="closeOrphanedModal" style="background: transparent; border: 1px solid var(--border); color: var(--text); padding: 8px 16px; border-radius: 6px; cursor: pointer;">
              Close
            </button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // Add proper event listeners after modal is in DOM
      const closeBtn = modal.querySelector('#closeOrphanedModal');
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          modal.remove();
        });
      }

      // Also allow clicking outside modal to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });

      // Add escape key handler
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          modal.remove();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    }

    // IRI Management Functions
    function showIRIDetails(iri) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center;
        z-index: 10000; padding: 20px;
      `;

      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 12px;
                    width: 90%; max-width: 700px; display: flex; flex-direction: column;">
          <div style="padding: 20px; border-bottom: 1px solid var(--border);">
            <h3 style="margin: 0; color: var(--accent); display: flex; align-items: center; gap: 8px;">
              🔗 Resource IRI Details
            </h3>
          </div>

          <div style="padding: 20px;">
            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 8px; color: var(--text); font-weight: 500;">Installation-Specific IRI:</label>
              <div style="background: var(--panel-2); border: 1px solid var(--border); border-radius: 6px; padding: 12px; font-family: monospace; font-size: 12px; word-break: break-all; color: var(--accent);">
                ${iri}
              </div>
            </div>

            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 8px; color: var(--text); font-weight: 500;">IRI Components:</label>
              <div style="background: var(--panel-2); border: 1px solid var(--border); border-radius: 6px; padding: 12px; font-size: 11px;">
                ${parseIRIComponents(iri)}
              </div>
            </div>

            <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid #3b82f6; border-radius: 8px; padding: 12px; font-size: 12px;">
              <strong>💡 About IRIs:</strong><br/>
              This IRI uniquely identifies this resource within the XMA-ADT installation.
              It follows military domain conventions and can be resolved to get resource metadata.
            </div>
          </div>

          <div style="padding: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: flex-end;">
            <button onclick="copyToClipboard('${iri}')" style="background: var(--accent); border: 1px solid var(--accent); color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 500;">
              📋 Copy IRI
            </button>
            <button id="closeIRIModal" style="background: transparent; border: 1px solid var(--border); color: var(--text); padding: 8px 16px; border-radius: 6px; cursor: pointer;">
              Close
            </button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // Add proper event listeners after modal is in DOM
      const closeBtn = modal.querySelector('#closeIRIModal');
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          modal.remove();
        });
      }

      // Also allow clicking outside modal to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });

      // Add escape key handler
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          modal.remove();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    }

    function parseIRIComponents(iri) {
      try {
        const url = new URL(iri);
        const pathParts = url.pathname.split('/').filter(p => p);

        let components = `
          <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px; font-family: monospace;">
            <span style="color: var(--muted);">Domain:</span>
            <span style="color: var(--accent);">${url.hostname}</span>
            <span style="color: var(--muted);">Path:</span>
            <span style="color: var(--text);">${url.pathname}</span>
        `;

        if (pathParts.length >= 2 && pathParts[0] === 'program') {
          components += `
            <span style="color: var(--muted);">Program:</span>
            <span style="color: var(--accent);">${pathParts[1]}</span>
          `;
        }

        if (pathParts.length >= 4 && pathParts[2] === 'project') {
          components += `
            <span style="color: var(--muted);">Project:</span>
            <span style="color: var(--accent);">${pathParts[3]}</span>
          `;
        }

        if (pathParts.length >= 6) {
          components += `
            <span style="color: var(--muted);">Type:</span>
            <span style="color: var(--accent);">${pathParts[4]}</span>
            <span style="color: var(--muted);">Resource:</span>
            <span style="color: var(--accent);">${pathParts[5]}</span>
          `;
        }

        components += '</div>';
        return components;

      } catch (e) {
        return `<span style="color: var(--err);">Invalid IRI format</span>`;
      }
    }

    // Make functions globally available
    window.showEnhancedDeleteDialog = showEnhancedDeleteDialog;
    window.executeFileDeletion = executeFileDeletion;
    window.performFileDeletion = performFileDeletion;
    window.manageOrphanedAssets = manageOrphanedAssets;
    window.showIRIDetails = showIRIDetails;

    // System Health and Cleanup Functions
    async function analyzeSystemHealth() {
      try {
        console.log('🔍 Analyzing system health...');

        // This analysis is done client-side from the loaded data
        await loadAllDocuments(); // Refresh data first

        // Show system health modal with detailed analysis
        showSystemHealthModal();

      } catch (error) {
        console.error('❌ Error analyzing system health:', error);
        toast(`System health analysis failed: ${error.message}`, true);
      }
    }

    function showSystemHealthModal() {
      // Get current data from the display
      const listElement = document.getElementById('adminDocumentList');
      if (!listElement) return;

      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center;
        z-index: 10000; padding: 20px;
      `;

      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 12px;
                    width: 90%; max-width: 700px; max-height: 80vh; display: flex; flex-direction: column;">
          <div style="padding: 20px; border-bottom: 1px solid var(--border);">
            <h3 style="margin: 0; color: var(--accent); display: flex; align-items: center; gap: 8px;">
              🏥 ODRAS System Health Analysis
            </h3>
          </div>

          <div style="padding: 20px; overflow-y: auto; flex: 1;">
            <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid #3b82f6; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
              <h4 style="margin: 0 0 8px 0; color: var(--accent);">📊 System Statistics</h4>
              <div id="healthStatsContent">Loading analysis...</div>
            </div>

            <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid #ef4444; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
              <h4 style="margin: 0 0 8px 0; color: #ef4444;">⚠️ Issues Found</h4>
              <div id="healthIssuesContent">Analyzing...</div>
            </div>

            <div style="background: rgba(34, 197, 94, 0.1); border: 1px solid #22c55e; border-radius: 8px; padding: 16px;">
              <h4 style="margin: 0 0 8px 0; color: #22c55e;">🛠️ Recommended Actions</h4>
              <div id="healthActionsContent">Generating recommendations...</div>
            </div>
          </div>

          <div style="padding: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: flex-end;">
            <button onclick="runAutoCleanup()" style="background: #f59e0b; border: 1px solid #f59e0b; color: #fbbf24; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 500;">
              🧹 Auto Cleanup
            </button>
            <button id="closeHealthModal" style="background: transparent; border: 1px solid var(--border); color: var(--text); padding: 8px 16px; border-radius: 6px; cursor: pointer;">
              Close
            </button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // Add proper event listeners
      const closeBtn = modal.querySelector('#closeHealthModal');
      if (closeBtn) {
        closeBtn.addEventListener('click', () => modal.remove());
      }

      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });

      // Populate with actual analysis
      populateHealthAnalysis();
    }

    async function populateHealthAnalysis() {
      try {
        // Perform actual system health check
        const token = localStorage.getItem('odras_token');

        // Get system statistics
        const [filesResponse, knowledgeResponse] = await Promise.all([
          fetch('/api/files?limit=1000', { headers: { 'Authorization': `Bearer ${token}` } }),
          fetch('/api/knowledge/admin/assets?limit=1000', { headers: { 'Authorization': `Bearer ${token}` } })
        ]);

        const files = filesResponse.ok ? (await filesResponse.json()).files || [] : [];
        const knowledge = knowledgeResponse.ok ? (await knowledgeResponse.json()).assets || [] : [];

        // Analyze relationships
        const orphanedFiles = files.filter(f => !knowledge.some(k => k.source_file_id === f.file_id));
        const orphanedKnowledge = knowledge.filter(k => !k.source_file_id || !files.some(f => f.file_id === k.source_file_id));

        // Detect duplicates
        const filesByName = {};
        files.forEach(f => {
          const name = f.filename.toLowerCase();
          if (!filesByName[name]) filesByName[name] = [];
          filesByName[name].push(f);
        });
        const duplicateFiles = Object.values(filesByName).filter(group => group.length > 1).flat();

        // Update UI
        document.getElementById('healthStatsContent').innerHTML = `
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; font-size: 12px;">
            <div><strong>📁 Files:</strong> ${files.length}</div>
            <div><strong>📄 Knowledge:</strong> ${knowledge.length}</div>
            <div><strong>🔗 Linked:</strong> ${files.length - orphanedFiles.length}</div>
            <div><strong>📎 Orphaned Files:</strong> ${orphanedFiles.length}</div>
            <div><strong>📎 Orphaned Knowledge:</strong> ${orphanedKnowledge.length}</div>
            <div><strong>👥 Duplicates:</strong> ${duplicateFiles.length}</div>
          </div>
        `;

        const issues = [];
        if (orphanedFiles.length > 0) issues.push(`${orphanedFiles.length} files without knowledge assets`);
        if (orphanedKnowledge.length > 0) issues.push(`${orphanedKnowledge.length} orphaned knowledge assets`);
        if (duplicateFiles.length > 0) issues.push(`${duplicateFiles.length} duplicate files`);

        document.getElementById('healthIssuesContent').innerHTML = issues.length > 0 ?
          `<ul style="margin: 0; padding-left: 20px;">${issues.map(issue => `<li>${issue}</li>`).join('')}</ul>` :
          '<div style="color: #22c55e;">✅ No issues detected</div>';

        const actions = [];
        if (orphanedFiles.length > 0) actions.push('Process orphaned files to create knowledge assets');
        if (orphanedKnowledge.length > 0) actions.push('Archive or delete orphaned knowledge assets');
        if (duplicateFiles.length > 0) actions.push('Review and remove duplicate files');

        document.getElementById('healthActionsContent').innerHTML = actions.length > 0 ?
          `<ul style="margin: 0; padding-left: 20px;">${actions.map(action => `<li>${action}</li>`).join('')}</ul>` :
          '<div style="color: #22c55e;">✅ System is healthy</div>';

      } catch (error) {
        console.error('Error populating health analysis:', error);
      }
    }

    // Admin Resource Deletion Function
    async function adminDeleteResource(resourceType, resourceId, resourceName) {
      const displayName = resourceName || 'Untitled';
      const typeLabel = resourceType === 'file' ? 'file' : 'knowledge asset';

      if (!confirm(`Are you sure you want to delete this ${typeLabel}?\\n\\n"${displayName}"\\n\\nThis action cannot be undone.`)) {
        return;
      }

      try {
        console.log(`🗑️ Admin deleting ${resourceType}:`, resourceId);
        const token = localStorage.getItem('odras_token');

        let deleteUrl;
        if (resourceType === 'file') {
          deleteUrl = `/api/files/${resourceId}?delete_knowledge_assets=false`; // Default to preserving knowledge
        } else if (resourceType === 'knowledge_asset') {
          deleteUrl = `/api/knowledge/assets/${resourceId}/force`; // Force delete for admin
        } else {
          throw new Error(`Unsupported resource type: ${resourceType}`);
        }

        const response = await fetch(deleteUrl, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (!response.ok) {
          if (response.status === 404) {
            // Asset was already deleted, just refresh the list
            console.log(`ℹ️ ${typeLabel} was already deleted, refreshing list...`);
            toast(`${typeLabel} was already deleted`);
            await loadAllDocuments();
            return;
          }
          throw new Error(`Delete failed: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ Resource deleted:', result);

        toast(`Deleted ${typeLabel}: "${displayName}"`);

        // Reload the resource list
        await loadAllDocuments();

      } catch (error) {
        console.error(`❌ Error deleting ${resourceType}:`, error);
        toast(`Failed to delete ${typeLabel}: ${error.message}`, true);
      }
    }

    // Make new functions globally available
    window.analyzeSystemHealth = analyzeSystemHealth;
    window.displayComprehensiveResourceList = displayComprehensiveResourceList;
    window.adminDeleteResource = adminDeleteResource;

    // Cleanup Tool Functions (placeholder implementations)
    async function cleanupOrphanedFiles() {
      toast('Orphaned files cleanup - Coming soon! Use the resource list to manually process or delete orphaned files.');
    }

    async function cleanupDuplicates() {
      toast('Duplicate detection - Coming soon! Use filters to view and manually remove duplicate files.');
    }

    async function processFileToKnowledge(fileId) {
      if (!confirm('Process this file to create a knowledge asset?')) return;

      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/files/${fileId}/process`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` },
          body: new FormData() // Empty form data
        });

        if (response.ok) {
          toast('File processing started - knowledge asset will be created');
          setTimeout(() => loadAllDocuments(), 5000); // Refresh after processing
        } else {
          throw new Error(`Processing failed: ${response.status}`);
        }
      } catch (error) {
        console.error('Error processing file:', error);
        toast('Failed to start file processing: ' + error.message, true);
      }
    }

    async function downloadFile(fileId) {
      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/files/${fileId}/download`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) {
          throw new Error(`Download failed: ${response.status}`);
        }

        // Trigger download
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `file-${fileId}`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);

        toast('File download started');

      } catch (error) {
        console.error('Error downloading file:', error);
        toast('Failed to download file: ' + error.message, true);
      }
    }

    // Duplicate Files Cleanup Function
    async function cleanupDuplicateFiles() {
      if (!confirm('Are you sure you want to remove duplicate files?\\n\\nThis will keep the newest version of each duplicate file and delete older versions.\\n\\nThis action cannot be undone.')) {
        return;
      }

      try {
        console.log('🔍 Starting duplicate files detection and cleanup...');
        const token = localStorage.getItem('odras_token');

        // Get all files
        const filesResponse = await fetch('/api/files/admin/all?limit=1000', {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!filesResponse.ok) {
          throw new Error(`Failed to fetch files: ${filesResponse.status}`);
        }

        const files = (await filesResponse.json()).files || [];
        console.log(`📁 Analyzing ${files.length} files for duplicates...`);

        // Group files by filename and size
        const fileGroups = {};
        files.forEach(file => {
          const key = `${file.filename}_${file.file_size}`;
          if (!fileGroups[key]) {
            fileGroups[key] = [];
          }
          fileGroups[key].push(file);
        });

        // Find groups with duplicates
        const duplicateGroups = Object.values(fileGroups).filter(group => group.length > 1);

        if (duplicateGroups.length === 0) {
          toast('No duplicate files found');
          return;
        }

        console.log(`🔍 Found ${duplicateGroups.length} groups of duplicate files`);

        let totalDeleted = 0;
        let totalErrors = 0;

        // Process each duplicate group
        for (const group of duplicateGroups) {
          // Sort by creation date (newest first)
          group.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

          // Keep the newest file, delete the rest
          const [newestFile, ...filesToDelete] = group;

          console.log(`🗑️ Deleting ${filesToDelete.length} duplicate(s) of "${newestFile.filename}" (keeping newest from ${newestFile.created_at})`);

          for (const fileToDelete of filesToDelete) {
            try {
              const response = await fetch(`/api/files/${fileToDelete.file_id}?delete_knowledge_assets=false`, {
                method: 'DELETE',
                headers: { 'Authorization': `Bearer ${token}` }
              });

              if (response.ok) {
                totalDeleted++;
                console.log(`✅ Deleted duplicate: ${fileToDelete.filename} (${fileToDelete.created_at})`);
              } else if (response.status === 404) {
                // File was already deleted, count as success
                totalDeleted++;
                console.log(`ℹ️ Already deleted duplicate: ${fileToDelete.filename}`);
              } else {
                totalErrors++;
                console.error(`❌ Failed to delete duplicate: ${fileToDelete.filename} (${response.status})`);
              }
            } catch (error) {
              totalErrors++;
              console.error(`❌ Error deleting duplicate ${fileToDelete.filename}:`, error);
            }
          }
        }

        const message = `Duplicate cleanup completed: ${totalDeleted} files deleted, ${totalErrors} errors`;
        console.log(message);
        toast(message);

        // Refresh the document list
        await loadAllDocuments();

      } catch (error) {
        console.error('❌ Error in duplicate cleanup:', error);
        toast(`Duplicate cleanup failed: ${error.message}`, true);
      }
    }

    // Bulk Cleanup Functions
    async function deleteAllOrphanedFiles() {
      if (!confirm('Are you sure you want to delete ALL orphaned files?\\n\\nThis will permanently delete all files that do not have knowledge assets.\\n\\nThis action cannot be undone.')) {
        return;
      }

      try {
        console.log('🗑️ Starting bulk deletion of orphaned files...');
        const token = localStorage.getItem('odras_token');

        // Get current orphaned files
        const [filesResponse, knowledgeResponse] = await Promise.all([
          fetch('/api/files/admin/all?limit=1000', { headers: { 'Authorization': `Bearer ${token}` } }),
          fetch('/api/knowledge/admin/assets?limit=1000', { headers: { 'Authorization': `Bearer ${token}` } })
        ]);

        const files = (await filesResponse.json()).files || [];
        const knowledgeAssets = (await knowledgeResponse.json()).assets || [];

        // Find orphaned files
        const orphanedFiles = files.filter(file =>
          !knowledgeAssets.some(ka => ka.source_file_id === file.file_id)
        );

        if (orphanedFiles.length === 0) {
          toast('No orphaned files found to delete');
          return;
        }

        console.log(`🗑️ Deleting ${orphanedFiles.length} orphaned files...`);

        let successCount = 0;
        let errorCount = 0;

        // Delete files one by one
        for (const file of orphanedFiles) {
          try {
            const response = await fetch(`/api/files/${file.file_id}?delete_knowledge_assets=false`, {
              method: 'DELETE',
              headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
              successCount++;
              console.log(`✅ Deleted: ${file.filename}`);
            } else if (response.status === 404) {
              // File was already deleted, count as success
              successCount++;
              console.log(`ℹ️ Already deleted: ${file.filename}`);
            } else {
              errorCount++;
              console.error(`❌ Failed to delete: ${file.filename} (${response.status})`);
            }
          } catch (error) {
            errorCount++;
            console.error(`❌ Error deleting ${file.filename}:`, error);
          }
        }

        toast(`Bulk deletion completed: ${successCount} deleted, ${errorCount} errors`);

        // Close modal and refresh
        const modal = document.querySelector('.comprehensive-orphaned-modal');
        if (modal) modal.remove();

        await loadAllDocuments();

      } catch (error) {
        console.error('❌ Error in bulk deletion:', error);
        toast(`Bulk deletion failed: ${error.message}`, true);
      }
    }

    async function processAllOrphanedFiles() {
      if (!confirm('Process ALL orphaned files to create knowledge assets?\\n\\nThis will start processing workflows for all files without knowledge assets.')) {
        return;
      }

      try {
        console.log('🧠 Starting bulk processing of orphaned files...');
        const token = localStorage.getItem('odras_token');

        // Get current orphaned files
        const [filesResponse, knowledgeResponse] = await Promise.all([
          fetch('/api/files/admin/all?limit=1000', { headers: { 'Authorization': `Bearer ${token}` } }),
          fetch('/api/knowledge/admin/assets?limit=1000', { headers: { 'Authorization': `Bearer ${token}` } })
        ]);

        const files = (await filesResponse.json()).files || [];
        const knowledgeAssets = (await knowledgeResponse.json()).assets || [];

        // Find orphaned files
        const orphanedFiles = files.filter(file =>
          !knowledgeAssets.some(ka => ka.source_file_id === file.file_id)
        );

        if (orphanedFiles.length === 0) {
          toast('No orphaned files found to process');
          return;
        }

        console.log(`🧠 Processing ${orphanedFiles.length} orphaned files...`);

        let successCount = 0;
        let errorCount = 0;

        // Process files one by one
        for (const file of orphanedFiles) {
          try {
            const response = await fetch(`/api/files/${file.file_id}/process`, {
              method: 'POST',
              headers: { 'Authorization': `Bearer ${token}` },
              body: new FormData()
            });

            if (response.ok) {
              successCount++;
              console.log(`✅ Started processing: ${file.filename}`);
            } else {
              errorCount++;
              console.error(`❌ Failed to process: ${file.filename}`);
            }
          } catch (error) {
            errorCount++;
            console.error(`❌ Error processing ${file.filename}:`, error);
          }
        }

        toast(`Bulk processing started: ${successCount} files queued, ${errorCount} errors`);

        // Close modal and refresh
        const modal = document.querySelector('.comprehensive-orphaned-modal');
        if (modal) modal.remove();

        // Refresh after a delay to show processing status
        setTimeout(() => loadAllDocuments(), 3000);

      } catch (error) {
        console.error('❌ Error in bulk processing:', error);
        toast(`Bulk processing failed: ${error.message}`, true);
      }
    }

    async function archiveAllOrphanedKnowledge() {
      toast('Archive orphaned knowledge assets - Coming soon! Use individual delete buttons for now.');
    }

    async function comprehensiveCleanup() {
      try {
        console.log('🧹 Starting comprehensive cleanup analysis...');

        // Show cleanup options modal
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed; top: 0; left: 0; right: 0; bottom: 0;
          background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center;
          z-index: 10000; padding: 20px;
        `;

        modal.innerHTML = `
          <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 12px;
                      width: 90%; max-width: 600px; display: flex; flex-direction: column;">
            <div style="padding: 20px; border-bottom: 1px solid var(--border);">
              <h3 style="margin: 0; color: var(--accent);">🧹 Comprehensive System Cleanup</h3>
              <div style="font-size: 12px; color: var(--muted); margin-top: 4px;">
                Choose cleanup operations to perform
              </div>
            </div>

            <div style="padding: 20px;">
              <div style="display: grid; gap: 12px;">
                <label style="display: flex; align-items: start; gap: 12px; padding: 12px; background: var(--panel-2); border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                  <input type="checkbox" id="cleanupOrphanedFilesCheck" checked style="margin-top: 2px;">
                  <div>
                    <div style="font-weight: 500; color: #f59e0b;">🗑️ Delete Orphaned Files</div>
                    <div style="font-size: 12px; color: var(--muted);">Remove files that don't have knowledge assets</div>
                  </div>
                </label>

                <label style="display: flex; align-items: start; gap: 12px; padding: 12px; background: var(--panel-2); border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                  <input type="checkbox" id="cleanupUnknownAssetsCheck" checked style="margin-top: 2px;">
                  <div>
                    <div style="font-weight: 500; color: #dc2626;">🗑️ Delete Unknown Knowledge Assets</div>
                    <div style="font-size: 12px; color: var(--muted);">Remove knowledge assets with unknown or empty titles</div>
                  </div>
                </label>

                <label style="display: flex; align-items: start; gap: 12px; padding: 12px; background: var(--panel-2); border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                  <input type="checkbox" id="cleanupDuplicatesCheck" style="margin-top: 2px;">
                  <div>
                    <div style="font-weight: 500; color: #7c3aed;">🗑️ Remove Duplicate Files</div>
                    <div style="font-size: 12px; color: var(--muted);">Keep newest version of duplicate files</div>
                  </div>
                </label>
              </div>
            </div>

            <div style="padding: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: flex-end;">
              <button onclick="this.closest('div').remove()" style="background: transparent; border: 1px solid var(--border); color: var(--text); padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                Cancel
              </button>
              <button onclick="executeComprehensiveCleanup()" style="background: #dc2626; border: 1px solid #dc2626; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                🧹 Start Cleanup
              </button>
            </div>
          </div>
        `;

        document.body.appendChild(modal);

      } catch (error) {
        console.error('❌ Error starting comprehensive cleanup:', error);
        toast(`Cleanup failed: ${error.message}`, true);
      }
    }

    async function executeComprehensiveCleanup() {
      const modal = document.querySelector('div[style*="z-index: 10000"]');

      const cleanupOrphaned = modal?.querySelector('#cleanupOrphanedFilesCheck')?.checked;
      const cleanupUnknown = modal?.querySelector('#cleanupUnknownAssetsCheck')?.checked;
      const cleanupDups = modal?.querySelector('#cleanupDuplicatesCheck')?.checked;

      if (!cleanupOrphaned && !cleanupUnknown && !cleanupDups) {
        toast('Please select at least one cleanup option', true);
        return;
      }

      if (!confirm('Are you sure you want to perform the selected cleanup operations?\\n\\nThis action cannot be undone.')) {
        return;
      }

      try {
        modal?.remove();

        let totalOperations = 0;

        if (cleanupOrphaned) {
          toast('🗑️ Starting orphaned files cleanup...');
          await deleteAllOrphanedFiles();
          totalOperations++;
        }

        if (cleanupUnknown) {
          toast('🗑️ Starting unknown assets cleanup...');
          await cleanupUnknownAssets(false);
          totalOperations++;
        }

        if (cleanupDups) {
          toast('🗑️ Starting duplicate files cleanup...');
          await cleanupDuplicateFiles();
          totalOperations++;
        }

        toast(`✅ Comprehensive cleanup completed (${totalOperations} operations)`);
        await loadAllDocuments();

      } catch (error) {
        console.error('❌ Error in comprehensive cleanup:', error);
        toast(`Comprehensive cleanup failed: ${error.message}`, true);
      }
    }

    // Make cleanup functions globally available
    window.cleanupOrphanedFiles = cleanupOrphanedFiles;
    window.cleanupDuplicates = cleanupDuplicates;
    window.cleanupDuplicateFiles = cleanupDuplicateFiles;
    window.processFileToKnowledge = processFileToKnowledge;
    window.downloadFile = downloadFile;
    window.deleteAllOrphanedFiles = deleteAllOrphanedFiles;
    window.processAllOrphanedFiles = processAllOrphanedFiles;
    window.archiveAllOrphanedKnowledge = archiveAllOrphanedKnowledge;
    window.comprehensiveCleanup = comprehensiveCleanup;
    window.executeComprehensiveCleanup = executeComprehensiveCleanup;

    // Test function for debugging
    function testToggle() {
      console.log('🧪 Testing toggle function...');
      const firstSection = document.querySelector('.section');
      if (firstSection) {
        const header = firstSection.querySelector('.section-header');
        if (header) {
          console.log('Found section and header, calling toggleSection...');
          toggleSection(header);
        } else {
          console.error('No header found in first section');
        }
      } else {
        console.error('No section found');
      }
    }
    window.testToggle = testToggle;

    // Add event listeners to section headers
    function addSectionListeners() {
      console.log('🔧 Adding event listeners to section headers...');
      const sectionHeaders = document.querySelectorAll('.section-header');
      console.log('Found section headers:', sectionHeaders.length);

      sectionHeaders.forEach((header, index) => {
        console.log(`Adding listener to header ${index}:`, header);
        header.addEventListener('click', function (e) {
          console.log(`Section header ${index} clicked via event listener`);
          e.preventDefault();
          e.stopPropagation();
          toggleSection(this);
        });
      });
    }
    window.addSectionListeners = addSectionListeners;

    // Menu functionality for ontology workbench
    function initializeOntologyMenus() {
      // Close all menus when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.menu-group')) {
          document.querySelectorAll('.menu-dropdown').forEach(menu => {
            menu.style.display = 'none';
          });
        }
      });

      // Handle menu button clicks
      const menuButtons = ['ontoLayoutMenuBtn', 'ontoViewMenuBtn', 'ontoEditMenuBtn', 'ontoFileMenuBtn', 'cadToolsMenuBtn'];
      menuButtons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const dropdown = btn.nextElementSibling;
            if (dropdown) {
              // Close other menus
              document.querySelectorAll('.menu-dropdown').forEach(menu => {
                if (menu !== dropdown) {
                  menu.style.display = 'none';
                }
              });
              // Toggle current menu
              dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
            }
          });
        }
      });
    }

    // Initialize menus when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeOntologyMenus);
    } else {
      initializeOntologyMenus();
    }

    // =============================================================================
    // THREAD MANAGER FUNCTIONALITY
    // =============================================================================

    let threadManagerData = null;
    let threadManagerProjectId = null;

    // Initialize Thread Manager when workbench becomes active
    function initializeThreadManager() {
      console.log('🧵 Initializing Thread Manager...');

      // Auto-detect current project from multiple sources
      let detectedProjectId = threadManagerProjectId;

      if (!detectedProjectId) {
        detectedProjectId = localStorage.getItem('active_project_id');
        console.log('🧵 Detected project from localStorage:', detectedProjectId);
      }

      if (!detectedProjectId) {
        // Try to get from URL
        const urlParams = new URLSearchParams(window.location.search);
        detectedProjectId = urlParams.get('project');
        console.log('🧵 Detected project from URL:', detectedProjectId);
      }

      if (detectedProjectId) {
        console.log('🧵 Setting threadManagerProjectId to:', detectedProjectId);
        threadManagerProjectId = detectedProjectId;
      }

      // Add event listeners
      const refreshBtn = document.getElementById('refresh-thread-btn');
      const entrySelect = document.getElementById('prompt-entry-select');
      const updateBtn = document.getElementById('update-entry-btn');
      const deleteBtn = document.getElementById('delete-entry-btn');
      const testPromptBtn = document.getElementById('test-prompt-btn');

      if (refreshBtn) {
        refreshBtn.addEventListener('click', loadCurrentProjectThread);
      }

      if (entrySelect) {
        entrySelect.addEventListener('change', displayConversationEntry);
      }

      if (updateBtn) {
        updateBtn.addEventListener('click', updateConversationEntry);
      }

      if (deleteBtn) {
        deleteBtn.addEventListener('click', deleteConversationEntry);
      }

      if (testPromptBtn) {
        testPromptBtn.addEventListener('click', showCustomPromptModal);
      }

      // Auto-load thread for current project
      if (threadManagerProjectId) {
        console.log('🧵 Auto-loading thread for project:', threadManagerProjectId);
        loadCurrentProjectThread();
      } else {
        console.log('🧵 No project available for Thread Manager');
        document.getElementById('thread-overview').innerHTML = `
          <div class="muted">No project selected. Please select a project first.</div>
        `;
      }
    }

    // Load project thread details
    async function loadCurrentProjectThread() {
      try {
        if (!threadManagerProjectId) {
          console.log('🧵 No project selected for Thread Manager');
          return;
        }

        console.log('🧵 Loading project thread for:', threadManagerProjectId);

        const response = await fetch(`/api/das2/project/${threadManagerProjectId}/thread`, {
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to load thread: ${response.status}`);
        }

        const threadInfo = await response.json();
        console.log('🧵 Thread info:', threadInfo);

        // Now get full thread details
        const detailsResponse = await fetch(`/api/thread-manager/threads/${threadInfo.project_thread_id}`, {
          headers: { ...authHeader() }
        });

        if (!detailsResponse.ok) {
          throw new Error(`Failed to load thread details: ${detailsResponse.status}`);
        }

        threadManagerData = await detailsResponse.json();
        console.log('🧵 Full thread data:', threadManagerData);

        displayThreadOverview();
        displayConversationHistory();

      } catch (error) {
        console.error('❌ Error loading thread:', error);
        document.getElementById('thread-overview').innerHTML = `
          <div style="color: var(--err);">Error loading thread: ${error.message}</div>
        `;
      }
    }

    // Display thread overview
    function displayThreadOverview() {
      const overviewDiv = document.getElementById('thread-overview');
      if (!overviewDiv || !threadManagerData) return;

      const projectDetails = threadManagerData.project_details || {};

      overviewDiv.innerHTML = `
        <div style="display: grid; gap: 8px; font-size: 14px;">
          <div><strong>Project:</strong> ${projectDetails.name || 'Unknown'}</div>
          <div><strong>Thread ID:</strong> <code style="font-size: 12px; background: var(--panel-2); padding: 2px 4px; border-radius: 3px;">${threadManagerData.project_thread_id}</code></div>
          <div><strong>Created:</strong> ${new Date(threadManagerData.created_at).toLocaleString()}</div>
          <div><strong>Last Activity:</strong> ${new Date(threadManagerData.last_activity).toLocaleString()}</div>
          <div><strong>Conversations:</strong> ${threadManagerData.conversation_history.length}</div>
          <div><strong>Project Events:</strong> ${threadManagerData.project_events.length}</div>
          <div><strong>Current Workbench:</strong> ${threadManagerData.current_workbench || 'None'}</div>
        </div>
      `;
    }

    // Display conversation history
    function displayConversationHistory() {
      const listDiv = document.getElementById('conversation-list');
      const selectElement = document.getElementById('prompt-entry-select');

      if (!listDiv || !selectElement || !threadManagerData) return;

      const conversations = threadManagerData.conversation_history || [];

      if (conversations.length === 0) {
        listDiv.innerHTML = '<div class="muted">No conversation history</div>';
        selectElement.innerHTML = '<option value="">No conversations available</option>';
        return;
      }

      // Populate conversation list
      const conversationHtml = conversations.map((conv, index) => {
        const timestamp = new Date(conv.timestamp).toLocaleString();
        const hasPromptContext = conv.prompt_context ? '🎯' : '❌';

        return `
          <div class="card" style="margin-bottom: 8px; padding: 12px; background: var(--panel-2);">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
              <span style="font-size: 12px; color: var(--muted);">${timestamp}</span>
              <span style="font-size: 12px;" title="Has prompt context: ${conv.prompt_context ? 'Yes' : 'No'}">${hasPromptContext}</span>
            </div>
            <div style="margin-bottom: 6px;">
              <strong>User:</strong> ${conv.user_message || 'No message'}
            </div>
            <div style="margin-bottom: 6px;">
              <strong>DAS:</strong> ${(conv.das_response || 'No response').substring(0, 100)}${conv.das_response && conv.das_response.length > 100 ? '...' : ''}
            </div>
            ${conv.rag_context ? `<div style="font-size: 12px; color: var(--muted);">📚 ${conv.rag_context.chunks_found || 0} knowledge chunks found</div>` : ''}
          </div>
        `;
      }).join('');

      listDiv.innerHTML = conversationHtml;

      // Populate select dropdown
      const optionsHtml = conversations.map((conv, index) => {
        const timestamp = new Date(conv.timestamp).toLocaleString();
        const preview = conv.user_message ? conv.user_message.substring(0, 50) : 'No message';
        return `<option value="${index}">${index + 1}. ${timestamp} - ${preview}${preview.length >= 50 ? '...' : ''}</option>`;
      }).join('');

      selectElement.innerHTML = `<option value="">Select conversation entry...</option>${optionsHtml}`;
    }

    // Display specific conversation entry details
    function displayConversationEntry() {
      const selectElement = document.getElementById('prompt-entry-select');
      const promptDetails = document.getElementById('prompt-details');

      if (!selectElement || !promptDetails || !threadManagerData) return;

      const entryIndex = parseInt(selectElement.value);
      if (isNaN(entryIndex)) {
        promptDetails.style.display = 'none';
        return;
      }

      const entry = threadManagerData.conversation_history[entryIndex];
      if (!entry) return;

      // Show prompt details
      promptDetails.style.display = 'block';

      // Fill in the data
      document.getElementById('prompt-content').value = entry.prompt_context || 'No prompt context available';
      document.getElementById('user-message-edit').value = entry.user_message || '';
      document.getElementById('das-response-edit').value = entry.das_response || '';

      // Context details
      const contextInfo = [
        `RAG Context: ${entry.rag_context ? JSON.stringify(entry.rag_context, null, 2) : 'None'}`,
        `Project Context: ${entry.project_context ? JSON.stringify(entry.project_context, null, 2) : 'None'}`,
        `Thread Metadata: ${entry.thread_metadata ? JSON.stringify(entry.thread_metadata, null, 2) : 'None'}`
      ].join('\n\n');

      document.getElementById('context-details').value = contextInfo;
    }

    // Update conversation entry
    async function updateConversationEntry() {
      const selectElement = document.getElementById('prompt-entry-select');
      if (!selectElement || !threadManagerData) return;

      const entryIndex = parseInt(selectElement.value);
      if (isNaN(entryIndex)) {
        toast('Please select a conversation entry to update', true);
        return;
      }

      const userMessage = document.getElementById('user-message-edit').value;
      const dasResponse = document.getElementById('das-response-edit').value;

      try {
        const response = await fetch(`/api/thread-manager/threads/${threadManagerData.project_thread_id}/conversation/${entryIndex}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            ...authHeader()
          },
          body: JSON.stringify({
            user_message: userMessage,
            das_response: dasResponse
          })
        });

        if (!response.ok) {
          throw new Error(`Update failed: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ Updated conversation entry:', result);

        toast('Conversation entry updated successfully');
        loadCurrentProjectThread(); // Refresh

      } catch (error) {
        console.error('❌ Error updating entry:', error);
        toast(`Error updating entry: ${error.message}`, true);
      }
    }

    // Delete conversation entry
    async function deleteConversationEntry() {
      const selectElement = document.getElementById('prompt-entry-select');
      if (!selectElement || !threadManagerData) return;

      const entryIndex = parseInt(selectElement.value);
      if (isNaN(entryIndex)) {
        toast('Please select a conversation entry to delete', true);
        return;
      }

      if (!confirm('Are you sure you want to delete this conversation entry?')) {
        return;
      }

      try {
        const response = await fetch(`/api/thread-manager/threads/${threadManagerData.project_thread_id}/conversation/${entryIndex}`, {
          method: 'DELETE',
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Delete failed: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ Deleted conversation entry:', result);

        toast('Conversation entry deleted successfully');
        loadCurrentProjectThread(); // Refresh

      } catch (error) {
        console.error('❌ Error deleting entry:', error);
        toast(`Error deleting entry: ${error.message}`, true);
      }
    }

    // Show custom prompt test modal
    function showCustomPromptModal() {
      // This would show a modal for testing custom prompts
      // For now, just show a simple prompt
      const customPrompt = prompt('Enter custom prompt to test:');
      if (customPrompt && threadManagerProjectId) {
        testCustomPrompt(customPrompt);
      }
    }

    // Test custom prompt
    async function testCustomPrompt(customPrompt) {
      try {
        const response = await fetch(`/api/thread-manager/threads/${threadManagerData.project_thread_id}/test-prompt`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...authHeader()
          },
          body: JSON.stringify({
            custom_prompt: customPrompt,
            project_id: threadManagerProjectId,
            simulate_only: true
          })
        });

        if (!response.ok) {
          throw new Error(`Test failed: ${response.status}`);
        }

        const result = await response.json();
        console.log('🧪 Custom prompt test result:', result);

        alert(`Custom prompt test:\n\nPrompt: ${result.custom_prompt}\n\nSimulated: ${result.simulated}`);

      } catch (error) {
        console.error('❌ Error testing prompt:', error);
        toast(`Error testing prompt: ${error.message}`, true);
      }
    }

    // Hook into project selection to update Thread Manager
    function updateThreadManagerProject(projectId) {
      threadManagerProjectId = projectId;

      // If Thread Manager workbench is active, load the thread
      const threadWorkbench = document.getElementById('wb-thread');
      if (threadWorkbench && threadWorkbench.classList.contains('active')) {
        loadCurrentProjectThread();
      }
    }

    // Hook into workbench switching to initialize Thread Manager
    function onThreadWorkbenchActivated() {
      console.log('🧵 Thread Manager workbench activated');
      initializeThreadManager();
    }

    // Initialize Thread Manager on page load if thread workbench is active
    function initializeThreadManagerOnLoad() {
      // Check if thread workbench is already active on page load
      const threadWorkbench = document.getElementById('wb-thread');
      if (threadWorkbench && threadWorkbench.classList.contains('active')) {
        console.log('🧵 Thread Manager workbench already active on page load - initializing...');
        const projectId = localStorage.getItem('active_project_id');
        if (projectId) {
          threadManagerProjectId = projectId;
          console.log('🧵 Auto-detected project on page load:', projectId);
          initializeThreadManager();
        }
      }
    }

    // Initialize on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(initializeThreadManagerOnLoad, 500); // Small delay for UI to be ready
      });
    } else {
      setTimeout(initializeThreadManagerOnLoad, 500);
    }

    // Expose functions for global access
    window.updateThreadManagerProject = updateThreadManagerProject;
    window.onThreadWorkbenchActivated = onThreadWorkbenchActivated;
    window.loadCurrentProjectThread = loadCurrentProjectThread;

    // Knowledge Processing Info Modal
    function showKnowledgeProcessingInfo() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'flex';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 700px;">
          <div class="modal-header">
            <h3>Knowledge Processing Guidance</h3>
            <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
          </div>
          <div class="modal-body">
            <h4>Document Types</h4>
            <ul>
              <li><strong>Requirements:</strong> System specifications and functional requirements</li>
              <li><strong>Knowledge:</strong> General knowledge base content and documentation</li>
              <li><strong>Reference:</strong> Reference materials and technical documentation</li>
              <li><strong>Specification:</strong> Technical specifications and standards</li>
              <li><strong>Analysis Template:</strong> Templates for analysis and evaluation frameworks</li>
            </ul>

            <h4>Automatic Processing Features</h4>
            <ul>
              <li>Intelligent chunking based on document structure</li>
              <li>Automatic embedding generation using selected model</li>
              <li>Vector storage for semantic search capabilities</li>
              <li>Knowledge asset creation for RAG queries</li>
            </ul>

            <h4>Best Practices</h4>
            <ul>
              <li>Use descriptive filenames for better organization</li>
              <li>Select appropriate document types for accurate categorization</li>
              <li>Ensure documents are well-structured for optimal chunking</li>
              <li>Review processing status before querying the knowledge base</li>
            </ul>

            <h4>Supported Embedding Models</h4>
            <ul>
              <li><strong>all-MiniLM-L6-v2:</strong> Fast, efficient 384-dimensional embeddings</li>
              <li><strong>all-mpnet-base-v2:</strong> Higher quality 768-dimensional embeddings</li>
            </ul>
          </v>
        </div>
      `;
      document.body.appendChild(modal);
    }

    // Add event listener for knowledge processing info button
    document.addEventListener('DOMContentLoaded', function () {
      const infoBtn = document.getElementById('knowledgeProcessingInfoBtn');
      if (infoBtn) {
        infoBtn.addEventListener('click', showKnowledgeProcessingInfo);
      }
    });
  </script>

  <!-- Knowledge Processing Info Modal -->
  <div id="knowledgeProcessingInfoModal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:800px; max-height:90vh; overflow-y:auto;">
      <div class="modal-header">
        <h3>Knowledge Processing Guide</h3>
        <button class="modal-close" onclick="closeKnowledgeProcessingInfoModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div style="display:grid; gap:20px;">

          <!-- Chunking Strategies Section -->
          <div>
            <h4 style="color:var(--accent); margin-bottom:12px;">📄 Chunking Strategies</h4>
            <div style="display:grid; gap:12px;">

              <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                  <strong style="color:var(--text);">Smart Default</strong>
                  <span
                    style="background:var(--success); color:white; padding:2px 6px; border-radius:4px; font-size:10px;">RECOMMENDED</span>
                </div>
                <p style="margin:0; font-size:12px; color:var(--muted);">Automatically selects the best strategy based
                  on file type and content.</p>
                <div style="margin-top:8px; font-size:11px;">
                  <strong>Auto-selection:</strong>
                  <ul style="margin:4px 0; padding-left:16px;">
                    <li>Requirements/Specifications → Semantic</li>
                    <li>Markdown/Text files → Hybrid</li>
                    <li>Code files → Fixed Size</li>
                    <li>Data files → Fixed Size</li>
                  </ul>
                </div>
              </div>

              <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                  <strong style="color:var(--text);">Semantic</strong>
                  <span
                    style="background:var(--warning); color:white; padding:2px 6px; border-radius:4px; font-size:10px;">HIGH
                    QUALITY</span>
                </div>
                <p style="margin:0; font-size:12px; color:var(--muted);">Splits text at semantic boundaries (paragraphs,
                  sections) preserving meaning.</p>
                <div style="margin-top:8px; font-size:11px;">
                  <strong>Best for:</strong> Requirements, specifications, technical documents<br>
                  <strong>Pros:</strong> Preserves context, better retrieval accuracy<br>
                  <strong>Cons:</strong> Variable chunk sizes, may be slower
                </div>
              </div>

              <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                  <strong style="color:var(--text);">Hybrid</strong>
                  <span
                    style="background:var(--info); color:white; padding:2px 6px; border-radius:4px; font-size:10px;">BALANCED</span>
                </div>
                <p style="margin:0; font-size:12px; color:var(--muted);">Tries semantic first, falls back to fixed-size
                  if needed.</p>
                <div style="margin-top:8px; font-size:11px;">
                  <strong>Best for:</strong> General documents, mixed content<br>
                  <strong>Pros:</strong> Adaptive, reliable, good balance<br>
                  <strong>Cons:</strong> More complex, variable performance
                </div>
              </div>

              <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                  <strong style="color:var(--text);">Fixed Size</strong>
                  <span
                    style="background:var(--muted); color:white; padding:2px 6px; border-radius:4px; font-size:10px;">FAST</span>
                </div>
                <p style="margin:0; font-size:12px; color:var(--muted);">Splits text into fixed-size chunks with overlap
                  for continuity.</p>
                <div style="margin-top:8px; font-size:11px;">
                  <strong>Best for:</strong> Code files, structured data, consistent content<br>
                  <strong>Pros:</strong> Fast, predictable, consistent chunk sizes<br>
                  <strong>Cons:</strong> May split concepts, less semantic awareness
                </div>
              </div>

            </div>
          </div>

          <!-- Embedding Models Section -->
          <div>
            <h4 style="color:var(--accent); margin-bottom:12px;">🧠 Embedding Models</h4>
            <div style="display:grid; gap:12px;">

              <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                  <strong style="color:var(--text);">all-MiniLM-L6-v2 (Fast)</strong>
                  <span
                    style="background:var(--success); color:white; padding:2px 6px; border-radius:4px; font-size:10px;">DEFAULT</span>
                </div>
                <p style="margin:0; font-size:12px; color:var(--muted);">Lightweight, fast model good for general text
                  processing.</p>
                <div style="margin-top:8px; font-size:11px;">
                  <strong>Dimensions:</strong> 384 | <strong>Speed:</strong> Very Fast | <strong>Cost:</strong> Free
                  (Local)<br>
                  <strong>Best for:</strong> General documents, quick processing, large volumes<br>
                  <strong>Trade-off:</strong> Lower quality for technical/specialized content
                </div>
              </div>

              <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                  <strong style="color:var(--text);">all-mpnet-base-v2 (Better)</strong>
                  <span
                    style="background:var(--warning); color:white; padding:2px 6px; border-radius:4px; font-size:10px;">RECOMMENDED</span>
                </div>
                <p style="margin:0; font-size:12px; color:var(--muted);">Higher quality model with better semantic
                  understanding.</p>
                <div style="margin-top:8px; font-size:11px;">
                  <strong>Dimensions:</strong> 768 | <strong>Speed:</strong> Moderate | <strong>Cost:</strong> Free
                  (Local)<br>
                  <strong>Best for:</strong> Technical documents, requirements, specifications<br>
                  <strong>Trade-off:</strong> Slower processing, higher memory usage
                </div>
              </div>

            </div>
          </div>

          <!-- Recommendations Section -->
          <div>
            <h4 style="color:var(--accent); margin-bottom:12px;">💡 Recommendations</h4>
            <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px;">
              <div style="font-size:12px;">
                <strong>For Technical Documents (Requirements, Specifications):</strong><br>
                • Chunking: Smart Default or Semantic<br>
                • Embedding: all-mpnet-base-v2 (Better)<br><br>

                <strong>For General Documents:</strong><br>
                • Chunking: Smart Default or Hybrid<br>
                • Embedding: all-MiniLM-L6-v2 (Fast)<br><br>

                <strong>For Code/Structured Data:</strong><br>
                • Chunking: Fixed Size<br>
                • Embedding: all-MiniLM-L6-v2 (Fast)
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script>
    // =====================================
    // REQUIREMENTS WORKBENCH JAVASCRIPT
    // =====================================

    // Requirements workbench state
    window.requirementsState = window.requirementsState || {
      initialized: false,
      requirements: [],
      currentPage: 1,
      pageSize: 50,
      totalItems: 0,
      filters: {
        search: '',
        requirement_type: '',
        state: '',
        priority: '',
        verification_status: ''
      },
      sorting: {
        sort_by: 'created_at',
        sort_order: 'desc'
      },
      selectedRequirement: null
    };

    // Simple inline markdown renderer for requirements text
    function renderInlineMarkdown(text) {
      if (!text) return '';

      // Escape HTML first
      let rendered = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');

      // Bold: **text** or __text__
      rendered = rendered.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
      rendered = rendered.replace(/__(.+?)__/g, '<strong>$1</strong>');

      // Italic: *text* or _text_ (but not within underscores in words)
      rendered = rendered.replace(/\*(.+?)\*/g, '<em>$1</em>');
      rendered = rendered.replace(/(?<!\w)_(.+?)_(?!\w)/g, '<em>$1</em>');

      // Code: `text`
      rendered = rendered.replace(/`(.+?)`/g, '<code style="background:var(--panel-2);padding:2px 4px;border-radius:3px;font-family:monospace;font-size:0.9em;">$1</code>');

      // Links: [text](url)
      rendered = rendered.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2" target="_blank" style="color:var(--primary);">$1</a>');

      return rendered;
    }

    // Initialize requirements workbench
    window.initializeRequirementsWorkbench = function () {
      if (window.requirementsState.initialized) {
        window.loadRequirements();
        return;
      }

      window.requirementsState.initialized = true;

      console.log('📋 Initializing Requirements Workbench...');

      // Initialize event handlers
      initRequirementsEventHandlers();

      // Load requirements for current project
      window.loadRequirements();
    }

    // Initialize all event handlers for requirements workbench
    function initRequirementsEventHandlers() {
      // Extract from document button
      const extractBtn = document.getElementById('reqExtractBtn');
      if (extractBtn) {
        extractBtn.onclick = () => showExtractRequirementsModal();
      }

      // Create new requirement button
      const createBtn = document.getElementById('reqCreateBtn');
      if (createBtn) {
        createBtn.onclick = () => showCreateRequirementModal();
      }

      // Import requirements button
      const importBtn = document.getElementById('reqImportBtn');
      if (importBtn) {
        importBtn.onclick = () => showImportRequirementsModal();
      }

      // Search input with debouncing
      const searchInput = document.getElementById('reqSearchInput');
      if (searchInput) {
        let searchTimeout;
        searchInput.addEventListener('input', (e) => {
          clearTimeout(searchTimeout);
          searchTimeout = setTimeout(() => {
            requirementsState.filters.search = e.target.value;
            requirementsState.currentPage = 1; // Reset to first page
            loadRequirements();
          }, 500); // 500ms debounce
        });
      }

      // Filter dropdowns
      const typeFilter = document.getElementById('reqTypeFilter');
      if (typeFilter) {
        typeFilter.addEventListener('change', (e) => {
          requirementsState.filters.requirement_type = e.target.value;
          requirementsState.currentPage = 1;
          loadRequirements();
        });
      }

      const stateFilter = document.getElementById('reqStateFilter');
      if (stateFilter) {
        stateFilter.addEventListener('change', (e) => {
          requirementsState.filters.state = e.target.value;
          requirementsState.currentPage = 1;
          loadRequirements();
        });
      }

      const priorityFilter = document.getElementById('reqPriorityFilter');
      if (priorityFilter) {
        priorityFilter.addEventListener('change', (e) => {
          requirementsState.filters.priority = e.target.value;
          requirementsState.currentPage = 1;
          loadRequirements();
        });
      }

      // Clear filters button
      const clearFiltersBtn = document.getElementById('reqClearFilters');
      if (clearFiltersBtn) {
        clearFiltersBtn.onclick = () => {
          // Reset all filter values
          requirementsState.filters = {
            search: '',
            requirement_type: '',
            state: '',
            priority: '',
            verification_status: ''
          };

          // Reset UI elements
          if (searchInput) searchInput.value = '';
          if (typeFilter) typeFilter.value = '';
          if (stateFilter) stateFilter.value = '';
          if (priorityFilter) priorityFilter.value = '';

          // Reload data
          requirementsState.currentPage = 1;
          loadRequirements();
        };
      }

      // Refresh button
      const refreshBtn = document.getElementById('reqRefreshBtn');
      if (refreshBtn) {
        refreshBtn.onclick = () => loadRequirements();
      }

      // Details panel handlers
      const closeDetailsBtn = document.getElementById('reqCloseDetails');
      if (closeDetailsBtn) {
        closeDetailsBtn.onclick = () => hideRequirementDetails();
      }

      const dasReviewBtn = document.getElementById('reqDASReviewBtn');
      if (dasReviewBtn) {
        dasReviewBtn.onclick = () => startDASReview();
      }

      const editBtn = document.getElementById('reqEditBtn');
      if (editBtn) {
        editBtn.onclick = () => editSelectedRequirement();
      }

      const publishBtn = document.getElementById('reqPublishBtn');
      if (publishBtn) {
        publishBtn.onclick = () => {
          if (requirementsState.selectedRequirement) {
            publishRequirement(requirementsState.selectedRequirement.requirement_id);
          }
        };
      }

      const unpublishBtn = document.getElementById('reqUnpublishBtn');
      if (unpublishBtn) {
        unpublishBtn.onclick = () => {
          if (requirementsState.selectedRequirement) {
            const confirmed = confirm(`Are you sure you want to unpublish "${requirementsState.selectedRequirement.requirement_identifier}"?\n\nThis will revert the requirement to "approved" state.`);
            if (confirmed) {
              unpublishRequirement(requirementsState.selectedRequirement.requirement_id);
            }
          }
        };
      }

      const unimportBtn = document.getElementById('reqUnimportBtn');
      if (unimportBtn) {
        unimportBtn.onclick = () => {
          if (requirementsState.selectedRequirement) {
            const req = requirementsState.selectedRequirement;
            const sourceInfo = req.source_namespace_path ?
              `\n\nSource: ${req.source_namespace_path}` : '';

            const confirmed = confirm(
              `Are you sure you want to un-import "${req.requirement_identifier}"?` +
              sourceInfo +
              `\n\nThis will permanently remove the imported requirement from this project. The original requirement in the source project will remain unchanged.`
            );

            if (confirmed) {
              unimportRequirement(req.requirement_id);
            }
          }
        };
      }

      const batchPublishBtn = document.getElementById('reqBatchPublishBtn');
      if (batchPublishBtn) {
        batchPublishBtn.onclick = () => batchPublishRequirements();
      }
    }

    // Load requirements from API
    window.loadRequirements = async function () {
      const projectId = localStorage.getItem('active_project_id');

      if (!projectId) {
        updateRequirementsTable([], 0);
        return;
      }

      // Show loading state
      const container = document.getElementById('requirementsTableContainer');

      if (container) {
        container.innerHTML = `
      <div style="text-align:center; padding:40px; color:var(--muted-color);">
        <div style="animation: spin 1s linear infinite; width:24px; height:24px; margin:0 auto 12px;">⚙️</div>
        Loading requirements...
      </div>
    `;
      }

      try {
        // Build query parameters
        const params = new URLSearchParams({
          page: requirementsState.currentPage.toString(),
          page_size: requirementsState.pageSize.toString(),
          sort_by: requirementsState.sorting.sort_by,
          sort_order: requirementsState.sorting.sort_order
        });

        // Add filters
        Object.entries(requirementsState.filters).forEach(([key, value]) => {
          if (value) {
            params.append(key, value);
          }
        });

        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/requirements?${params}`);

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
        }

        const result = await response.json();
        updateRequirementsTable(result.requirements, result.pagination.total_items, result.pagination);

      } catch (error) {
        console.error('Error loading requirements:', error);

        // Show error state
        if (container) {
          container.innerHTML = `
        <div style="text-align:center; padding:40px; color:var(--error-color);">
          <div style="margin-bottom:12px;">❌</div>
          Error loading requirements: ${error.message}
          <div style="margin-top:12px;">
            <button onclick="loadRequirements()" class="btn btn-sm">Retry</button>
          </div>
        </div>
      `;
        }
      }
    }

    // Update requirements table with data
    function updateRequirementsTable(requirements, totalItems, pagination = null) {
      requirementsState.requirements = requirements;
      requirementsState.totalItems = totalItems;

      // Update statistics
      const statsEl = document.getElementById('reqTableStats');
      if (statsEl) {
        if (pagination) {
          statsEl.textContent = `${totalItems} requirements (page ${pagination.page} of ${pagination.total_pages})`;
        } else {
          statsEl.textContent = `${requirements.length} requirements`;
        }
      }

      // Generate table HTML
      const container = document.getElementById('requirementsTableContainer');
      if (!container) return;

      if (requirements.length === 0) {
        // Check if we have active filters
        const hasActiveFilters = requirementsState.filters.search ||
          requirementsState.filters.requirement_type ||
          requirementsState.filters.state ||
          requirementsState.filters.priority ||
          requirementsState.filters.verification_status;

        if (hasActiveFilters) {
          // No results due to filters
          container.innerHTML = `
            <div style="text-align:center; padding:40px; color:var(--muted-color);">
              <div style="margin-bottom:12px;">🔍</div>
              <div style="font-weight:600; margin-bottom:8px;">No matching requirements</div>
              <div style="font-size:12px; margin-bottom:16px;">Try adjusting your filters or search criteria</div>
              <button onclick="document.getElementById('reqClearFilters').click()" class="btn btn-sm">Clear Filters</button>
            </div>
          `;
        } else {
          // No requirements exist at all
          container.innerHTML = `
            <div style="text-align:center; padding:40px; color:var(--muted-color);">
              <div style="margin-bottom:12px;">📋</div>
              No requirements found.
              <div style="margin-top:12px;">
                <button onclick="document.getElementById('reqExtractBtn').click()" class="btn btn-sm">Extract from Document</button>
                <button onclick="document.getElementById('reqCreateBtn').click()" class="btn btn-sm">Create Manually</button>
              </div>
            </div>
          `;
        }
        return;
      }

      // Build sortable table
      const tableHtml = `
    <table style="width:100%; border-collapse:separate; border-spacing:0 4px;">
      <thead>
        <tr style="background:var(--panel-2);">
          <th style="padding:8px; text-align:center; width:40px; border-radius:6px 0 0 6px;">
            <input type="checkbox" id="selectAllRequirements" onchange="toggleSelectAllRequirements()" 
                   title="Select all requirements" />
          </th>
          <th style="padding:8px; text-align:left; cursor:pointer;" 
              onclick="sortRequirements('requirement_identifier')">
            ID ${getSortIndicator('requirement_identifier')}
          </th>
          <th style="padding:8px; text-align:left; cursor:pointer;" 
              onclick="sortRequirements('requirement_title')">
            Title ${getSortIndicator('requirement_title')}
          </th>
          <th style="padding:8px; text-align:left; cursor:pointer;" 
              onclick="sortRequirements('requirement_type')">
            Type ${getSortIndicator('requirement_type')}
          </th>
          <th style="padding:8px; text-align:left; cursor:pointer;" 
              onclick="sortRequirements('priority')">
            Priority ${getSortIndicator('priority')}
          </th>
          <th style="padding:8px; text-align:left; cursor:pointer;" 
              onclick="sortRequirements('state')">
            Status ${getSortIndicator('state')}
          </th>
          <th style="padding:8px; text-align:left; cursor:pointer;" 
              onclick="sortRequirements('verification_status')">
            Verification ${getSortIndicator('verification_status')}
          </th>
          <th style="padding:8px; text-align:center;">Confidence</th>
          <th style="padding:8px; text-align:right; border-radius:0 6px 6px 0;">Actions</th>
        </tr>
      </thead>
      <tbody>
        ${requirements.map(req => generateRequirementRow(req)).join('')}
      </tbody>
    </table>
  `;

      container.innerHTML = tableHtml;

      // Add pagination if needed
      if (pagination && pagination.total_pages > 1) {
        container.innerHTML += generatePaginationControls(pagination);
      }
    }

    // Generate HTML for a single requirement row
    function generateRequirementRow(req) {
      const priorityColors = {
        critical: '#ef4444',
        high: '#f97316',
        medium: '#eab308',
        low: '#22c55e'
      };

      const stateColors = {
        draft: '#6b7280',
        review: '#3b82f6',
        approved: '#10b981',
        published: '#8b5cf6',
        imported: '#06b6d4',
        deprecated: '#ef4444',
        cancelled: '#9ca3af'
      };

      const typeColors = {
        functional: '#3b82f6',
        performance: '#f97316',
        safety: '#ef4444',
        security: '#dc2626',
        interface: '#8b5cf6',
        non_functional: '#6b7280'
      };

      const confidenceColor = req.extraction_confidence >= 0.8 ? '#10b981' :
        req.extraction_confidence >= 0.6 ? '#eab308' : '#ef4444';

      return `
    <tr style="background:${(req.state === 'imported' || req.is_immutable) ? '#2a2f3a' : 'var(--panel)'}; border:1px solid var(--border); border-radius:6px; cursor:pointer;"
        onclick="selectRequirement('${req.requirement_id}')"
        onmouseover="this.style.background='${(req.state === 'imported' || req.is_immutable) ? '#323946' : 'var(--panel-2)'}'"
        onmouseout="this.style.background='${(req.state === 'imported' || req.is_immutable) ? '#2a2f3a' : 'var(--panel)'}'">
      <td style="padding:8px; text-align:center;">
        <input type="checkbox" class="requirement-checkbox" value="${req.requirement_id}" 
               data-state="${req.state}" onchange="updateSelectedCount(); event.stopPropagation();" />
      </td>
      <td style="padding:8px; font-weight:600; color:var(--accent);">
        ${req.state === 'imported' ? '<span style="color:#06b6d4; margin-right:4px;" title="Imported Requirement"><svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd"/></svg></span>' : ''}
        ${req.requirement_identifier}
        ${req.is_immutable ? '<span style="color:#6b7280; margin-left:4px;" title="Read-only"><svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"/></svg></span>' : ''}
      </td>
      <td style="padding:8px; max-width:300px;">
        <div style="font-weight:500; margin-bottom:4px;">
          ${renderInlineMarkdown(req.requirement_title || req.requirement_text.substring(0, 80) + '...')}
        </div>
        <div style="font-size:11px; color:var(--muted-color); max-width:300px; overflow:hidden; text-overflow:ellipsis;">
          ${renderInlineMarkdown(req.requirement_text.substring(0, 120))}...
        </div>
      </td>
      <td style="padding:8px;">
        <span style="background:${typeColors[req.requirement_type] || '#6b7280'}; 
                     color:white; padding:2px 6px; border-radius:4px; font-size:11px; font-weight:500;">
          ${req.requirement_type}
        </span>
      </td>
      <td style="padding:8px;">
        <span style="background:${priorityColors[req.priority] || '#6b7280'}; 
                     color:white; padding:2px 6px; border-radius:4px; font-size:11px; font-weight:500;">
          ${req.priority}
        </span>
      </td>
      <td style="padding:8px;">
        <span style="background:${stateColors[req.state] || '#6b7280'}; 
                     color:white; padding:2px 6px; border-radius:4px; font-size:11px; font-weight:500;">
          ${req.state}
        </span>
      </td>
      <td style="padding:8px;">
        <span style="color:${req.verification_status === 'passed' ? '#10b981' :
          req.verification_status === 'failed' ? '#ef4444' :
            req.verification_status === 'in_progress' ? '#3b82f6' : '#6b7280'}; 
                     font-size:11px; font-weight:500;">
          ${req.verification_status?.replace('_', ' ') || 'not started'}
        </span>
      </td>
      <td style="padding:8px; text-align:center;">
        ${req.extraction_confidence ?
          `<span style="color:${confidenceColor}; font-size:11px; font-weight:600;">
             ${Math.round(req.extraction_confidence * 100)}%
           </span>` :
          `<span style="color:var(--muted-color); font-size:11px;">manual</span>`
        }
      </td>
      <td style="padding:8px; text-align:right;">
        ${req.state === 'imported' || req.is_immutable ?
          `<span style="color:var(--muted-color); font-size:10px; font-style:italic;">Read-only</span>` :
          `<button onclick="event.stopPropagation(); editRequirement('${req.requirement_id}')" 
                  class="btn btn-sm" style="font-size:10px; padding:4px 8px;">
            Edit
          </button>
          <button onclick="event.stopPropagation(); requestDASReview('${req.requirement_id}')" 
                  class="btn btn-primary btn-sm" style="font-size:10px; padding:4px 8px; margin-left:4px;">
            DAS Review
          </button>`
        }
      </td>
    </tr>
  `;
    }

    // Generate pagination controls
    function generatePaginationControls(pagination) {
      const { page, total_pages, total_items } = pagination;

      if (total_pages <= 1) return '';

      let paginationHtml = `
    <div style="display:flex; justify-content:between; align-items:center; margin-top:12px; padding:12px; background:var(--panel-2); border-radius:6px;">
      <div style="font-size:12px; color:var(--muted-color);">
        Page ${page} of ${total_pages} (${total_items} total)
      </div>
      <div style="display:flex; gap:4px;">
  `;

      // Previous button
      if (page > 1) {
        paginationHtml += `<button onclick="goToPage(${page - 1})" class="btn btn-sm">Previous</button>`;
      }

      // Page numbers (show current page and a few around it)
      const startPage = Math.max(1, page - 2);
      const endPage = Math.min(total_pages, page + 2);

      for (let p = startPage; p <= endPage; p++) {
        if (p === page) {
          paginationHtml += `<button class="btn btn-sm btn-primary" disabled>${p}</button>`;
        } else {
          paginationHtml += `<button onclick="goToPage(${p})" class="btn btn-sm">${p}</button>`;
        }
      }

      // Next button
      if (page < total_pages) {
        paginationHtml += `<button onclick="goToPage(${page + 1})" class="btn btn-sm">Next</button>`;
      }

      paginationHtml += `
      </div>
    </div>
  `;

      return paginationHtml;
    }

    // Get sort indicator for column headers
    function getSortIndicator(column) {
      if (requirementsState.sorting.sort_by !== column) {
        return '<span style="color:var(--muted-color);">⇅</span>';
      }
      return requirementsState.sorting.sort_order === 'asc' ?
        '<span style="color:var(--accent);">↑</span>' :
        '<span style="color:var(--accent);">↓</span>';
    }

    // Sort requirements by column
    function sortRequirements(column) {
      if (requirementsState.sorting.sort_by === column) {
        // Toggle sort direction
        requirementsState.sorting.sort_order =
          requirementsState.sorting.sort_order === 'asc' ? 'desc' : 'asc';
      } else {
        // New column, default to ascending
        requirementsState.sorting.sort_by = column;
        requirementsState.sorting.sort_order = 'asc';
      }

      requirementsState.currentPage = 1; // Reset to first page
      loadRequirements();
    }

    // Go to specific page
    function goToPage(pageNum) {
      requirementsState.currentPage = pageNum;
      loadRequirements();
    }

    // Select a requirement and show details
    function selectRequirement(requirementId) {
      const requirement = requirementsState.requirements.find(r => r.requirement_id === requirementId);
      if (!requirement) return;

      requirementsState.selectedRequirement = requirement;
      showRequirementDetails(requirement);
    }

    // Show requirement details panel
    function showRequirementDetails(requirement) {
      const panel = document.getElementById('requirementDetailsPanel');
      const content = document.getElementById('requirementDetailsContent');

      if (!panel || !content) return;

      // Generate details HTML
      const detailsHtml = `
    <div style="display:grid; gap:16px;">
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:16px;">
        <div>
          <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:4px;">IDENTIFIER</div>
          <div style="font-weight:600; color:var(--accent);">${requirement.requirement_identifier}</div>
        </div>
        <div>
          <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:4px;">TYPE</div>
          <div>${requirement.requirement_type}</div>
        </div>
        <div>
          <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:4px;">PRIORITY</div>
          <div>${requirement.priority}</div>
        </div>
        <div>
          <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:4px;">STATUS</div>
          <div>${requirement.state}</div>
        </div>
      </div>

      <div>
        <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:8px;">REQUIREMENT TEXT</div>
        <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px; line-height:1.5;" class="das-markdown">
          ${marked.parse(requirement.requirement_text || '')}
        </div>
      </div>

      ${requirement.requirement_rationale ? `
        <div>
          <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:8px;">RATIONALE</div>
          <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px; line-height:1.5;" class="das-markdown">
            ${marked.parse(requirement.requirement_rationale)}
          </div>
        </div>
      ` : ''}

      ${requirement.verification_criteria ? `
        <div>
          <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:8px;">VERIFICATION CRITERIA</div>
          <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px; line-height:1.5;" class="das-markdown">
            ${marked.parse(requirement.verification_criteria)}
          </div>
        </div>
      ` : ''}

      <div id="requirementConstraints-${requirement.requirement_id}">
        <!-- Constraints will be loaded here -->
      </div>

      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:16px; font-size:12px; color:var(--muted-color);">
        <div>
          Created: ${new Date(requirement.created_at).toLocaleString()}<br/>
          ${requirement.state === 'imported' ?
          `<span style="color:#06b6d4;"><svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor" style="margin-right:4px;"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd"/></svg>Imported from source project</span>` :
          (requirement.extraction_confidence ? `Extraction Confidence: ${Math.round(requirement.extraction_confidence * 100)}%` : 'Manual Entry')
        }
        </div>
        <div>
          Updated: ${new Date(requirement.updated_at).toLocaleString()}<br/>
          Version: ${requirement.version || 1}
          ${requirement.is_immutable ? '<br/><span style="color:#f59e0b;"><svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor" style="margin-right:4px;"><path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"/></svg>Read-only (Imported)</span>' : ''}
        </div>
      </div>

      ${requirement.state === 'imported' && (requirement.source_namespace_path || requirement.source_project_iri) ? `
        <div style="margin-top:16px; padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px; border-left:3px solid #06b6d4;">
          <div style="font-size:11px; color:var(--accent); font-weight:600; margin-bottom:8px; display:flex; align-items:center; gap:4px;">
            <svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd"/></svg>SOURCE PROJECT TRACEABILITY
          </div>
          <div style="font-size:12px; color:var(--text); line-height:1.4;">
            ${requirement.source_namespace_path ? `<strong>Namespace:</strong> ${requirement.source_namespace_path}<br/>` : ''}
            ${requirement.source_project_iri ? `<strong>Project IRI:</strong> <code style="background:var(--bg); padding:2px 4px; border-radius:3px; font-family:monospace; font-size:11px;">${requirement.source_project_iri}</code><br/>` : ''}
            <strong>Source Requirement ID:</strong> ${requirement.source_requirement_id || requirement.requirement_id}<br/>
            ${requirement.source_namespace_prefix ? `<strong>Namespace Prefix:</strong> ${requirement.source_namespace_prefix}` : ''}
          </div>
          <div style="margin-top:6px; font-size:11px; color:var(--muted-color); font-style:italic;">
            This requirement was imported and cannot be modified. Changes must be made in the source project.
          </div>
        </div>
      ` : ''}
    </div>
  `;

      content.innerHTML = detailsHtml;
      panel.style.display = 'block';

      // Load constraints for this requirement
      loadRequirementConstraintsForDetails(requirement.requirement_id);

      // Load notes for this requirement
      loadRequirementNotes(requirement.requirement_id);

      // Update publish button visibility based on requirement state
      updatePublishButtonVisibility(requirement);
    }

    // Hide requirement details panel
    function hideRequirementDetails() {
      const panel = document.getElementById('requirementDetailsPanel');
      if (panel) {
        panel.style.display = 'none';
      }
      requirementsState.selectedRequirement = null;
    }

    // Load notes for a requirement
    async function loadRequirementNotes(requirementId) {
      const projectId = localStorage.getItem('active_project_id');
      if (!projectId) return;

      try {
        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/requirements/${requirementId}/notes`);

        if (!response.ok) {
          console.warn('Failed to load notes:', response.statusText);
          return;
        }

        const notes = await response.json();

        // Add notes section to details panel if notes exist
        if (notes.length > 0) {
          const content = document.getElementById('requirementDetailsContent');
          if (content) {
            const notesHtml = `
          <div style="margin-top:16px; padding-top:16px; border-top:1px solid var(--border);">
            <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:8px;">
              COLLABORATIVE NOTES (${notes.length})
            </div>
            ${notes.map(note => `
              <div style="margin-bottom:12px; padding:8px; background:var(--panel-2); border-radius:4px;">
                <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                  <span style="font-size:11px; color:var(--accent); font-weight:600;">${note.note_type}</span>
                  <span style="font-size:11px; color:var(--muted-color);">
                    ${new Date(note.created_at).toLocaleString()} by ${note.created_by_name || 'Unknown'}
                  </span>
                </div>
                <div style="font-size:12px; line-height:1.4;">${note.note_text}</div>
              </div>
            `).join('')}
          </div>
        `;
            content.innerHTML += notesHtml;
          }
        }

      } catch (error) {
        console.error('Error loading requirement notes:', error);
      }
    }

    // Start DAS review for selected requirement
    async function startDASReview() {
      const requirement = requirementsState.selectedRequirement;
      if (!requirement) {
        alert('No requirement selected');
        return;
      }

      const projectId = localStorage.getItem('active_project_id');
      if (!projectId) return;

      // Show loading state
      const dasBtn = document.getElementById('reqDASReviewBtn');
      if (dasBtn) {
        dasBtn.disabled = true;
        dasBtn.innerHTML = `
      <div style="animation: spin 1s linear infinite; width:14px; height:14px; margin-right:4px;">⚙️</div>
      Reviewing...
    `;
      }

      try {
        const response = await authenticatedFetch(
          `/api/requirements/projects/${projectId}/requirements/${requirement.requirement_id}/das-review`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              review_type: 'improvement',
              include_context: true,
              focus_areas: ['clarity', 'testability', 'completeness']
            })
          }
        );

        if (!response.ok) {
          throw new Error(`DAS review failed: ${response.statusText}`);
        }

        const reviewResult = await response.json();

        // Show DAS review in a modal
        showDASReviewModal(reviewResult);

      } catch (error) {
        console.error('Error requesting DAS review:', error);
        alert(`DAS review failed: ${error.message}`);
      } finally {
        // Restore button
        if (dasBtn) {
          dasBtn.disabled = false;
          dasBtn.innerHTML = `
        <svg style="width:14px; height:14px; margin-right:4px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M9 11l3 3L22 4"/>
          <path d="M21 12c-.12 2.51-.61 4.92-1.44 7.08"/>
          <path d="M16 19.35l-.35.35c-1.96 1.96-5.14 1.96-7.1 0l-.35-.35"/>
        </svg>
        DAS Review
      `;
        }
      }
    }

    // Show DAS review results in a modal
    function showDASReviewModal(reviewResult) {
      // Create modal overlay
      const modal = document.createElement('div');
      modal.style.cssText = `
    position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
    background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;
  `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: var(--panel); border: 1px solid var(--border); border-radius: 8px; 
    width: 90%; max-width: 800px; max-height: 80vh; overflow: auto; padding: 20px;
  `;

      modalContent.innerHTML = `
    <div style="display:flex; justify-content:between; align-items:center; margin-bottom:16px;">
      <h3 style="margin:0;">DAS Requirement Review</h3>
      <button onclick="this.closest('.das-modal').remove()" class="btn" style="padding:4px 8px;">
        <svg style="width:16px; height:16px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>

    <div style="margin-bottom:16px;">
      <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:8px;">ORIGINAL REQUIREMENT</div>
      <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px;" class="das-markdown">
        ${marked.parse(requirementsState.selectedRequirement.requirement_text)}
      </div>
    </div>

    <div style="margin-bottom:16px;">
      <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:8px;">DAS ANALYSIS & SUGGESTIONS</div>
      <div style="padding:12px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px; line-height:1.5;" class="das-markdown">
        ${marked.parse(reviewResult.das_response || '')}
      </div>
    </div>

    ${reviewResult.suggestions && reviewResult.suggestions.length > 0 ? `
      <div style="margin-bottom:16px;">
        <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:8px;">KEY SUGGESTIONS</div>
        ${reviewResult.suggestions.map(suggestion => `
          <div style="padding:8px; margin-bottom:8px; background:var(--success-bg); border:1px solid var(--success); border-radius:4px; font-size:12px;">
            ${renderInlineMarkdown(suggestion)}
          </div>
        `).join('')}
      </div>
    ` : ''}

    <div style="display:flex; gap:8px; justify-content:flex-end;">
      <button onclick="this.closest('.das-modal').remove()" class="btn">Close</button>
      <button onclick="acceptDASReview('${reviewResult.review_id}')" class="btn btn-primary">Apply Suggestions</button>
    </div>
  `;

      modal.className = 'das-modal';
      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      // Close modal on outside click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }

    // Accept DAS review suggestions
    async function acceptDASReview(reviewId) {
      // For demo purposes, just show a success message
      toast('DAS suggestions accepted! (Implementation in progress)');

      // Close modal
      const modal = document.querySelector('.das-modal');
      if (modal) modal.remove();

      // Reload requirement details
      if (requirementsState.selectedRequirement) {
        showRequirementDetails(requirementsState.selectedRequirement);
      }
    }

    // Show extract requirements modal
    function showExtractRequirementsModal() {
      const projectId = localStorage.getItem('active_project_id');
      if (!projectId) {
        alert('Please select a project first');
        return;
      }

      // Create modal for document selection and extraction configuration
      const modal = document.createElement('div');
      modal.style.cssText = `
    position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
    background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;
  `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: var(--panel); border: 1px solid var(--border); border-radius: 8px; 
    width: 90%; max-width: 600px; padding: 20px;
  `;

      modalContent.innerHTML = `
    <div style="margin-bottom:16px;">
      <h3>Extract Requirements from Document</h3>
      <div class="muted">Select a document and configure extraction settings</div>
    </div>

    <div style="margin-bottom:16px;">
      <label style="display:block; font-weight:600; margin-bottom:8px;">Select Document:</label>
      <select id="extractDocumentSelect" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px;">
        <option value="">Loading documents...</option>
      </select>
    </div>

    <div style="margin-bottom:16px;">
      <label style="display:block; font-weight:600; margin-bottom:8px;">Job Name:</label>
      <input type="text" id="extractJobName" value="Requirements Extraction ${new Date().toISOString().slice(0, 16)}" 
             style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px;" />
    </div>

    <div style="margin-bottom:16px;">
      <label style="display:block; font-weight:600; margin-bottom:8px;">Minimum Confidence:</label>
      <input type="range" id="extractMinConfidence" min="0.5" max="1.0" step="0.05" value="0.7" 
             style="width:100%;" />
      <div style="display:flex; justify-content:space-between; font-size:12px; color:var(--muted-color);">
        <span>50%</span>
        <span id="confidenceDisplay">70%</span>
        <span>100%</span>
      </div>
    </div>

    <div style="margin-bottom:16px;">
      <label style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="extractConstraints" checked />
        Extract constraints (thresholds, objectives, KPCs, KPPs)
      </label>
    </div>

    <div style="display:flex; gap:8px; justify-content:flex-end;">
      <button onclick="this.closest('.extract-modal').remove()" class="btn">Cancel</button>
      <button onclick="startExtractionJob()" class="btn btn-primary">Start Extraction</button>
    </div>
  `;

      modal.className = 'extract-modal';
      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      // Load available documents
      loadDocumentsForExtraction();

      // Update confidence display
      const confidenceSlider = document.getElementById('extractMinConfidence');
      const confidenceDisplay = document.getElementById('confidenceDisplay');
      if (confidenceSlider && confidenceDisplay) {
        confidenceSlider.addEventListener('input', (e) => {
          confidenceDisplay.textContent = `${Math.round(e.target.value * 100)}%`;
        });
      }
    }

    // Load documents available for extraction
    async function loadDocumentsForExtraction() {
      const projectId = localStorage.getItem('active_project_id');
      if (!projectId) return;

      try {
        const response = await authenticatedFetch(`/api/files?project_id=${projectId}`);
        if (!response.ok) throw new Error('Failed to load documents');

        const result = await response.json();
        const files = result.files || [];

        const select = document.getElementById('extractDocumentSelect');
        if (select) {
          if (files.length === 0) {
            select.innerHTML = '<option value="">No documents available</option>';
          } else {
            select.innerHTML = [
              '<option value="">Select a document...</option>',
              ...files.map(file => `<option value="${file.file_id}">${file.filename} (${file.content_type || 'unknown type'})</option>`)
            ].join('');
          }
        }
      } catch (error) {
        console.error('Error loading documents:', error);
        const select = document.getElementById('extractDocumentSelect');
        if (select) {
          select.innerHTML = '<option value="">Error loading documents</option>';
        }
      }
    }

    // Start extraction job
    async function startExtractionJob() {
      const documentId = document.getElementById('extractDocumentSelect').value;
      const jobName = document.getElementById('extractJobName').value;
      const minConfidence = parseFloat(document.getElementById('extractMinConfidence').value);
      const extractConstraints = document.getElementById('extractConstraints').checked;

      if (!documentId) {
        alert('Please select a document');
        return;
      }

      if (!jobName.trim()) {
        alert('Please enter a job name');
        return;
      }

      const projectId = localStorage.getItem('active_project_id');
      if (!projectId) return;

      try {
        // Show progress
        const startBtn = document.querySelector('.extract-modal button[onclick="startExtractionJob()"]');
        if (startBtn) {
          startBtn.disabled = true;
          startBtn.textContent = 'Extracting...';
        }

        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/extract`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            job_name: jobName,
            source_document_id: documentId,
            min_confidence: minConfidence,
            extract_constraints: extractConstraints
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Extraction failed (${response.status}): ${errorText}`);
        }

        const result = await response.json();

        // Close modal
        const modal = document.querySelector('.extract-modal');
        if (modal) modal.remove();

        // Show success message
        toast(`Extraction completed! Created ${result.requirements_created} requirements and ${result.constraints_created} constraints.`);

        // Reload requirements table
        loadRequirements();

      } catch (error) {
        console.error('Error starting extraction job:', error);
        alert(`Extraction failed: ${error.message}`);

        // Restore button
        const startBtn = document.querySelector('.extract-modal button[onclick="startExtractionJob()"]');
        if (startBtn) {
          startBtn.disabled = false;
          startBtn.textContent = 'Start Extraction';
        }
      }
    }

    // Show create requirement modal
    function showCreateRequirementModal() {
      const projectId = localStorage.getItem('active_project_id');
      if (!projectId) {
        alert('Please select a project first');
        return;
      }

      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
        background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;
      `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
        background: var(--panel); border: 1px solid var(--border); border-radius: 8px; 
        width: 90%; max-width: 700px; max-height: 90vh; overflow: auto; padding: 20px;
      `;

      modalContent.innerHTML = `
        <div style="display:flex; justify-content:between; align-items:center; margin-bottom:20px;">
          <h3 style="margin:0; color:var(--accent);">Create New Requirement</h3>
          <button onclick="this.closest('.create-req-modal').remove()" class="btn" style="padding:4px 8px;">
            <svg style="width:16px; height:16px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>

        <form id="createRequirementForm" style="display:grid; gap:16px;">
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">TITLE *</label>
              <input type="text" id="newReqTitle" value="" 
                     style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text);" 
                     maxlength="500" placeholder="Enter a clear, concise title..." required>
            </div>
            
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">TYPE *</label>
              <select id="newReqType" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text);" required>
                <option value="">Select type...</option>
                <option value="functional" selected>Functional</option>
                <option value="non_functional">Non-Functional</option>
                <option value="performance">Performance</option>
                <option value="safety">Safety</option>
                <option value="security">Security</option>
                <option value="interface">Interface</option>
                <option value="operational">Operational</option>
                <option value="design">Design</option>
                <option value="implementation">Implementation</option>
              </select>
            </div>
          </div>

          <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:16px;">
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">PRIORITY</label>
              <select id="newReqPriority" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text);">
                <option value="critical">Critical</option>
                <option value="high">High</option>
                <option value="medium" selected>Medium</option>
                <option value="low">Low</option>
              </select>
            </div>
            
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">STATUS</label>
              <select id="newReqState" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text);">
                <option value="draft" selected>Draft</option>
                <option value="review">Review</option>
                <option value="approved">Approved</option>
                <!-- Published state removed - use Publish button for proper workflow -->
              </select>
            </div>
            
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">VERIFICATION METHOD</label>
              <select id="newReqVerificationMethod" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text);">
                <option value="">Not specified</option>
                <option value="test">Test</option>
                <option value="analysis">Analysis</option>
                <option value="inspection">Inspection</option>
                <option value="demonstration">Demonstration</option>
                <option value="review">Review</option>
              </select>
            </div>
          </div>

          <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">CATEGORY</label>
              <input type="text" id="newReqCategory" value="" 
                     style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text);" 
                     placeholder="e.g. User Interface, Data Management">
            </div>
            
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">SUBCATEGORY</label>
              <input type="text" id="newReqSubcategory" value="" 
                     style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text);" 
                     placeholder="e.g. Login, Database Access">
            </div>
          </div>

          <div>
            <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">REQUIREMENT TEXT *</label>
            <textarea id="newReqText" rows="4" 
                      style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text); resize:vertical;" 
                      placeholder="The system SHALL... (use clear language with modal verbs)" required></textarea>
            <div style="font-size:11px; color:var(--muted-color); margin-top:4px;">
              💡 Tip: Use modal verbs like SHALL, MUST, WILL for mandatory requirements, SHOULD for recommended features
            </div>
          </div>

          <div>
            <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">RATIONALE</label>
            <textarea id="newReqRationale" rows="3" 
                      style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text); resize:vertical;" 
                      placeholder="Why is this requirement necessary? What business need does it address?"></textarea>
          </div>

          <div>
            <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">VERIFICATION CRITERIA</label>
            <textarea id="newReqVerificationCriteria" rows="2" 
                      style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text); resize:vertical;" 
                      placeholder="How will this requirement be verified or tested?"></textarea>
          </div>

          <div>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <label style="font-weight:600; font-size:12px; color:var(--muted-color);">CONSTRAINTS</label>
              <div style="display:flex; gap:8px;">
                <button type="button" onclick="addNewConstraint()" class="btn btn-sm" style="font-size:11px; padding:4px 8px;">
                  <svg style="width:12px; height:12px; margin-right:4px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 5v14M5 12h14"/>
                  </svg>
                  Add Constraint
                </button>
                <button type="button" onclick="askDASForConstraints('create')" class="btn btn-sm" style="font-size:11px; padding:4px 8px; background:var(--primary); color:white; opacity:0.6;" disabled title="Coming soon!">
                  <svg style="width:12px; height:12px; margin-right:4px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 11l3 3L22 4"/>
                    <path d="M21 12c-.12 2.51-.61 4.92-1.44 7.08"/>
                  </svg>
                  Ask DAS
                </button>
              </div>
            </div>
            <div id="newReqConstraintsContainer" style="min-height:40px; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2);">
              <div style="text-align:center; color:var(--muted-color); font-size:11px; padding:16px;">
                No constraints defined. Click "Add Constraint" to add manual constraints or "Ask DAS" to auto-extract from requirement text.
              </div>
            </div>
          </div>

          <div style="display:flex; gap:8px; justify-content:flex-end; padding-top:12px; border-top:1px solid var(--border);">
            <button type="button" onclick="this.closest('.create-req-modal').remove()" class="btn">Cancel</button>
            <button type="submit" class="btn btn-primary">Create Requirement</button>
          </div>
        </form>
      `;

      modal.className = 'create-req-modal';
      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      // Initialize constraints for create modal
      window.modalConstraints = [];
      const constraintsContainer = document.getElementById('newReqConstraintsContainer');
      renderConstraints(constraintsContainer, 'create');

      // Handle form submission
      const form = document.getElementById('createRequirementForm');
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        saveNewRequirement();
      });

      // Focus on title field
      setTimeout(() => {
        document.getElementById('newReqTitle').focus();
      }, 100);
    }

    // Show import requirements modal
    function showImportRequirementsModal() {
      console.log('🔥 SHOW_IMPORT_MODAL called');

      const projectId = localStorage.getItem('active_project_id');
      if (!projectId) {
        alert('Please select a project first');
        return;
      }

      console.log('🔥 Project ID:', projectId);

      const modal = document.createElement('div');
      modal.className = 'import-req-modal';
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
        background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;
      `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
        background: var(--panel); border: 1px solid var(--border); border-radius: 8px; 
        width: 90%; max-width: 900px; max-height: 90vh; overflow: auto; padding: 20px;
      `;

      modalContent.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
          <h3 style="margin:0; color:var(--accent);">Import Published Requirements</h3>
          <button onclick="this.closest('.import-req-modal').remove()" class="btn" style="padding:4px 8px;">
            <svg style="width:16px; height:16px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>

        <div style="margin-bottom:16px; padding:12px; background:var(--panel-2); border-radius:6px; border:1px solid var(--border);">
          <div style="color:var(--accent); font-weight:600; margin-bottom:4px;">📋 Import Requirements</div>
          <div style="color:var(--muted); font-size:13px;">
            Import published requirements from other projects. Imported requirements are read-only and maintain traceability to their source project.
          </div>
        </div>

        <div style="display:flex; gap:12px; align-items:center; margin-bottom:16px;">
          <label style="font-weight:600; color:var(--text);">Source Project:</label>
          <select id="sourceProjectSelect" style="flex:1; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text);">
            <option value="">Loading projects...</option>
          </select>
          <button id="refreshProjectsBtn" class="btn" style="padding:6px 12px;">
            <svg style="width:14px; height:14px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
              <path d="M21 3v5h-5"/>
              <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
              <path d="M3 21v-5h5"/>
            </svg>
            Refresh
          </button>
        </div>

        <div id="publishedRequirements" style="border:1px solid var(--border); border-radius:6px; min-height:300px; max-height:400px; overflow:auto; background:var(--bg);">
          <div style="padding:40px; text-align:center; color:var(--muted);">
            Select a source project to view published requirements
          </div>
        </div>

        <div style="margin-top:16px; display:flex; justify-content:space-between; align-items:center;">
          <div id="importSummary" style="color:var(--muted); font-size:13px;">
            No requirements selected
          </div>
          <div style="display:flex; gap:8px;">
            <button onclick="this.closest('.import-req-modal').remove()" class="btn">Cancel</button>
            <button id="importSelectedBtn" class="btn btn-primary" disabled>
              <svg style="width:14px; height:14px; margin-right:4px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 17l3-3 3 3"/>
                <path d="M6 14v7"/>
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
              </svg>
              Import Selected
            </button>
          </div>
        </div>
      `;

      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      // Initialize import modal
      console.log('🔥 About to initialize import modal');
      initializeImportModal();

      // Debug: Check if critical elements exist after initialization
      setTimeout(() => {
        console.log('🔥 POST-INIT DEBUG:');
        console.log('🔥 sourceProjectSelect exists:', !!document.getElementById('sourceProjectSelect'));
        console.log('🔥 publishedRequirements exists:', !!document.getElementById('publishedRequirements'));
        console.log('🔥 importSummary exists:', !!document.getElementById('importSummary'));
        console.log('🔥 importSelectedBtn exists:', !!document.getElementById('importSelectedBtn'));
        console.log('🔥 Global importModalSelectedRequirements:', typeof window.importModalSelectedRequirements, window.importModalSelectedRequirements);
      }, 100);
    }

    // Global variable for import modal
    let importModalSelectedRequirements = [];

    // Initialize import modal functionality
    function initializeImportModal() {
      importModalSelectedRequirements = [];

      // Load projects with published requirements
      loadProjectsWithPublishedRequirements();

      // Handle project selection
      document.getElementById('sourceProjectSelect').addEventListener('change', async (e) => {
        const projectId = e.target.value;
        if (projectId) {
          await loadPublishedRequirements(projectId);
        } else {
          clearPublishedRequirements();
        }
        updateImportSummary();
      });

      // Handle refresh button
      document.getElementById('refreshProjectsBtn').addEventListener('click', () => {
        loadProjectsWithPublishedRequirements();
      });

      // Handle import button
      document.getElementById('importSelectedBtn').addEventListener('click', async () => {
        await importSelectedRequirements();
      });

      // Load projects with published requirements
      async function loadProjectsWithPublishedRequirements() {
        try {
          const currentProjectId = localStorage.getItem('active_project_id');
          const response = await authenticatedFetch('/api/requirements/projects/published-summary');
          if (response.ok) {
            const projects = await response.json();
            const select = document.getElementById('sourceProjectSelect');
            select.innerHTML = '<option value="">Select source project...</option>';

            projects.forEach(project => {
              // Don't show current project as an option
              if (project.project_id !== currentProjectId) {
                const option = document.createElement('option');
                option.value = project.project_id;
                option.textContent = `${project.name} (${project.published_count} requirements)`;
                select.appendChild(option);
              }
            });
          } else {
            console.error('Failed to load projects with published requirements');
            toast('Failed to load projects', true);
          }
        } catch (error) {
          console.error('Error loading projects:', error);
          toast('Failed to load projects', true);
        }
      }

      // Load published requirements for selected project
      async function loadPublishedRequirements(projectId) {
        try {
          const currentProjectId = localStorage.getItem('active_project_id');
          // Use the new published endpoint with target project filtering
          const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/published-requirements?target_project_id=${currentProjectId}&limit=100`);
          if (response.ok) {
            const data = await response.json();
            displayPublishedRequirements(data.requirements || []);
          } else {
            console.error('Failed to load published requirements');
            toast('Failed to load published requirements', true);
          }
        } catch (error) {
          console.error('Error loading published requirements:', error);
          toast('Failed to load published requirements', true);
        }
      }

      // Display published requirements in table
      function displayPublishedRequirements(requirements) {
        const container = document.getElementById('publishedRequirements');
        importModalSelectedRequirements = [];

        if (!requirements || requirements.length === 0) {
          container.innerHTML = `
            <div style="padding:40px; text-align:center; color:var(--muted);">
              No published requirements found in selected project
            </div>
          `;
          return;
        }

        const tableHtml = `
          <table style="width:100%; border-collapse:separate; border-spacing:0;">
            <thead>
              <tr style="background:var(--panel-2); border-bottom:1px solid var(--border);">
                <th style="padding:8px; text-align:center; width:40px;">
                  <input type="checkbox" id="selectAllPublished" onchange="toggleSelectAllPublished()" />
                </th>
                <th style="padding:8px; text-align:left; font-weight:600; color:var(--text);">ID</th>
                <th style="padding:8px; text-align:left; font-weight:600; color:var(--text);">Title</th>
                <th style="padding:8px; text-align:left; font-weight:600; color:var(--text);">Type</th>
                <th style="padding:8px; text-align:left; font-weight:600; color:var(--text);">Priority</th>
                <th style="padding:8px; text-align:left; font-weight:600; color:var(--text);">Published</th>
              </tr>
            </thead>
            <tbody>
              ${requirements.map(req => `
                <tr style="border-bottom:1px solid var(--border); cursor:pointer;">
                  <td style="padding:8px; text-align:center;" onclick="event.stopPropagation();">
                    <input type="checkbox" class="req-checkbox" value="${req.requirement_id}" 
                           onchange="console.log('🔥 CHECKBOX CHANGE:', this.value, this.checked); updateRequirementSelection(); event.stopPropagation();" 
                           onclick="console.log('🔥 CHECKBOX CLICK:', this.value, this.checked); event.stopPropagation();" />
                  </td>
                  <td style="padding:8px; font-weight:600; color:var(--accent);">${req.requirement_identifier}</td>
                  <td style="padding:8px;">
                    <div style="font-weight:500; margin-bottom:2px;">${req.requirement_title || 'Untitled'}</div>
                    <div style="color:var(--muted); font-size:12px; max-width:400px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                      ${req.requirement_text ? req.requirement_text.substring(0, 100) + (req.requirement_text.length > 100 ? '...' : '') : ''}
                    </div>
                  </td>
                  <td style="padding:8px; text-transform:capitalize;">${req.requirement_type || 'functional'}</td>
                  <td style="padding:8px; text-transform:capitalize;">${req.priority || 'medium'}</td>
                  <td style="padding:8px; color:var(--muted); font-size:12px;">
                    ${req.published_at ? new Date(req.published_at).toLocaleDateString() : 'Unknown'}
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        `;

        container.innerHTML = tableHtml;

        // Add global functions for selection handling
        window.toggleSelectAllPublished = function () {
          const selectAll = document.getElementById('selectAllPublished');
          const checkboxes = document.querySelectorAll('.req-checkbox');
          checkboxes.forEach(cb => cb.checked = selectAll.checked);
          updateRequirementSelection();
        };

        window.toggleRequirementSelection = function (reqId) {
          const checkbox = document.querySelector(`input[value="${reqId}"]`);
          if (checkbox) {
            checkbox.checked = !checkbox.checked;
            updateRequirementSelection();
          }
        };

        window.updateRequirementSelection = function () {
          console.log('🔥 UPDATE_REQUIREMENT_SELECTION called');

          // Debug: Check what checkboxes exist and are checked
          const allCheckboxes = document.querySelectorAll('.req-checkbox');
          const checkedCheckboxes = document.querySelectorAll('.req-checkbox:checked');
          console.log('🔥 Total checkboxes found:', allCheckboxes.length);
          console.log('🔥 Checked checkboxes found:', checkedCheckboxes.length);

          // Log details of all checkboxes
          allCheckboxes.forEach((cb, i) => {
            console.log(`🔥 Checkbox ${i}: value=${cb.value}, checked=${cb.checked}`);
          });

          importModalSelectedRequirements = Array.from(checkedCheckboxes).map(cb => cb.value);
          console.log('🔥 Updated importModalSelectedRequirements:', importModalSelectedRequirements);

          updateImportSummary();

          const importBtn = document.getElementById('importSelectedBtn');
          if (importBtn) {
            importBtn.disabled = importModalSelectedRequirements.length === 0;
            console.log('🔥 Import button disabled:', importBtn.disabled);
          } else {
            console.log('🔥 ERROR: importSelectedBtn not found!');
          }

          // Update select all checkbox state
          const selectAll = document.getElementById('selectAllPublished');
          if (selectAll) {
            if (importModalSelectedRequirements.length === 0) {
              selectAll.indeterminate = false;
              selectAll.checked = false;
            } else if (importModalSelectedRequirements.length === allCheckboxes.length) {
              selectAll.indeterminate = false;
              selectAll.checked = true;
            } else {
              selectAll.indeterminate = true;
            }
            console.log('🔥 Select all state updated');
          } else {
            console.log('🔥 ERROR: selectAllPublished not found!');
          }
        };
      }

      // Clear published requirements display
      function clearPublishedRequirements() {
        document.getElementById('publishedRequirements').innerHTML = `
          <div style="padding:40px; text-align:center; color:var(--muted);">
            Select a source project to view published requirements
          </div>
        `;
        importModalSelectedRequirements = [];
      }

      // Update import summary
      function updateImportSummary() {
        console.log('🔥 UPDATE_IMPORT_SUMMARY called with:', importModalSelectedRequirements);
        const summary = document.getElementById('importSummary');
        if (summary) {
          if (importModalSelectedRequirements.length === 0) {
            summary.textContent = 'No requirements selected';
          } else {
            summary.textContent = `${importModalSelectedRequirements.length} requirement${importModalSelectedRequirements.length === 1 ? '' : 's'} selected for import`;
          }
          console.log('🔥 Summary updated to:', summary.textContent);
        } else {
          console.log('🔥 ERROR: importSummary element not found!');
        }
      }

      // Import selected requirements
      async function importSelectedRequirements() {
        if (importModalSelectedRequirements.length === 0) return;

        const currentProjectId = localStorage.getItem('active_project_id');
        const sourceProjectId = document.getElementById('sourceProjectSelect').value;

        try {
          const button = document.getElementById('importSelectedBtn');
          const originalText = button.innerHTML;
          button.disabled = true;
          button.innerHTML = '<svg style="width:14px; height:14px; margin-right:4px; animation:spin 1s linear infinite;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 2v4M12 18v4M4.22 4.22l2.83 2.83M16.95 16.95l2.83 2.83M2 12h4M18 12h4M4.22 19.78l2.83-2.83M16.95 7.05l2.83-2.83"/></svg>Importing...';

          const response = await authenticatedFetch(`/api/requirements/projects/${currentProjectId}/import`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              source_project_id: sourceProjectId,
              requirement_ids: importModalSelectedRequirements
            })
          });

          if (response.ok) {
            const result = await response.json();
            toast(`Successfully imported ${result.imported_count} requirement${result.imported_count === 1 ? '' : 's'}`, false);

            // Close modal and refresh requirements
            document.querySelector('.import-req-modal').remove();
            loadRequirements();
          } else {
            const error = await response.json();
            toast(`Import failed: ${error.detail || 'Unknown error'}`, true);
          }
        } catch (error) {
          console.error('Error importing requirements:', error);
          toast('Import failed due to network error', true);
        } finally {
          const button = document.getElementById('importSelectedBtn');
          if (button) {
            button.disabled = false;
            button.innerHTML = originalText;
          }
        }
      }
    }

    // Save new requirement
    async function saveNewRequirement() {
      const projectId = localStorage.getItem('active_project_id');
      if (!projectId) {
        alert('No project selected');
        return;
      }

      // Get form values
      const formData = {
        requirement_title: document.getElementById('newReqTitle').value.trim(),
        requirement_text: document.getElementById('newReqText').value.trim(),
        requirement_rationale: document.getElementById('newReqRationale').value.trim() || null,
        requirement_type: document.getElementById('newReqType').value,
        category: document.getElementById('newReqCategory').value.trim() || null,
        subcategory: document.getElementById('newReqSubcategory').value.trim() || null,
        priority: document.getElementById('newReqPriority').value,
        verification_method: document.getElementById('newReqVerificationMethod').value || null,
        verification_criteria: document.getElementById('newReqVerificationCriteria').value.trim() || null
      };

      // Validate required fields
      if (!formData.requirement_title) {
        alert('Title is required');
        document.getElementById('newReqTitle').focus();
        return;
      }
      if (!formData.requirement_text) {
        alert('Requirement text is required');
        document.getElementById('newReqText').focus();
        return;
      }
      if (formData.requirement_text.length < 10) {
        alert('Requirement text must be at least 10 characters');
        document.getElementById('newReqText').focus();
        return;
      }
      if (!formData.requirement_type) {
        alert('Requirement type is required');
        document.getElementById('newReqType').focus();
        return;
      }

      // Show saving state
      const saveBtn = document.querySelector('.create-req-modal .btn-primary');
      const originalText = saveBtn.textContent;
      saveBtn.disabled = true;
      saveBtn.textContent = 'Creating...';

      try {
        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/requirements`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(formData)
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Creation failed (${response.status}): ${errorText}`);
        }

        const newRequirement = await response.json();

        // Add to local state (insert at beginning of array)
        requirementsState.requirements.unshift(newRequirement);
        requirementsState.totalItems += 1;

        // Close modal
        document.querySelector('.create-req-modal').remove();

        // Save any constraints that were added
        await saveConstraintsForRequirement(newRequirement.requirement_id, window.modalConstraints);

        // Show success message
        if (window.toast) {
          window.toast('Requirement created successfully', 'success');
        } else {
          alert('Requirement created successfully');
        }

        // Refresh the table
        updateRequirementsTable(requirementsState.requirements, requirementsState.totalItems);

        // Optionally select the new requirement
        requirementsState.selectedRequirement = newRequirement;
        showRequirementDetails(newRequirement);

      } catch (error) {
        console.error('Error creating requirement:', error);
        alert(`Failed to create requirement: ${error.message}`);
      } finally {
        // Restore button state
        saveBtn.disabled = false;
        saveBtn.textContent = originalText;
      }
    }

    // =====================================
    // CONSTRAINTS MANAGEMENT
    // =====================================

    // Global constraints state for modals
    window.modalConstraints = [];

    // Add constraint to create modal
    function addNewConstraint() {
      const container = document.getElementById('newReqConstraintsContainer');
      const constraintId = 'constraint_' + Date.now();

      const constraint = {
        id: constraintId,
        name: '',
        description: '',
        constraint_type: 'threshold',
        value_type: 'text',
        text_value: ''
      };

      window.modalConstraints.push(constraint);
      renderConstraints(container, 'create');
    }

    // Add constraint to edit modal
    function addEditConstraint() {
      const container = document.getElementById('reqConstraintsContainer');
      const constraintId = 'constraint_' + Date.now();

      const constraint = {
        id: constraintId,
        name: '',
        description: '',
        constraint_type: 'threshold',
        value_type: 'text',
        text_value: ''
      };

      window.modalConstraints.push(constraint);
      renderConstraints(container, 'edit');
    }

    // Placeholder for future DAS integration
    function askDASForConstraints(modalType) {
      // Future implementation: 
      // 1. Get requirement text from modal
      // 2. Send to DAS for constraint extraction
      // 3. Parse DAS response into constraint objects
      // 4. Add to modalConstraints array
      // 5. Re-render constraints

      alert('DAS constraint extraction coming in future release!\n\nThis will analyze your requirement text and automatically suggest relevant constraints like thresholds, objectives, and performance parameters.');
    }

    // Render constraints in container
    function renderConstraints(container, modalType) {
      if (window.modalConstraints.length === 0) {
        container.innerHTML = `
          <div style="text-align:center; color:var(--muted-color); font-size:11px; padding:16px;">
            No constraints defined. Click "Add Constraint" to add manual constraints or "Ask DAS" to auto-extract from requirement text.
          </div>
        `;
        return;
      }

      const constraintsHtml = window.modalConstraints.map(constraint => `
        <div style="display:grid; grid-template-columns:1fr 1fr auto; gap:8px; align-items:end; margin-bottom:8px; padding:8px; background:var(--panel); border:1px solid var(--border); border-radius:4px;">
          <div>
            <label style="display:block; font-size:10px; color:var(--muted-color); margin-bottom:2px;">TYPE</label>
            <select onchange="updateConstraint('${constraint.id}', 'constraint_type', this.value)" 
                    style="width:100%; padding:4px; border:1px solid var(--border); border-radius:3px; background:var(--panel-2); font-size:11px;">
              <option value="threshold" ${constraint.constraint_type === 'threshold' ? 'selected' : ''}>Threshold</option>
              <option value="objective" ${constraint.constraint_type === 'objective' ? 'selected' : ''}>Objective</option>
              <option value="kpc" ${constraint.constraint_type === 'kpc' ? 'selected' : ''}>KPC</option>
              <option value="kpp" ${constraint.constraint_type === 'kpp' ? 'selected' : ''}>KPP</option>
              <option value="design" ${constraint.constraint_type === 'design' ? 'selected' : ''}>Design</option>
              <option value="interface" ${constraint.constraint_type === 'interface' ? 'selected' : ''}>Interface</option>
              <option value="environmental" ${constraint.constraint_type === 'environmental' ? 'selected' : ''}>Environmental</option>
              <option value="equation" ${constraint.constraint_type === 'equation' ? 'selected' : ''}>Equation</option>
            </select>
          </div>
          <div>
            <label style="display:block; font-size:10px; color:var(--muted-color); margin-bottom:2px;">NAME & VALUE</label>
            <input type="text" value="${constraint.name}" 
                   onchange="updateConstraint('${constraint.id}', 'name', this.value)"
                   placeholder="e.g. Maximum range, Response time"
                   style="width:100%; padding:4px; border:1px solid var(--border); border-radius:3px; background:var(--panel-2); font-size:11px;">
          </div>
          <div>
            <button onclick="removeConstraint('${constraint.id}', '${modalType}')" 
                    class="btn" style="padding:4px 6px; background:var(--error); color:white; font-size:10px;" 
                    title="Remove constraint">
              <svg style="width:10px; height:10px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 6L6 18M6 6l12 12"/>
              </svg>
            </button>
          </div>
          <div style="grid-column:1/-1;">
            ${constraint.constraint_type === 'equation' ? `
              <div style="display:grid; grid-template-columns:1fr auto; gap:8px; align-items:center;">
                <div>
                  <label style="display:block; font-size:10px; color:var(--muted-color); margin-bottom:2px;">EQUATION EXPRESSION</label>
                  <input type="text" value="${constraint.equation_expression || ''}" 
                         onchange="updateConstraint('${constraint.id}', 'equation_expression', this.value)"
                         placeholder="e.g. ResponseTime <= 30, Velocity = Distance / Time"
                         style="width:100%; padding:4px; border:1px solid var(--border); border-radius:3px; background:var(--panel-2); font-size:11px; font-family:monospace;">
                </div>
                <button onclick="openParameterPicker('${constraint.id}')" class="btn btn-sm" style="font-size:10px; padding:4px 8px; opacity:0.6;" disabled title="SysMLv2-lite Parameter Picker - Coming Soon!">
                  <svg style="width:12px; height:12px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
                    <polyline points="3.27,6.96 12,12.01 20.73,6.96"/>
                    <line x1="12" y1="22.08" x2="12" y2="12"/>
                  </svg>
                  Ontology
                </button>
              </div>
              <div style="margin-top:4px;">
                <input type="text" value="${constraint.text_value || ''}" 
                       onchange="updateConstraint('${constraint.id}', 'text_value', this.value)"
                       placeholder="Description (e.g. 'System response time must not exceed target threshold')"
                       style="width:100%; padding:4px; border:1px solid var(--border); border-radius:3px; background:var(--panel-2); font-size:11px;">
              </div>
            ` : `
              <input type="text" value="${constraint.text_value || ''}" 
                     onchange="updateConstraint('${constraint.id}', 'text_value', this.value)"
                     placeholder="Constraint description/value (e.g. '50 km maximum', 'Less than 2 hours', 'Encrypted transmission')"
                     style="width:100%; padding:4px; border:1px solid var(--border); border-radius:3px; background:var(--panel-2); font-size:11px;">
            `}
          </div>
        </div>
      `).join('');

      container.innerHTML = constraintsHtml;
    }

    // Update constraint value
    function updateConstraint(constraintId, field, value) {
      const constraint = window.modalConstraints.find(c => c.id === constraintId);
      if (constraint) {
        constraint[field] = value;

        // When constraint type changes, update value_type accordingly
        if (field === 'constraint_type') {
          if (value === 'equation') {
            constraint.value_type = 'equation';
            constraint.equation_expression = constraint.equation_expression || '';
          } else {
            constraint.value_type = 'text';
          }

          // Re-render to show/hide equation fields
          const modalType = document.querySelector('.create-req-modal') ? 'create' : 'edit';
          const containerName = modalType === 'create' ? 'newReqConstraintsContainer' : 'reqConstraintsContainer';
          const container = document.getElementById(containerName);
          if (container) renderConstraints(container, modalType);
        }
      }
    }

    // Placeholder for future SysMLv2-lite parameter picker
    function openParameterPicker(constraintId) {
      alert('SysMLv2-lite Parameter Picker Coming Soon!\n\nThis will allow you to:\n• Browse ontology-defined parameters\n• Select data properties with proper units\n• Build semantically validated equations\n• Ensure mathematical consistency across requirements\n\nExample: Select "ResponseTime" from ontology → Auto-suggests units and valid operations');
    }

    // Remove constraint
    function removeConstraint(constraintId, modalType) {
      const constraint = window.modalConstraints.find(c => c.id === constraintId);

      // Mark existing constraints for deletion
      if (constraint && constraint.existing) {
        constraint.deleted = true;
      }

      // Remove from UI array
      window.modalConstraints = window.modalConstraints.filter(c => c.id !== constraintId);

      const containerName = modalType === 'create' ? 'newReqConstraintsContainer' : 'reqConstraintsContainer';
      const container = document.getElementById(containerName);
      renderConstraints(container, modalType);
    }

    // Delete constraints marked for deletion
    async function deleteRemovedConstraints(requirementId, deletedConstraints) {
      if (!deletedConstraints || deletedConstraints.length === 0) return;

      const projectId = localStorage.getItem('active_project_id');

      for (const constraint of deletedConstraints) {
        try {
          const response = await authenticatedFetch(
            `/api/requirements/projects/${projectId}/requirements/${requirementId}/constraints/${constraint.id}`,
            { method: 'DELETE' }
          );

          if (!response.ok) {
            console.error(`Failed to delete constraint ${constraint.name}: ${response.statusText}`);
          }
        } catch (error) {
          console.error(`Error deleting constraint ${constraint.name}:`, error);
        }
      }
    }

    // Load existing constraints for edit modal
    async function loadConstraintsForEdit(requirementId) {
      try {
        const projectId = localStorage.getItem('active_project_id');
        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/requirements/${requirementId}/constraints`);

        if (response.ok) {
          const constraints = await response.json();
          window.modalConstraints = constraints.map(c => ({
            id: c.constraint_id,
            name: c.constraint_name,
            description: c.constraint_description,
            constraint_type: c.constraint_type,
            value_type: c.value_type,
            text_value: c.text_value || `${c.numeric_value || ''}${c.numeric_unit ? ' ' + c.numeric_unit : ''}`,
            equation_expression: c.equation_expression,
            equation_parameters: c.equation_parameters,
            existing: true  // Mark as existing for updates
          }));
        } else {
          window.modalConstraints = [];
        }
      } catch (error) {
        console.error('Error loading constraints:', error);
        window.modalConstraints = [];
      }
    }

    // Save constraints for a requirement
    async function saveConstraintsForRequirement(requirementId, constraints) {
      if (!constraints || constraints.length === 0) return;

      const projectId = localStorage.getItem('active_project_id');
      const validConstraints = constraints.filter(c => c.name && (c.text_value || c.numeric_value || c.equation_expression));

      try {
        for (const constraint of validConstraints) {
          const constraintData = {
            constraint_type: constraint.constraint_type,
            constraint_name: constraint.name,
            constraint_description: constraint.text_value || constraint.equation_expression || constraint.name,
            value_type: constraint.value_type,
            text_value: constraint.text_value,
            numeric_value: constraint.numeric_value,
            numeric_unit: constraint.numeric_unit,
            priority: constraint.priority || 'medium'
          };

          // Add equation fields if this is an equation constraint
          if (constraint.constraint_type === 'equation') {
            constraintData.equation_expression = constraint.equation_expression;
            constraintData.equation_parameters = constraint.equation_parameters || null;
          }

          if (constraint.existing && constraint.id.includes('-')) {
            // Update existing constraint
            const response = await authenticatedFetch(
              `/api/requirements/projects/${projectId}/requirements/${requirementId}/constraints/${constraint.id}`,
              {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(constraintData)
              }
            );

            if (!response.ok) {
              console.error(`Failed to update constraint ${constraint.name}: ${response.statusText}`);
            }
          } else {
            // Create new constraint
            const response = await authenticatedFetch(
              `/api/requirements/projects/${projectId}/requirements/${requirementId}/constraints`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(constraintData)
              }
            );

            if (!response.ok) {
              console.error(`Failed to create constraint ${constraint.name}: ${response.statusText}`);
            }
          }
        }
      } catch (error) {
        console.error('Error saving constraints:', error);
        // Don't fail the whole operation for constraint errors
      }
    }

    // Load and display constraints in requirement details panel
    async function loadRequirementConstraintsForDetails(requirementId) {
      try {
        const projectId = localStorage.getItem('active_project_id');
        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/requirements/${requirementId}/constraints`);

        const container = document.getElementById(`requirementConstraints-${requirementId}`);
        if (!container) return;

        if (response.ok) {
          const constraints = await response.json();

          if (constraints.length === 0) {
            container.innerHTML = '';
            return;
          }

          const constraintsHtml = `
            <div style="margin-bottom:16px;">
              <div style="font-size:11px; color:var(--muted-color); font-weight:600; margin-bottom:8px;">CONSTRAINTS (${constraints.length})</div>
              <div style="display:grid; gap:6px;">
                ${constraints.map(c => {
            const typeColors = {
              threshold: '#ef4444', objective: '#3b82f6', kpc: '#8b5cf6', kpp: '#06b6d4',
              design: '#6b7280', interface: '#10b981', environmental: '#f59e0b', equation: '#7c3aed'
            };
            const color = typeColors[c.constraint_type] || '#6b7280';

            let displayValue = '';
            if (c.constraint_type === 'equation' && c.equation_expression) {
              displayValue = `📐 ${c.equation_expression}`;
            } else {
              displayValue = c.text_value || `${c.numeric_value || ''}${c.numeric_unit ? ' ' + c.numeric_unit : ''}`;
            }

            return `
                    <div style="display:flex; align-items:center; gap:8px; padding:6px 8px; background:var(--panel-2); border:1px solid var(--border); border-radius:4px; font-size:12px;">
                      <span style="background:${color}; color:white; padding:2px 6px; border-radius:3px; font-size:10px; font-weight:500; min-width:70px; text-align:center;">
                        ${c.constraint_type.toUpperCase()}
                      </span>
                      <span style="font-weight:500;">${c.constraint_name}</span>
                      ${displayValue ? `<span style="color:var(--muted-color); font-family:${c.constraint_type === 'equation' ? 'monospace' : 'inherit'};">→ ${displayValue}</span>` : ''}
                    </div>
                  `;
          }).join('')}
              </div>
            </div>
          `;

          container.innerHTML = constraintsHtml;
        } else {
          container.innerHTML = '';
        }
      } catch (error) {
        console.error('Error loading requirement constraints:', error);
        const container = document.getElementById(`requirementConstraints-${requirementId}`);
        if (container) container.innerHTML = '';
      }
    }

    // Edit requirement
    function editRequirement(requirementId) {
      const requirement = requirementsState.requirements.find(r => r.requirement_id === requirementId);
      if (!requirement) {
        alert('Requirement not found');
        return;
      }
      showEditRequirementModal(requirement);
    }

    // Edit selected requirement
    function editSelectedRequirement() {
      if (requirementsState.selectedRequirement) {
        showEditRequirementModal(requirementsState.selectedRequirement);
      }
    }

    // Show edit requirement modal
    function showEditRequirementModal(requirement) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
        background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;
      `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
        background: var(--panel); border: 1px solid var(--border); border-radius: 8px; 
        width: 90%; max-width: 700px; max-height: 90vh; overflow: auto; padding: 20px;
      `;

      modalContent.innerHTML = `
        <div style="display:flex; justify-content:between; align-items:center; margin-bottom:20px;">
          <h3 style="margin:0; color:var(--accent);">Edit Requirement: ${requirement.requirement_identifier}</h3>
          <button onclick="this.closest('.edit-req-modal').remove()" class="btn" style="padding:4px 8px;">
            <svg style="width:16px; height:16px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>

        <form id="editRequirementForm" style="display:grid; gap:16px;">
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">TITLE</label>
              <input type="text" id="reqTitle" value="${requirement.requirement_title || ''}" 
                     style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2);" 
                     maxlength="500">
            </div>
            
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">TYPE</label>
              <select id="reqType" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2);">
                <option value="functional" ${requirement.requirement_type === 'functional' ? 'selected' : ''}>Functional</option>
                <option value="non_functional" ${requirement.requirement_type === 'non_functional' ? 'selected' : ''}>Non-Functional</option>
                <option value="performance" ${requirement.requirement_type === 'performance' ? 'selected' : ''}>Performance</option>
                <option value="safety" ${requirement.requirement_type === 'safety' ? 'selected' : ''}>Safety</option>
                <option value="security" ${requirement.requirement_type === 'security' ? 'selected' : ''}>Security</option>
                <option value="interface" ${requirement.requirement_type === 'interface' ? 'selected' : ''}>Interface</option>
                <option value="operational" ${requirement.requirement_type === 'operational' ? 'selected' : ''}>Operational</option>
                <option value="design" ${requirement.requirement_type === 'design' ? 'selected' : ''}>Design</option>
                <option value="implementation" ${requirement.requirement_type === 'implementation' ? 'selected' : ''}>Implementation</option>
              </select>
            </div>
          </div>

          <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:16px;">
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">PRIORITY</label>
              <select id="reqPriority" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2);">
                <option value="critical" ${requirement.priority === 'critical' ? 'selected' : ''}>Critical</option>
                <option value="high" ${requirement.priority === 'high' ? 'selected' : ''}>High</option>
                <option value="medium" ${requirement.priority === 'medium' ? 'selected' : ''}>Medium</option>
                <option value="low" ${requirement.priority === 'low' ? 'selected' : ''}>Low</option>
              </select>
            </div>
            
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">STATUS</label>
              <select id="reqState" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2);">
                <option value="draft" ${requirement.state === 'draft' ? 'selected' : ''}>Draft</option>
                <option value="review" ${requirement.state === 'review' ? 'selected' : ''}>Review</option>
                <option value="approved" ${requirement.state === 'approved' ? 'selected' : ''}>Approved</option>
                <!-- Published state removed - use Publish button for proper workflow -->
                ${requirement.state === 'published' ? '<option value="published" selected disabled>Published (Use Publish Button)</option>' : ''}
                <option value="deprecated" ${requirement.state === 'deprecated' ? 'selected' : ''}>Deprecated</option>
                <option value="cancelled" ${requirement.state === 'cancelled' ? 'selected' : ''}>Cancelled</option>
              </select>
            </div>
            
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">VERIFICATION METHOD</label>
              <select id="reqVerificationMethod" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2);">
                <option value="">Not specified</option>
                <option value="test" ${requirement.verification_method === 'test' ? 'selected' : ''}>Test</option>
                <option value="analysis" ${requirement.verification_method === 'analysis' ? 'selected' : ''}>Analysis</option>
                <option value="inspection" ${requirement.verification_method === 'inspection' ? 'selected' : ''}>Inspection</option>
                <option value="demonstration" ${requirement.verification_method === 'demonstration' ? 'selected' : ''}>Demonstration</option>
                <option value="review" ${requirement.verification_method === 'review' ? 'selected' : ''}>Review</option>
              </select>
            </div>
          </div>

          <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">CATEGORY</label>
              <input type="text" id="reqCategory" value="${requirement.category || ''}" 
                     style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2);" 
                     placeholder="e.g. User Interface, Data Management">
            </div>
            
            <div>
              <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">SUBCATEGORY</label>
              <input type="text" id="reqSubcategory" value="${requirement.subcategory || ''}" 
                     style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2);" 
                     placeholder="e.g. Login, Database Access">
            </div>
          </div>

          <div>
            <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">REQUIREMENT TEXT *</label>
            <textarea id="reqText" rows="4" 
                      style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text); resize:vertical;" 
                      placeholder="Enter the full requirement text..." required>${requirement.requirement_text || ''}</textarea>
          </div>

          <div>
            <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">RATIONALE</label>
            <textarea id="reqRationale" rows="3" 
                      style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text); resize:vertical;" 
                      placeholder="Why is this requirement necessary?">${requirement.requirement_rationale || ''}</textarea>
          </div>

          <div>
            <label style="display:block; font-weight:600; margin-bottom:4px; font-size:12px; color:var(--muted-color);">VERIFICATION CRITERIA</label>
            <textarea id="reqVerificationCriteria" rows="2" 
                      style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--text); resize:vertical;" 
                      placeholder="How will this requirement be verified/tested?">${requirement.verification_criteria || ''}</textarea>
          </div>

          <div>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <label style="font-weight:600; font-size:12px; color:var(--muted-color);">CONSTRAINTS</label>
              <div style="display:flex; gap:8px;">
                <button type="button" onclick="addEditConstraint()" class="btn btn-sm" style="font-size:11px; padding:4px 8px;">
                  <svg style="width:12px; height:12px; margin-right:4px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 5v14M5 12h14"/>
                  </svg>
                  Add Constraint
                </button>
                <button type="button" onclick="askDASForConstraints('edit')" class="btn btn-sm" style="font-size:11px; padding:4px 8px; background:var(--primary); color:white; opacity:0.6;" disabled title="Coming soon!">
                  <svg style="width:12px; height:12px; margin-right:4px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 11l3 3L22 4"/>
                    <path d="M21 12c-.12 2.51-.61 4.92-1.44 7.08"/>
                  </svg>
                  Ask DAS
                </button>
              </div>
            </div>
            <div id="reqConstraintsContainer" style="min-height:40px; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2);">
              <!-- Constraints will be loaded here -->
            </div>
          </div>

          <div style="display:flex; gap:8px; justify-content:flex-end; padding-top:12px; border-top:1px solid var(--border);">
            <button type="button" onclick="this.closest('.edit-req-modal').remove()" class="btn">Cancel</button>
            <button type="submit" class="btn btn-primary">Save Changes</button>
          </div>
        </form>
      `;

      modal.className = 'edit-req-modal';
      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      // Load existing constraints for edit modal
      loadConstraintsForEdit(requirement.requirement_id).then(() => {
        const constraintsContainer = document.getElementById('reqConstraintsContainer');
        renderConstraints(constraintsContainer, 'edit');
      });

      // Handle form submission
      const form = document.getElementById('editRequirementForm');
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        saveRequirementEdit(requirement.requirement_id);
      });

      // Focus on title field
      setTimeout(() => {
        document.getElementById('reqTitle').focus();
      }, 100);
    }

    // Save requirement edit
    async function saveRequirementEdit(requirementId) {
      const projectId = localStorage.getItem('active_project_id');
      if (!projectId) {
        alert('No project selected');
        return;
      }

      // Get form values
      const formData = {
        requirement_title: document.getElementById('reqTitle').value.trim(),
        requirement_text: document.getElementById('reqText').value.trim(),
        requirement_rationale: document.getElementById('reqRationale').value.trim() || null,
        requirement_type: document.getElementById('reqType').value,
        category: document.getElementById('reqCategory').value.trim() || null,
        subcategory: document.getElementById('reqSubcategory').value.trim() || null,
        priority: document.getElementById('reqPriority').value,
        state: document.getElementById('reqState').value,
        verification_method: document.getElementById('reqVerificationMethod').value || null,
        verification_criteria: document.getElementById('reqVerificationCriteria').value.trim() || null
      };

      // Validate required fields
      if (!formData.requirement_text) {
        alert('Requirement text is required');
        return;
      }

      // Show saving state
      const saveBtn = document.querySelector('.edit-req-modal .btn-primary');
      const originalText = saveBtn.textContent;
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';

      try {
        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/requirements/${requirementId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(formData)
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Update failed (${response.status}): ${errorText}`);
        }

        const updatedRequirement = await response.json();

        // Update local state
        const reqIndex = requirementsState.requirements.findIndex(r => r.requirement_id === requirementId);
        if (reqIndex !== -1) {
          requirementsState.requirements[reqIndex] = { ...requirementsState.requirements[reqIndex], ...updatedRequirement };
        }

        // Update selected requirement if it's the one we edited
        if (requirementsState.selectedRequirement && requirementsState.selectedRequirement.requirement_id === requirementId) {
          requirementsState.selectedRequirement = { ...requirementsState.selectedRequirement, ...updatedRequirement };
        }

        // Save any constraint changes
        await saveConstraintsForRequirement(requirementId, window.modalConstraints);

        // Close modal
        document.querySelector('.edit-req-modal').remove();

        // Show success message
        if (window.toast) {
          window.toast('Requirement updated successfully', 'success');
        } else {
          alert('Requirement updated successfully');
        }

        // Refresh the table and details panel
        updateRequirementsTable(requirementsState.requirements, requirementsState.totalItems);

        if (requirementsState.selectedRequirement) {
          showRequirementDetails(requirementsState.selectedRequirement);
        }

      } catch (error) {
        console.error('Error updating requirement:', error);
        alert(`Failed to update requirement: ${error.message}`);
      } finally {
        // Restore button state
        saveBtn.disabled = false;
        saveBtn.textContent = originalText;
      }
    }

    // Request DAS review for specific requirement
    async function requestDASReview(requirementId) {
      const requirement = requirementsState.requirements.find(r => r.requirement_id === requirementId);
      if (!requirement) return;

      requirementsState.selectedRequirement = requirement;
      await startDASReview();
    }

    // =====================================
    // PUBLISHING FUNCTIONS
    // =====================================

    let selectedRequirements = new Set();

    function updateSelectedCount() {
      const checkboxes = document.querySelectorAll('.requirement-checkbox:checked');
      selectedRequirements.clear();
      checkboxes.forEach(cb => selectedRequirements.add(cb.value));

      const count = selectedRequirements.size;
      const countEl = document.getElementById('selectedCount');
      const batchBtn = document.getElementById('reqBatchPublishBtn');

      if (countEl) countEl.textContent = count;
      if (batchBtn) batchBtn.style.display = count > 0 ? 'inline-flex' : 'none';

      // Update select all checkbox state
      const selectAllCb = document.getElementById('selectAllRequirements');
      const allCheckboxes = document.querySelectorAll('.requirement-checkbox');
      if (selectAllCb && allCheckboxes.length > 0) {
        selectAllCb.indeterminate = count > 0 && count < allCheckboxes.length;
        selectAllCb.checked = count === allCheckboxes.length;
      }
    }

    function toggleSelectAllRequirements() {
      const selectAllCb = document.getElementById('selectAllRequirements');
      const checkboxes = document.querySelectorAll('.requirement-checkbox');

      checkboxes.forEach(cb => {
        cb.checked = selectAllCb.checked;
      });

      updateSelectedCount();
    }

    async function publishRequirement(requirementId, force = false) {
      if (!requirementId) return;

      try {
        const projectId = localStorage.getItem('active_project_id');
        if (!projectId) {
          toast('No active project selected', true);
          return;
        }

        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/requirements/${requirementId}/publish`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ force: force })
        });

        if (!response.ok) {
          const errorData = await response.json();
          if (response.status === 400 && errorData.detail.includes('approved') && !force) {
            // Offer to force publish
            const forcePublish = confirm(`${errorData.detail}\n\nWould you like to force publish this requirement anyway?`);
            if (forcePublish) {
              return await publishRequirement(requirementId, true);
            }
          }
          throw new Error(errorData.detail || `HTTP ${response.status}`);
        }

        const result = await response.json();
        toast(`✅ ${result.message}`);

        // Refresh the requirements list to show updated state
        await loadRequirements();

        // Update selected requirement if it's showing in details
        if (requirementsState.selectedRequirement?.requirement_id === requirementId) {
          const updatedReq = requirementsState.requirements.find(r => r.requirement_id === requirementId);
          if (updatedReq) {
            requirementsState.selectedRequirement = updatedReq;
            showRequirementDetails(updatedReq);
          }
        }

      } catch (error) {
        console.error('Error publishing requirement:', error);
        toast(`Failed to publish requirement: ${error.message}`, true);
      }
    }

    async function unpublishRequirement(requirementId) {
      if (!requirementId) return;

      try {
        const projectId = localStorage.getItem('active_project_id');
        if (!projectId) {
          toast('No active project selected', true);
          return;
        }

        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/requirements/${requirementId}/unpublish`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.detail || `HTTP ${response.status}`);
        }

        const result = await response.json();
        toast(`✅ ${result.message}`);

        // Refresh the requirements list
        await loadRequirements();

        // Update selected requirement if showing in details
        if (requirementsState.selectedRequirement?.requirement_id === requirementId) {
          const updatedReq = requirementsState.requirements.find(r => r.requirement_id === requirementId);
          if (updatedReq) {
            requirementsState.selectedRequirement = updatedReq;
            showRequirementDetails(updatedReq);
          }
        }

      } catch (error) {
        console.error('Error unpublishing requirement:', error);
        toast(`Failed to unpublish requirement: ${error.message}`, true);
      }
    }

    async function unimportRequirement(requirementId) {
      if (!requirementId) return;

      try {
        const projectId = localStorage.getItem('active_project_id');
        if (!projectId) {
          toast('No active project selected', true);
          return;
        }

        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/requirements/${requirementId}/import`, {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.detail || `HTTP ${response.status}`);
        }

        const result = await response.json();
        toast(`✅ ${result.message}`);

        // Close details panel and refresh requirements list
        hideRequirementDetails();
        await loadRequirements();

      } catch (error) {
        console.error('Error un-importing requirement:', error);
        toast(`Failed to un-import requirement: ${error.message}`, true);
      }
    }

    async function batchPublishRequirements(force = false) {
      const selectedIds = Array.from(selectedRequirements);
      if (selectedIds.length === 0) {
        toast('No requirements selected', true);
        return;
      }

      try {
        const projectId = localStorage.getItem('active_project_id');
        if (!projectId) {
          toast('No active project selected', true);
          return;
        }

        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/requirements/batch-publish`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            requirement_ids: selectedIds,
            force: force
          })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.detail || `HTTP ${response.status}`);
        }

        const result = await response.json();

        // Show detailed results
        const publishedCount = result.summary.published_count;
        const skippedCount = result.summary.skipped_count;

        if (publishedCount > 0) {
          toast(`✅ Published ${publishedCount} requirements successfully`);
        }

        if (skippedCount > 0) {
          const skippedReasons = result.skipped.map(s => `${s.requirement_identifier || s.requirement_id}: ${s.reason}`).join('\n');
          console.warn('Skipped requirements:', skippedReasons);

          if (publishedCount === 0) {
            // If nothing was published, offer to force publish
            const hasUnforceable = result.skipped.some(s => s.reason.includes('approved'));
            if (hasUnforceable && !force) {
              const forcePublish = confirm(`No requirements were published:\n\n${skippedReasons}\n\nWould you like to force publish the eligible requirements anyway?`);
              if (forcePublish) {
                return await batchPublishRequirements(true);
              }
            } else {
              toast(`No requirements published: ${skippedCount} skipped`, true);
            }
          } else {
            toast(`⚠️ Published ${publishedCount}, skipped ${skippedCount} requirements`);
          }
        }

        // Clear selections and refresh
        selectedRequirements.clear();
        document.querySelectorAll('.requirement-checkbox').forEach(cb => cb.checked = false);
        updateSelectedCount();
        await loadRequirements();

      } catch (error) {
        console.error('Error batch publishing requirements:', error);
        toast(`Failed to batch publish: ${error.message}`, true);
      }
    }

    function updatePublishButtonVisibility(requirement) {
      const publishBtn = document.getElementById('reqPublishBtn');
      const unpublishBtn = document.getElementById('reqUnpublishBtn');
      const unimportBtn = document.getElementById('reqUnimportBtn');
      const editBtn = document.getElementById('reqEditBtn');

      if (!publishBtn || !unpublishBtn) return;

      // Handle imported/immutable requirements - show un-import button
      const isImported = requirement.state === 'imported' || requirement.is_immutable;

      if (isImported) {
        publishBtn.style.display = 'none';
        unpublishBtn.style.display = 'none';
        if (editBtn) editBtn.style.display = 'none';
        if (unimportBtn) unimportBtn.style.display = 'inline-flex';
        return;
      }

      // Hide un-import button for non-imported requirements
      if (unimportBtn) unimportBtn.style.display = 'none';

      // Show appropriate buttons for regular requirements
      const canPublish = requirement.state === 'approved' ||
        (requirement.state === 'draft' || requirement.state === 'review');
      const isPublished = requirement.state === 'published';

      publishBtn.style.display = !isPublished && canPublish ? 'inline-flex' : 'none';
      unpublishBtn.style.display = isPublished ? 'inline-flex' : 'none';
      if (editBtn) editBtn.style.display = 'inline-flex';
    }

    // Toast notification function (if not already defined)
    if (typeof window.toast === 'undefined') {
      window.toast = function (message, isError = false) {
        console.log(isError ? '❌' : '✅', message);

        // Create toast element
        const toast = document.createElement('div');
        toast.style.cssText = `
      position: fixed; bottom: 20px; right: 20px; z-index: 10001;
      background: ${isError ? '#ef4444' : '#10b981'}; color: white;
      padding: 12px 16px; border-radius: 6px; font-size: 14px; font-weight: 500;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: slideInRight 0.3s ease-out;
    `;
        toast.textContent = message;

        document.body.appendChild(toast);

        // Auto remove after 3 seconds
        setTimeout(() => {
          toast.style.animation = 'slideOutRight 0.3s ease-in forwards';
          setTimeout(() => toast.remove(), 300);
        }, 3000);
      };
    }

    // Add CSS animations for toast
    const style = document.createElement('style');
    style.textContent = `
  @keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  @keyframes slideOutRight {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
  }
  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
`;
    document.head.appendChild(style);

    console.log('📋 Requirements Workbench JavaScript initialized');

    // Diagnostic function for debugging
    window.debugRequirements = async function () {
      console.log('=== REQUIREMENTS DEBUG ===');
      console.log('1. Active Project ID:', localStorage.getItem('active_project_id'));
      console.log('2. Auth Token exists:', !!localStorage.getItem('odras_token'));
      console.log('3. Requirements State:', requirementsState);
      console.log('4. Container exists:', !!document.getElementById('requirementsTableContainer'));

      // Try to manually fetch requirements
      const projectId = localStorage.getItem('active_project_id');
      if (!projectId) {
        console.error('❌ No active project ID!');
        return;
      }

      try {
        console.log('5. Attempting manual fetch...');
        const response = await authenticatedFetch(`/api/requirements/projects/${projectId}/requirements`);
        console.log('6. Response status:', response.status);

        if (response.ok) {
          const data = await response.json();
          console.log('✅ Requirements data:', data);
          console.log('   - Total requirements:', data.requiremts?.length || 0);
          console.log('   - First requirement:', data.requirements?.[0]);
        } else {
          const error = await response.text();
          console.error('❌ API Error:', error);
        }
      } catch (err) {
        console.error('❌ Fetch error:', err);
      }

      console.log('=== END DEBUG ===');
    };

    // End of Requirements Workbench JavaScript

    // =====================================
    // INDIVIDUAL TABLES SYSTEM
    // =====================================

    /**
     * Load Individual Tables for the currently selected ontology
     */
    async function loadIndividualTablesForCurrentOntology() {
      const currentGraphIri = getCurrentOntologyGraphIri();
      const currentLabel = getCurrentOntologyLabel();

      if (!currentGraphIri) {
        const content = document.getElementById('individualsTableContent');
        if (content) {
          content.innerHTML = `
            <div style="padding: 40px; text-align: center; color: var(--muted);">
              <h3>No Ontology Selected</h3>
              <p>Please select an ontology from the tree to view its individuals</p>
            </div>
          `;
        }
        return;
      }

      try {
        // Load ontology structure
        const ontologyData = await analyzeOntologyStructure(currentGraphIri);
        await loadIndividualTablesInterface(currentGraphIri, currentLabel || 'Ontology', ontologyData);
      } catch (error) {
        console.error('❌ Error loading Individual Tables:', error);
        const content = document.getElementById('individualsTableContent');
        if (content) {
          content.innerHTML = `
            <div style="padding: 40px; text-align: center; color: var(--err);">
              <h3>Error Loading Individuals</h3>
              <p>${error.message}</p>
            </div>
          `;
        }
      }
    }

    /**
     * Get currently selected ontology graph IRI
     */
    function getCurrentOntologyGraphIri() {
      // Try multiple ways to get the current ontology

      // Method 1: From ontoState (most reliable)
      if (window.ontoState && window.ontoState.currentGraph) {
        console.log('🔍 Found ontology from ontoState:', window.ontoState.currentGraph);
        return window.ontoState.currentGraph;
      }

      // Method 2: From localStorage active ontology
      const projectId = localStorage.getItem('active_project_id');
      if (projectId) {
        const activeIri = localStorage.getItem(`onto_active_iri__${projectId}`);
        if (activeIri) {
          console.log('🔍 Found ontology from localStorage:', activeIri);
          return activeIri;
        }
      }

      // Method 3: From graph label dataset
      const graphLabel = document.getElementById('ontoGraphLabel');
      if (graphLabel && graphLabel.dataset.graphIri) {
        console.log('🔍 Found ontology from graph label:', graphLabel.dataset.graphIri);
        return graphLabel.dataset.graphIri;
      }

      // Method 4: Parse from URL hash if available
      try {
        const hash = window.location.hash;
        const params = new URLSearchParams(hash.replace('#', ''));
        const graphParam = params.get('graph');
        if (graphParam) {
          const graphIri = decodeURIComponent(graphParam);
          console.log('🔍 Found ontology from URL hash:', graphIri);
          return graphIri;
        }
      } catch (e) {
        console.log('🔍 No ontology found in URL hash');
      }

      console.log('❌ No ontology found');
      return null;
    }

    /**
     * Get currently selected ontology label
     */
    function getCurrentOntologyLabel() {
      const graphLabel = document.getElementById('ontoGraphLabel');
      if (graphLabel && graphLabel.textContent !== 'No graph selected') {
        return graphLabel.textContent;
      }

      // Try to get from localStorage model name
      const projectId = localStorage.getItem('active_project_id');
      if (projectId) {
        const modelName = localStorage.getItem(`onto_model_name__${projectId}`);
        if (modelName) {
          return modelName;
        }
      }

      return 'Unknown Ontology';
    }

    /**
     * Switch between Ontologies and Individuals tabs
     * @param {string} tabName - 'ontology' or 'individuals' 
     */
    window.switchWorkbenchTab = function (tabName) {
      console.log('🔍 Switching workbench tab to:', tabName);

      // Update tab buttons
      const ontologyTab = document.getElementById('ontologyTab');
      const individualsTab = document.getElementById('individualsTab');

      if (ontologyTab) ontologyTab.classList.toggle('active', tabName === 'ontology');
      if (individualsTab) individualsTab.classList.toggle('active', tabName === 'individuals');

      // Show/hide content areas
      const ontoLayout = document.getElementById('ontoLayoutSection');
      const individualsContent = document.getElementById('individualsContent');

      if (tabName === 'ontology') {
        if (ontoLayout) ontoLayout.style.display = 'grid';
        if (individualsContent) individualsContent.classList.remove('active');
      } else if (tabName === 'individuals') {
        if (ontoLayout) ontoLayout.style.display = 'none';
        if (individualsContent) individualsContent.classList.add('active');

        // Load individuals for currently selected ontology
        loadIndividualTablesForCurrentOntology();
      }
    };

    /**
     * Analyze ontology structure to extract classes, properties, and constraints
     */
    async function analyzeOntologyStructure(graphIri) {
      console.log('🔍 Analyzing ontology structure for:', graphIri);

      try {
        const token = localStorage.getItem(tokenKey);

        // Query SPARQL to get classes AND their data properties for this specific graph
        const sparqlQuery = `
          SELECT ?class ?classLabel ?classComment ?dataProp ?dataPropLabel ?dataPropComment ?dataPropRange WHERE {
            GRAPH <${graphIri}> {
              # Get all classes
              ?class a <http://www.w3.org/2002/07/owl#Class> .
              OPTIONAL { ?class <http://www.w3.org/2000/01/rdf-schema#label> ?classLabel }
              OPTIONAL { ?class <http://www.w3.org/2000/01/rdf-schema#comment> ?classComment }
              
              # Get data properties for each class  
              OPTIONAL {
                ?dataProp a <http://www.w3.org/2002/07/owl#DatatypeProperty> .
                ?dataProp <http://www.w3.org/2000/01/rdf-schema#domain> ?class .
                OPTIONAL { ?dataProp <http://www.w3.org/2000/01/rdf-schema#label> ?dataPropLabel }
                OPTIONAL { ?dataProp <http://www.w3.org/2000/01/rdf-schema#comment> ?dataPropComment }
                OPTIONAL { ?dataProp <http://www.w3.org/2000/01/rdf-schema#range> ?dataPropRange }
              }
            }
          }
        `;

        const sparqlResponse = await fetch('/api/ontology/sparql', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
          },
          body: JSON.stringify({ query: sparqlQuery })
        });

        if (!sparqlResponse.ok) {
          throw new Error(`SPARQL query failed: ${sparqlResponse.statusText}`);
        }

        const sparqlResult = await sparqlResponse.json();
        console.log('🔍 SPARQL result:', sparqlResult);

        // Transform SPARQL results to ontology structure with data properties
        const classesMap = new Map();
        const dataProperties = [];
        const bindings = sparqlResult.results?.bindings || [];

        console.log(`🔍 Found ${bindings.length} bindings (classes + data properties)`);

        // Process all bindings to build classes with their data properties
        for (const binding of bindings) {
          const classUri = binding.class?.value || '';
          const classLabel = binding.classLabel?.value || '';
          const classComment = binding.classComment?.value || '';

          // Extract class name from label or URI
          const className = classLabel && classLabel !== 'None' ? classLabel : classUri.split('#').pop().split('/').pop();

          if (className && !classesMap.has(className)) {
            classesMap.set(className, {
              name: className,
              uri: classUri,
              comment: classComment,
              definition: classComment,
              dataProperties: []
            });
            console.log(`🔍 Added class: ${className}`);
          }

          // Process data properties
          if (binding.dataProp?.value) {
            const propUri = binding.dataProp.value;
            const propLabel = binding.dataPropLabel?.value || propUri.split('#').pop().split('/').pop();
            const propComment = binding.dataPropComment?.value || '';
            const propRange = binding.dataPropRange?.value || 'xsd:string';

            const dataProperty = {
              name: propLabel,
              uri: propUri,
              comment: propComment,
              range: propRange.split('#').pop().split('/').pop(), // Get just the type name
              domain: className
            };

            // Add to class's data properties
            const classData = classesMap.get(className);
            if (classData && !classData.dataProperties.find(dp => dp.name === propLabel)) {
              classData.dataProperties.push(dataProperty);
              console.log(`🔍 Added data property ${propLabel} to class ${className}`);
            }

            // Also add to global data properties list
            if (!dataProperties.find(dp => dp.name === propLabel && dp.domain === className)) {
              dataProperties.push(dataProperty);
            }
          }
        }

        const classes = Array.from(classesMap.values());

        // Build ontology structure for Individual Tables
        const ontologyStructure = {
          name: `Ontology (${classes.length} classes)`,
          classes: classes,
          object_properties: [],
          datatype_properties: dataProperties,
          constraints: {},
          form_configs: {},
          enumerations: {}
        };

        // Log data properties for each class
        classes.forEach(cls => {
          if (cls.dataProperties.length > 0) {
            console.log(`🔍 Class ${cls.name} has ${cls.dataProperties.length} data properties:`, cls.dataProperties.map(dp => dp.name));
          }
        });

        console.log('🔍 Final ontology structure:', ontologyStructure);
        return ontologyStructure;

      } catch (error) {
        console.error('❌ Error analyzing ontology structure:', error);

        // Return empty structure with error info
        return {
          name: 'Error Loading Ontology',
          classes: [],
          object_properties: [],
          datatype_properties: [],
          constraints: {},
          form_configs: {},
          enumerations: {},
          error: error.message
        };
      }
    }

    // Simplified Individual Tables - Load interfaces when needed
    async function loadIndividualTablesInterface(graphIri, ontologyLabel, ontologyData) {
      console.log('🔍 Loading Individual Tables interface for:', ontologyLabel);

      try {
        // Update content area with loading state
        const content = document.getElementById('individualsTableContent');
        if (content) {
          content.innerHTML = `
            <div style="padding: 40px; text-align: center; color: var(--muted);">
              <div style="animation: spin 1s linear infinite; width:24px; height:24px; margin:0 auto 12px;">⚙️</div>
              Loading individual tables for ${ontologyLabel}...
            </div>
          `;
        }

        // Generate tabs for each class
        generateClassTabs(ontologyData);

        // Load default tab (overall ontology)
        showIndividualTable('_ontology', ontologyData);

        console.log('✅ Individual Tables interface loaded');

      } catch (error) {
        console.error('❌ Error loading Individual Tables interface:', error);
        const content = document.getElementById('individualsTableContent');
        if (content) {
          content.innerHTML = `
            <div style="padding: 40px; text-align: center; color: var(--err);">
              <h3>Error Loading Individual Tables</h3>
              <p>${error.message}</p>
            </div>
          `;
        }
      }
    }

    /**
     * Generate tabs for each ontology class - FULLY DYNAMIC
     */
    function generateClassTabs(ontologyData) {
      const tabList = document.getElementById('individualsTabList');
      if (!tabList) return;

      let tabsHtml = '';

      // Overall ontology tab (always present)
      tabsHtml += `
        <button class="individuals-tab-item active" data-class="_ontology" onclick="showIndividualTable('_ontology')">
          <span class="individuals-tab-icon">🧠</span>
          <span class="individuals-tab-label">${ontologyData.name || 'Overview'}</span>
        </button>
      `;

      // Dynamic class-specific tabs - ONLY for classes that actually exist in the ontology
      if (ontologyData.classes && ontologyData.classes.length > 0) {
        console.log(`🔍 Creating ${ontologyData.classes.length} dynamic class tabs:`, ontologyData.classes.map(c => c.name));

        ontologyData.classes.forEach(cls => {
          const icon = getClassIcon(cls.name);
          const dataPropertyCount = cls.dataProperties ? cls.dataProperties.length : 0;
          const tabDisplayName = dataPropertyCount > 0 ? `${cls.name} (${dataPropertyCount})` : cls.name;

          tabsHtml += `
            <button class="individuals-tab-item" data-class="${cls.name}" onclick="showIndividualTable('${cls.name}')">
              <span class="individuals-tab-icon">${icon}</span>
              <span class="individuals-tab-label">${tabDisplayName}</span>
            </button>
          `;
        });
      } else {
        console.log('🔍 No classes found in ontology - only overview tab will be shown');
      }

      tabList.innerHTML = tabsHtml;

      // Store ontology data globally for tab functions to access
      window.currentOntologyData = ontologyData;
    }

    /**
     * Get appropriate icon for ontology class
     */
    function getClassIcon(className) {
      const iconMap = {
        'Requirement': '📋',
        'Component': '🔧',
        'Process': '⚙️',
        'Function': '🎯',
        'Interface': '🔌',
        'Constraint': '⚠️',
        'System': '🏗️'
      };
      return iconMap[className] || '📄';
    }

    /**
     * Show individual table for specific class - FULLY DYNAMIC
     */
    function showIndividualTable(className) {
      console.log('🔍 Showing individual table for class:', className);

      // Get current ontology data
      const ontologyData = window.currentOntologyData;
      if (!ontologyData) {
        console.error('❌ No ontology data available');
        return;
      }

      // Update active tab
      const tabList = document.getElementById('individualsTabList');
      if (tabList) {
        tabList.querySelectorAll('.individuals-tab-item').forEach(t => t.classList.remove('active'));
        const activeTab = tabList.querySelector(`[data-class="${className}"]`);
        if (activeTab) activeTab.classList.add('active');
      }

      const content = document.getElementById('individualsTableContent');
      if (!content) return;

      if (className === '_ontology') {
        // Show overall ontology view with ALL classes from ontology
        showOntologyOverview(ontologyData);
      } else {
        // Show specific class table (only if class exists in ontology)
        const classExists = ontologyData.classes?.some(c => c.name === className);
        if (!classExists) {
          content.innerHTML = `
            <div style="padding: 40px; text-align: center; color: var(--err);">
              <h3>Class Not Found</h3>
              <p>Class "${className}" does not exist in the current ontology.</p>
            </div>
          `;
          return;
        }

        showClassTable(className, ontologyData);
      }
    }

    /**
     * Show overall ontology overview
     */
    function showOntologyOverview(ontologyData) {
      const content = document.getElementById('individualsTableContent');
      if (!content) return;

      let html = `
        <div class="ontology-overview">
          <h3>${ontologyData.name || 'Ontology Overview'}</h3>
          <p style="color: var(--muted); margin-bottom: 20px;">Manage individuals across all ontology classes</p>
          
          <div class="class-summary-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px;">
      `;

      if (ontologyData.classes && ontologyData.classes.length > 0) {
        console.log(`🔍 Generating overview cards for ${ontologyData.classes.length} classes from ontology:`, ontologyData.classes.map(c => c.name));

        ontologyData.classes.forEach(cls => {
          const icon = getClassIcon(cls.name);
          const dataPropertyCount = cls.dataProperties ? cls.dataProperties.length : 0;
          const classDisplayName = dataPropertyCount > 0 ? `${cls.name} (${dataPropertyCount})` : cls.name;

          html += `
            <div class="class-summary-card" style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
              <div class="card-header" style="display: flex; align-items: center; margin-bottom: 12px;">
                <span style="font-size: 24px; margin-right: 8px;">${icon}</span>
                <div>
                  <h4 style="margin: 0; color: var(--text);">${classDisplayName}</h4>
                  <p style="margin: 0; color: var(--muted); font-size: 14px;">${cls.comment || cls.definition || 'No description'}</p>
                  ${dataPropertyCount > 0 ? `<p style="margin: 0; color: var(--accent); font-size: 12px; margin-top: 4px;">📊 ${dataPropertyCount} data ${dataPropertyCount === 1 ? 'property' : 'properties'}</p>` : ''}
                </div>
              </div>
              <div class="card-stats">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <span style="color: var(--muted);">Individuals: <strong>0</strong></span>
                  <button class="btn" style="background: var(--accent); color: white; font-size: 12px;" onclick="showIndividualTable('${cls.name}')">
                    View Table →
                  </button>
                </div>
              </div>
            </div>
          `;
        });
      } else {
        html += `
          <div style="padding: 40px; text-align: center; color: var(--muted);">
            <h4>No Classes Found</h4>
            <p>This ontology doesn't have any classes to create individuals for.</p>
          </div>
        `;
      }

      html += `
          </div>
        </div>
      `;

      content.innerHTML = html;
    }

    /**
     * Show table for specific class
     */
    function showClassTable(className, ontologyData) {
      console.log('🔍 Showing table for class:', className);

      const content = document.getElementById('individualsTableContent');
      if (!content) return;

      // Find class definition
      const classData = ontologyData.classes?.find(c => c.name === className);
      if (!classData) {
        content.innerHTML = `
          <div style="padding: 40px; text-align: center; color: var(--err);">
            <h3>Class Not Found</h3>
            <p>Class "${className}" not found in ontology structure.</p>
          </div>
        `;
        return;
      }

      // Generate table structure based on class properties
      const properties = getClassProperties(className, ontologyData);
      const tableHtml = generateClassTable(className, classData, properties);
      content.innerHTML = tableHtml;
    }

    /**
     * Get properties for a specific class - DYNAMIC based on ontology
     */
    function getClassProperties(className, ontologyData) {
      const properties = [];

      // Get the specific class data
      const classData = ontologyData.classes?.find(c => c.name === className);

      if (classData && classData.dataProperties) {
        // Add data properties as table columns
        classData.dataProperties.forEach(prop => {
          properties.push({
            name: prop.name,
            label: prop.name, // Use the actual property label 
            type: 'datatype',
            range: prop.range,
            comment: prop.comment,
            constraints: {}
          });
        });

        console.log(`🔍 Class ${className} properties for table:`, properties.map(p => p.name));
      }

      // Also add object properties that have this class as domain (for future use)
      if (ontologyData.object_properties) {
        ontologyData.object_properties.forEach(prop => {
          if (prop.domain === className) {
            properties.push({
              name: prop.name,
              label: prop.label || prop.name,
              type: 'object',
              range: prop.range,
              constraints: prop.constraints || {}
            });
          }
        });
      }

      return properties;
    }

    /**
     * Generate HTML table for class individuals
     */
    function generateClassTable(className, classData, properties) {
      const icon = getClassIcon(className);

      let html = `
        <div class="class-table-container">
          <div class="table-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <div>
              <h3>${icon} ${className} Individuals</h3>
              <p style="color: var(--muted); margin: 0;">${classData.comment || classData.definition || 'No description available'}</p>
            </div>
            <div class="table-actions" style="display: flex; gap: 8px;">
              <button class="btn btn-success" onclick="showAddIndividualDialog('${className}')">➕ Add ${className}</button>
              ${className.toLowerCase() === 'requirement' ? '<button class="btn" onclick="showImportRequirementsDialog()">📥 Import Requirements</button>' : ''}
              <button class="btn" onclick="exportClassTable('${className}')">📤 Export</button>
            </div>
          </div>
          
          <div class="table-wrapper" style="border: 1px solid var(--border); border-radius: 8px; overflow: hidden; background: var(--panel);">
            <table style="width: 100%; border-collapse: collapse;">
              <thead style="background: var(--panel-2);">
                <tr>
      `;

      // Table headers
      html += '<th style="padding: 12px; text-align: left; border-bottom: 1px solid var(--border); color: var(--text);">Name</th>';

      properties.forEach(prop => {
        html += `<th style="padding: 12px; text-align: left; border-bottom: 1px solid var(--border); color: var(--text);">${prop.label || prop.name}</th>`;
      });

      html += `
                  <th style="padding: 12px; text-align: left; border-bottom: 1px solid var(--border); color: var(--text);">Actions</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td colspan="${properties.length + 2}" style="padding: 40px; text-align: center; color: var(--muted);">
                    No ${className.toLowerCase()} individuals yet. Click "Add ${className}" to create one.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      `;

      return html;
    }

    /**
     * Placeholder functions for future implementation
     */
    function showAddIndividualDialog(className) {
      alert(`Add ${className} dialog - Coming soon!`);
    }

    function showImportRequirementsDialog() {
      alert('Import Requirements dialog - Coming soon!');
    }

    function exportClassTable(className) {
      alert(`Export ${className} table - Coming soon!`);
    }

    // End of Individual Tables System
  </script>

</body>

</html>
