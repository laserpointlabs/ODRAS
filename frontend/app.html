<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ODRAS — UI Restart</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #0b1220;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #60a5fa;
      --border: #1f2937;
      --warn: #f59e0b;
      --ok: #10b981;
      --err: #ef4444;
      --iconbar-w: 56px;
      --tree-w: 320px;
      --tree-w-min: 220px;
      --tree-w-max: 520px;
      --onto-iconbar-w: 56px;
      --onto-tree-w: 300px;
      --onto-tree-w-min: 180px;
      --onto-tree-w-max: 520px;
      --onto-tree-collapsed-w: 40px;
      --onto-props-w: 300px;
      --onto-props-w-min: 200px;
      --onto-props-w-max: 520px;
      --onto-props-collapsed-w: 40px;
      --toolbar-h: 48px;
      --bottombar-h: 32px;
      /* DAS (Digital Assistant Service) */
      --das-w: 420px;
      --das-h: 40vh;
      --das-toolbar-h: 40px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, sans-serif; }
    .layout {
      display: grid;
      grid-template-rows: var(--toolbar-h) 1fr var(--bottombar-h);
      height: 100vh;
    }
    .topbar, .bottombar {
      display: flex; align-items: center; gap: 12px; padding: 0 12px;
      background: var(--panel); border-bottom: 1px solid var(--border);
    }
    .bottombar { border-top: 1px solid var(--border); border-bottom: none; color: var(--muted); gap: 16px; }
    .brand { font-weight: 600; letter-spacing: .5px; }
    .spacer { flex: 1; }
    .btn, select {
      background: #0b1220; color: var(--text); border: 1px solid var(--border);
      padding: 6px 10px; border-radius: 6px; cursor: pointer;
    }
    .btn:hover {
      background: var(--panel); border-color: var(--accent);
    }
    #previewFullscreenBtn:hover, #previewPopoutBtn:hover {
      background: var(--accent); color: white; border-color: var(--accent);
    }
    #fileDropZone:hover {
      background: rgba(15, 22, 40, 0.5) !important;
      border-color: #6b7280 !important;
    }
    select { padding: 6px; }
    .content {
      display: grid; grid-template-columns: var(--iconbar-w) var(--tree-w) 6px 1fr; height: 100%;
    }
    .iconbar {
      background: var(--panel); border-right: 1px solid var(--border);
      display: flex; flex-direction: column; align-items: center; padding: 8px 6px; gap: 8px;
    }
    .icon {
      width: 40px; height: 40px; border-radius: 8px; border: 1px solid var(--border);
      background: var(--panel-2); display: grid; place-items: center; color: var(--muted);
      cursor: pointer;
    }
    .icon svg { width: 22px; height: 22px; stroke: currentColor; }
    .icon.active { color: var(--accent); border-color: var(--accent); }
    .tree {
      border-right: 1px solid var(--border); background: var(--panel-2);
      display: grid; grid-template-rows: auto 1fr; min-width: var(--tree-w-min); max-width: var(--tree-w-max);
      width: var(--tree-w);
    }
    .tree-header { padding: 10px; border-bottom: 1px solid var(--border); display: flex; gap: 8px; align-items: center; }
    .tree-scroll { overflow: auto; padding: 8px; }
    /* CAD-like tree view */
    .treeview [role="tree"] { list-style: none; margin: 0; padding: 4px; }
    .treeview [role="group"] { list-style: none; margin: 0; padding-left: 16px; border-left: 1px dashed var(--border); }
    .treeview li[role="treeitem"] { margin: 2px 0; outline: none; }
    .treeview li[role="treeitem"][aria-expanded="false"] > ul[role="group"] { display: none; }
    .node-row { display: flex; align-items: center; gap: 6px; padding: 4px 6px; border: 1px solid transparent; border-radius: 6px; cursor: default; }
    .node-row:hover { background: #0d1426; border-color: var(--border); }
    .node-row.selected { background: #0f1a33; border-color: var(--accent); }
    .twist { width: 12px; text-align: center; color: var(--muted); user-select: none; }
    li[role="treeitem"][aria-expanded="false"] > .node-row .twist::before { content: '▸'; }
    li[role="treeitem"][aria-expanded="true"] > .node-row .twist::before { content: '▾'; }
    li[role="treeitem"]:not([aria-expanded]) > .node-row .twist::before { content: '•'; opacity: .25; }
    .node-icon { width: 14px; height: 14px; border: 1px solid var(--border); border-radius: 3px; background: #0a1120; }
    .node-icon.folder { background: linear-gradient(180deg, #0f1a33, #0c1529); }
    .node-icon.req { background: #1b2a45; }
    .node-icon.doc { background: #1b2a45; border-style: dashed; }
    .node-icon.out { background: #1b2a45; border-color: #2a3b5f; }
    .node-icon.docreq { background: #263b61; border-color: #3b5a8f; }
    .node-icon.docknow { background: #2a3f5f; border-color: #4a6a9a; }
    .node-icon.onto { background: #22304f; border-color: #39507a; }
    .node-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .resizer {
      width: 6px; cursor: col-resize; background: transparent; position: relative;
    }
    .resizer::after { content: ""; position: absolute; inset: 0; }
    .main {
      padding: 12px; overflow: auto;
    }
    .workbench { display: none; }
    .workbench.active { display: block; }
    .status-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }
    .ok { background: var(--ok); } .warn { background: var(--warn); } .err { background: var(--err); }
    .muted { color: var(--muted); }
    /* Ontology Workbench */
    .ontology-toolbar { display: flex; gap: 8px; align-items: center; margin: 8px 0 12px 0; }
    #cy { width: 100%; min-width: 0; height: calc(100vh - var(--toolbar-h) - var(--bottombar-h) - 140px); min-height: 360px; border: 1px solid var(--border); border-radius: 8px; background: #0a0f1f; }
    .onto-layout { display: grid; grid-template-columns: var(--onto-tree-w) var(--onto-tree-divider-w, 6px) var(--onto-iconbar-w) minmax(0, 1fr) var(--onto-props-divider-w, 6px) var(--onto-props-w); gap: 0; align-items: stretch; overflow: hidden; width: 100%; }
    /* Inline editor for canvas labels */
    #ontoInlineEdit { position: fixed; z-index: 9999; display: none; background: #0b1220; color: #e5e7eb; border: 1px solid var(--accent); border-radius: 6px; padding: 4px 6px; font: inherit; }
    /* Fullscreen adjustments */
    #wb-ontology:fullscreen #cy { height: calc(100vh - 140px); }
    /* Context menu */
    .onto-menu { position: fixed; z-index: 9999; display: none; min-width: 160px; background: #0b1220; color: #e5e7eb; border: 1px solid var(--border); border-radius: 8px; box-shadow: 0 8px 24px rgba(0,0,0,.4); }
    .onto-menu button { width: 100%; background: transparent; color: #e5e7eb; border: none; text-align: left; padding: 8px 10px; cursor: pointer; }
    .onto-menu button:hover { background: #0f172a; }
    .connect-source { outline: 2px dashed var(--accent); outline-offset: 2px; }
    /* Pin children to explicit grid columns so hiding resizers doesn't shift layout */
    .onto-layout > .onto-tree { grid-column: 1; }
    .onto-layout > #ontoResizer { grid-column: 2; }
    .onto-layout > .onto-iconbar { grid-column: 3; }
    .onto-layout > #cy { grid-column: 4; }
    .onto-layout > #ontoPropsResizer { grid-column: 5; }
    .onto-layout > .onto-props { grid-column: 6; }
    .onto-iconbar { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 8px 6px; display: flex; flex-direction: column; align-items: center; gap: 8px; height: calc(100vh - var(--toolbar-h) - var(--bottombar-h) - 140px); }
    .onto-icon { width: 40px; height: 40px; border-radius: 8px; border: 1px solid var(--border); background: var(--panel-2); display: grid; place-items: center; color: var(--muted); cursor: grab; }
    .onto-icon svg { width: 22px; height: 22px; stroke: currentColor; }
    .onto-tree { border: 1px solid var(--border); background: var(--panel-2); border-radius: 8px; display: grid; grid-template-rows: auto 1fr; min-width: 0; }
    .onto-tree-header { padding: 8px; border-bottom: 1px solid var(--border); display: flex; gap: 8px; align-items: center; position: sticky; top: 0; z-index: 1; background: var(--panel-2); }
    .onto-tree-scroll { overflow: auto; padding: 8px; }
    .onto-treeview [role="tree"] { list-style: none; margin: 0; padding: 4px; }
    .onto-treeview [role="group"] { list-style: none; margin: 0; padding-left: 16px; border-left: 1px dashed var(--border); }
    .onto-treeview li[role="treeitem"] { margin: 2px 0; outline: none; }
    .onto-treeview li[role="treeitem"][aria-expanded="false"] > ul[role="group"] { display: none; }
    .onto-node-row { display: flex; align-items: center; gap: 6px; padding: 4px 6px; border: 1px solid transparent; border-radius: 6px; cursor: pointer; }
    .onto-node-row:hover { background: #0d1426; border-color: var(--border); }
    .onto-node-row.selected { background: #0f1a33; border-color: var(--accent); }
    .onto-twist { width: 12px; text-align: center; color: var(--muted); user-select: none; }
    li[role="treeitem"][aria-expanded="false"] > .onto-node-row .onto-twist::before { content: '▸'; }
    li[role="treeitem"][aria-expanded="true"] > .onto-node-row .onto-twist::before { content: '▾'; }
    li[role="treeitem"]:not([aria-expanded]) > .onto-node-row .onto-twist::before { content: '•'; opacity: .25; }
    .onto-node-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .onto-resizer { width: 6px; cursor: col-resize; background: transparent; position: relative; }
    .onto-resizer::after { content: ""; position: absolute; inset: 0; }
    /* Collapsed tree mode */
    #wb-ontology.onto-tree-collapsed .onto-tree { overflow: hidden; }
    #wb-ontology.onto-tree-collapsed .onto-tree-header .muted { display: none; }
    #wb-ontology.onto-tree-collapsed .onto-tree-scroll { display: none; }
    /* Keep the collapse chevron visible and prevent overlap */
    #wb-ontology.onto-tree-collapsed .onto-tree { z-index: 2; }
    .onto-iconbar { z-index: 1; }
    #wb-ontology.onto-tree-collapsed #ontoResizer { display: none; }
    /* Collapse behavior: shrink tree width to rail without affecting tools/canvas/props */
    #wb-ontology.onto-tree-collapsed { --onto-tree-w: var(--onto-tree-collapsed-w); --onto-tree-divider-w: 0px; }
    .iconbtn { background: #0b1220; color: var(--text); border: 1px solid var(--border); width: 28px; height: 28px; border-radius: 8px; display: grid; place-items: center; cursor: pointer; }
    .iconbtn svg { width: 16px; height: 16px; stroke: currentColor; transition: transform 160ms ease; }
    /* Left panel chevron: right when collapsed, left when expanded */
    #wb-ontology.onto-tree-collapsed #ontoTreeToggleIcon { transform: rotate(0deg); }
    #wb-ontology:not(.onto-tree-collapsed) #ontoTreeToggleIcon { transform: rotate(180deg); }
    #wb-ontology.onto-tree-collapsed .onto-tree-header { padding: 4px !important; justify-content: center !important; }

    /* Properties panel */
    .onto-props { border: 1px solid var(--border); background: var(--panel-2); border-radius: 8px; display: grid; grid-template-rows: auto 1fr; min-width: 0; }
    .onto-props-header { padding: 8px; border-bottom: 1px solid var(--border); display: flex; gap: 8px; align-items: center; position: sticky; top: 0; z-index: 1; background: var(--panel-2); justify-content: space-between; }
    .onto-props-scroll { overflow: auto; padding: 8px; }
    #wb-ontology.onto-props-collapsed .onto-props-header .muted { display: none; }
    #wb-ontology.onto-props-collapsed .onto-props-header { padding: 4px !important; justify-content: center !important; }
    #wb-ontology.onto-props-collapsed .onto-props-scroll { display: none; }
    #wb-ontology.onto-props-collapsed #ontoPropsResizer { display: none; }
    #wb-ontology.onto-props-collapsed { --onto-props-w: var(--onto-props-collapsed-w); --onto-props-divider-w: 0px; }
    #wb-ontology.onto-props-collapsed .onto-props { width: var(--onto-props-collapsed-w); min-width: var(--onto-props-collapsed-w); max-width: var(--onto-props-collapsed-w); }
    /* Right panel chevron: left when collapsed, right when expanded */
    #wb-ontology.onto-props-collapsed #ontoPropsToggleIcon { transform: rotate(180deg); }
    #wb-ontology:not(.onto-props-collapsed) #ontoPropsToggleIcon { transform: rotate(0deg); }
    .login {
      display: grid; place-items: center; height: calc(100vh - var(--toolbar-h) - var(--bottombar-h));
    }
    /* Keep login card narrow without constraining other cards */
    #authView .card { width: 360px; }
    .card { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 16px; }
    .row { display: grid; gap: 6px; margin-bottom: 10px; }
    input[type="text"], input[type="password"] {
      background: #0b1220; color: var(--text); border: 1px solid var(--border); padding: 8px; border-radius: 6px;
    }
    /* DAS dock styles */
    .das-panel {
      position: fixed;
      z-index: 9000;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      display: none;
      color: var(--text);
    }
    .das-panel.active { display: grid; grid-template-rows: var(--das-toolbar-h) 1fr; }
    .das-toolbar {
      height: var(--das-toolbar-h);
      display: flex; gap: 8px; align-items: center;
      padding: 6px 10px;
      border-bottom: 1px solid var(--border);
      background: var(--panel-2);
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
    }
    .das-body { padding: 8px; overflow: auto; }
    .das-dock-right { right: 8px; top: 0; bottom: 0; width: var(--das-w); }
    .das-dock-left { left: 8px; top: 0; bottom: 0; width: var(--das-w); }
    .das-dock-bottom { left: 8px; right: 8px; bottom: 8px; height: var(--das-h); }
    .das-resizer-x { position: absolute; top: 0; bottom: 0; width: 6px; cursor: col-resize; }
    .das-resizer-y { position: absolute; left: 0; right: 0; height: 6px; cursor: row-resize; }
    .das-dock-right .das-resizer-x { left: -3px; }
    .das-dock-left .das-resizer-x { right: -3px; }
    .das-dock-bottom .das-resizer-y { top: -3px; }
    .das-toolbar .spacer { flex: 1; }
    .das-help { font-size: 12px; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60%; }
    /* When DAS is open, shift the app layout to avoid overlap */
    body.das-open-right #app { margin-right: calc(var(--das-w) + 16px); }
    body.das-open-left #app { margin-left: calc(var(--das-w) + 16px); }
    body.das-open-bottom #app { padding-bottom: calc(var(--das-h) + 16px); }
  </style>
  <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/cytoscape-edgehandles@4.0.1/cytoscape-edgehandles.min.js"></script>
  </head>
  <body>
  <div id="app" class="layout">
    <div class="topbar">
      <div class="brand">ODRAS</div>
      <div class="spacer"></div>
      
      <div class="spacer"></div>
      <div id="userMenu" class="muted"></div>
      <button class="btn" id="logoutBtn">Logout</button>
    </div>

    <div id="authView" class="login" style="display:none;">
      <div class="card">
        <h3 style="margin:0 0 8px 0;">Sign in</h3>
        <div class="row"><label>Username</label><input id="u" type="text" /></div>
        <div class="row"><label>Password</label><input id="p" type="password" /></div>
        <button class="btn" id="loginBtn">Login</button>
        <div id="loginMsg" class="muted" style="margin-top:8px;"></div>
      </div>
    </div>

    <div id="mainView" class="content" style="display:none;">
      <nav class="iconbar" aria-label="Workbench">
        <div class="icon active" data-wb="ontology" title="Ontology" aria-label="Ontology">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="6" cy="6" r="2"/>
            <circle cx="18" cy="6" r="2"/>
            <circle cx="6" cy="18" r="2"/>
            <circle cx="18" cy="18" r="2"/>
            <path d="M8 6h8M6 8v8M18 8v8M8 18h8"/>
          </svg>
        </div>
        <div class="icon" data-wb="files" title="Files" aria-label="Files">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 7h5l2 2h11v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z"/>
          </svg>
        </div>
        <div class="icon" data-wb="knowledge" title="Knowledge Management" aria-label="Knowledge Management">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"/>
            <path d="M12 1v6"/>
            <path d="M12 17v6"/>
            <path d="m4.2 4.2 4.2 4.2"/>
            <path d="m15.6 15.6 4.2 4.2"/>
            <path d="M1 12h6"/>
            <path d="M17 12h6"/>
            <path d="m4.2 19.8 4.2-4.2"/>
            <path d="m15.6 8.4 4.2-4.2"/>
          </svg>
        </div>
        <div class="icon" data-wb="requirements" title="Requirements" aria-label="Requirements">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 7h11M9 12h11M9 17h11"/>
            <path d="M4 7l1 1 2-2M4 12l1 1 2-2M4 17l1 1 2-2"/>
          </svg>
        </div>
        <div class="icon" data-wb="graph" title="GraphDB" aria-label="GraphDB">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <ellipse cx="12" cy="5" rx="8" ry="3"/>
            <path d="M4 5v10c0 1.7 3.6 3 8 3s8-1.3 8-3V5"/>
            <path d="M4 12c0 1.7 3.6 3 8 3s8-1.3 8-3"/>
          </svg>
        </div>
        <div class="icon" data-wb="rag" title="RAG" aria-label="RAG">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="6"/>
            <path d="M20 20l-4-4"/>
          </svg>
        </div>
        <div class="icon" data-wb="process" title="Process" aria-label="Process">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <rect x="4" y="4" width="8" height="6" rx="1"/>
            <rect x="12" y="14" width="8" height="6" rx="1"/>
            <path d="M8 10v4M8 14h8M16 14v-4"/>
          </svg>
        </div>
        <div class="icon" data-wb="thread" title="Thread" aria-label="Thread">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <rect x="4" y="4" width="16" height="12" rx="2"/>
            <path d="M8 16l-4 4v-4"/>
            <path d="M8 8h8M8 12h6"/>
          </svg>
        </div>
        <div class="icon" data-wb="playground" title="Playground" aria-label="Playground">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 3h6"/>
            <path d="M10 3v4l-5 9a3 3 0 0 0 3 5h8a3 3 0 0 0 3-5l-5-9V3"/>
            <path d="M8 15h8"/>
          </svg>
        </div>
        <div class="icon" data-wb="admin" title="Admin" aria-label="Admin">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 3l8 4v6c0 5-5 8-8 8s-8-3-8-8V7l8-4z"/>
          </svg>
        </div>
      </nav>

      <aside class="tree" id="treePanel" aria-label="Project Tree">
        <div class="tree-header">
          <select id="projectSelect2" title="Active project"></select>
          <button class="btn" id="addNodeBtn" title="New Project">＋</button>
        </div>
        <div class="tree-scroll">
          <nav class="treeview" aria-label="Project">
            <ul role="tree" id="treeRoot" aria-label="Project tree"></ul>
          </nav>
        </div>
      </aside>
      <!-- Project context menu -->
      <div id="projectContextMenu" style="position:absolute; display:none; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding:4px; z-index: 9999; min-width: 220px;">
        <button id="projRenameBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Rename Project…</button>
        <button id="projArchiveBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Archive Project</button>
        <button id="projDeleteBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:#ef4444;">Delete Project</button>
        <hr style="border:none; border-top:1px solid var(--border); margin:6px 0;"/>
        <button id="projShowArchivedBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Archived…</button>
      </div>

      <div class="resizer" id="resizer" aria-hidden="true"></div>

      <main class="main">
        <section id="wb-ontology" class="workbench">
          <h2>Ontology Workbench</h2>
          <div class="ontology-toolbar">
            <span id="ontoGraphLabel" class="muted" style="max-width:55%; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">No graph selected</span>
            <div class="spacer"></div>
            <button class="btn" id="ontoLayoutBtn" title="Auto layout">Layout</button>
            <button class="btn" id="ontoFitBtn" title="Fit to view">Fit</button>
            <button class="btn" id="ontoFullscreenBtn" title="Enter fullscreen">Fullscreen</button>
            <button class="btn" id="ontoDeleteBtn" title="Delete selected">Delete</button>
            <button class="btn" id="ontoLinkIdenticalBtn" title="Link identical classes">Link</button>
            <button class="btn" id="ontoSaveBtn" title="Save ontology to Fuseki">Save</button>
            <button class="btn" id="ontoImportBtn" title="Import graph JSON">Import</button>
            <button class="btn" id="ontoExportBtn" title="Export graph JSON">Export</button>
            <input type="file" id="ontoImportFile" accept="application/json" style="display:none" />
          </div>
          <div id="ontoEmpty" class="card" style="margin-top:10px; display:none;">
            Create or Select an Ontology to begin
          </div>
          <div class="onto-layout" id="ontoLayoutSection">
            <aside class="onto-tree" aria-label="Ontology Tree">
              <div class="onto-tree-header" id="ontoTreeHeader" style="display:flex; justify-content:space-between; align-items:center;">
                <div class="muted">Ontology</div>
                <button class="iconbtn" id="ontoTreeToggle" title="Collapse">
                  <svg id="ontoTreeToggleIcon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M9 6l6 6-6 6"/></svg>
                </button>
              </div>
              <div class="onto-tree-scroll">
                <nav class="onto-treeview" aria-label="Ontology">
                  <ul role="tree" id="ontoTreeRoot" aria-label="Ontology tree"></ul>
                </nav>
              </div>
            </aside>
            <div class="onto-resizer" id="ontoResizer" aria-hidden="true"></div>
            <aside class="onto-iconbar" aria-label="Ontology Tools">
              <div class="onto-icon" draggable="true" data-onto-type="class" title="Class">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
              </div>
              <div class="onto-icon" draggable="true" data-onto-type="objectProperty" title="Object Property">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="12" r="3"/><circle cx="17" cy="12" r="3"/><path d="M10 12h4"/></svg>
              </div>
              <div class="onto-icon" draggable="true" data-onto-type="dataProperty" title="Data Property">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="12" r="3"/><rect x="14" y="9" width="6" height="6" rx="1"/></svg>
              </div>
              <div class="onto-icon" draggable="true" data-onto-type="note" title="Note">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h12l4 4v12H4z"/><path d="M16 4v4h4"/></svg>
              </div>
            </aside>
            <div id="cy" role="application" aria-label="Ontology Graph Canvas"></div>
            <div class="onto-resizer" id="ontoPropsResizer" aria-hidden="true"></div>
            <aside class="onto-props" aria-label="Properties Panel">
              <div class="onto-props-header" id="ontoPropsHeader">
                <div class="muted">Properties</div>
                <button class="iconbtn" id="ontoPropsToggle" title="Collapse">
                  <svg id="ontoPropsToggleIcon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M9 6l6 6-6 6"/></svg>
                </button>
              </div>
              <div class="onto-props-scroll">
                <form id="ontoPropsForm" style="display:grid; gap:8px;">
                  <div>
                    <label class="muted" for="propName">Name</label>
                    <input id="propName" type="text" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;" />
                  </div>
                  <div>
                    <label class="muted" for="propType">Type</label>
                    <select id="propType" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
                      <option value="class">Class</option>
                      <option value="objectProperty">Object Property</option>
                      <option value="dataProperty">Data Property</option>
                      <option value="note">Note</option>
                      <option value="model">Model</option>
                    </select>
                  </div>
                  <div>
                    <label class="muted" for="propAttrs">Attributes (JSON)</label>
                    <textarea id="propAttrs" rows="6" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;"></textarea>
                  </div>
                  <div style="display:flex; gap:8px;">
                    <button type="button" class="btn" id="propSaveBtn">Save</button>
                    <span id="propSaveStatus" class="muted"></span>
                  </div>
                </form>
              </div>
            </aside>
          </div>
          <input id="ontoInlineEdit" type="text" />
          <div id="ontoContextMenu" class="onto-menu">
            <button id="menuAddRel">Add relationship</button>
            <button id="menuAddDataProp">Add data property</button>
            <button id="menuCancel">Cancel</button>
          </div>
        </section>
        <section id="wb-files" class="workbench">
          <h2>File Management</h2>
          <div class="muted">Upload requirements and knowledge docs (MinIO).</div>
          <div class="card" style="margin-top:8px;">
            <div class="muted" style="font-weight:600; margin-bottom:6px;">Quick steps</div>
            <ol style="margin:0; padding-left:18px; color:#9aa4b2;">
              <li>Choose Files (or drop) → files appear under Staged files</li>
              <li>Click Upload next to a file (or Upload All)</li>
              <li>Select uploaded file in Library → click 🧠 Knowledge or 📋 Extract Requirements</li>
            </ol>
          </div>
          <div id="filesToast" class="muted" style="margin-top:6px;"></div>
          <div class="files-toolbar" style="display:flex; gap:8px; align-items:center; margin:10px 0; flex-wrap:wrap;">
            <label class="muted" for="filesDocType">Type</label>
            <select id="filesDocType" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
              <option value="">All Types</option>
              <option value="requirements">Requirements</option>
              <option value="knowledge">Knowledge</option>
              <option value="reference">Reference</option>
              <option value="specification">Specification</option>
              <option value="unknown">Unknown</option>
            </select>
            <label class="muted" for="filesStatus">Status</label>
            <select id="filesStatus" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
              <option value="">Any</option>
              <option value="new">New</option>
              <option value="ingested">Ingested</option>
              <option value="embedded">Embedded</option>
            </select>
            <input id="filesTags" type="text" placeholder="tags (comma)" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px; min-width:200px;" />
            <label class="muted"><input type="checkbox" id="filesIncludePublic" /> Include public files</label>
            <button class="btn" id="filesRefreshBtn" title="Refresh">Refresh</button>
            <div class="spacer"></div>
            <button class="btn" id="filesBulkProcessBtn" title="Extract requirements using BPMN workflows">📋 Extract Requirements</button>
            <button class="btn" id="filesBulkIngestBtn" title="Transform into searchable knowledge for AI & semantic search">🧠 Add to Knowledge Base</button>
            <button class="btn" id="filesBulkDeleteBtn" title="Delete selected">Delete Selected</button>
          </div>

          <div class="card" style="margin-top:8px;">
            <div class="muted">Upload or import by URL</div>
            <div style="display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap;">
              <input type="file" id="fileUploadInput" multiple style="display:none" />
              <button class="btn" id="fileChooseBtn" type="button">Choose Files</button>
              <input id="fileUrlInput" type="url" placeholder="https://example.com/doc.pdf" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px; min-width:320px;" />
              <button class="btn" id="fileUrlImportBtn">Import URL</button>
            </div>
            <div id="fileDropZone" tabindex="0" role="button" aria-label="Drop files or click to select" style="margin-top:10px; border:2px dashed var(--border); border-radius:8px; padding:20px; text-align:center; color:#9aa4b2; user-select:none; cursor:pointer; background:rgba(15, 22, 40, 0.3); transition:all 0.2s ease;">
              Drag & drop files here, or use the Choose Files button above
            </div>
            <div id="uploadPreview" class="muted" style="margin-top:6px;"></div>
          </div>

          <div class="card" style="margin-top:10px; display:grid; grid-template-columns: minmax(420px, 1fr) 8px minmax(360px, 420px); gap:0; align-items:stretch;">
            <div style="display:grid; gap:10px;">
              <div>
                <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                  <div class="muted">Staged files</div>
                  <div style="display:flex; gap:8px; align-items:center;">
                    <button class="btn" id="filesUploadAllBtn" type="button">Upload All</button>
                    <button class="btn" id="filesClearStagedBtn" type="button">Clear</button>
                  </div>
                </div>
                
                <!-- Document Type Selector for Staged Files -->
                <div id="stagedDocTypeSelector" style="display:none; margin:6px 0; padding:8px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px;">
                  <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                    <span class="muted" style="font-size:12px;">Set document type for upload:</span>
                    <select id="stagedDocType" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:4px 8px; font-size:12px;">
                      <option value="unknown">Unknown</option>
                      <option value="requirements">Requirements</option>
                      <option value="knowledge">Knowledge</option>
                      <option value="reference">Reference</option>
                      <option value="specification">Specification</option>
                    </select>
                    <button class="btn" id="setStagedDocType" style="padding:4px 8px; font-size:12px;">Apply to All Staged</button>
                    <span class="muted" style="font-size:11px;" id="stagedDocTypeHint">Files will be uploaded with this document type</span>
                  </div>
                </div>
                
                <!-- Knowledge Processing Options -->
                <div id="knowledgeProcessingOptions" style="display:none; margin:6px 0; padding:8px; background:rgba(37, 99, 235, 0.1); border:1px solid var(--accent); border-radius:6px;">
                  <div style="margin-bottom:8px;">
                    <label class="muted" style="display:flex; align-items:center; font-size:12px;">
                      <input type="checkbox" id="enableKnowledgeProcessing" style="margin-right:8px;" /> 
                      🧠 Process for Knowledge Management
                    </label>
                    <div class="muted" style="font-size:10px; margin-left:20px; color:var(--muted);">
                      Transform documents into searchable knowledge with embeddings and semantic chunking
                    </div>
                  </div>
                  <div id="knowledgeProcessingConfig" style="display:none; margin-left:20px; display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                    <div>
                      <label class="muted" style="font-size:10px; display:block; margin-bottom:2px;">Embedding Model:</label>
                      <select id="embeddingModel" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:4px; padding:2px 4px; font-size:10px; width:100%;">
                        <option value="all-MiniLM-L6-v2">all-MiniLM-L6-v2 (Fast)</option>
                        <option value="all-mpnet-base-v2">all-mpnet-base-v2 (Better)</option>
                      </select>
                    </div>
                    <div>
                      <label class="muted" style="font-size:10px; display:block; margin-bottom:2px;">Chunking Strategy:</label>
                      <select id="chunkingStrategy" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:4px; padding:2px 4px; font-size:10px; width:100%;">
                        <option value="hybrid">Hybrid (Recommended)</option>
                        <option value="semantic">Semantic</option>
                        <option value="fixed">Fixed Size</option>
                      </select>
                    </div>
                  </div>
                </div>
                
                <div id="stagedList" style="display:grid; gap:6px; margin-top:6px;"></div>
              </div>
              <div>
                <div class="muted" style="margin-bottom:6px;">Library</div>
                <div id="filesList" style="display:block; overflow:auto;"></div>
              </div>
            </div>
            <div style="width:8px; cursor:col-resize;" id="filesSplitResizer" aria-hidden="true"></div>
            <aside id="filePreviewPane" style="border-left:1px solid var(--border); padding-left:10px; overflow:auto;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                <div class="muted">Preview</div>
                <div id="previewControls" style="display:flex; gap:6px; align-items:center;">
                  <button class="btn" id="previewFullscreenBtn" title="Fullscreen preview" style="min-width:auto; padding:6px 8px; font-size:14px; background:var(--panel-2); border:1px solid var(--border); color:var(--text);">⛶</button>
                  <button class="btn" id="previewPopoutBtn" title="Open in new window" style="display:none; min-width:auto; padding:6px 8px; font-size:14px; background:var(--panel-2); border:1px solid var(--border); color:var(--text);">↗</button>
                </div>
              </div>
              <div id="fileMetaBox" class="card" style="margin-bottom:8px;">
                <div class="muted">Metadata</div>
                <div id="fileMetaContent" class="muted">Select a file to see metadata.</div>
              </div>
              <div class="card">
                <div class="muted" style="margin-bottom:6px;">Content</div>
                <div id="filePreviewContent" class="muted">Select a file to preview.</div>
              </div>
              <div class="card" style="margin-top:8px;">
                <div class="muted" style="margin-bottom:6px;">Recent Runs</div>
                <div id="fileRunsContent" class="muted">No runs yet.</div>
              </div>
            </aside>
          </div>
        </section>
        
        <!-- Files: Ingestion Params Modal -->
        <div id="ingestParamsModal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); z-index:9999;">
          <div style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:10px; width:460px; max-width:90vw; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,0.4);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <h3 style="margin:0; font-size:16px;">🧠 Knowledge Processing Parameters</h3>
              <button class="btn" id="ingestParamsCloseBtn" style="min-width:auto;">✕</button>
            </div>
            <div style="display:grid; gap:10px;">
              <div style="display:grid; gap:6px;">
                <label class="muted">Chunking</label>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                  <div>
                    <label class="muted" for="ing_chunk_size">Size (tokens)</label>
                    <input id="ing_chunk_size" type="number" value="350" min="50" max="2000" step="10" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;" />
                  </div>
                  <div>
                    <label class="muted" for="ing_chunk_overlap">Overlap (tokens)</label>
                    <input id="ing_chunk_overlap" type="number" value="50" min="0" max="500" step="5" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;" />
                  </div>
                </div>
                <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
                  <label><input type="checkbox" id="ing_respect_headings" checked /> Respect headings</label>
                  <label><input type="checkbox" id="ing_join_short" checked /> Join short paragraphs</label>
                  <label><input type="checkbox" id="ing_split_code" checked /> Split code blocks</label>
                </div>
              </div>
              <div style="display:grid; gap:6px;">
                <label class="muted">Embedding</label>
                <select id="ing_model_id" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
                  <option value="simple-hasher">Simple Hasher (Testing)</option>
                  <option value="all-MiniLM-L6-v2" selected>all-MiniLM-L6-v2 (384 dim)</option>
                  <option value="all-mpnet-base-v2">all-mpnet-base-v2 (768 dim)</option>
                  <option value="text-embedding-3-small">OpenAI text-embedding-3-small (1536 dim)</option>
                  <option value="text-embedding-3-large">OpenAI text-embedding-3-large (3072 dim)</option>
                </select>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                  <div>
                    <label class="muted" for="ing_batch_size">Batch size</label>
                    <input id="ing_batch_size" type="number" value="64" min="1" max="1000" step="1" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;" />
                  </div>
                  <div style="display:flex; align-items:center; padding-top:20px;">
                <label><input type="checkbox" id="ing_normalize" checked /> Normalize vectors</label>
                  </div>
                </div>
              </div>
              <div style="display:flex; gap:8px; justify-content:flex-end;">
                <button class="btn" id="ingestParamsCancelBtn">Cancel</button>
                <button class="btn" id="ingestParamsStartBtn">Start</button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Fullscreen Preview Modal -->
        <div id="previewFullscreenModal" style="position:fixed; inset:0; display:none; background:rgba(0,0,0,0.95); z-index:10000; padding:20px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <div id="fullscreenPreviewTitle" style="color:#e5e7eb; font-weight:600; font-size:16px;">Document Preview</div>
            <div style="display:flex; gap:8px;">
              <button class="btn" id="fullscreenPopoutBtn" title="Open in new window" style="display:none; min-width:auto; padding:6px 12px;">↗ Popout</button>
              <button class="btn" id="fullscreenCloseBtn" title="Close fullscreen" style="min-width:auto; padding:6px 12px;">✕ Close</button>
            </div>
          </div>
          <div id="fullscreenPreviewContent" style="width:100%; height:calc(100vh - 80px); background:var(--panel); border:1px solid var(--border); border-radius:8px; overflow:hidden;">
            <!-- Preview content will be cloned here -->
          </div>
        </div>
        
        <section id="wb-knowledge" class="workbench">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <div>
              <h2>Knowledge Management</h2>
              <div class="muted">Transform documents into searchable knowledge with AI-powered insights</div>
            </div>
            <div style="display:flex; gap:8px;">
              <button class="btn" id="knowledgeProcessBtn" disabled>Process Documents</button>
              <button class="btn" id="knowledgeRefreshBtn">Refresh</button>
            </div>
          </div>

          <div style="display:grid; grid-template-columns: 2fr 1fr; gap:20px; height:calc(100vh - 200px);">
            <!-- Main Knowledge Area -->
            <div style="display:flex; flex-direction:column; gap:16px;">
              <!-- Knowledge Assets List -->
              <div style="flex:1; background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:16px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                  <h3 style="margin:0;">Knowledge Assets</h3>
                  <div style="display:flex; gap:8px; align-items:center;">
                    <input type="text" id="knowledgeSearchInput" placeholder="Search knowledge..." style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px 10px; width:200px;"/>
                  </div>
                </div>
                <div id="knowledgeAssetsList" style="height:calc(100% - 60px); overflow-y:auto;">
                  <div class="muted" style="padding:20px; text-align:center;">
                    No knowledge assets yet.<br/>
                    <small>Upload and process documents to begin building your knowledge base.</small>
                  </div>
                </div>
              </div>

              <!-- Processing Status -->
              <div style="background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:16px; height:120px;">
                <h4 style="margin:0 0 8px 0;">Processing Status</h4>
                <div id="knowledgeProcessingStatus">
                  <div class="muted">No processing jobs running</div>
                </div>
              </div>
            </div>

            <!-- Knowledge Panel -->
            <div style="background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:16px; display:flex; flex-direction:column;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                <h4 style="margin:0;">Knowledge Details</h4>
                <div style="display:flex; gap:4px;">
                  <button class="btn" id="knowledgeQueryBtn" title="Query Knowledge" style="min-width:auto; padding:4px 8px; font-size:16px;">🔍</button>
                  <button class="btn" id="knowledgeGraphBtn" title="View Graph" style="min-width:auto; padding:4px 8px; font-size:16px;">🕸️</button>
                </div>
              </div>
              <div id="knowledgeDetailsContent" style="flex:1; overflow-y:auto;">
                <div class="muted" style="padding:20px; text-align:center;">
                  Select a knowledge asset to view details
                </div>
              </div>
            </div>
          </div>
        </section>
        <section id="wb-requirements" class="workbench">
          <h2>Requirements</h2>
          <div class="muted">Extraction rules, SME review, LLM critique.</div>
        </section>
        <section id="wb-graph" class="workbench">
          <h2>Graph Explorer</h2>
          <div class="muted">Quick look into RDF store (SPARQL).
            <button class="btn" id="btnRefreshSummary" style="margin-left:8px;">Refresh Summary</button>
          </div>
          <div id="graphSummary" class="card" style="margin-top:10px;"></div>
          <div class="card" style="margin-top:10px;">
            <div class="muted">Run SPARQL (SELECT):</div>
            <textarea id="sparqlInput" rows="6" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:8px;">SELECT ?s ?p ?o WHERE { ?s ?p ?o } LIMIT 25</textarea>
            <div style="margin-top:6px; display:flex; gap:8px; align-items:center;">
              <button class="btn" id="btnRunSparql">Run</button>
              <span id="sparqlStatus" class="muted"></span>
            </div>
            <pre id="sparqlResult" style="margin-top:8px; white-space:pre-wrap;"></pre>
          </div>
        </section>
        <section id="wb-rag" class="workbench">
          <h2>RAG</h2>
          <div class="muted">Develop/test BPMN workflows with LLM help.</div>
        </section>
        <section id="wb-process" class="workbench">
          <h2>Process</h2>
          <div class="muted">Manage extraction BPMN processes.</div>
        </section>
        <section id="wb-thread" class="workbench">
          <h2>Thread Workbench</h2>
          <div class="muted">Chronological, project-scoped thread of tasks, user actions, and system events.</div>
        </section>
        <section id="wb-playground" class="workbench">
          <h2>LLM Playground</h2>
          <div class="muted">Ask questions, generate white papers, save to project.</div>
        </section>
        <section id="wb-admin" class="workbench">
          <h2>Admin</h2>
          <div class="muted">Users, projects overview (read-only for MVP).</div>
        </section>
      </main>
    </div>

    <div class="bottombar">
      <span><span class="status-dot ok"></span>Camunda</span>
      <span><span class="status-dot ok"></span>Fuseki</span>
      <span><span class="status-dot ok"></span>Vector</span>
      <span class="spacer"></span>
      <span class="muted">UI Restart Prototype</span>
    </div>
  </div>

  <!-- DAS docked panel scaffold -->
  <section id="dasPanel" class="das-panel das-dock-right" aria-label="Digital Assistant">
    <div class="das-toolbar">
      <strong>DAS</strong>
      <span class="muted" id="dasStatus" style="margin-left:8px;">Idle</span>
      <div class="spacer"></div>
      <span class="das-help">Ctrl+Alt+D (or Alt+Shift+D) to toggle; <br>Alt+Shift+←/→/↓ to dock</span>
    </div>
    <div class="das-body" id="dasBody">
      <div class="card" style="margin-bottom:8px;">
        <div class="row" style="grid-template-columns: 1fr auto; align-items:center;">
          <input type="text" id="dasPrompt" placeholder="Type a prompt..." />
          <button class="btn" id="dasSendBtn" type="button">Send</button>
        </div>
        <div class="muted">Scaffold only — integration pending.</div>
      </div>
      <div id="dasTranscript" style="display:grid; gap:8px;"></div>
    </div>
    <div class="das-resizer-x" id="dasResizerX" aria-hidden="true"></div>
    <div class="das-resizer-y" id="dasResizerY" aria-hidden="true"></div>
  </section>

  <script>
    const qs = (s, r = document) => r.querySelector(s);
    const qsa = (s, r = document) => Array.from(r.querySelectorAll(s));
    function debounce(fn, wait) {
      let t; return function(...args){ clearTimeout(t); t = setTimeout(()=>fn.apply(this,args), wait); };
    }
    // Ensure we persist canvas before unload/refresh
    window.addEventListener('beforeunload', () => { try { if (ontoState && ontoState.cy && activeOntologyIri) persistOntologyToLocalStorage(); } catch(_) {} });

    // Ontology workbench state
    const ontoState = { cy: null, eh: null, connectMode: false, clickConnectFrom: null, nextId: 1, currentPredicateType: 'objectProperty', isCanvasActive: false };
    let activeProject = null;
    let suppressWorkbenchSwitch = false;
    let activeOntologyIri = null;

    function updateOntoGraphLabel() {
      const el = qs('#ontoGraphLabel');
      if (!el) return;
      if (activeOntologyIri) {
        el.textContent = 'Graph: ' + activeOntologyIri;
        el.title = activeOntologyIri;
      } else {
        el.textContent = 'No graph selected';
        el.title = '';
      }
      // Toggle empty-state hint
      const empty = qs('#ontoEmpty');
      const layout = qs('#ontoLayoutSection');
      if (empty && layout) {
        const showEmpty = !activeOntologyIri;
        empty.style.display = showEmpty ? 'block' : 'none';
        layout.style.display = showEmpty ? 'none' : 'grid';
      }
    }

    function slugify(str) {
      try {
        return String(str || '')
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-+|-+$/g, '') || 'ontology';
      } catch (_) { return 'ontology'; }
    }

    function computeOntologyIri(projectId, name, version) {
      const pid = encodeURIComponent(projectId || 'project');
      const n = slugify(name || 'ontology');
      const ver = version ? ('/v' + encodeURIComponent(version)) : '';
      return `http://odras.local/onto/${pid}/${n}${ver}`;
    }

    function handleTreeSelection(li) {
      if (!li || !li.dataset) return;
      const type = li.dataset.nodeType || '';
      if (type === 'ontology') {
        const iri = li.dataset.iri;
        if (iri) {
          // Save previous active ontology canvas before switching
          const prevIri = activeOntologyIri;
          ensureOntologyInitialized();
          if (ontoState.cy && prevIri) {
            saveGraphToLocal(prevIri);
          }
          // Switch active ontology
          activeOntologyIri = iri;
          try {
            const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
            localStorage.setItem(`onto_active_iri__${pid}`, iri);
            // Set model name for properties panel based on discovered label or IRI tail
            const friendly = (li.dataset.label && li.dataset.label.trim()) || iri.split('/').pop() || iri;
            localStorage.setItem(`onto_model_name__${pid}`, friendly);
            // Also store display label and graph in model attributes
            let attrs = {};
            try { attrs = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}'); } catch(_) { attrs = {}; }
            attrs.displayLabel = friendly;
            attrs.graphIri = iri;
            localStorage.setItem(`onto_model_attrs__${pid}`, JSON.stringify(attrs));
            // Keep project-scoped label map in sync so the top node reflects selection
            try { saveOntologyLabel(iri, friendly); } catch(_) {}
          } catch(_) {}
          updateOntoGraphLabel();
          // Load new graph from local storage if present
          if (ontoState.cy) {
            // Avoid racing autosave during restore
            ontoState.suspendAutosave = true;
            try { ontoState.cy.elements().remove(); } catch(_) {}
            loadGraphFromLocal(iri);
            setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
          }
          // Show model-level props when nothing selected
          updatePropertiesPanelFromSelection();
          // Rebuild ontology tree (top node label and contents)
          try { refreshOntologyTree(); } catch(_) {}
          // Switch to Ontology workbench view unless suppressed during restore
          if (!suppressWorkbenchSwitch) {
            const ico = document.querySelector('.icon[data-wb="ontology"]');
            if (ico && !document.querySelector('#wb-ontology.workbench.active')) {
              ico.click();
            }
          }
          // Reflect in hash for deep-linking (preserve current workbench)
          try {
            const params = new URLSearchParams(location.hash.replace(/^#/, ''));
            const wb = localStorage.getItem('active_workbench') || 'ontology';
            params.set('wb', wb);
            params.set('graph', encodeURIComponent(iri));
            location.hash = params.toString();
          } catch(_) {}
        }
      }
    }
    function ensureOntologyInitialized() {
      if (ontoState.cy) return;
      const container = qs('#cy');
      if (!container) return;
      // Make canvas focusable for keyboard events (Delete)
      try { container.setAttribute('tabindex', '0'); container.style.outline = 'none'; } catch(_) {}
      try {
        if (window.cytoscape && (window.cytoscapeEdgehandles || window.edgehandles)) {
          const plugin = window.cytoscapeEdgehandles || window.edgehandles;
          if (plugin && typeof plugin === 'function') window.cytoscape.use(plugin);
        }
      } catch (_) {}
      ontoState.cy = cytoscape({
        container,
        layout: { name: 'grid', padding: 10, avoidOverlap: true },
        style: [
          { selector: 'node', style: {
            'shape': 'round-rectangle',
            'background-color': '#1b2a45',
            'border-color': '#2a3b5f',
            'border-width': 1,
            'label': 'data(label)',
            'color': '#e5e7eb',
            'font-size': 12,
            'text-wrap': 'wrap',
            'text-max-width': 180,
            'text-valign': 'center',
            'text-halign': 'center'
          }},
          { selector: 'node[type = "class"]', style: { 'width': 180, 'height': 56 } },
          { selector: 'node[type = "dataProperty"]', style: {
            'width': 160,
            'height': 48,
            'background-color': '#154e5a',
            'border-color': '#2ea3b0'
          } },
          { selector: 'edge', style: {
            'curve-style': 'bezier',
            'width': 2,
            'line-color': '#3b4a6b',
            'target-arrow-shape': 'triangle',
            'target-arrow-color': '#3b4a6b',
            'arrow-scale': 1,
            'label': 'data(predicate)',
            'color': '#e5e7eb',
            'font-size': 10,
            'text-rotation': 'autorotate',
            'text-background-color': '#0b1220',
            'text-background-opacity': 0.6,
            'text-background-padding': 2
          }},
          { selector: '.imported', style: {
            'opacity': 0.55
          }},
          { selector: 'edge.imported', style: { 'line-style': 'dashed' } },
          { selector: 'edge.imported-equivalence', style: {
            'line-style': 'dotted',
            'width': 1.5,
            'line-color': '#60a5fa',
            'label': '≡',
            'color': '#9ca3af',
            'font-size': 9,
            'text-background-opacity': 0
          } },
          { selector: 'node[type = "note"], .note', style: {
            'shape': 'round-rectangle',
            'background-color': '#2a1f0a',
            'border-color': '#8b5a1e',
            'border-style': 'dashed',
            'border-width': 1,
            'label': 'data(label)',
            'color': '#f5e6cc',
            'font-size': 12,
            'text-wrap': 'wrap',
            'text-max-width': 220,
            'text-valign': 'center',
            'text-halign': 'center',
            'width': 220, 'height': 80
          }},
          { selector: ':selected', style: {
            'border-color': '#60a5fa',
            'border-width': 2,
            'line-color': '#60a5fa',
            'target-arrow-color': '#60a5fa'
          }}
        ],
        elements: []
      });
      window._cy = ontoState.cy;
      ontoState.nextId = 1;
      // Focus canvas on interaction so Delete works reliably
      ontoState.cy.on('tap', () => { try { container.focus(); } catch(_) {} });
      ontoState.cy.on('select', () => { try { container.focus(); } catch(_) {} });
      try { container.addEventListener('keydown', handleDeleteKey); } catch(_) {}

      // Mark canvas active on any interaction
      ontoState.cy.on('tap', () => { ontoState.isCanvasActive = true; });

      if (typeof ontoState.cy.edgehandles === 'function') {
        ontoState.eh = ontoState.cy.edgehandles({
          handleSize: 8,
          handleNodes: 'node[type = "class"], node[type = "note"]',
          handleColor: '#60a5fa',
          handleOutlineColor: '#0b1220',
          handleOutlineWidth: 2,
          toggleOffOnLeave: true,
          enabled: true,
          edgeParams: () => ({ data: { predicate: 'relatedTo', type: 'objectProperty' } })
        });
        ontoState.cy.on('ehcomplete', (event, sourceNode, targetNode, addedEdge) => {
          try {
            const srcType = (sourceNode.data('type') || 'class');
            const tgtType = (targetNode.data('type') || 'class');
            const edgeType = (addedEdge && addedEdge.data('type')) || ontoState.currentPredicateType || 'objectProperty';
            let invalid = false;
            // Allow note -> class as 'note_for' (reverse if class->note used)
            if ((srcType === 'note' && (tgtType === 'class' || tgtType === 'dataProperty')) || ((srcType === 'class' || srcType === 'dataProperty') && tgtType === 'note')) {
              // Ensure direction note -> class
              if ((srcType === 'class' || srcType === 'dataProperty') && tgtType === 'note') {
                addedEdge.data('source', targetNode.id());
                addedEdge.data('target', sourceNode.id());
              }
              addedEdge.data('predicate', 'note_for');
              addedEdge.data('type', 'note');
            } else {
              // For object properties, only allow class→class
              if (edgeType === 'objectProperty' && (srcType !== 'class' || tgtType !== 'class')) invalid = true;
              // Disallow any other note edges
              if (srcType === 'note' || tgtType === 'note') invalid = true;
              if (invalid && addedEdge) { addedEdge.remove(); return; }
            }
          } catch(_) {}
          requestAnimationFrame(() => { refreshOntologyTree(); persistOntologyToLocalStorage(); });
        });
        ontoState.cy.on('select unselect add remove data free', () => {
          updatePropertiesPanelFromSelection();
          persistOntologyToLocalStorage();
        });
        // Persist overlay positions when moved
        ontoState.cy.on('free', 'node.imported', (ev) => {
          try {
            const n = ev.target; const imp = n.data('importSource');
            if (!imp || !activeOntologyIri) return;
            const curr = loadOverlayPositions(activeOntologyIri, imp);
            curr[n.id()] = n.position();
            saveOverlayPositions(activeOntologyIri, imp, curr);
          } catch(_) {}
        });
        // Persist overlay positions when moved
        ontoState.cy.on('free', 'node.imported', (ev) => {
          try {
            const n = ev.target; const imp = n.data('importSource');
            if (!imp || !activeOntologyIri) return;
            const curr = loadOverlayPositions(activeOntologyIri, imp);
            curr[n.id()] = n.position();
            saveOverlayPositions(activeOntologyIri, imp, curr);
          } catch(_) {}
        });
      } else {
        ontoState.cy.on('tap', 'node', (ev) => {
          if (!ontoState.connectMode) return;
          const node = ev.target;
          if (!ontoState.clickConnectFrom) {
            ontoState.clickConnectFrom = node.id();
          } else {
            const from = ontoState.clickConnectFrom;
            const to = node.id();
            if (from !== to) {
              const src = ontoState.cy.$(`#${from}`)[0];
              const tgt = ontoState.cy.$(`#${to}`)[0];
              const srcType = (src && (src.data('type')||'class')) || 'class';
              const tgtType = (tgt && (tgt.data('type')||'class')) || 'class';
              if (srcType !== 'note' && tgtType !== 'note' && srcType === 'class' && tgtType === 'class') {
                ontoState.cy.add({ group: 'edges', data: { id: `e${Date.now()}`, source: from, target: to, predicate: 'relatedTo', type: 'objectProperty' } });
                refreshOntologyTree();
                persistOntologyToLocalStorage();
              }
            }
            ontoState.clickConnectFrom = null;
          }
        });
        ontoState.cy.on('select unselect add remove data free', () => {
          updatePropertiesPanelFromSelection();
          persistOntologyToLocalStorage();
        });
      }

      // Background click clears selection and shows model-level props
      ontoState.cy.on('tap', (ev) => {
        if (ev.target === ontoState.cy) {
          ontoState.cy.$(':selected').unselect();
          updatePropertiesPanelFromSelection();
          hideMenu();
          clearConnectState();
        }
      });

      // Inline label editor on F2 or Enter when focused
      ontoState.cy.on('cxttap', 'node', (ev) => {
        const n = ev.target; const t = (n.data('type')||'class');
        const rect = qs('#cy').getBoundingClientRect();
        const rp = ev.renderedPosition || n.renderedPosition();
        // Configure menu per node type
        const menu = qs('#ontoContextMenu');
        if (!menu) return;
        const btnRel = qs('#menuAddRel');
        const btnDP = qs('#menuAddDataProp');
        if (t === 'note') {
          if (btnRel) btnRel.textContent = 'Link to class/property';
          if (btnDP) btnDP.style.display = 'none';
        } else {
          if (btnRel) btnRel.textContent = 'Add relationship';
          if (btnDP) btnDP.style.display = 'block';
        }
        showMenuAt(rect.left + rp.x + 6, rect.top + rp.y + 6);
        menu.dataset.nodeId = n.id();
        menu.dataset.nodeType = t;
      });
      function showInlineEditor(target) {
        const input = qs('#ontoInlineEdit'); if (!input) return;
        const pos = target.renderedPosition();
        const rect = qs('#cy').getBoundingClientRect();
        const current = target.isNode() ? (target.data('label') || '') : (target.data('predicate') || '');
        input.value = current;
        input.style.left = (rect.left + pos.x - Math.min(100, rect.width*0.2)) + 'px';
        input.style.top = (rect.top + pos.y - 12) + 'px';
        input.style.display = 'block';
        input.focus();
        input.select();
        function commit(save) {
          if (save) {
            const v = input.value.trim();
            if (target.isNode()) target.data('label', v || current);
            else target.data('predicate', v || current);
            refreshOntologyTree();
            persistOntologyToLocalStorage();
          }
          input.style.display = 'none';
          input.onkeydown = null; input.onblur = null;
        }
        input.onkeydown = (e) => {
          if (e.key === 'Enter') commit(true);
          else if (e.key === 'Escape') commit(false);
        };
        input.onblur = () => commit(true);
      }
      ontoState.cy.on('keydown', 'node,edge', (ev) => {
        if (ev.originalEvent && ev.originalEvent.key === 'F2') showInlineEditor(ev.target);
      });
      // Double-click to edit
      ontoState.cy.on('dblclick', 'node,edge', (ev) => showInlineEditor(ev.target));

      // Context menu actions
      document.addEventListener('click', (e) => {
        const menu = qs('#ontoContextMenu');
        if (!menu) return;
        if (e.target === qs('#menuCancel')) { hideMenu(); return; }
        if (e.target === qs('#menuAddRel')) {
          hideMenu();
          const id = menu.dataset.nodeId; if (!id) return;
          const node = ontoState.cy.$('#' + id)[0]; if (!node) return;
          const t = menu.dataset.nodeType || 'class';
          clearConnectState(); startConnectFrom(node); cmState.sourceType = t;
          return;
        }
        if (e.target === qs('#menuAddDataProp')) {
          hideMenu();
          const id = menu.dataset.nodeId; if (!id) return;
          const node = ontoState.cy.$('#' + id)[0]; if (!node) return;
          // Add a default data property node near the class
          const pos = node.position();
          const pid = `DP${Date.now()}`;
          const label = `Data Property ${Date.now()%1000}`;
          ontoState.cy.add({ group: 'nodes', data: { id: pid, label, type: 'dataProperty' }, position: { x: pos.x + 120, y: pos.y } });
          // Use objectProperty for the visual connector edge
          ontoState.cy.add({ group: 'edges', data: { id: `edp${Date.now()}`, source: id, target: pid, predicate: label, type: 'objectProperty' } });
          refreshOntologyTree(); persistOntologyToLocalStorage();
          return;
        }
      });
      // Clicking a target after 'Add relationship' completes the edge
      ontoState.cy.on('tap', 'node', (ev) => {
        const target = ev.target; if (!cmState.sourceId) return;
        const tgtType = (target.data('type')||'class');
        const source = ontoState.cy.$('#' + cmState.sourceId)[0]; if (!source) { clearConnectState(); return; }
        const srcType = cmState.sourceType || (source.data('type')||'class');
        if (source.id() !== target.id()) {
          if (srcType === 'note' && (tgtType === 'class' || tgtType === 'dataProperty')) {
            ontoState.cy.add({ group: 'edges', data: { id: `enote${Date.now()}`, source: source.id(), target: target.id(), predicate: 'note_for', type: 'note' } });
            refreshOntologyTree(); persistOntologyToLocalStorage();
          } else if (srcType === 'class' && tgtType === 'class') {
            ontoState.cy.add({ group: 'edges', data: { id: `e${Date.now()}`, source: source.id(), target: target.id(), predicate: 'relatedTo', type: 'objectProperty' } });
            refreshOntologyTree(); persistOntologyToLocalStorage();
          }
        }
        source.removeClass('connect-source');
        clearConnectState();
      });

      // Drag-and-drop from tool icons
      const icons = Array.from(document.querySelectorAll('.onto-icon'));
      icons.forEach(icon => {
        icon.addEventListener('dragstart', (ev) => {
          ev.dataTransfer.setData('text/onto-type', icon.getAttribute('data-onto-type') || 'class');
          try { ev.dataTransfer.effectAllowed = 'copy'; } catch(_) {}
        });
      });

      container.addEventListener('dragenter', (ev) => { ev.preventDefault(); });
      container.addEventListener('dragover', (ev) => { ev.preventDefault(); ontoState.isCanvasActive = true; try { ev.dataTransfer.dropEffect = 'copy'; } catch(_) {} });
      container.addEventListener('drop', (ev) => {
        ev.preventDefault();
        ontoState.isCanvasActive = true;
        const ontoType = ev.dataTransfer.getData('text/onto-type') || 'class';
        const rect = container.getBoundingClientRect();
        const renderedPos = { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
        const pan = ontoState.cy.pan();
        const zoom = ontoState.cy.zoom();
        const pos = { x: (renderedPos.x - pan.x) / zoom, y: (renderedPos.y - pan.y) / zoom };
        if (ontoType === 'class') {
          const label = `Class ${ontoState.nextId}`;
          const id = addClassNodeAt(label, pos);
          if (id) { ontoState.cy.$('#' + id).select(); }
        } else if (ontoType === 'objectProperty') {
          ontoState.currentPredicateType = 'objectProperty';
          setConnectMode(true);
          // With edgehandles enabled, user can drag handle from a class to another class
        } else if (ontoType === 'dataProperty') {
          const sel = ontoState.cy.nodes(':selected').filter(n => (n.data('type') || 'class') === 'class');
          if (sel.length !== 1) { return; }
          const prop = `Data Property ${Date.now()%1000}`;
          const pid = `DP${Date.now()}`;
          ontoState.cy.add({ group: 'nodes', data: { id: pid, label: prop, type: 'dataProperty' }, position: pos });
          // Link edge is a visual connector; keep it as objectProperty for consistency
          ontoState.cy.add({ group: 'edges', data: { id: `edp${Date.now()}`, source: sel[0].id(), target: pid, predicate: prop, type: 'objectProperty' } });
          refreshOntologyTree();
        } else if (ontoType === 'note') {
          const nid = `Note${Date.now()}`;
          const text = `Note ${nid.slice(-4)}`;
          ontoState.cy.add({ group: 'nodes', data: { id: nid, label: text, type: 'note' }, position: pos, classes: 'note' });
          // If exactly one class is selected, auto-link note -> class
          const sel = ontoState.cy.nodes(':selected').filter(n => (n.data('type')||'class') === 'class');
          if (sel && sel.length === 1) {
            ontoState.cy.add({ group: 'edges', data: { id: `enote${Date.now()}`, source: nid, target: sel[0].id(), predicate: 'note_for', type: 'note' } });
          }
          refreshOntologyTree(); persistOntologyToLocalStorage();
        }
        persistOntologyToLocalStorage();
      });
      // Bind autosave on edits (add/remove/data/position)
      try {
        const autosave = debounce(() => { try { if (activeOntologyIri) persistOntologyToLocalStorage(); } catch(_) {} }, 250);
        ontoState.cy.on('add remove data position', autosave);
        ontoState.autosaveBound = true;
      } catch(_) {}
    }

    function addClassNode(label) {
      ensureOntologyInitialized();
      const id = `Class${ontoState.nextId++}`;
      const x = 100 + Math.random() * 400;
      const y = 100 + Math.random() * 300;
      ontoState.cy.add({ group: 'nodes', data: { id, label, type: 'class' }, position: { x, y } });
      refreshOntologyTree();
      persistOntologyToLocalStorage();
    }

    function addClassNodeAt(label, position) {
      ensureOntologyInitialized();
      const id = `Class${ontoState.nextId++}`;
      ontoState.cy.add({ group: 'nodes', data: { id, label, type: 'class' }, position });
      refreshOntologyTree();
      persistOntologyToLocalStorage();
      return id;
    }

    function runAutoLayout() {
      ensureOntologyInitialized();
      const layout = ontoState.cy.layout({ name: 'cose', animate: 'end', animationDuration: 200 });
      layout.run();
    }

    function setConnectMode(enabled) {
      ensureOntologyInitialized();
      ontoState.connectMode = !!enabled;
      const btn = qs('#ontoConnectBtn');
      if (btn) btn.style.borderColor = enabled ? '#60a5fa' : 'var(--border)';
      if (ontoState.eh) {
        if (enabled) ontoState.eh.enableDrawMode(); else ontoState.eh.disableDrawMode();
      } else {
        if (!enabled) ontoState.clickConnectFrom = null;
      }
    }

    function exportOntologyJSON() {
      ensureOntologyInitialized();
      const nodes = ontoState.cy.nodes().map(n => ({ data: n.data(), position: n.position() }));
      const edges = ontoState.cy.edges().map(e => ({ data: e.data() }));
      const payload = { nodes, edges };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'ontology.json';
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
    }

    function slugId(text) {
      return String(text||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
    }

    function iriMapKey(graphIri) { return 'onto_iri_map__' + encodeURIComponent(graphIri); }
    function loadIriMap(graphIri) { try { return JSON.parse(localStorage.getItem(iriMapKey(graphIri))||'{}'); } catch(_) { return {}; } }
    function saveIriMap(graphIri, map) { try { localStorage.setItem(iriMapKey(graphIri), JSON.stringify(map||{})); } catch(_) {} }

    function toTurtle(graphIri, linkedPairsOpt) {
      // Build per-graph stable id→IRI map
      const iriMap = loadIriMap(graphIri);
      const lines = [
        '@prefix owl: <http://www.w3.org/2002/07/owl#> .',
        '@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .',
        (()=>{ try {
          const labels = loadOntologyLabelMap(activeProject);
          const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : null;
          const scopedName = pid ? (localStorage.getItem(`onto_model_name__${pid}`) || '') : '';
          const mapLabel = labels[graphIri] || '';
          const tail = (graphIri.split('/').pop()||graphIri);
          // Prefer the actively edited model name, then label map, then IRI tail
          const chosen = ((activeOntologyIri === graphIri && scopedName.trim()) || mapLabel || tail);
          const lbl = String(chosen||'');
          return `\n<${graphIri}> a owl:Ontology ; rdfs:label "${String(lbl||'').replace(/\\/g,'\\\\').replace(/"/g,'\\"')}" .\n`;
        } catch(_) { return `\n<${graphIri}> a owl:Ontology .\n`; } })()
      ];
      // Include owl:imports from local storage
      try {
        const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(graphIri)) || '[]');
        imports.forEach(imp => { lines.push(`<${graphIri}> <http://www.w3.org/2002/07/owl#imports> <${imp}> .`); });
      } catch(_) {}
      const nodes = ontoState.cy.nodes();
      const edges = ontoState.cy.edges();
      function nodeIri(n) {
        const id = n.id();
        if (iriMap[id]) return iriMap[id];
        const explicit = n.data('iri');
        if (explicit) { iriMap[id] = explicit; return explicit; }
        const base = slugId(n.data('label')||id)||id;
        const iri = `${graphIri}#${base}`;
        iriMap[id] = iri;
        return iri;
      }
      // Classes and data properties (exclude imported overlays)
      nodes.forEach(n => {
        if (n.hasClass && n.hasClass('imported')) return;
        const t = n.data('type')||'class';
        const iri = nodeIri(n);
        const label = (n.data('label')||'').replace(/\\/g,'\\\\').replace(/"/g,'\\"');
        if (t === 'class') {
          lines.push(`<${iri}> a owl:Class ; rdfs:label "${label}" .`);
        } else if (t === 'dataProperty') {
          lines.push(`<${iri}> a owl:DatatypeProperty ; rdfs:label "${label}" .`);
          const incoming = n.incomers('edge');
          if (incoming && incoming.length) {
            const src = incoming[0].source();
            const srcIri = nodeIri(src);
            lines.push(`<${iri}> rdfs:domain <${srcIri}> .`);
            lines.push(`<${iri}> rdfs:range <http://www.w3.org/2001/XMLSchema#string> .`);
          }
        }
      });
      // Object properties from edges
      const existingEquiv = new Set();
      edges.forEach(e => {
        if (e.hasClass && (e.hasClass('imported') || e.hasClass('imported-equivalence'))) return;
        const s = e.source(); const t = e.target();
        const pred = (e.data('predicate')||'relatedTo').replace(/\\/g,'\\\\').replace(/"/g,'\\"');
        const propIri = `${graphIri}#${slugId(pred)}`;
        const sIri = nodeIri(s); const tIri = nodeIri(t);
        const isData = (e.data('type')||'objectProperty') === 'dataProperty';
        const sType = (s.data('type')||'class'); const tType = (t.data('type')||'class');
        if (!isData) {
          if (sType === 'class' && tType === 'class') {
            // Treat special case for equivalence edges represented in UI as predicate 'equivalentClass'
            if (pred === 'equivalentClass' || pred === 'linked_by') {
              const key = `${sIri}|${tIri}`;
              if (!existingEquiv.has(key)) {
                existingEquiv.add(key);
                lines.push(`<${sIri}> owl:equivalentClass <${tIri}> .`);
              }
            } else {
              lines.push(`<${propIri}> a owl:ObjectProperty ; rdfs:label "${pred}" ; rdfs:domain <${sIri}> ; rdfs:range <${tIri}> .`);
            }
          } else if (sType === 'note' && (tType === 'class' || tType === 'dataProperty') && pred === 'note_for') {
            // Emit as annotation on target element
            const text = (s.data('label')||'').replace(/\\/g,'\\\\').replace(/"/g,'\\"');
            lines.push(`<${tIri}> rdfs:comment "${text}" .`);
          }
        }
      });
      // Add auto-computed equivalence pairs (no UI edges) if provided
      if (Array.isArray(linkedPairsOpt)) {
        linkedPairsOpt.forEach(p => {
          try {
            const n = p.baseNode; const targetIri = p.importIri;
            const sIri = nodeIri(n);
            const key = `${sIri}|${targetIri}`;
            if (!existingEquiv.has(key)) {
              existingEquiv.add(key);
              lines.push(`<${sIri}> owl:equivalentClass <${targetIri}> .`);
            }
          } catch(_) {}
        });
      }
      saveIriMap(graphIri, iriMap);
      return lines.join('\n');
    }

    // Compute linked_by pairs between base classes and imported graphs by label/local name
    async function computeLinkedByPairs(graphIri) {
      try {
        const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(graphIri)) || '[]');
        if (!imports || !imports.length || !ontoState.cy) return [];
        const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type')||'class') === 'class' && !n.hasClass('imported'));
        const norm = (s) => String(s||'').trim().toLowerCase();
        const baseByLabel = new Map();
        baseClasses.forEach(n => { baseByLabel.set(norm(n.data('label')||n.id()), n); });
        const pairs = [];
        for (const imp of imports) {
          const q = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?c ?label WHERE { GRAPH <${imp}> { ?c a owl:Class . OPTIONAL { ?c rdfs:label ?label } } }`;
          const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
          if (!res.ok) continue;
          const json = await res.json();
          const rows = (json && json.results && json.results.bindings) ? json.results.bindings : [];
          rows.forEach(b => {
            const iri = b.c && b.c.value; const label = b.label && b.label.value;
            const local = iri ? (iri.includes('#') ? iri.split('#').pop() : iri.split('/').pop()) : '';
            const key = norm(label || local);
            const base = baseByLabel.get(key);
            if (base && iri) pairs.push({ baseNode: base, importIri: iri });
          });
        }
        // Deduplicate pairs by base id + target iri
        const out = [];
        const seen = new Set();
        pairs.forEach(p => { const k = p.baseNode.id() + '|' + p.importIri; if (!seen.has(k)) { seen.add(k); out.push(p); } });
        return out;
      } catch(_) { return []; }
    }

    // Imported overlay visibility persistence
    function visibleImportsKey(graphIri) { return 'onto_imports_visible__' + encodeURIComponent(graphIri || ''); }
    function loadVisibleImports(graphIri) { try { return new Set(JSON.parse(localStorage.getItem(visibleImportsKey(graphIri)) || '[]')); } catch(_) { return new Set(); } }
    function saveVisibleImports(graphIri, set) { try { localStorage.setItem(visibleImportsKey(graphIri), JSON.stringify(Array.from(set || []))); } catch(_) {} }

    // Persist per-import overlay node positions
    function overlayPositionsKey(baseIri, importIri) { return 'onto_import_positions__' + encodeURIComponent(baseIri || '') + '__' + encodeURIComponent(importIri || ''); }
    function loadOverlayPositions(baseIri, importIri) { try { return JSON.parse(localStorage.getItem(overlayPositionsKey(baseIri, importIri)) || '{}'); } catch(_) { return {}; } }
    function saveOverlayPositions(baseIri, importIri, obj) { try { localStorage.setItem(overlayPositionsKey(baseIri, importIri), JSON.stringify(obj || {})); } catch(_) {} }

    async function fetchImportGraphSnapshot(importIri) {
      try {
        const qClasses = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?c ?label WHERE { GRAPH <${importIri}> { ?c a owl:Class . OPTIONAL { ?c rdfs:label ?label } } }`;
        const qProps = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?p ?pl ?d ?r WHERE { GRAPH <${importIri}> { ?p a owl:ObjectProperty . OPTIONAL { ?p rdfs:label ?pl } OPTIONAL { ?p rdfs:domain ?d } OPTIONAL { ?p rdfs:range ?r } } }`;
        const classesRes = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qClasses }) });
        const propsRes = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qProps }) });
        const classesJson = classesRes.ok ? await classesRes.json() : { results: { bindings: [] } };
        const propsJson = propsRes.ok ? await propsRes.json() : { results: { bindings: [] } };
        const cls = (classesJson.results?.bindings || []).map(b => ({ iri: b.c.value, label: (b.label && b.label.value) || (b.c.value.includes('#') ? b.c.value.split('#').pop() : b.c.value.split('/').pop()) }));
        const edges = [];
        (propsJson.results?.bindings || []).forEach(b => {
          const d = b.d && b.d.value; const r = b.r && b.r.value; if (!d || !r) return;
          const label = (b.pl && b.pl.value) || (b.p && b.p.value ? (b.p.value.includes('#') ? b.p.value.split('#').pop() : b.p.value.split('/').pop()) : 'relatedTo');
          edges.push({ sourceIri: d, targetIri: r, label });
        });
        return { classes: cls, edges };
      } catch(_) { return { classes: [], edges: [] }; }
    }

    async function overlayImportsRefresh() {
      try {
        if (!ontoState.cy || !activeOntologyIri) return;
        const visible = loadVisibleImports(activeOntologyIri);
        const visibleList = Array.from(visible);
        // Before removing overlays, snapshot positions for imports being hidden
        ontoState.cy.nodes('.imported').forEach(n => {
          const imp = n.data('importSource') || '';
          if (!visible.has(imp)) {
            const curr = loadOverlayPositions(activeOntologyIri, imp);
            curr[n.id()] = n.position();
            saveOverlayPositions(activeOntologyIri, imp, curr);
          }
        });
        // Remove overlays for imports no longer visible
        ontoState.cy.elements('.imported, .imported-equivalence').forEach(el => { if (!visible.has(el.data('importSource') || '')) el.remove(); });
        // Add overlays for newly visible imports
        for (const imp of visibleList) {
          const existing = ontoState.cy.elements('.imported').filter(e => (e.data('importSource') || '') === imp);
          if (existing && existing.length) continue;
          const snap = await fetchImportGraphSnapshot(imp);
          const added = [];
          // Compute a simple cluster origin to the right of the base graph to avoid overlap (notes included)
          const baseBBox = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).boundingBox();
          const orderIndex = Math.max(0, visibleList.indexOf(imp));
          const padX = 200, padY = 40, jitterX = orderIndex * 100, jitterY = orderIndex * 60;
          const safe = (n, f)=> (Number.isFinite(n) ? n : f);
          const originX = safe(baseBBox.x2, 0) + padX + jitterX;
          const originY = safe(baseBBox.y1, 0) + jitterY;
          const total = Math.max(1, snap.classes.length);
          const cols = Math.ceil(Math.sqrt(total));
          const spacing = 160;
          let nextIdx = 0;
          function nextPos() {
            const col = nextIdx % cols; const row = Math.floor(nextIdx / cols); nextIdx += 1;
            return { x: originX + col * spacing, y: originY + row * spacing };
          }
          // Add class nodes in a simple grid within the cluster; apply saved positions if available
          const savedPos = loadOverlayPositions(activeOntologyIri, imp);
          snap.classes.forEach(c => {
            const id = `imp:${imp}#${c.iri}`;
            if (ontoState.cy.$(`#${CSS.escape(id)}`).length) return;
            const pos = savedPos[id] ? savedPos[id] : nextPos();
            added.push(ontoState.cy.add({ group: 'nodes', data: { id, iri: c.iri, label: c.label, type: 'class', importSource: imp }, position: pos, classes: 'imported' }));
          });
          // Add edges where both endpoints available; create missing nodes on demand
          let idx = 0;
          snap.edges.forEach(e => {
            const sid = `imp:${imp}#${e.sourceIri}`;
            const tid = `imp:${imp}#${e.targetIri}`;
            if (!ontoState.cy.$(`#${CSS.escape(sid)}`).length) {
              const label = e.sourceIri.includes('#') ? e.sourceIri.split('#').pop() : e.sourceIri.split('/').pop();
              const pos = savedPos[sid] ? savedPos[sid] : nextPos();
              added.push(ontoState.cy.add({ group: 'nodes', data: { id: sid, iri: e.sourceIri, label, type: 'class', importSource: imp }, position: pos, classes: 'imported' }));
            }
            if (!ontoState.cy.$(`#${CSS.escape(tid)}`).length) {
              const label = e.targetIri.includes('#') ? e.targetIri.split('#').pop() : e.targetIri.split('/').pop();
              const pos = savedPos[tid] ? savedPos[tid] : nextPos();
              added.push(ontoState.cy.add({ group: 'nodes', data: { id: tid, iri: e.targetIri, label, type: 'class', importSource: imp }, position: pos, classes: 'imported' }));
            }
            added.push(ontoState.cy.add({ group: 'edges', data: { id: `impE${Date.now()}_${idx++}`, source: sid, target: tid, predicate: e.label, type: 'objectProperty', importSource: imp }, classes: 'imported' }));
          });
          // Make overlays semi-interactive for positioning: allow drag, but don't select or edit
          added.forEach(el => {
            try {
              if (el.isNode && el.isNode()) {
                el.selectable(false); el.grabbable(true); el.locked(false);
              } else {
                el.selectable(false); el.grabbable(false); el.locked(true);
              }
            } catch(_) {}
          });

          // Add owl:equivalentClass visual links between base and imported nodes (by label/local name)
          try {
            const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type')||'class')==='class' && !n.hasClass('imported'));
            const imported = ontoState.cy.nodes().filter(n => (n.data('type')||'class')==='class' && n.hasClass('imported') && (n.data('importSource')||'')===imp);
            const byKey = (s)=>String(s||'').trim().toLowerCase();
            const baseMap = new Map(); baseClasses.forEach(n => baseMap.set(byKey(n.data('label')||n.id()), n));
            let idx2 = 0;
            imported.forEach(n => {
              const key = byKey(n.data('label')||n.id());
              const base = baseMap.get(key);
              if (base) {
                const eid = `impEq${Date.now()}_${idx2++}`;
                ontoState.cy.add({ group: 'edges', data: { id: eid, source: base.id(), target: n.id(), predicate: 'equivalentClass', type: 'objectProperty', importSource: imp }, classes: 'imported imported-equivalence' });
              }
            });
          } catch(_) {}
        }
        // Do not persist imported overlays to base local storage
        refreshOntologyTree();
      } catch(_) {}
    }

    // Context menu helpers
    let cmState = { visible: false, sourceId: null };
    function showMenuAt(x, y) {
      const m = qs('#ontoContextMenu'); if (!m) return;
      m.style.left = x + 'px'; m.style.top = y + 'px'; m.style.display = 'block'; cmState.visible = true;
    }
    function hideMenu() { const m = qs('#ontoContextMenu'); if (!m) return; m.style.display = 'none'; cmState.visible = false; }
    function startConnectFrom(node) {
      cmState.sourceId = node.id();
      node.addClass('connect-source');
    }
    function clearConnectState() {
      if (cmState.sourceId && ontoState.cy) {
        const n = ontoState.cy.$('#' + cmState.sourceId);
        if (n) n.removeClass('connect-source');
      }
      cmState.sourceId = null;
    }

    // Ensure new class IDs do not collide with existing nodes after imports/loads
    function recomputeNextId() {
      try {
        if (!ontoState || !ontoState.cy) return;
        let maxNum = 0;
        ontoState.cy.nodes().forEach(n => {
          try {
            const nid = (n && typeof n.id === 'function') ? n.id() : '';
            const m = /^Class(\d+)$/.exec(String(nid || ''));
            if (m) {
              const num = parseInt(m[1], 10);
              if (!isNaN(num)) maxNum = Math.max(maxNum, num);
            }
          } catch(_) {}
        });
        ontoState.nextId = Math.max(1, maxNum + 1);
      } catch(_) {}
    }

    function importOntologyJSON(obj) {
      ensureOntologyInitialized();
      if (!obj || !Array.isArray(obj.nodes) || !Array.isArray(obj.edges)) return;
      // Clear only base elements, keep imported overlays intact
      ontoState.cy.elements().filter(el => !el.hasClass('imported') && !el.hasClass('imported-equivalence')).remove();
      // Migration guard: filter out any overlays accidentally saved to JSON
      const isOverlayNode = (n) => {
        try {
          const d = (n && n.data) ? n.data : {};
          const id = String(d.id || '');
          const cls = String(n.classes || d.classes || '');
          return !!d.importSource || id.startsWith('imp:') || cls.includes('imported');
        } catch(_) { return false; }
      };
      const baseNodes = (obj.nodes || []).filter(n => !isOverlayNode(n));
      const baseNodeIds = new Set(baseNodes.map(n => (n.data && n.data.id) || ''));
      const baseEdges = (obj.edges || []).filter(e => {
        try {
          const d = (e && e.data) ? e.data : {};
          const cls = String(e.classes || d.classes || '');
          if (d.importSource || cls.includes('imported')) return false;
          if (String(d.predicate || '').toLowerCase() === 'equivalentclass') return false;
          return baseNodeIds.has(d.source) && baseNodeIds.has(d.target);
        } catch(_) { return false; }
      });
      // Add back base nodes and edges only
      ontoState.cy.add(baseNodes.map(n => ({ group: 'nodes', data: n.data, position: n.position })));
      ontoState.cy.add(baseEdges.map(e => ({ group: 'edges', data: e.data })));
      ontoState.cy.fit();
      refreshOntologyTree();
      persistOntologyToLocalStorage();
      // Update ID counter so new classes get unique IDs
      recomputeNextId();
    }

    // Auth/UI gating
    const tokenKey = 'odras_token';
    const userKey = 'odras_user';
    function showAuth(show) {
      qs('#authView').style.display = show ? 'grid' : 'none';
      qs('#mainView').style.display = show ? 'none' : 'grid';
    }
    async function initAuth() {
      const token = localStorage.getItem(tokenKey);
      if (!token) { showAuth(true); return; }
      const me = await fetch('/api/auth/me', { headers: { Authorization: 'Bearer ' + token }}).then(r=>r.json()).catch(()=>null);
      if (!me || me.error) { showAuth(true); return; }
      qs('#userMenu').textContent = me.username + (me.is_admin ? ' (admin)' : '');
      showAuth(false);
      // Restore last active workbench before loading projects
      try {
        const hashWB = (()=>{ try { const p = new URLSearchParams(location.hash.replace(/^#/, '')); return p.get('wb') || ''; } catch(_) { return ''; } })();
        const wb = hashWB || localStorage.getItem('active_workbench') || 'ontology';
        // Activate matching icon and section
        const icon = qs(`.icon[data-wb="${wb}"]`);
        if (icon) {
          qsa('.icon').forEach(i => i.classList.remove('active')); icon.classList.add('active');
          qsa('.workbench').forEach(w => w.classList.remove('active'));
          const sec = qs('#wb-' + wb); if (sec) sec.classList.add('active');
        }
        // If no workbench got activated (e.g., missing section), default to ontology
        if (!document.querySelector('.workbench.active')) {
          const fallback = qs('.icon[data-wb="ontology"]');
          if (fallback) fallback.click();
        }
      } catch(_) {}
      // Initialize Cytoscape BEFORE loading projects so restore can occur during renderTree
      ensureOntologyInitialized();
      // If Files workbench is already active from restore, initialize its handlers now
      try { if (document.querySelector('#wb-files.workbench.active')) { ensureFilesInitialized(); } } catch(_) {}
      await loadProjects();
      refreshOntologyTree();
      // Bind Files workbench handlers proactively so Choose Files works immediately
      try { ensureFilesInitialized(); } catch(_) {}
      // Restore ontology tree collapsed state
      try {
        // Restore left project tree width
        const uiMainTreeW = parseInt(localStorage.getItem('ui_main_tree_w') || '0', 10);
        if (uiMainTreeW) document.documentElement.style.setProperty('--tree-w', uiMainTreeW + 'px');
        // Restore ontology left tree width
        const ontoTreeW = parseInt(localStorage.getItem('onto_tree_w') || '0', 10);
        if (ontoTreeW) document.documentElement.style.setProperty('--onto-tree-w', ontoTreeW + 'px');
        const treeCollapsed = localStorage.getItem('onto_tree_collapsed') === '1';
        if (treeCollapsed) {
          const sec = qs('#wb-ontology');
          if (sec && !sec.classList.contains('onto-tree-collapsed')) sec.classList.add('onto-tree-collapsed');
          const icon = qs('#ontoTreeToggleIcon');
          if (icon) icon.innerHTML = '<path d="M9 6l6 6-6 6"/>';
        }
        const propsCollapsed = localStorage.getItem('onto_props_collapsed') === '1';
        if (propsCollapsed) {
          const sec = qs('#wb-ontology');
          if (sec && !sec.classList.contains('onto-props-collapsed')) sec.classList.add('onto-props-collapsed');
          const icon = qs('#ontoPropsToggleIcon');
          if (icon) icon.innerHTML = '<path d="M15 6l-6 6 6 6"/>';
        }
        // Ensure icon SVGs match classes and allow CSS rotation animation to apply
        const treeIcon = qs('#ontoTreeToggleIcon');
        if (treeIcon && !treeCollapsed) treeIcon.innerHTML = '<path d="M15 6l-6 6 6 6"/>';
        const propsIcon = qs('#ontoPropsToggleIcon');
        if (propsIcon && !propsCollapsed) propsIcon.innerHTML = '<path d="M9 6l6 6-6 6"/>';
        const savedW = parseInt(localStorage.getItem('onto_props_w') || '0', 10);
        if (savedW) document.documentElement.style.setProperty('--onto-props-w', savedW + 'px');
        // Do not load any graph here; renderTree handles per-project restore safely
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      } catch(_) {}
    }
    qs('#loginBtn').onclick = async () => {
      const username = qs('#u').value.trim();
      const password = qs('#p').value;
      qs('#loginMsg').textContent = 'Signing in...';
      const res = await fetch('/api/auth/login', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ username, password }) });
      const json = await res.json();
      if (res.ok && json.token) {
        localStorage.setItem(tokenKey, json.token);
        localStorage.setItem(userKey, username);
        qs('#loginMsg').textContent = '';
        initAuth();
      } else {
        qs('#loginMsg').textContent = json.error || 'Login failed';
      }
    };
    qs('#logoutBtn').onclick = () => { localStorage.removeItem(tokenKey); localStorage.removeItem(userKey); activeOntologyIri = null; updateOntoGraphLabel(); try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {} showAuth(true); };

    // Projects
    async function loadProjects() {
      const token = localStorage.getItem(tokenKey);
      const res = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token }});
      const json = await res.json();
      const raw = json.projects || [];
      // Normalize backend shape to { id, name }
      const list = raw.map(p => ({
        id: p.id || p.project_id || p.projectId,
        name: p.name || p.project_name || 'Project'
      })).filter(p => !!p.id);
      const selects = [qs('#projectSelect2')];
      if (list.length) {
        // restore previously selected project if available
        const savedPid = (localStorage.getItem('active_project_id') || '').trim();
        let selected = list[0];
        if (savedPid) {
          const found = list.find(p => p.id === savedPid);
          if (found) selected = found;
        }
        selects.forEach(sel => { if (sel) { sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join(''); sel.disabled = false; sel.value = selected.id; } });
        await renderTree(selected);
      } else {
        // No projects: clear tree and show empty state
        selects.forEach(sel => { if (sel) { sel.innerHTML = '<option value="" disabled selected>Create Project...</option>'; sel.disabled = true; } });
        await renderTree({ id: null, name: '' });
      }
    }
    (function(){
      const npb = qs('#newProjectBtn');
      if (!npb) return;
      npb.onclick = async () => {
        const name = prompt('Project name'); if (!name) return;
        const token = localStorage.getItem(tokenKey);
        const res = await fetch('/api/projects', { method:'POST', headers:{'Content-Type':'application/json', Authorization: 'Bearer ' + token}, body: JSON.stringify({ name }) });
        let pid = '';
        let pname = name;
        if (res.ok) {
          const js = await res.json().catch(()=>({}));
          const proj = js.project || js;
          pid = (proj && (proj.id || proj.project_id || proj.projectId)) || '';
          pname = (proj && proj.name) || name;
          if (pid) try { localStorage.setItem('active_project_id', pid); } catch(_) {}
        }
        // Reload projects, select the created one, and render it
        const pr = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token }}).then(r=>r.json()).catch(()=>({projects:[]}));
        const raw = pr.projects || [];
        const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' })).filter(p => !!p.id);
        const sel = qs('#projectSelect2');
        if (sel) {
          sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
          if (pid && list.find(p => p.id === pid)) sel.value = pid; else if (list.length) sel.value = list[0].id;
          sel.disabled = !list.length;
        }
        const selected = pid ? { id: pid, name: pname } : (list[0] || { id: null, name: '' });
        await renderTree(selected);
      };
    })();
    ['#projectSelect2'].forEach(id => {
      const sel = qs(id); if (!sel) return;
      sel.addEventListener('change', async (e) => {
        const pid = e.target.value;
        try { localStorage.setItem('active_project_id', pid); } catch(_) {}
        const token = localStorage.getItem(tokenKey);
        // Save current ontology canvas before switching projects
        try { if (ontoState && ontoState.cy && activeOntologyIri) saveGraphToLocal(activeOntologyIri); } catch(_) {}
        const res = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token }});
        const json = await res.json();
        const raw = json.projects || [];
        const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' }));
        const proj = list.find(p => p.id === pid);
        if (proj) { activeOntologyIri = null; updateOntoGraphLabel(); await renderTree(proj); }
      });
    });

    // Plus button near project selector creates a new project
    (function(){
      const btn = qs('#addNodeBtn');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        const name = prompt('Project name'); if (!name) return;
        const token = localStorage.getItem(tokenKey);
        const res = await fetch('/api/projects', { method:'POST', headers:{'Content-Type':'application/json', Authorization: 'Bearer ' + token}, body: JSON.stringify({ name }) });
        if (res.ok) {
          // Reload and select the newly created project
          const pr = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token }}).then(r=>r.json()).catch(()=>({projects:[]}));
          const raw = pr.projects || [];
          const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' })).filter(p => !!p.id);
          const sel = qs('#projectSelect2');
          if (sel && list.length) {
            sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
            const js = await res.json().catch(()=>({}));
            const proj = js.project || js;
            const pid = (proj && (proj.id || proj.project_id || proj.projectId)) || list[list.length - 1].id;
            sel.value = pid;
            try { localStorage.setItem('active_project_id', pid); } catch(_) {}
            sel.disabled = false;
            // Save current ontology canvas before switching projects
            try { if (ontoState && ontoState.cy && activeOntologyIri) saveGraphToLocal(activeOntologyIri); } catch(_) {}
            const selected = list.find(p => p.id === pid) || list[list.length - 1];
            await renderTree(selected);
          }
        }
      });
    })();

    // Workbench switching
    qsa('.icon').forEach(el => el.onclick = () => {
      qsa('.icon').forEach(i => i.classList.remove('active')); el.classList.add('active');
      const wb = el.getAttribute('data-wb');
      qsa('.workbench').forEach(w => w.classList.remove('active'));
      qs('#wb-' + wb).classList.add('active');
      // Persist selected workbench
      try { localStorage.setItem('active_workbench', wb); } catch(_) {}
      // Reflect in hash
      try {
        const params = new URLSearchParams(location.hash.replace(/^#/, ''));
        params.set('wb', wb);
        location.hash = params.toString();
      } catch(_) {}
      if (wb === 'graph') refreshGraphSummary();
      if (wb === 'ontology') { ensureOntologyInitialized(); if (ontoState.cy) ontoState.cy.resize(); }
      if (wb === 'files') { ensureFilesInitialized(); }
    });

    // Tree collapsible sections
    qsa('.section > button').forEach(btn => {
      btn.onclick = (e) => {
        const sec = e.currentTarget.parentElement;
        const expanded = sec.getAttribute('aria-expanded') !== 'false';
        sec.setAttribute('aria-expanded', expanded ? 'false' : 'true');
      };
    });

    // Resizer
    (function(){
      const res = qs('#resizer');
      const panel = qs('#treePanel');
      let dragging = false;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => {
        dragging = false;
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tree-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tree-w-max'));
        let w = e.clientX - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--iconbar-w'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty('--tree-w', w + 'px');
        try { localStorage.setItem('ui_main_tree_w', String(w)); } catch(_) {}
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    // Ontology panel resizer
    (function(){
      const res = qs('#ontoResizer');
      const panelWidthProp = '--onto-tree-w';
      let dragging = false;
      if (!res) return;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => {
        dragging = false;
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const layout = qs('#wb-ontology .onto-layout'); if (!layout) return;
        const layoutRect = layout.getBoundingClientRect();
        // Grid columns: [tree][divider][iconbar][canvas][divider][props]
        // If tree is collapsed, divider width is 0; math still uses layout left
        let w = e.clientX - layoutRect.left;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-tree-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-tree-w-max'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty(panelWidthProp, w + 'px');
        try { localStorage.setItem('onto_tree_w', String(w)); } catch(_) {}
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    // Properties panel resizer
    (function(){
      const res = qs('#ontoPropsResizer');
      let dragging = false;
      if (!res) return;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => dragging = false);
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const layoutRect = qs('#wb-ontology .onto-layout')?.getBoundingClientRect();
        if (!layoutRect) return;
        let w = layoutRect.right - e.clientX;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-props-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-props-w-max'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty('--onto-props-w', w + 'px');
        try { localStorage.setItem('onto_props_w', String(w)); } catch(_) {}
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    async function renderTree(project) {
      activeProject = project && project.id ? project : null;
      // Reset active ontology when switching context or when no project
      activeOntologyIri = null;
      updateOntoGraphLabel();
      try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {}
      // Restore per-project active ontology selection (label only)
      try {
        const pid = project && (project.id || project.project_id);
        const savedIri = localStorage.getItem(`onto_active_iri__${pid}`);
        if (savedIri) {
          activeOntologyIri = savedIri;
          updateOntoGraphLabel();
          // Ensure properties panel model name reflects the saved active ontology
          try {
            const labels = loadOntologyLabelMap(project);
            const pid2 = (project && (project.id || project.project_id)) ? (project.id || project.project_id) : 'default';
            const friendly = (labels[savedIri] && String(labels[savedIri]).trim()) || (savedIri.split('/').pop() || savedIri);
            localStorage.setItem(`onto_model_name__${pid2}`, friendly);
            let attrs = {};
            try { attrs = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid2}`) || '{}'); } catch(_) { attrs = {}; }
            attrs.displayLabel = friendly; attrs.graphIri = savedIri;
            localStorage.setItem(`onto_model_attrs__${pid2}`, JSON.stringify(attrs));
            updatePropertiesPanelFromSelection();
          } catch(_) {}
          // Attempt to load saved canvas for this active IRI
          try {
            if (ontoState.cy) {
              ontoState.suspendAutosave = true;
              ontoState.cy.elements().remove();
              loadGraphFromLocal(savedIri);
              setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
            }
          } catch(_) {}
        }
      } catch(_) {}
      const root = qs('#treeRoot');
      const makeItem = (id, label, iconCls, children = [], dataAttrs = {}) => {
        const hasChildren = children && children.length > 0;
        const li = document.createElement('li');
        li.setAttribute('role', 'treeitem');
        if (hasChildren) li.setAttribute('aria-expanded', 'true');
        li.dataset.nodeId = id;
        Object.keys(dataAttrs || {}).forEach(k => { li.dataset[k] = dataAttrs[k]; });

        const row = document.createElement('div');
        row.className = 'node-row';
        row.tabIndex = 0;
        row.onclick = (e) => { selectNode(li); handleTreeSelection(li); };
        row.onkeydown = (e) => handleKey(e, li);
        // Inline rename on double-click for ontology nodes
        row.ondblclick = (e) => {
          if (li.dataset.nodeType === 'ontology') {
            const current = (li.dataset.label || row.querySelector('.node-label')?.textContent || '').trim();
            const name = prompt('Rename ontology label', current);
            if (!name || name.trim() === current) return;
            try {
              const payload = { graph: li.dataset.iri, label: name.trim() };
              const token = localStorage.getItem(tokenKey);
              fetch('/api/ontologies/label', { method: 'PUT', headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token }, body: JSON.stringify(payload) })
                .then(async (res) => {
                  if (!res.ok) throw new Error('rename failed');
                  const newLabel = name.trim();
                  row.querySelector('.node-label').textContent = newLabel; li.dataset.label = newLabel; saveOntologyLabel(li.dataset.iri, newLabel);
                  if (activeOntologyIri === li.dataset.iri) {
                    const pid = project.id || project.project_id || 'default';
                    localStorage.setItem(`onto_model_name__${pid}`, newLabel);
                    try {
                      let attrs = {};
                      try { attrs = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}'); } catch(_) { attrs = {}; }
                      attrs.displayLabel = newLabel;
                      localStorage.setItem(`onto_model_attrs__${pid}`, JSON.stringify(attrs));
                    } catch(_) {}
                    updateOntoGraphLabel();
                    // Immediately update properties panel model name
                    try { updatePropertiesPanelFromSelection(); } catch(_) {}
                    // Immediately reflect in Ontology tree view without a full tree reload
                    try { refreshOntologyTree(); } catch(_) {}
                  }
                  // Avoid immediate server re-fetch that could race and overwrite the fresh label
                })
                .catch(()=>{ alert('Rename failed'); });
            } catch(_) {}
          }
        };

        const twist = document.createElement('span'); twist.className = 'twist';
        if (hasChildren) {
          twist.onclick = (e) => { e.stopPropagation(); toggleNode(li); };
        }
        row.appendChild(twist);

        const icon = document.createElement('span'); icon.className = 'node-icon ' + iconCls; row.appendChild(icon);
        const text = document.createElement('span'); text.className = 'node-label'; text.textContent = label; row.appendChild(text);
        li.appendChild(row);

        if (hasChildren) {
          const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
          children.forEach(ch => ul.appendChild(ch));
          li.appendChild(ul);
        }
        return li;
      };

      const reqItems = ((project && project.requirements) || []).map((r, idx) => {
        const rid = r.id || `SP-${String(idx + 1).padStart(3, '0')}`;
        const label = rid; // ID only
        return makeItem(rid, label, 'req');
      });
      const docReqItems = (project && project.documents && project.documents.requirements ? project.documents.requirements : []).map(d => makeItem(d.id || d.name, d.name || d.id, 'docreq'));
      const docKnowItems = (project && project.documents && project.documents.knowledge ? project.documents.knowledge : []).map(d => makeItem(d.id || d.name, d.name || d.id, 'docknow'));
      const outItems = ((project && (project.artifacts || project.outputs)) || []).map(o => makeItem(o.id || o.name, o.name || o.id, 'out'));

      // Ontology tree: discover from Fuseki
      let ontologyNode = null;
      try {
        const pid = project && (project.id || project.project_id);
        const res = await fetch(`/api/ontologies${pid ? `?project=${encodeURIComponent(pid)}` : ''}`);
        const json = await res.json();
        const onts = Array.isArray(json.ontologies) ? json.ontologies : [];
        const labelsMap = loadOntologyLabelMap(project);
        const ontoItems = onts.map((o, idx) => {
          const serverLabel = (o.label && String(o.label).trim()) || '';
          const mapLabel = (labelsMap[o.graphIri] && String(labelsMap[o.graphIri]).trim()) || '';
          const displayLabel = mapLabel || serverLabel || o.graphIri;
          const li = makeItem(
            `ontology-${idx}-${o.graphIri}`,
            displayLabel,
            'onto',
            [],
            { nodeType: 'ontology', iri: o.graphIri, label: displayLabel }
          );
          // Enable dragging this ontology into the Imports node
          const row = li.querySelector('.node-row');
          if (row) {
            row.setAttribute('draggable', 'true');
            row.addEventListener('dragstart', (ev) => {
              try { ev.dataTransfer.setData('text/graph-iri', o.graphIri); ev.dataTransfer.effectAllowed = 'copy'; } catch(_) {}
            });
          }
          // Initialize label map from server only if missing
          if (!mapLabel && serverLabel) {
            try { saveOntologyLabel(o.graphIri, serverLabel); } catch(_) {}
          }
          return li;
        });
        if (ontoItems.length) {
          ontologyNode = makeItem('ontology', 'Ontology', 'folder', ontoItems);
        } else {
          // No ontologies: ensure empty state is shown
          activeOntologyIri = null;
          updateOntoGraphLabel();
          ontologyNode = makeItem('ontology', 'Ontology', 'folder', []);
        }
      } catch (_) {
        // Network/SPARQL error: show a placeholder item
        ontologyNode = makeItem('ontology', 'Ontology', 'folder', [
          makeItem('onto-error', 'Discovery unavailable', 'onto')
        ]);
      }

      const projectDisplay = (project && (project.name || project.id)) ? (project.name || project.id) : '';
      const projectInfo = makeItem('project-info', `Project: ${projectDisplay}`, 'folder');
      // Enable delete on main tree top node when project is selected
      try {
        const row = projectInfo.querySelector('.node-row');
        if (row && project && (project.id || project.project_id)) {
          // Context menu binding
          row.oncontextmenu = (ev) => {
            ev.preventDefault();
            const menu = qs('#projectContextMenu'); if (!menu) return;
            menu.style.display = 'block';
            menu.style.left = ev.pageX + 'px';
            menu.style.top = ev.pageY + 'px';
            const hide = () => { menu.style.display = 'none'; document.removeEventListener('click', hide, { capture: true }); };
            setTimeout(() => { document.addEventListener('click', hide, { capture: true }); }, 0);
            const pid = project.id || project.project_id;
            const token = localStorage.getItem(tokenKey);
            const archiveBtn = qs('#projArchiveBtn');
            const deleteBtn = qs('#projDeleteBtn');
            const showArchivedBtn = qs('#projShowArchivedBtn');
            const renameBtn = qs('#projRenameBtn');
            if (renameBtn) renameBtn.onclick = async () => {
              try {
                const currentName = (project && (project.name || '')) || '';
                const newName = prompt('Rename project', currentName);
                if (!newName || newName.trim() === currentName) return;
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token },
                  body: JSON.stringify({ name: newName.trim() })
                });
                if (res.ok) {
                  await loadProjects();
                } else {
                  const t = await res.text().catch(()=>String(res.status));
                  alert('Rename failed: ' + t);
                }
              } finally { hide(); }
            };
            if (archiveBtn) archiveBtn.onclick = async () => {
              try {
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}/archive`, { method: 'POST', headers: { Authorization: 'Bearer ' + token }});
                if (res.ok) { try { localStorage.removeItem('active_project_id'); } catch(_) {} await loadProjects(); }
                else { const t = await res.text().catch(()=>String(res.status)); alert('Archive failed: ' + t); }
              } finally { hide(); }
            };
            if (deleteBtn) deleteBtn.onclick = async () => {
              try {
                if (!confirm('Delete this project? This does not delete external artifacts.')) return;
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token }});
                if (res.ok) { try { localStorage.removeItem('active_project_id'); } catch(_) {} await loadProjects(); }
                else { const t = await res.text().catch(()=>String(res.status)); alert('Delete failed: ' + t); }
              } finally { hide(); }
            };
            if (showArchivedBtn) showArchivedBtn.onclick = async () => {
              try {
                const res = await fetch('/api/projects?state=archived', { headers: { Authorization: 'Bearer ' + token }});
                const json = await res.json();
                const rows = (json.projects || []).map(p => ({ id: p.project_id || p.id, name: p.name || 'Project' })).filter(p => p.id);
                const overlay = document.createElement('div');
                overlay.style.position='fixed'; overlay.style.inset='0'; overlay.style.background='rgba(0,0,0,0.4)'; overlay.style.zIndex='9998';
                const panel = document.createElement('div'); panel.style.position='fixed'; panel.style.top='20%'; panel.style.left='50%'; panel.style.transform='translateX(-50%)'; panel.style.background='var(--panel)'; panel.style.border='1px solid var(--border)'; panel.style.borderRadius='12px'; panel.style.padding='12px'; panel.style.minWidth='420px'; panel.style.zIndex='9999';
                panel.innerHTML = `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;"><strong>Archived Projects</strong><button id="archClose" class="btn">Close</button></div><div id="archList"></div>`;
                document.body.appendChild(overlay); document.body.appendChild(panel);
                const close = ()=>{ try { document.body.removeChild(panel); document.body.removeChild(overlay); } catch(_) {} };
                panel.querySelector('#archClose').onclick = close; overlay.onclick = close;
                const listEl = panel.querySelector('#archList');
                if (!rows.length) { listEl.innerHTML = '<div class="muted">No archived projects.</div>'; return; }
                listEl.innerHTML = rows.map(r => `<div style="display:flex; justify-content:space-between; align-items:center; border:1px solid var(--border); border-radius:8px; padding:8px; margin-bottom:6px;"><span>${r.name}</span><div><button class="btn" data-restore="${r.id}">Restore</button></div></div>`).join('');
                listEl.addEventListener('click', async (e)=>{
                  const btn = e.target.closest('button[data-restore]'); if (!btn) return;
                  const rid = btn.getAttribute('data-restore');
                  const rr = await fetch(`/api/projects/${encodeURIComponent(rid)}/restore`, { method:'POST', headers:{ Authorization:'Bearer ' + token }});
                  if (rr.ok) {
                    try { localStorage.setItem('active_project_id', rid); } catch(_) {}
                    close();
                    await loadProjects();
                  } else {
                    const t = await rr.text().catch(()=>String(rr.status)); alert('Restore failed: ' + t);
                  }
                });
              } finally { hide(); }
            };
          };
          row.onkeydown = async (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
              e.preventDefault();
              const pid = project.id || project.project_id;
              const token = localStorage.getItem(tokenKey);
              if (!confirm('Delete this project? This does not delete external artifacts.')) return;
              const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token }});
              if (res.ok) {
                try { localStorage.removeItem('active_project_id'); } catch(_) {}
                await loadProjects();
              } else {
                const t = await res.text().catch(()=>String(res.status));
                alert('Delete failed: ' + t);
              }
            }
          };
        }
      } catch(_) {}
      const docsReqNode = makeItem('documents-requirements', 'Requirements Documents', 'folder', docReqItems);
      const docsKnowNode = makeItem('documents-knowledge', 'Knowledge Documents', 'folder', docKnowItems);
      const docsChildren = [];
      if (docReqItems.length) docsChildren.push(docsReqNode);
      if (docKnowItems.length) docsChildren.push(docsKnowNode);
      const docsNode = makeItem('documents', 'Documents', 'folder', docsChildren);
      const reqNode = makeItem('requirements', 'Extracted Requirements', 'folder', reqItems);
      const outNode = makeItem('artifacts', 'Artifacts', 'folder', outItems);

      root.innerHTML = '';
      // If no project, show minimal empty tree
      root.innerHTML = '';
      if (project && (project.id || project.project_id)) {
        [projectInfo, ontologyNode, docsNode, reqNode, outNode].filter(Boolean).forEach(n => root.appendChild(n));
      }

      // Auto-restore previously selected ontology for this project, if available
      try {
        const pid = project && (project.id || project.project_id);
        const savedIri = pid ? localStorage.getItem(`onto_active_iri__${pid}`) : null;
        const treeEl = qs('#treeRoot');
        if (savedIri && treeEl) {
          const li = Array.from(treeEl.querySelectorAll('li[role="treeitem"]')).find(el => el.dataset && el.dataset.iri === savedIri);
          if (li) {
            // Restore canvas first (if we have saved content), then select the ontology to sync panels
            try {
              if (ontoState.cy) {
                ontoState.suspendAutosave = true;
                ontoState.cy.elements().remove();
                loadGraphFromLocal(savedIri);
                setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
              }
            } catch(_) {}
            selectNode(li);
            // Prevent workbench switching when restoring selection on load
            suppressWorkbenchSwitch = true;
            try { handleTreeSelection(li); } finally { suppressWorkbenchSwitch = false; }
          } else {
            // Saved IRI no longer present; reset to empty state
            activeOntologyIri = null;
            updateOntoGraphLabel();
            try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {}
            refreshOntologyTree();
          }
        } else {
          // No saved selection for this project
          activeOntologyIri = null;
          updateOntoGraphLabel();
          try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {}
          refreshOntologyTree();
        }
      } catch(_) {}

      // Add plus button on Ontology section header (right side)
      try {
        const ontoSection = Array.from(root.children).find(li => li.querySelector('.node-label')?.textContent === 'Ontology');
        const headerRow = ontoSection ? ontoSection.querySelector('.node-row') : null;
        if (headerRow && !headerRow.querySelector('.tree-add-btn')) {
          const addBtn = document.createElement('button');
          addBtn.className = 'btn tree-add-btn';
          addBtn.title = 'New Ontology';
          addBtn.textContent = '+';
          addBtn.style.marginLeft = '8px';
          addBtn.onclick = async (e) => {
            e.stopPropagation();
            if (!project || !(project.id || project.project_id)) { alert('Create a project first'); return; }
            const disp = prompt('Display label for new ontology'); if (!disp) return;
            const base = slugify(disp) || `ontology-${Date.now()}`;
            const label = disp;
            try {
              const token = localStorage.getItem(tokenKey);
              const pid2 = project.id || project.project_id;
              const res = await fetch('/api/ontologies', { method: 'POST', headers: { 'Content-Type':'application/json', Authorization: 'Bearer ' + token }, body: JSON.stringify({ project: pid2, name: base, label }) });
              if (!res.ok) {
                const msg = await res.text().catch(()=>String(res.status));
                alert('Create ontology failed: ' + msg);
                return;
              }
              const created = await res.json();
              if (created && created.graphIri) {
                try { saveOntologyLabel(created.graphIri, created.label || label); } catch(_) {}
              }
              await renderTree(project);
              // Ensure label is shown and select the created ontology (guard for valid response)
              if (created && created.graphIri) {
                const newRoot = qs('#treeRoot');
                const li = Array.from(newRoot.querySelectorAll('li[role="treeitem"]')).find(el => el.dataset && el.dataset.iri === created.graphIri);
                // Update top node label immediately
                try {
                  const ontoTop = qs('#ontoTreeRoot .onto-node-label');
                  if (ontoTop) ontoTop.textContent = created.label || label;
                } catch(_) {}
                if (li) {
                  const lbl = li.querySelector('.node-label'); if (lbl) lbl.textContent = created.label || label;
                  li.dataset.label = created.label || label;
                  selectNode(li);
                  handleTreeSelection(li);
                } else {
                  // Fallback: set selection and force refresh display
                  activeOntologyIri = created.graphIri;
                  updateOntoGraphLabel();
                  refreshOntologyTree();
                }
              }
            } catch(_) {}
          };
          headerRow.appendChild(addBtn);
        }
      } catch(_) {}

      // Handle Delete key for ontology deletion
      root.addEventListener('keydown', async (e) => {
        if (e.key === 'Delete' || e.keyCode === 46) {
          const sel = root.querySelector('.node-row.selected');
          if (!sel) return;
          const li = sel.closest('li[role="treeitem"]');
          if (!li || li.dataset.nodeType !== 'ontology') return;
          const iri = li.dataset.iri;
          if (!iri) return;
          try {
            const url = `/api/ontologies?graph=${encodeURIComponent(iri)}`;
            const token = localStorage.getItem(tokenKey);
            const res = await fetch(url, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token } });
            if (res.ok) {
              await renderTree(project);
              if (activeOntologyIri === iri) { activeOntologyIri = null; updateOntoGraphLabel(); ensureOntologyInitialized(); ontoState.cy?.elements().remove(); refreshOntologyTree(); }
            }
          } catch(_) {}
        }
      });
    }

    async function refreshGraphSummary() {
      const el = qs('#graphSummary'); if (!el) return;
      el.textContent = 'Loading summary...';
      try {
        const res = await fetch('/api/ontology/summary');
        const json = await res.json();
        if (json.rows) {
          el.innerHTML = json.rows.map(r => `<div class="row"><span class="muted">${r.type}</span> — ${r.count}</div>`).join('') || '<div class="muted">No data</div>';
        } else {
          el.textContent = json.error || 'No data';
        }
      } catch (e) { el.textContent = 'Error loading summary'; }
    }
    (function(){
      const btnS = () => qs('#btnRefreshSummary');
      const btnQ = () => qs('#btnRunSparql');
      document.addEventListener('click', async (e) => {
        if (e.target === btnS()) {
          refreshGraphSummary();
        } else if (e.target === btnQ()) {
          const q = (qs('#sparqlInput')?.value) || '';
          const st = qs('#sparqlStatus'); const out = qs('#sparqlResult');
          st.textContent = 'Running...'; out.textContent = '';
          try {
            const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
            const json = await res.json();
            if (res.ok) { out.textContent = JSON.stringify(json, null, 2); st.textContent = 'OK'; }
            else { out.textContent = JSON.stringify(json, null, 2); st.textContent = 'Error'; }
          } catch (err) { out.textContent = String(err); st.textContent = 'Error'; }
        }
      });
    })();

    function refreshOntologyTree() {
      const root = qs('#ontoTreeRoot');
      if (!root || !ontoState.cy) return;
      const classes = ontoState.cy.nodes().filter(n => n.visible() && (n.data('type') || 'class') === 'class' && !n.hasClass('imported'));
      const importedClasses = ontoState.cy.nodes().filter(n => n.visible() && (n.data('type') || 'class') === 'class' && n.hasClass('imported'));
      const notes = ontoState.cy.nodes().filter(n => n.visible() && (n.data('type') || '') === 'note' && !n.hasClass('imported'));
      // Simple grouping: Classes as top-level; edges shown under a "Relationships" group per class
      root.innerHTML = '';
      const makeItem = (label, expanded = true, children = []) => {
        const li = document.createElement('li');
        li.setAttribute('role', 'treeitem');
        if (children.length) li.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        const row = document.createElement('div'); row.className = 'onto-node-row';
        const twist = document.createElement('span'); twist.className = 'onto-twist'; if (children.length) twist.onclick = (e)=>{ e.stopPropagation(); li.setAttribute('aria-expanded', li.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'); };
        const text = document.createElement('span'); text.className = 'onto-node-label'; text.textContent = label;
        row.appendChild(twist); row.appendChild(text); li.appendChild(row);
        if (children.length) {
          const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
          children.forEach(c => ul.appendChild(c));
          li.appendChild(ul);
        }
        return li;
      };
      const items = [];
      classes.forEach(cls => {
        const label = cls.data('label') || cls.id();
        const outEdges = cls.outgoers('edge');
        const rels = outEdges.map(e => {
          const other = e.target();
          const pred = e.data('predicate') || 'relatedTo';
          const type = e.data('type') || 'objectProperty';
          return makeItem(`${pred} → ${(other.data('label') || other.id())} (${type})`, false, []);
        });
        items.push(makeItem(label, false, rels));
      });
      if (importedClasses.length) {
        const importedChildren = importedClasses.map(cls => makeItem((cls.data('label')||cls.id()) + ' (imported)', false, []));
        items.push(makeItem('Imported Classes', true, importedChildren));
      }
      if (notes.length) {
        const noteChildren = notes.map(n => makeItem(n.data('label') || n.id(), false, []));
        items.push(makeItem('Notes', true, noteChildren));
      }
      const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
      items.forEach(i => ul.appendChild(i));
      // Root level
      const rootItem = document.createElement('li'); rootItem.setAttribute('role', 'treeitem'); rootItem.setAttribute('aria-expanded', 'true');
      const row = document.createElement('div'); row.className = 'onto-node-row';
      const twist = document.createElement('span'); twist.className = 'onto-twist'; twist.onclick = (e)=>{ e.stopPropagation(); rootItem.setAttribute('aria-expanded', rootItem.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'); };
      const text = document.createElement('span'); text.className = 'onto-node-label';
      (function(){
        try {
          const labels = loadOntologyLabelMap(activeProject);
          let modelName = 'Ontology';
          const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
          const scopedName = localStorage.getItem(`onto_model_name__${pid}`) || '';
          if (scopedName.trim()) modelName = scopedName.trim();
          else if (activeOntologyIri) {
            modelName = (labels[activeOntologyIri] && String(labels[activeOntologyIri]).trim()) || (activeOntologyIri.split('/').pop() || 'Ontology');
          }
          text.textContent = modelName;
        } catch(_) { text.textContent = 'Ontology'; }
      })();
      row.appendChild(twist); row.appendChild(text); rootItem.appendChild(row); rootItem.appendChild(ul);
      // (Do not delete projects here; project deletion is handled in the main tree top node in renderTree)
      root.innerHTML = '';
      root.appendChild(rootItem);

      // Imports node specific to current ontology
      try {
        const importsKey = 'onto_imports__' + encodeURIComponent(activeOntologyIri || '');
        const imports = JSON.parse(localStorage.getItem(importsKey) || '[]');
        const importsRoot = document.createElement('li'); importsRoot.setAttribute('role','treeitem'); importsRoot.setAttribute('aria-expanded','true');
        const row = document.createElement('div'); row.className = 'onto-node-row'; const tw = document.createElement('span'); tw.className = 'onto-twist'; const lbl = document.createElement('span'); lbl.className='onto-node-label'; lbl.textContent='Imports'; row.appendChild(tw); row.appendChild(lbl); importsRoot.appendChild(row);
        const ul = document.createElement('ul'); ul.setAttribute('role','group');
        function removeImport(iri) {
          const key = 'onto_imports__' + encodeURIComponent(activeOntologyIri || '');
          try {
            const curr = new Set(JSON.parse(localStorage.getItem(key) || '[]'));
            if (curr.has(iri)) { curr.delete(iri); localStorage.setItem(key, JSON.stringify(Array.from(curr))); refreshOntologyTree(); }
          } catch(_) {}
        }
        async function friendlyImportName(iri) {
          try {
            const q = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?label WHERE { GRAPH <${iri}> { <${iri}> a owl:Ontology . OPTIONAL { <${iri}> rdfs:label ?label } } }`;
            const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
            if (!res.ok) throw new Error('sparql');
            const json = await res.json();
            const b = json.results && json.results.bindings && json.results.bindings[0];
            const lbl = b && b.label && b.label.value;
            return (lbl && lbl.trim()) || (iri.split('/').pop() || iri);
          } catch(_) { return iri.split('/').pop() || iri; }
        }
        async function importEquivCount(importIri) {
          try {
            if (!ontoState.cy) return 0;
            const norm = s => String(s||'').trim().toLowerCase();
            const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type')||'class') === 'class' && !n.hasClass('imported'));
            const baseByLabel = new Map();
            baseClasses.forEach(n => { baseByLabel.set(norm(n.data('label')||n.id()), n); });
            const q = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?c ?label WHERE { GRAPH <${importIri}> { ?c a owl:Class . OPTIONAL { ?c rdfs:label ?label } } }`;
            const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
            if (!res.ok) return 0;
            const json = await res.json();
            const rows = (json && json.results && json.results.bindings) ? json.results.bindings : [];
            const matched = new Set();
            rows.forEach(b => {
              const iri = b.c && b.c.value; const label = b.label && b.label.value;
              const local = iri ? (iri.includes('#') ? iri.split('#').pop() : iri.split('/').pop()) : '';
              const key = norm(label || local);
              if (baseByLabel.has(key) && iri) matched.add(iri);
            });
            return matched.size;
          } catch(_) { return 0; }
        }
        const visibleSet = loadVisibleImports(activeOntologyIri);
        imports.forEach(async g => {
          const li = document.createElement('li'); li.setAttribute('role','treeitem'); li.dataset.importIri = g;
          const r=document.createElement('div'); r.className='onto-node-row'; r.tabIndex = 0;
          const cb=document.createElement('input'); cb.type='checkbox'; cb.style.marginRight = '6px'; cb.checked = visibleSet.has(g);
          const t=document.createElement('span'); t.className='onto-twist';
          const l=document.createElement('span'); l.className='onto-node-label';
          const name = await friendlyImportName(g);
          const cnt = await importEquivCount(g);
          l.textContent = `${name}${cnt ? ` (${cnt})` : ''}`;
          cb.addEventListener('change', async () => {
            const vis = loadVisibleImports(activeOntologyIri);
            if (cb.checked) vis.add(g); else vis.delete(g);
            saveVisibleImports(activeOntologyIri, vis);
            await overlayImportsRefresh();
          });
          r.onclick = (e)=>{ Array.from(ul.querySelectorAll('.onto-node-row')).forEach(n=>n.classList.remove('selected')); r.classList.add('selected'); };
          r.onkeydown = (e)=>{ const key=e.key||e.code; if (key==='Delete' || key==='Backspace') { e.preventDefault(); removeImport(g); } };
          r.appendChild(cb); r.appendChild(t); r.appendChild(l);
          li.appendChild(r); ul.appendChild(li);
        });
        importsRoot.appendChild(ul);
        root.appendChild(importsRoot);
        // Enable drop to import
        row.addEventListener('dragover', (e)=>{ e.preventDefault(); });
        row.addEventListener('drop', async (e)=>{
          e.preventDefault();
          const draggedIri = e.dataTransfer.getData('text/graph-iri');
          if (!draggedIri) return;
          const list = new Set(imports);
          if (!list.has(draggedIri)) { list.add(draggedIri); localStorage.setItem(importsKey, JSON.stringify(Array.from(list))); refreshOntologyTree(); }
          // Overlay imported classes (placeholder: we only list; loading remote triples is OW-2)
        });
      } catch(_) {}
    }

    // (empty-state banner removed)

    function updatePropertiesPanelFromSelection() {
      const form = qs('#ontoPropsForm'); if (!form || !ontoState.cy) return;
      const sel = ontoState.cy.$(':selected');
      const nameEl = qs('#propName');
      const typeEl = qs('#propType');
      const attrsEl = qs('#propAttrs');
      if (sel.length === 1 && sel[0].isNode()) {
        const n = sel[0];
        nameEl.value = n.data('label') || n.id();
        typeEl.value = n.data('type') || 'class';
        attrsEl.value = JSON.stringify(n.data('attrs') || {}, null, 2);
      } else if (sel.length === 1 && sel[0].isEdge()) {
        const e = sel[0];
        nameEl.value = e.data('predicate') || e.id();
        typeEl.value = e.data('type') || 'objectProperty';
        attrsEl.value = JSON.stringify(e.data('attrs') || {}, null, 2);
      } else {
        const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
        nameEl.value = localStorage.getItem(`onto_model_name__${pid}`) || 'Ontology Model';
        typeEl.value = 'model';
        try {
          const json = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}');
          attrsEl.value = JSON.stringify(json, null, 2);
        } catch(_) { attrsEl.value = '{}'; }
      }
    }

    function persistOntologyToLocalStorage() {
      if (!ontoState.cy) return;
      if (ontoState.suspendAutosave) return;
      try {
        const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({ data: n.data(), position: n.position() }));
        const edges = ontoState.cy.edges().filter(e => !e.hasClass('imported')).map(e => ({ data: e.data() }));
        if (activeOntologyIri) {
          localStorage.setItem(storageKeyForGraph(activeOntologyIri), JSON.stringify({ nodes, edges }));
        }
      } catch(_) {}
    }

    // graphKeyForActive not used; per-project keys are used via storageKeyForGraph
    function attrsFromModel() {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      try { return JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}'); } catch(_) { return {}; }
    }
    function loadOntologyLabelMap(project) {
      const pid = project?.id || project?.project_id || (activeProject && (activeProject.id || activeProject.project_id)) || 'default';
      try { return JSON.parse(localStorage.getItem(`onto_label_map__${pid}`) || '{}'); } catch(_) { return {}; }
    }
    function saveOntologyLabel(graphIri, label) {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      try { const m = loadOntologyLabelMap(activeProject); m[graphIri] = label; localStorage.setItem(`onto_label_map__${pid}`, JSON.stringify(m)); } catch(_) {}
    }
    function storageKeyForGraph(iri) {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      return `onto_graph__${pid}__` + encodeURIComponent(iri);
    }
    function saveGraphToLocal(graphIri) {
      try {
        const nodes = ontoState.cy ? ontoState.cy.nodes().jsons() : [];
        const edges = ontoState.cy ? ontoState.cy.edges().jsons() : [];
        localStorage.setItem(storageKeyForGraph(graphIri), JSON.stringify({ nodes, edges }));
      } catch(_) {}
    }
    function loadGraphFromLocal(graphIri) {
      try {
        const json = localStorage.getItem(storageKeyForGraph(graphIri));
        if (!json) return;
        const data = JSON.parse(json);
        if (!ontoState.cy) return;
        ontoState.cy.elements().remove();
        ontoState.cy.add(data.nodes || []);
        ontoState.cy.add(data.edges || []);
        // After loading, ensure nextId is advanced beyond existing ClassNNN
        recomputeNextId();
        requestAnimationFrame(()=>{ ontoState.cy.fit(); });
      } catch(_) {}
    }

    // Ontology toolbar events and import handling
    (function(){
      document.addEventListener('click', async (e) => {
        if (e.target === qs('#ontoLayoutBtn')) {
          runAutoLayout();
        } else if (e.target === qs('#ontoFitBtn')) {
          try { if (ontoState.cy) ontoState.cy.fit(undefined, 20); } catch(_) {}
        } else if (e.target === qs('#ontoFullscreenBtn')) {
          try {
            const sec = qs('#wb-ontology');
            if (!sec) return;
            if (!document.fullscreenElement) {
              if (sec.requestFullscreen) await sec.requestFullscreen();
            } else {
              if (document.exitFullscreen) await document.exitFullscreen();
            }
          } catch(_) {}
        } else if (e.target === qs('#ontoSaveBtn')) {
          try {
            if (!activeOntologyIri) { alert('Select an ontology to save.'); return; }
            // Compute auto linked_by pairs from imports
            const pairs = await computeLinkedByPairs(activeOntologyIri);
            const ttl = toTurtle(activeOntologyIri, pairs);
            const res = await fetch(`/api/ontology/save?graph=${encodeURIComponent(activeOntologyIri)}`, { method: 'POST', headers: { 'Content-Type': 'text/turtle' }, body: ttl });
            const json = await res.json().catch(()=>({}));
            if (res.ok) alert('Saved to Fuseki'); else alert('Save failed: ' + (json.detail || res.status));
          } catch (err) { alert('Save error: ' + err.message); }
        } else if (e.target.closest && e.target.closest('#ontoLinkIdenticalBtn')) {
          // Preview: count equivalent class links that will be saved (no UI edges yet)
          try {
            if (!activeOntologyIri || !ontoState.cy) return;
            const pairs = await computeLinkedByPairs(activeOntologyIri);
            if (pairs.length) alert(`Will save ${pairs.length} owl:equivalentClass links on Save.`);
            else alert('No identical classes found');
          } catch (err) { console.error(err); alert('Link check failed'); }
        } else if (e.target === qs('#ontoExportBtn')) {
          exportOntologyJSON();
        } else if (e.target === qs('#ontoImportBtn')) {
          const inp = qs('#ontoImportFile'); if (inp) inp.click();
        } else if (e.target === qs('#ontoTreeToggle') || e.target === qs('#ontoTreeToggleIcon')) {
          const sec = qs('#wb-ontology');
          if (!sec) return;
          const collapsed = sec.classList.toggle('onto-tree-collapsed');
          const icon = qs('#ontoTreeToggleIcon');
          if (icon) {
            // Left panel: show right chevron when collapsed, left chevron when expanded
            icon.innerHTML = collapsed
              ? '<path d="M9 6l6 6-6 6"/>'
              : '<path d="M15 6l-6 6 6 6"/>';
          }
          try { localStorage.setItem('onto_tree_collapsed', collapsed ? '1' : '0'); } catch(_) {}
          requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
        } else if (e.target === qs('#ontoPropsToggle') || e.target.closest('#ontoPropsToggle')) {
          const sec = qs('#wb-ontology');
          if (!sec) return;
          const collapsed = sec.classList.toggle('onto-props-collapsed');
          const icon = qs('#ontoPropsToggleIcon');
          if (icon) {
            // Right panel: show left chevron when collapsed, right chevron when expanded
            icon.innerHTML = collapsed
              ? '<path d="M15 6l-6 6 6 6"/>'
              : '<path d="M9 6l6 6-6 6"/>';
          }
          try { localStorage.setItem('onto_props_collapsed', collapsed ? '1' : '0'); } catch(_) {}
          // Wait for reflow before resizing Cytoscape so it fits the new grid
          requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
        } else if (e.target === qs('#propSaveBtn')) {
          // Save properties
          try {
            if (!ontoState.cy) return;
            const sel = ontoState.cy.$(':selected');
            const nameEl = qs('#propName');
            const typeEl = qs('#propType');
            const attrsEl = qs('#propAttrs');
            if (sel.length === 1 && sel[0].isNode()) {
              const n = sel[0];
              n.data('label', nameEl.value.trim() || n.data('label'));
              n.data('type', typeEl.value || n.data('type'));
              const parsed = JSON.parse(attrsEl.value || '{}');
              n.data('attrs', parsed);
            } else if (sel.length === 1 && sel[0].isEdge()) {
              const ed = sel[0];
              ed.data('predicate', nameEl.value.trim() || ed.data('predicate'));
              ed.data('type', typeEl.value || ed.data('type'));
              const parsed = JSON.parse(attrsEl.value || '{}');
              ed.data('attrs', parsed);
            } else {
              localStorage.setItem('onto_model_name', nameEl.value.trim() || 'Ontology Model');
              try { localStorage.setItem('onto_model_attrs', JSON.stringify(JSON.parse(attrsEl.value || '{}'))); } catch(_) { localStorage.setItem('onto_model_attrs', '{}'); }
            }
            refreshOntologyTree();
            persistOntologyToLocalStorage();
            const st = qs('#propSaveStatus'); if (st) { st.textContent = 'Saved'; setTimeout(()=>{ const s=qs('#propSaveStatus'); if (s) s.textContent=''; }, 1000); }
          } catch (_) {
            const st = qs('#propSaveStatus'); if (st) { st.textContent = 'Error'; setTimeout(()=>{ const s=qs('#propSaveStatus'); if (s) s.textContent=''; }, 1200); }
          }
        }
      });
      // Keep Cytoscape sized correctly in fullscreen and update button title
      document.addEventListener('fullscreenchange', () => {
        const btn = qs('#ontoFullscreenBtn');
        if (btn) btn.title = document.fullscreenElement ? 'Exit fullscreen' : 'Enter fullscreen';
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      const header = qs('#ontoTreeHeader');
      if (header) header.addEventListener('dblclick', (e) => {
        const toggleBtn = qs('#ontoTreeToggle');
        if (toggleBtn) toggleBtn.click();
      });
      const propsHeader = qs('#ontoPropsHeader');
      if (propsHeader) propsHeader.addEventListener('dblclick', (e) => {
        const toggleBtn = qs('#ontoPropsToggle');
        if (toggleBtn) toggleBtn.click();
      });
      const fileInput = () => qs('#ontoImportFile');
      document.addEventListener('change', async (e) => {
        if (e.target === fileInput()) {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          try {
            const text = await file.text();
            const json = JSON.parse(text);
            importOntologyJSON(json);
          } catch (_) {
            alert('Invalid ontology JSON');
          } finally {
            e.target.value = '';
          }
        }
      });
    })();

    window.addEventListener('resize', () => { if (ontoState.cy) ontoState.cy.resize(); });

    function getSampleProject() {
      return {
        id: 'demo',
        name: 'Sample Project',
        ontology: {
          base: { id: 'BASE-ONTO', name: 'Base Ontology', versions: ['1.0', '1.1'] },
          systems: {
            base: { id: 'SYS-BASE', name: 'Systems Ontology', versions: ['0.1', '0.2'] },
            imports: [
              { id: 'GEO', name: 'Geo Ontology', versions: ['2023-09', '2024-02'] },
              { id: 'RELY', name: 'Reliability Ontology', versions: ['1.0'] },
              { id: 'ORG', name: 'Organization Ontology', versions: ['0.9'] }
            ]
          }
        },
        requirements: [
          { id: 'R-001', title: 'The system shall ingest documents and extract requirements.' },
          { id: 'R-002', title: 'The system should support ontology-based tagging of entities.' },
          { id: 'R-003', title: 'The system must store outputs in RDF, GraphDB, and Vector Store.' }
        ],
        documents: {
          requirements: [
            { id: 'RD-01', name: 'Concept of Operations.pdf' },
            { id: 'RD-02', name: 'Capabilities Development Document.docx' }
          ],
          knowledge: [
            { id: 'KD-01', name: 'Requirements Development Instructions.md' },
            { id: 'KD-02', name: 'Industry Spec MIL-STD-961E.pdf' }
          ]
        },
        artifacts: [
          { id: 'ART-01', name: 'White Paper - Initial Draft.md' },
          { id: 'ART-02', name: 'System Architecture Diagram.png' }
        ]
      };
    }

    function toggleNode(li) {
      const exp = li.getAttribute('aria-expanded');
      if (exp === null) return;
      li.setAttribute('aria-expanded', exp === 'true' ? 'false' : 'true');
    }

    function selectNode(li) {
      qsa('.node-row').forEach(r => r.classList.remove('selected'));
      const row = li.querySelector('.node-row');
      if (row) row.classList.add('selected');
    }

    function handleKey(e, li) {
      const LEFT = 37, UP = 38, RIGHT = 39, DOWN = 40, ENTER = 13, SPACE = 32;
      const exp = li.getAttribute('aria-expanded');
      switch (e.keyCode) {
        case LEFT:
          if (exp === 'true') { toggleNode(li); } else { focusParent(li); }
          e.preventDefault(); break;
        case RIGHT:
          if (exp === 'false') { toggleNode(li); } else { focusFirstChild(li); }
          e.preventDefault(); break;
        case UP:
          focusPrev(li); e.preventDefault(); break;
        case DOWN:
          focusNext(li); e.preventDefault(); break;
        case ENTER:
        case SPACE:
          selectNode(li); handleTreeSelection(li); e.preventDefault(); break;
      }
    }

    function focusParent(li) {
      const parentLi = li.parentElement.closest('li[role="treeitem"]');
      if (parentLi) (parentLi.querySelector('.node-row') || parentLi).focus();
    }
    function focusFirstChild(li) {
      const child = li.querySelector('ul[role="group"] > li[role="treeitem"] .node-row');
      if (child) child.focus();
    }
    function visibleTreeItems() {
      const acc = [];
      function addVisible(container) {
        const items = Array.from(container.children).filter(n => n.matches('li[role="treeitem"]'));
        items.forEach(li => {
          acc.push(li);
          const exp = li.getAttribute('aria-expanded');
          if (exp === 'true') {
            const group = li.querySelector('ul[role="group"]');
            if (group) addVisible(group);
          }
        });
      }
      addVisible(qs('#treeRoot'));
      return acc;
    }
    function focusPrev(li) {
      const list = visibleTreeItems();
      const idx = list.indexOf(li);
      if (idx > 0) (list[idx - 1].querySelector('.node-row') || list[idx - 1]).focus();
    }
    function focusNext(li) {
      const list = visibleTreeItems();
      const idx = list.indexOf(li);
      if (idx >= 0 && idx < list.length - 1) (list[idx + 1].querySelector('.node-row') || list[idx + 1]).focus();
    }

    // Boot
    initAuth();
    // Per-project restore happens inside renderTree; avoid global restore that can clobber state
    // Save shortcut Ctrl/Cmd+S
    document.addEventListener('keydown', async (e) => {
      const isSave = (e.key === 's' || e.key === 'S') && (e.ctrlKey || e.metaKey);
      if (!isSave) return;
      e.preventDefault();
      try {
        if (!activeOntologyIri) { alert('Select an ontology to save.'); return; }
        const ttl = toTurtle(activeOntologyIri);
        const res = await fetch(`/api/ontology/save?graph=${encodeURIComponent(activeOntologyIri)}`, { method: 'POST', headers: { 'Content-Type': 'text/turtle' }, body: ttl });
        const json = await res.json().catch(()=>({}));
        if (res.ok) alert('Saved to Fuseki'); else alert('Save failed: ' + (json.detail || res.status));
      } catch (err) { alert('Save error: ' + err.message); }
    }, false);

    // Delete selected canvas entities (nodes/edges) for current ontology only
    function performDelete() {
      if (!(qs('#wb-ontology') && qs('#wb-ontology').classList.contains('active'))) return false;
      if (!ontoState.cy) return false;
      const sel = ontoState.cy.$(':selected');
      if (!sel || sel.length === 0) return false;
      ontoState.cy.remove(sel);
      refreshOntologyTree();
      persistOntologyToLocalStorage();
      return true;
    }
    function handleDeleteKey(e) {
      const key = e.key || e.code;
      const tgt = e.target;
      const isTyping = tgt && (tgt.tagName === 'INPUT' || tgt.tagName === 'TEXTAREA' || tgt.isContentEditable);
      const inline = qs('#ontoInlineEdit');
      const inlineVisible = inline ? (getComputedStyle(inline).display !== 'none') : false;
      if (isTyping || inlineVisible) return;
      if ((key === 'Delete' || key === 'Backspace') && ontoState.cy) {
        const ok = performDelete();
        if (ok) { e.preventDefault(); e.stopPropagation(); }
      }
    }
    document.addEventListener('keydown', handleDeleteKey, false);
    window.addEventListener('keydown', handleDeleteKey, true);
    // Keyup fallback in case keydown is intercepted by browser/OS
    document.addEventListener('keyup', handleDeleteKey, false);
    // Toolbar delete
    document.addEventListener('click', (e) => {
      if (e.target === qs('#ontoDeleteBtn')) {
        performDelete();
      }
    });

    // Files workbench state + helpers
    const filesState = { initialized: false, lastFiles: [], staged: [], library: [], sortBy: 'name', sortDir: 'asc' };
    function toast(msg, isError=false) {
      const el = qs('#filesToast'); if (!el) return;
      el.textContent = msg || '';
      el.style.color = isError ? '#ef4444' : '#9aa4b2';
      if (!msg) return;
      setTimeout(()=>{ if (el.textContent === msg) el.textContent=''; }, 3000);
    }
    function renderFilesList(items, projectId = null) {
      const list = qs('#filesList'); if (!list) return;
      list.innerHTML = '';
      const arr = Array.isArray(items) ? items : [];
      if (!arr.length) {
        const div = document.createElement('div');
        div.className = 'muted';
        div.textContent = 'No files yet. Upload or import to begin.';
        list.appendChild(div);
        return;
      }
      
      // Get current project ID if not provided
      if (!projectId) {
        try { 
          projectId = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : localStorage.getItem('active_project_id'); 
        } catch(_) { 
          projectId = '';
        }
      }
      const toBadge = (text) => `<span style="border:1px solid var(--border); padding:2px 6px; border-radius:6px; font-size:12px;">${text}</span>`;
        const getVisibilityBadge = (visibility, fileProjectId, currentProjectId) => {
          const isPublic = visibility === 'public';
          const isFromOtherProject = fileProjectId !== currentProjectId;
          
          if (isPublic) {
            const badgeText = isFromOtherProject ? '🌐 Shared' : '🌐 Public';
            return `<span style="background:rgba(37, 99, 235, 0.2); border:1px solid var(--accent); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--accent);" title="Available to all projects">${badgeText}</span>`;
          } else {
            return `<span style="background:var(--panel-2); border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--muted);" title="Only available in this project">🔒 Private</span>`;
          }
        };
        
        const getActionButtons = (meta, id, currentProjectId) => {
          const isSharedFile = meta.visibility === 'public' && meta.project_id !== currentProjectId;
          const username = localStorage.getItem('odras_user') || '';
          const isAdminUser = username === 'admin';
          
          let buttons = [];
          
          // Knowledge ingest button - disabled for shared files for non-admin users
          if (!isSharedFile || isAdminUser) {
            buttons.push(`<button class="btn" data-action="ingest" data-id="${id}" title="Add to Knowledge Base">🧠 Knowledge</button>`);
          } else {
            buttons.push(`<button class="btn" data-action="ingest" data-id="${id}" disabled style="opacity:0.5; cursor:not-allowed;" title="Cannot ingest shared files">🧠 Knowledge</button>`);
          }
          
          // URL button - always available
          buttons.push(`<button class="btn" data-action="url" data-id="${id}">URL</button>`);
          
          // Admin visibility toggle - only for admin users
          buttons.push(`<button class="btn admin-only" data-action="toggle-visibility" data-id="${id}" data-visibility="${meta.visibility || 'private'}" title="Toggle visibility (Admin)" style="display:none;">${(meta.visibility === 'public') ? '🔒' : '🌐'}</button>`);
          
          // Delete button - disabled for shared files for non-admin users
          if (!isSharedFile || isAdminUser) {
            buttons.push(`<button class="btn" data-action="delete" data-id="${id}">Delete</button>`);
          } else {
            buttons.push(`<button class="btn" data-action="delete" data-id="${id}" disabled style="opacity:0.5; cursor:not-allowed;" title="Cannot delete shared files">Delete</button>`);
          }
          
          return buttons.join(' ');
        };
        
        const getEditableDocTypeBadge = (docType, fileId, currentProjectId, meta) => {
          const isSharedFile = meta.visibility === 'public' && meta.project_id !== currentProjectId;
          const username = localStorage.getItem('odras_user') || '';
          const isAdminUser = username === 'admin';
          const canEdit = !isSharedFile || isAdminUser;
          
          const colors = {
            'requirements': { bg: 'rgba(239, 68, 68, 0.2)', border: '#ef4444', color: '#f87171' },
            'knowledge': { bg: 'rgba(34, 197, 94, 0.2)', border: '#22c55e', color: '#4ade80' },
            'reference': { bg: 'rgba(168, 85, 247, 0.2)', border: '#a855f7', color: '#c084fc' },
            'specification': { bg: 'rgba(59, 130, 246, 0.2)', border: '#3b82f6', color: '#60a5fa' },
            'unknown': { bg: 'var(--panel-2)', border: 'var(--border)', color: 'var(--muted)' }
          };
          
          const style = colors[docType] || colors['unknown'];
          const cursor = canEdit ? 'pointer' : 'default';
          const title = canEdit ? 'Click to change document type' : (isSharedFile ? 'Cannot edit shared files' : '');
          
          return `<span 
            class="doc-type-badge${canEdit ? ' editable-doc-type' : ''}" 
            data-file-id="${fileId}" 
            data-current-type="${docType}"
            style="background:${style.bg}; border:1px solid ${style.border}; color:${style.color}; padding:2px 6px; border-radius:6px; font-size:12px; cursor:${cursor};" 
            title="${title}"
            ${canEdit ? 'onclick="editDocType(this)"' : ''}
          >${docType.charAt(0).toUpperCase() + docType.slice(1)}</span>`;
        };
      const rows = arr.map(meta => {
        const name = meta.filename || meta.name || 'file';
        const id = meta.file_id || meta.id || '';
        const tags = meta.tags || {};
        const status = tags.status || 'new';
        const size = meta.size || 0;
        const sizeStr = size ? `${size}` : '';
        const created = meta.created_at ? new Date(meta.created_at).toLocaleString() : '';
        return `<tr>
          <td style="width:32px; text-align:center;"><input type="checkbox" class="file-select" data-id="${id}" /></td>
          <td><div style="display:flex; flex-direction:column;"><span style="font-weight:600;">${name}</span><span class="muted" style="font-size:12px;">${id}</span></div></td>
          <td>${getEditableDocTypeBadge(tags.docType || 'unknown', id, projectId, meta)}</td>
          <td>${toBadge(status)}</td>
          <td>${getVisibilityBadge(meta.visibility || 'private', meta.project_id, projectId)}</td>
          <td style="text-align:right;">${sizeStr}</td>
          <td class="muted" style="font-size:12px;">${created}</td>
          <td style="text-align:right;">
            ${getActionButtons(meta, id, projectId)}
          </td>
        </tr>`;
      }).join('');
      list.innerHTML = `
        <div style="overflow:auto;">
          <table style="width:100%; border-collapse:separate; border-spacing:0 6px;">
            <thead>
              <tr>
                <th style="width:32px;"><input type="checkbox" id="filesSelectAll" /></th>
                <th data-sort="name" style="cursor:pointer;">Name</th>
                <th data-sort="type" style="cursor:pointer;">Type</th>
                <th data-sort="status" style="cursor:pointer;">Status</th>
                <th data-sort="visibility" style="cursor:pointer;">Visibility</th>
                <th data-sort="size" style="text-align:right; cursor:pointer;">Size</th>
                <th>Uploaded</th>
                <th style="text-align:right;">Actions</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>`;
      // Sorting handlers
      const thead = list.querySelector('thead');
      if (thead) thead.addEventListener('click', (e) => {
        const th = e.target.closest('[data-sort]'); if (!th) return;
        const key = th.getAttribute('data-sort');
        if (filesState.sortBy === key) filesState.sortDir = (filesState.sortDir === 'asc' ? 'desc' : 'asc');
        else { filesState.sortBy = key; filesState.sortDir = 'asc'; }
        // Re-sort current state
        try { renderFilesList(sortItems(filesState.library)); } catch(_) {}
      });
      const selAll = list.querySelector('#filesSelectAll');
      if (selAll) selAll.addEventListener('change', () => {
        list.querySelectorAll('.file-select').forEach(cb => { cb.checked = selAll.checked; });
        
        // Clear preview when deselecting all
        if (!selAll.checked) {
          clearFilePreview();
        }
      });
      // Update "Select All" state based on individual checkboxes
      function updateSelectAllState() {
        const selAll = list.querySelector('#filesSelectAll');
        if (!selAll) return;
        
        const allCheckboxes = list.querySelectorAll('.file-select');
        const checkedBoxes = list.querySelectorAll('.file-select:checked');
        
        if (checkedBoxes.length === 0) {
          selAll.checked = false;
          selAll.indeterminate = false;
          clearFilePreview(); // Clear preview when no files are selected
        } else if (checkedBoxes.length === allCheckboxes.length) {
          selAll.checked = true;
          selAll.indeterminate = false;
        } else {
          selAll.checked = false;
          selAll.indeterminate = true;
        }
      }
      
      // Handle individual checkbox clicks (without interfering with row clicks)
      list.querySelectorAll('.file-select').forEach(cb => {
        cb.addEventListener('click', async (e) => {
          e.stopPropagation(); // Prevent row click from firing
          const id = cb.getAttribute('data-id');
          console.log('🔲 Checkbox clicked for file:', id, 'checked:', cb.checked);
          
          // Update Select All state
          updateSelectAllState();
          
          // Update preview based on selection
          if (cb.checked && id) {
            await updateFilePreview(id);
          } else {
            clearFilePreview();
          }
        });
      });
      
      // Click to select and preview (but not on checkboxes or buttons)
      list.querySelectorAll('tbody tr').forEach(tr => {
        tr.addEventListener('click', async (e) => {
          if (e.target.closest('button')) return;
          if (e.target.closest('.file-select')) return; // Don't interfere with checkbox clicks
          const cb = tr.querySelector('.file-select');
          const id = cb ? cb.getAttribute('data-id') : '';
          if (!id) return;
          // Toggle checkbox state instead of always setting to true
          cb.checked = !cb.checked;
          console.log('🔲 Row clicked, toggled checkbox for file:', id, 'checked:', cb.checked);
          
          // Update Select All state
          updateSelectAllState();
          
          if (cb.checked) {
          await updateFilePreview(id);
          } else {
            clearFilePreview();
          }
        });
      });
      // Delegate actions
      list.onclick = async (e) => {
        const btn = e.target.closest('button[data-action]');
        if (!btn) return;
        const id = btn.getAttribute('data-id');
        const action = btn.getAttribute('data-action');
        if (!id) return;
        if (action === 'delete') {
          if (!confirm('Delete this file?')) return;
          console.log('🗑️  Starting delete for file:', id);
          const ok = await deleteStoredFileViaApi(id);
          console.log('🗑️  Delete result:', ok);
          if (ok) { 
            console.log('🗑️  Refreshing library after successful delete');
            toast('Deleted'); 
            await window.loadLibraryFromApi(); 
            console.log('🗑️  Library refresh completed');
          } else { 
            console.error('🗑️  Delete failed, not refreshing library');
            toast('Delete failed', true); 
          }
        }
        if (action === 'toggle-visibility') {
          // Check admin status synchronously for immediate response
          const username = localStorage.getItem('odras_user') || '';
          const isAdminUser = username === 'admin';
          
          console.log('👑 Checking admin access - username:', username, 'isAdmin:', isAdminUser);
          
          if (!isAdminUser) {
            toast('Admin access required', true);
            return;
          }
          
          const currentVisibility = btn.getAttribute('data-visibility') || 'private';
          const newVisibility = currentVisibility === 'public' ? 'private' : 'public';
          const confirmText = `Make this file ${newVisibility}?\n\n${newVisibility === 'public' ? 'Public files are available to all projects.' : 'Private files are only visible in their project.'}`;
          
          if (!confirm(confirmText)) return;
          
          console.log('👑 Admin toggling file visibility:', id, 'from', currentVisibility, 'to', newVisibility);
          toast('Updating visibility...');
          
          try {
            const formData = new FormData();
            formData.append('visibility', newVisibility);
            
            console.log('👑 Making API call to /api/files/' + id + '/visibility with visibility:', newVisibility);
            
            const response = await fetch(`/api/files/${id}/visibility`, {
              method: 'PUT',
              headers: { ...window.authHeader() },
              body: formData
            });
            
            console.log('👑 API response status:', response.status, response.statusText);
            
            const result = await response.json();
            console.log('👑 API response data:', result);
            
            if (result.success) {
              toast(`File is now ${newVisibility}`);
              console.log('👑 Refreshing library to show updated visibility');
              await window.loadLibraryFromApi(); // Refresh to show updated visibility
            } else {
              console.error('👑 API returned error:', result);
              toast('Visibility update failed: ' + (result.error || result.message || 'Unknown error'), true);
            }
          } catch (error) {
            console.error('👑 Visibility update error:', error);
            toast('Network error updating visibility', true);
          }
        } else if (action === 'url') {
          const url = await getFileUrlViaApi(id);
          if (url) { try { await navigator.clipboard.writeText(url); toast('URL copied'); } catch(_) { window.open(url, '_blank'); } }
        } else if (action === 'ingest') {
          const pid = window.currentProjectId ? window.currentProjectId() : ''; if (!pid) { toast('Select a project first', true); return; }
          if (window.openIngestParamsModal) window.openIngestParamsModal(pid, [id]);
        }
      };
      // Bulk buttons
      try {
        const bulkDelete = qs('#filesBulkDeleteBtn');
        const bulkProcess = qs('#filesBulkProcessBtn');
        const bulkIngest = qs('#filesBulkIngestBtn');
        const selectedIds = () => Array.from(list.querySelectorAll('.file-select:checked')).map(c => c.getAttribute('data-id'));
        if (bulkDelete) bulkDelete.onclick = async () => {
          const ids = selectedIds(); if (!ids.length) { toast('No files selected', true); return; }
          if (!confirm(`Delete ${ids.length} file(s)?`)) return;
          console.log('🗑️  Starting bulk delete for files:', ids);
          let ok = 0; for (const id of ids) { if (await deleteStoredFileViaApi(id)) ok++; }
          console.log('🗑️  Bulk delete completed:', ok, 'of', ids.length);
          toast(`Deleted ${ok}/${ids.length}`); 
          console.log('🗑️  Refreshing library after bulk delete');
          await window.loadLibraryFromApi();
          console.log('🗑️  Bulk delete library refresh completed');
        };
        if (bulkProcess) bulkProcess.onclick = async () => {
          const ids = selectedIds(); if (!ids.length) { toast('No files selected', true); return; }
          let ok = 0; for (const id of ids) { if (await processFileViaApi(id)) ok++; }
          toast(`Started ${ok}/${ids.length}`);
        };
        if (bulkIngest) bulkIngest.onclick = async () => {
          const ids = selectedIds(); if (!ids.length) { toast('No files selected', true); return; }
          const pid = window.currentProjectId ? window.currentProjectId() : ''; if (!pid) { toast('Select a project first', true); return; }
          if (window.openIngestParamsModal) window.openIngestParamsModal(pid, ids);
        };
      } catch(_) {}
    }
    function renderStagedList() {
      const list = qs('#stagedList'); if (!list) return;
      const docTypeSelector = qs('#stagedDocTypeSelector');
      const knowledgeOptions = qs('#knowledgeProcessingOptions');
      
      list.innerHTML = '';
      
      if (!filesState.staged.length) {
        const div = document.createElement('div'); div.className = 'muted'; div.textContent = 'No staged files.'; list.appendChild(div);
        // Hide options when no files are staged
        if (docTypeSelector) docTypeSelector.style.display = 'none';
        if (knowledgeOptions) knowledgeOptions.style.display = 'none';
        return;
      }
      
      // Show options when files are staged
      if (docTypeSelector) docTypeSelector.style.display = 'block';
      if (knowledgeOptions) knowledgeOptions.style.display = 'block';
      filesState.staged.forEach((f, idx) => {
        const row = document.createElement('div'); row.className = 'card'; row.style.display='grid'; row.style.gridTemplateColumns='1fr auto'; row.style.alignItems='center'; row.style.padding='8px';
        const left = document.createElement('div'); left.innerHTML = `<strong>${f.name}</strong> <span class="muted">${f.size} bytes</span>`;
        const actions = document.createElement('div'); actions.style.display='flex'; actions.style.gap='8px';
        const up = document.createElement('button'); up.className='btn'; up.textContent='Upload'; up.onclick=async()=>{ const ok = await (window.odrasUploadOne ? window.odrasUploadOne(f) : Promise.resolve(false)); if (ok) { toast('Uploaded 1/1'); filesState.staged.splice(idx,1); renderStagedList(); try { if (window.odrasLoadLibrary) await window.odrasLoadLibrary(); } catch(_) {} } else { toast('Upload failed', true); } };
        const rem = document.createElement('button'); rem.className='btn'; rem.textContent='Remove'; rem.onclick=()=>{ filesState.staged.splice(idx,1); renderStagedList(); };
        actions.appendChild(up); actions.appendChild(rem);
        row.appendChild(left); row.appendChild(actions);
        list.appendChild(row);
      });
    }
    function previewSelectedFiles(fileList) {
      const el = qs('#uploadPreview'); if (!el) return;
      if (!fileList || !fileList.length) { el.textContent = ''; return; }
      const names = Array.from(fileList).map(f => `${f.name} (${f.size} bytes)`).join(', ');
      el.textContent = `Selected: ${names}`;
    }
    function ensureFilesInitialized() {
      if (filesState.initialized) return;
      filesState.initialized = true;
      const input = qs('#fileUploadInput');
      const choose = qs('#fileChooseBtn');
      const drop = qs('#fileDropZone');
      const urlInput = qs('#fileUrlInput');
      const urlBtn = qs('#fileUrlImportBtn');
      const refreshBtn = qs('#filesRefreshBtn');
      const includePublicCheckbox = qs('#filesIncludePublic');
      const docType = qs('#filesDocType');
      const statusSel = qs('#filesStatus');
      const tags = qs('#filesTags');
      function authHeader() {
        try { const t = localStorage.getItem('odras_token'); return t ? { Authorization: 'Bearer ' + t } : {}; } catch(_) { return {}; }
      }
      function currentProjectId() {
        try { const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : localStorage.getItem('active_project_id'); return pid || ''; } catch(_) { return ''; }
      }
      // Expose currentProjectId globally for use in other scopes
      window.currentProjectId = currentProjectId;
      async function uploadOne(fileMeta) {
        console.log('🔼 Starting upload for:', fileMeta.name, fileMeta.size, 'bytes');
        
        const pid = currentProjectId(); 
        console.log('📁 Project ID for upload:', pid);
        console.log('📁 activeProject:', window.activeProject);
        console.log('📁 localStorage project_id:', localStorage.getItem('active_project_id'));
        if (!pid) { 
          console.error('❌ No project selected');
          toast('Select a project first', true); 
          return false; 
        }
        
        const headers = { ...authHeader() };
        console.log('🔐 Auth headers:', headers.Authorization ? 'Present' : 'Missing');
        if (!headers.Authorization) { 
          console.error('❌ No auth token');
          toast('Login required', true); 
          return false; 
        }
        
        const fd = new FormData();
        fd.append('file', fileMeta);
        fd.append('project_id', pid);
        
        // Check knowledge processing options
        const enableKnowledgeProcessing = qs('#enableKnowledgeProcessing');
        const knowledgeEnabled = enableKnowledgeProcessing && enableKnowledgeProcessing.checked;
        
        if (knowledgeEnabled) {
          fd.append('process_for_knowledge', 'true');
          
          // Add embedding model and chunking strategy
          const embeddingModel = qs('#embeddingModel')?.value || 'all-MiniLM-L6-v2';
          const chunkingStrategy = qs('#chunkingStrategy')?.value || 'hybrid';
          
          fd.append('embedding_model', embeddingModel);
          fd.append('chunking_strategy', chunkingStrategy);
          
          console.log('🧠 Knowledge processing enabled:', embeddingModel, chunkingStrategy);
        }
        
        try {
          const t = (tags && tags.value || '').trim();
          const list = t ? t.split(',').map(s=>s.trim()).filter(Boolean) : [];
          // Use document type from staged file if available, otherwise fall back to filter dropdown
          const selectedDocType = fileMeta.docType || (docType && docType.value) || 'unknown';
          const tagObj = { docType: selectedDocType, status: 'new' };
          if (list.length) tagObj.userTags = list;
          fd.append('tags', JSON.stringify(tagObj));
          console.log('🏷️  Tags with document type:', tagObj);
        } catch(e) {
          console.warn('⚠️  Tags error:', e);
        }
        
        try {
          console.log('📤 Making upload request to /api/files/upload');
          const res = await fetch('/api/files/upload', { method: 'POST', headers, body: fd });
          console.log('📥 Upload response status:', res.status, res.statusText);
          
          const js = await res.json().catch((e)=>{ 
            console.error('❌ Failed to parse response JSON:', e); 
            return {}; 
          });
          console.log('📄 Upload response data:', js);
          
          if (!res.ok || js.success === false) { 
            const errorMsg = js.error || js.detail || 'upload failed';
            console.error('❌ Upload failed:', errorMsg);
            toast(`Upload failed: ${errorMsg}`, true);
            throw new Error(errorMsg); 
          }
          
          console.log('✅ Upload successful, file_id:', js.file_id);
          toast(`Uploaded: ${fileMeta.name}`, false);
          return true;
        } catch (err) {
          console.error('❌ Upload exception:', err);
          toast(`Upload error: ${err.message}`, true);
          return false;
        }
      }
      // Expose for other handlers defined outside this scope
      try { window.odrasUploadOne = uploadOne; } catch(_) {}
      async function loadLibraryFromApi() {
        const pid = currentProjectId(); 
        console.log('📚 Loading library for project:', pid);
        console.log('📚 activeProject:', window.activeProject);
        console.log('📚 localStorage project_id:', localStorage.getItem('active_project_id'));
        if (!pid) { 
          console.log('📚 No project ID, clearing library');
          renderFilesList([], ''); 
          return; 
        }
        
        
        const includePublicCheckbox = qs('#filesIncludePublic');
        const includePublic = includePublicCheckbox ? includePublicCheckbox.checked : false;
        
        try {
          const url = `/api/files?project_id=${pid}${includePublic ? '&include_public=true' : ''}`;
          console.log('📚 Fetching files from', url);
          const res = await fetch(url, { headers: { ...authHeader() } });
          console.log('📚 Files API response status:', res.status, res.statusText);
          
          const js = await res.json();
          console.log('📚 Files API response data:', js);
          console.log('📚 Individual files:', js.files);
          
          let items = js && js.files ? js.files : [];
          console.log('📚 Raw files count:', items.length);
          
          // Client-side filters
          const wantType = (docType && docType.value) || '';
          const wantStatus = (statusSel && statusSel.value) || '';
          const tagFilter = (tags && tags.value || '').trim().toLowerCase();
          console.log('📚 Filters - Type:', wantType, 'Status:', wantStatus, 'Tags:', tagFilter);
          
          const filtered = items.filter(m => {
            const t = m.tags || {};
            const okType = !wantType || (t.docType || 'unknown') === wantType;
            const okStatus = !wantStatus || (t.status || 'new') === wantStatus;
            const okTags = !tagFilter || JSON.stringify(t).toLowerCase().includes(tagFilter);
            return okType && okStatus && okTags;
          });
          
          console.log('📚 Filtered files count:', filtered.length);
          if (filtered.length > 0) {
            console.log('📚 Sample file:', filtered[0]);
          } else {
            console.log('📚 No files after filtering. Original count:', items.length);
            console.log('📚 Filter settings - Type:', wantType, 'Status:', wantStatus, 'Tags:', tagFilter);
            if (items.length > 0) {
              console.log('📚 Sample raw file:', items[0]);
            }
          }
          
          filesState.library = filtered;
          renderFilesList(sortItems(filtered), pid);
          console.log('📚 Library updated and rendered');
          
          // Show admin buttons if user is admin
          toggleAdminButtons();
        } catch(e) { 
          console.error('📚 Library loading failed:', e);
          renderFilesList([], pid);
          
          // Show admin buttons if user is admin (even on error)
          toggleAdminButtons();
        }
      }
      // Show/hide admin buttons after rendering list
      async function toggleAdminButtons() {
        try {
          const adminStatus = await isAdmin();
          console.log('👑 Admin status:', adminStatus);
          
          document.querySelectorAll('.admin-only').forEach(btn => {
            btn.style.display = adminStatus ? 'inline-block' : 'none';
          });
        } catch (error) {
          console.error('👑 Error checking admin status:', error);
          // Hide admin buttons on error
          document.querySelectorAll('.admin-only').forEach(btn => {
            btn.style.display = 'none';
          });
        }
      }
      // Expose functions globally for staged-list handlers and other components
      try { 
        window.odrasLoadLibrary = loadLibraryFromApi; 
        window.loadLibraryFromApi = loadLibraryFromApi; // Also expose without prefix for internal use
        window.authHeader = authHeader; // Expose auth header function globally
        window.editDocType = editDocType; // Expose document type editor globally
      } catch(_) {}
      
      // Document type inline editor
      async function editDocType(badgeElement) {
        const fileId = badgeElement.getAttribute('data-file-id');
        const currentType = badgeElement.getAttribute('data-current-type');
        
        // Create inline dropdown
        const select = document.createElement('select');
        select.style.cssText = 'background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:4px; padding:2px 4px; font-size:12px;';
        
        const options = ['unknown', 'requirements', 'knowledge', 'reference', 'specification'];
        options.forEach(type => {
          const option = document.createElement('option');
          option.value = type;
          option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
          option.selected = type === currentType;
          select.appendChild(option);
        });
        
        // Replace badge with dropdown temporarily
        const originalHTML = badgeElement.outerHTML;
        badgeElement.parentNode.replaceChild(select, badgeElement);
        select.focus();
        
        // Handle selection
        const handleChange = async (newType) => {
          if (newType === currentType) {
            // No change, restore original badge
            select.parentNode.innerHTML = originalHTML;
            return;
          }
          
          try {
            // Update file tags on server
            const response = await fetch(`/api/files/${fileId}/tags`, {
              method: 'PUT',
              headers: { 
                'Content-Type': 'application/json',
                ...window.authHeader() 
              },
              body: JSON.stringify({ tags: { docType: newType } })
            });
            
            const result = await response.json();
            if (result.success) {
              toast(`Document type changed to "${newType}"`);
              // Refresh library to show updated badge
              window.loadLibraryFromApi();
            } else {
              throw new Error(result.error || 'Update failed');
            }
          } catch (error) {
            console.error('Error updating document type:', error);
            toast(`Failed to update document type: ${error.message}`, true);
            // Restore original badge on error
            select.parentNode.innerHTML = originalHTML;
          }
        };
        
        // Handle dropdown events
        select.addEventListener('change', () => handleChange(select.value));
        select.addEventListener('blur', () => handleChange(select.value));
        select.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleChange(select.value);
          } else if (e.key === 'Escape') {
            e.preventDefault();
            // Restore original badge
            select.parentNode.innerHTML = originalHTML;
          }
        });
      }
      function sortItems(items) {
        const arr = Array.from(items || []);
        const dir = filesState.sortDir === 'desc' ? -1 : 1;
        const key = filesState.sortBy || 'name';
        const get = (m) => {
          const tags = m.tags || {};
          if (key === 'name') return (m.filename || '').toLowerCase();
          if (key === 'type') return (tags.docType || '').toLowerCase();
          if (key === 'status') return (tags.status || '').toLowerCase();
          if (key === 'size') return Number(m.size || 0);
          return (m.filename || '').toLowerCase();
        };
        arr.sort((a,b)=>{ const av=get(a), bv=get(b); if (av<bv) return -1*dir; if (av>bv) return 1*dir; return 0; });
        return arr;
      }
      if (input) {
        input.addEventListener('change', (e) => {
          const files = e.target.files;
          previewSelectedFiles(files);
          filesState.lastFiles = Array.from(files || []);
          filesState.staged.push(...filesState.lastFiles);
          renderStagedList();
          const n = filesState.lastFiles.length; if (n) toast(`${n} file(s) staged. Click Upload next to a file or Upload All.`); else toast('No files selected', true);
          try { input.value = ''; } catch(_) {}
        });
      }
      if (choose && input) {
        choose.addEventListener('click', ()=> { try { input.value = ''; } catch(_) {}; input.click(); });
      }
      if (drop) {
        ;['dragenter','dragover'].forEach(ev => drop.addEventListener(ev, (e)=>{ 
          e.preventDefault(); 
          drop.style.background = 'rgba(37, 99, 235, 0.2)'; 
          drop.style.borderColor = 'var(--accent)'; 
          drop.style.color = 'var(--accent)'; 
        }));
        ;['dragleave','drop'].forEach(ev => drop.addEventListener(ev, (e)=>{ 
          e.preventDefault(); 
          drop.style.background = 'rgba(15, 22, 40, 0.3)'; 
          drop.style.borderColor = 'var(--border)'; 
          drop.style.color = '#9aa4b2'; 
        }));
        drop.addEventListener('drop', (e) => {
          const dt = e.dataTransfer; const files = dt && dt.files ? dt.files : [];
          previewSelectedFiles(files);
          filesState.lastFiles = Array.from(files || []);
          filesState.staged.push(...filesState.lastFiles);
          renderStagedList();
          const n = filesState.lastFiles.length; if (n) toast(`${n} file(s) staged. Click Upload All to upload.`);
        });
        drop.addEventListener('click', ()=>{ if (input) { try { input.value = ''; } catch(_) {}; input.click(); } });
        drop.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); if (input) input.click(); } });
      }
      
      // Refresh button and Include Public Files checkbox handlers
      if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
          console.log('🔄 Manual library refresh triggered');
          window.loadLibraryFromApi();
        });
      }
      
      if (includePublicCheckbox) {
        // Restore checkbox state from localStorage
        const savedState = localStorage.getItem('files_include_public');
        if (savedState !== null) {
          includePublicCheckbox.checked = savedState === 'true';
          console.log('🌐 Restored "Include public files" state:', includePublicCheckbox.checked);
        }
        
        includePublicCheckbox.addEventListener('change', () => {
          console.log('🌐 Include public files changed:', includePublicCheckbox.checked);
          // Save checkbox state to localStorage
          localStorage.setItem('files_include_public', includePublicCheckbox.checked.toString());
          console.log('🌐 Saved "Include public files" state to localStorage');
          window.loadLibraryFromApi(); // Refresh library with new visibility setting
        });
      }
      
      // Auto-refresh Files Workbench when project changes
      let lastProjectId = window.currentProjectId ? window.currentProjectId() : '';
      setInterval(() => {
        const newProjectId = window.currentProjectId ? window.currentProjectId() : '';
        if (newProjectId !== lastProjectId) {
          console.log('🔄 Project changed from', lastProjectId, 'to', newProjectId);
          lastProjectId = newProjectId;
          // Only refresh if we're currently viewing the Files Workbench
          const filesSection = qs('#wb-files');
          if (filesSection && filesSection.style.display !== 'none') {
            console.log('🔄 Auto-refreshing Files Workbench for new project');
            window.loadLibraryFromApi();
          }
        }
      }, 1000); // Check every second
      if (urlBtn && urlInput) {
        urlBtn.addEventListener('click', async () => {
          const u = (urlInput.value || '').trim();
          const el = qs('#uploadPreview');
          if (!u) { toast('Please enter a URL', true); if (el) el.textContent=''; return; }
          try { new URL(u); } catch(_) { toast('Invalid URL', true); return; }
          const pid = window.currentProjectId ? window.currentProjectId() : ''; if (!pid) { toast('Select a project first', true); return; }
          const fd = new FormData(); fd.append('url', u); fd.append('project_id', pid);
          try {
            const res = await fetch('/api/files/import-url', { method: 'POST', body: fd });
            const js = await res.json().catch(()=>({}));
            if (!res.ok || js.success === false) throw new Error(js.detail || js.error || 'Import failed');
            if (el) el.textContent = `Imported URL: ${u}`;
            toast('Imported URL');
            loadLibraryFromApi();
          } catch(e) {
            toast('Import failed', true);
          }
        });
      }
      const uploadAll = qs('#filesUploadAllBtn');
      const clearStaged = qs('#filesClearStagedBtn');
      const setStagedDocTypeBtn = qs('#setStagedDocType');
      
      if (clearStaged) clearStaged.addEventListener('click', ()=>{ filesState.staged = []; renderStagedList(); previewSelectedFiles([]); });
      
      // Handle document type selector for staged files
      if (setStagedDocTypeBtn) {
        setStagedDocTypeBtn.addEventListener('click', () => {
          const selectedType = qs('#stagedDocType')?.value || 'unknown';
          
          // Add docType property to all staged files
          filesState.staged.forEach(file => {
            file.docType = selectedType;
          });
          
          toast(`Set document type to "${selectedType}" for ${filesState.staged.length} staged file(s)`);
          
          // Update hint text
          const hint = qs('#stagedDocTypeHint');
          if (hint) {
            hint.textContent = `${filesState.staged.length} file(s) will be uploaded as "${selectedType}"`;
          }
        });
      }
      
      // Handle knowledge processing checkbox
      const enableKnowledgeProcessing = qs('#enableKnowledgeProcessing');
      const knowledgeProcessingConfig = qs('#knowledgeProcessingConfig');
      
      if (enableKnowledgeProcessing && knowledgeProcessingConfig) {
        enableKnowledgeProcessing.addEventListener('change', () => {
          knowledgeProcessingConfig.style.display = enableKnowledgeProcessing.checked ? 'grid' : 'none';
          
          if (enableKnowledgeProcessing.checked) {
            toast('🧠 Knowledge processing enabled - files will be automatically processed for search and retrieval');
          }
        });
      }
      if (uploadAll) uploadAll.addEventListener('click', async ()=>{
        if (!filesState.staged.length) { toast('Nothing to upload', true); return; }
        const total = filesState.staged.length; let ok = 0; const keep = [];
        for (const f of filesState.staged) { const res = await (window.odrasUploadOne ? window.odrasUploadOne(f) : Promise.resolve(false)); if (res) ok++; else keep.push(f); }
        const failed = total - ok;
        toast(`Uploaded ${ok}/${total}${failed?` (failed ${failed})`:''}`);
        filesState.staged = keep; renderStagedList(); previewSelectedFiles(keep);
        try { if (window.odrasLoadLibrary) await window.odrasLoadLibrary(); } catch(_) {}
      });
      const triggerRefresh = () => {
        loadLibraryFromApi();
        try { refreshRunsPanel(); } catch(_) {}
      };
      if (refreshBtn) refreshBtn.addEventListener('click', triggerRefresh);
      if (docType) docType.addEventListener('change', triggerRefresh);
      if (statusSel) statusSel.addEventListener('change', triggerRefresh);
      if (tags) tags.addEventListener('keyup', (e)=>{ if (e.key === 'Enter') triggerRefresh(); });
      // Initial empty list
      loadLibraryFromApi();
      renderStagedList();

      // Ingest params modal handlers
      const modal = qs('#ingestParamsModal');
      const btnClose = qs('#ingestParamsCloseBtn');
      const btnCancel = qs('#ingestParamsCancelBtn');
      const btnStart = qs('#ingestParamsStartBtn');
      const inputChunk = qs('#ing_chunk_size');
      const inputOverlap = qs('#ing_chunk_overlap');
      const inputModel = qs('#ing_model_id');
      const inputBatch = qs('#ing_batch_size');
      const chkHeadings = qs('#ing_respect_headings');
      const chkJoin = qs('#ing_join_short');
      const chkSplit = qs('#ing_split_code');
      const chkNorm = qs('#ing_normalize');
      let modalCtx = { projectId: '', fileIds: [] };
      
      // Load embedding models from API and populate selector
      async function loadEmbeddingModels() {
        try {
          const response = await fetch('/api/embedding-models/');
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.models && inputModel) {
              // Clear existing options
              inputModel.innerHTML = '';
              
              // Add models from API
              data.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = `${model.name} (${model.dimensions} dim)`;
                if (model.status === 'deprecated') {
                  option.textContent += ' [DEPRECATED]';
                  option.disabled = true;
                }
                if (model.id === 'all-MiniLM-L6-v2') {
                  option.selected = true; // Default selection
                }
                inputModel.appendChild(option);
              });
            }
          }
        } catch (error) {
          console.warn('Failed to load embedding models:', error);
          // Fall back to hardcoded options if API fails
        }
      }
      
      function openIngestParamsModal(projectId, fileIds) {
        modalCtx = { projectId, fileIds };
        loadEmbeddingModels(); // Load latest models when modal opens
        if (modal) modal.style.display = 'flex';
      }
      function closeIngestParamsModal() { if (modal) modal.style.display = 'none'; }
      if (btnClose) btnClose.addEventListener('click', closeIngestParamsModal);
      if (btnCancel) btnCancel.addEventListener('click', closeIngestParamsModal);
      if (modal) modal.addEventListener('click', (e)=>{ if (e.target === modal) closeIngestParamsModal(); });
      if (btnStart) btnStart.addEventListener('click', async () => {
        const pid = modalCtx.projectId; const ids = modalCtx.fileIds;
        if (!pid || !ids || !ids.length) { closeIngestParamsModal(); return; }
        const sizeTokens = parseInt((inputChunk && inputChunk.value) || '350', 10);
        const overlapTokens = parseInt((inputOverlap && inputOverlap.value) || '50', 10);
        const modelId = (inputModel && inputModel.value) || 'all-MiniLM-L6-v2';
        const batchSize = parseInt((inputBatch && inputBatch.value) || '64', 10);
        const params = {
          chunking: {
            strategy: 'semantic',
            sizeTokens,
            overlapTokens,
            respectHeadings: !!(chkHeadings && chkHeadings.checked),
            joinShortParagraphs: !!(chkJoin && chkJoin.checked),
            splitCodeBlocks: !!(chkSplit && chkSplit.checked)
          },
          embedding: {
            modelId,
            normalize: !!(chkNorm && chkNorm.checked),
            batchSize
          }
        };
        // Optimistically mark status=processing for selected files
        try { await Promise.all(ids.map(async (fid)=>{
          await fetch(`/api/files/${encodeURIComponent(fid)}/tags`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ tags: { status: 'processing' } }) });
        })); } catch(_) {}
        closeIngestParamsModal();
        const res = await startWorkflowStartApi('ingestion_pipeline', pid, ids, params);
        if (res.ok) { toast('Ingestion started'); try { refreshRunsPanel(); } catch(_) {} } else { toast(`Ingestion failed: ${res.error}`, true); }
      });
      // Expose for bulk handler
      window.openIngestParamsModal = openIngestParamsModal;
    }

    // Runs panel
    async function loadRecentRuns() {
      try { const res = await fetch('/api/runs'); const js = await res.json(); return (js && js.runs) ? js.runs : []; } catch(_) { return []; }
    }
    async function refreshRunsPanel() {
      const pane = qs('#fileRunsContent'); if (!pane) return;
      const runs = await loadRecentRuns();
      if (!runs.length) { pane.textContent = 'No runs yet.'; return; }
      const rows = runs.slice(-10).reverse().map(r => {
        const name = r.filename || r.processKey || 'run';
        const status = r.status || 'started';
        const url = r.camunda_url || '';
        const when = r.started_at ? new Date(r.started_at).toLocaleString() : '';
        const link = url ? `<a href="${url}" target="_blank">Open</a>` : '';
        return `<div style="display:flex; justify-content:space-between; gap:8px; align-items:center;">
          <span>${name}</span>
          <span class="muted">${status}</span>
          <span>${link}</span>
        </div>`;
      }).join('');
      pane.innerHTML = rows;
    }
    // Initial runs load
    try { refreshRunsPanel(); } catch(_) {}
    async function deleteStoredFileViaApi(fileId) {
      console.log('🗑️  Deleting file:', fileId);
      try { 
        const res = await fetch(`/api/files/${encodeURIComponent(fileId)}`, { method: 'DELETE' }); 
        console.log('🗑️  Delete response:', res.status, res.statusText);
        
        if (res.ok) {
          console.log('🗑️  Delete successful');
          return true;
        } else {
          console.error('🗑️  Delete failed:', res.status);
          return false;
        }
      } catch(e) { 
        console.error('🗑️  Delete error:', e);
        return false; 
      }
    }
    async function getFileUrlViaApi(fileId) {
      try { const res = await fetch(`/api/files/${encodeURIComponent(fileId)}/url`); const js = await res.json(); return (js && js.url) ? js.url : (js && js.success && js.file_id ? js.url : null); } catch(_) { return null; }
    }
    async function processFileViaApi(fileId) {
      try { const fd = new FormData(); const res = await fetch(`/api/files/${encodeURIComponent(fileId)}/process`, { method: 'POST', body: fd }); return res.ok; } catch(_) { return false; }
    }
    function clearFilePreview() {
      console.log('👁️  Clearing file preview');
      const pane = qs('#filePreviewContent');
      const metaPane = qs('#fileMetaContent');
      
      if (pane) {
        pane.innerHTML = '<div class="muted" style="padding:20px; text-align:center;">Select a file to preview.</div>';
      }
      
      if (metaPane) {
        metaPane.innerHTML = '';
      }
      
      // Hide/clear preview controls data
      const controls = qs('#previewControls');
      if (controls) {
        controls.removeAttribute('data-file-id');
        controls.removeAttribute('data-filename');
        controls.removeAttribute('data-url');
      }
      
      // Clear current preview data
      currentPreviewData = { fileId: '', filename: '', url: '' };
    }

    async function updateFilePreview(fileId) {
      console.log('👁️  Starting preview for file:', fileId);
      try {
        const url = await getFileUrlViaApi(fileId);
        console.log('👁️  Got file URL:', url);
        
        const pane = qs('#filePreviewContent'); 
        const metaPane = qs('#fileMetaContent');
        
        if (!pane) { 
          console.error('👁️  Preview pane not found');
          return; 
        }
        
        if (!url) { 
          console.log('👁️  No URL available, showing unavailable message');
          pane.textContent = 'Preview unavailable.'; 
          if (metaPane) metaPane.textContent=''; 
          return; 
        }
        
        // Get file metadata from the current library state
        const fileMetadata = filesState.library.find(f => f.file_id === fileId);
        console.log('👁️  File metadata:', fileMetadata);
        
        // Use metadata for extension and content type
        const filename = fileMetadata ? fileMetadata.filename : '';
        const metaContentType = fileMetadata ? fileMetadata.content_type : '';
        
        // Extract extension from filename instead of URL
        const ext = filename ? filename.toLowerCase().split('.').pop() || '' : '';
        console.log('👁️  File extension from metadata:', ext, 'from filename:', filename);
        
        // Use metadata content type, fallback to HEAD request
        let contentType = metaContentType || '';
        if (!contentType) {
          console.log('👁️  No content type in metadata, trying HEAD request...');
          try { 
            const head = await fetch(url, { method: 'HEAD' }); 
            contentType = head.headers.get('Content-Type') || '';
            console.log('👁️  HEAD request successful, content type:', contentType);
          } catch(e) {
            console.log('👁️  HEAD request failed (expected for presigned URLs):', e.message);
          }
        } else {
          console.log('👁️  Using content type from metadata:', contentType);
        }
        
        // Render enhanced metadata
        try {
          if (metaPane) {
            const size = fileMetadata ? fileMetadata.size : 0;
            const sizeStr = size > 1024 * 1024 ? `${(size / (1024*1024)).toFixed(1)} MB` : size > 1024 ? `${(size / 1024).toFixed(1)} KB` : `${size} bytes`;
            const tags = fileMetadata ? fileMetadata.tags || {} : {};
            const docType = tags.docType || 'unknown';
            const status = tags.status || 'new';
            
            metaPane.innerHTML = `<div style="display:grid; gap:4px; font-size:12px;">
              <div><strong>Filename:</strong> ${filename || 'Unknown'}</div>
              <div><strong>Type:</strong> ${docType} (${contentType || ext || 'unknown'})</div>
              <div><strong>Size:</strong> ${sizeStr}</div>
              <div><strong>Status:</strong> ${status}</div>
              <div><strong>Actions:</strong> <a href="${url}" target="_blank" style="color:var(--accent);">Open</a></div>
          </div>`;
          }
        } catch(e) { 
          console.error('👁️  Metadata render error:', e);
        }
        // PDF preview (with multiple rendering options)
        if (ext === 'pdf' || (contentType && contentType.includes('pdf'))) {
          console.log('👁️  Rendering PDF preview for URL:', url);
          
          // Create container with fallback structure
          const pdfContainer = `
            <div style="border:1px solid var(--border); border-radius:6px; overflow:hidden;">
              <div id="pdf-iframe-${fileId}" style="width:100%; height:500px; display:block;">
                <iframe src="${url}#toolbar=0&navpanes=0" style="width:100%; height:100%; border:none;"></iframe>
              </div>
              
              <div id="pdf-fallback-${fileId}" style="display:none; padding:40px; text-align:center; background:var(--panel-2);">
                <div style="margin-bottom:16px; color:var(--muted);">
                  <svg style="width:48px; height:48px; margin-bottom:12px;" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                  </svg>
                  <br/>
                  <strong>PDF Document</strong>
                  <br/>
                  <small>Click to open in new tab</small>
                </div>
                <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">
                  <a href="${url}" target="_blank" class="btn" style="text-decoration:none;">
                    📄 Open PDF
                  </a>
                  <button class="btn" onclick="navigator.clipboard.writeText('${url}').then(()=>this.textContent='✓ Copied').catch(()=>this.textContent='Copy failed');">
                    📋 Copy URL
                  </button>
                </div>
              </div>
            </div>
          `;
          
          pane.innerHTML = pdfContainer;
          
          // Add proper event handling after DOM insertion
          setTimeout(() => {
            const iframe = pane.querySelector(`#pdf-iframe-${fileId} iframe`);
            const fallbackDiv = pane.querySelector(`#pdf-fallback-${fileId}`);
            const iframeContainer = pane.querySelector(`#pdf-iframe-${fileId}`);
            
            if (iframe && fallbackDiv && iframeContainer) {
              // Set up error handling
              iframe.onerror = () => {
                console.error('👁️ PDF iframe failed to load');
                iframeContainer.style.display = 'none';
                fallbackDiv.style.display = 'block';
              };
              
              iframe.onload = () => {
                console.log('👁️ PDF iframe onload triggered');
                // Check if it actually loaded a PDF or just showed source
                setTimeout(() => {
                  try {
                    // If we can't access contentDocument, assume it's working (CORS blocked)
                    iframe.contentDocument;
                    console.log('👁️ PDF iframe content accessible - might be showing source');
                    // For now, assume PDF is working if no error occurs
                  } catch(e) {
                    console.log('👁️ PDF iframe CORS blocked - PDF is likely rendering correctly');
                  }
                }, 1000);
              };
              
              // Check after 3 seconds if iframe seems to be working
              setTimeout(() => {
                try {
                  // Simple heuristic: if iframe is still visible, assume it's working
                  if (iframeContainer.style.display !== 'none') {
                    console.log('👁️ PDF iframe appears to be working');
                  }
                } catch(e) {
                  console.log('👁️ PDF iframe error check failed:', e);
                }
              }, 3000);
            }
          }, 100);
          
          return;
        }
        
        // Image inline (with size constraints)
        if (['png','jpg','jpeg','gif','webp','bmp','svg'].includes(ext) || (contentType && contentType.startsWith('image/'))) {
          console.log('👁️  Rendering image preview');
          pane.innerHTML = `<div style="text-align:center; padding:10px;">
            <img src="${url}" alt="preview" style="max-width:100%; max-height:300px; height:auto; border-radius:6px; box-shadow:0 2px 8px rgba(0,0,0,0.1);" />
          </div>`;
          return;
        }
        
        // CSV table (full content with responsive styling)
        if (ext === 'csv' || (contentType && contentType.includes('csv'))) {
          console.log('👁️  Rendering CSV preview');
          try {
          const res = await fetch(url);
            if (!res.ok) throw new Error('Fetch failed');
          const text = await res.text();
            const lines = text.split(/\r?\n/).filter(line => line.trim()); // Show all rows, filter empty lines
            const cells = lines.map(l => l.split(',').map(x => x.replace(/&/g,'&amp;').replace(/</g,'&lt;'))); // No cell content limits
          const header = cells.shift() || [];
            const rows = cells.map(row => `<tr>${row.map(c=>`<td style="padding:4px 8px; border-bottom:1px solid var(--border); font-size:12px; word-wrap:break-word; max-width:200px;">${c}</td>`).join('')}</tr>`).join('');
            pane.innerHTML = `<div style="max-height:600px; overflow:auto; border:1px solid var(--border); border-radius:6px;">
              <table style="width:100%; border-collapse:collapse; font-size:12px;">
                <thead style="position:sticky; top:0; background:var(--panel);">
                  <tr>${header.map(h=>`<th style="padding:6px 8px; text-align:left; border-bottom:2px solid var(--border); font-weight:600; word-wrap:break-word; max-width:200px;">${h}</th>`).join('')}</tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>
            </div>`;
          } catch(e) {
            console.error('👁️  CSV preview error:', e);
            pane.textContent = 'CSV preview unavailable.';
          }
          return;
        }
        
        // Markdown preview (full content with styling)
        if (['md','markdown'].includes(ext) || (contentType && contentType.includes('markdown'))) {
          console.log('👁️  Rendering Markdown preview');
          try {
          const res = await fetch(url);
            if (!res.ok) throw new Error('Fetch failed');
          const text = await res.text();
            const html = renderBasicMarkdown(text);
            pane.innerHTML = `<div style="max-height:600px; overflow:auto; padding:10px; border:1px solid var(--border); border-radius:6px; background:var(--panel-2); font-size:13px; line-height:1.5;">
              ${html}
            </div>`;
          } catch(e) {
            console.error('👁️  Markdown preview error:', e);
            pane.textContent = 'Markdown preview unavailable.';
          }
          return;
        }
        
        // Fallback text preview (full content with styling)
        console.log('👁️  Rendering fallback text preview');
        try {
        const res = await fetch(url, { method: 'GET' });
          if (!res.ok) throw new Error('Fetch failed');
        const buf = await res.arrayBuffer();
          const bytes = new Uint8Array(buf); // Load full file content
        let text = '';
          try { 
            text = new TextDecoder('utf-8', { fatal: false }).decode(bytes); 
      } catch(_) {
            pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--muted);">Binary file - preview not available<br/><small>Use "Open" link to download</small></div>';
            return;
          }
          
          const safe = (s)=>String(s||'').replace(/[&<>]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;' }[c]));
          
          if (text) {
            pane.innerHTML = `<div style="max-height:600px; overflow:auto; border:1px solid var(--border); border-radius:6px; background:var(--panel-2);">
              <pre style="white-space:pre-wrap; margin:0; padding:12px; font-size:12px; line-height:1.4; font-family:'Monaco','Menlo','Ubuntu Mono',monospace;">${safe(text)}</pre>
            </div>`;
          } else {
            pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--muted);">Empty file or unsupported format</div>';
          }
        } catch(e) {
          console.error('👁️  Text preview error:', e);
          pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--err);">Preview unavailable<br/><small>Use "Open" link to access file</small></div>';
        }
      } catch(e) {
        console.error('👁️  Preview function error:', e);
        const pane = qs('#filePreviewContent'); 
        if (pane) pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--err);">Preview error occurred</div>';
      }
      
      // Store current file info in preview controls for fullscreen/popout
      const controls = qs('#previewControls');
      if (controls) {
        // Store current file info for fullscreen/popout
        controls.setAttribute('data-file-id', fileId);
        controls.setAttribute('data-filename', filename || 'document');
        controls.setAttribute('data-url', url || '');
        console.log('👁️  Controls configured with:', { fileId, filename, url });
      }
    }
    
    // Fullscreen and popout functionality
    let currentPreviewData = { fileId: '', filename: '', url: '' };
    
    function openFullscreenPreview() {
      const pane = qs('#filePreviewContent');
      const modal = qs('#previewFullscreenModal');
      const fullscreenContent = qs('#fullscreenPreviewContent');
      const title = qs('#fullscreenPreviewTitle');
      const controls = qs('#previewControls');
      
      if (!pane || !modal || !fullscreenContent) {
        console.error('👁️  Missing elements for fullscreen');
        return;
      }
      
      // Get current file data
      if (controls) {
        currentPreviewData.fileId = controls.getAttribute('data-file-id') || '';
        currentPreviewData.filename = controls.getAttribute('data-filename') || 'Document';
        currentPreviewData.url = controls.getAttribute('data-url') || '';
      }
      
      // Clone content structure but regenerate with full height
      const originalHTML = pane.innerHTML;
      
      // For PDFs and iframes, recreate with full height instead of constrained height
      if (originalHTML.includes('<iframe') && originalHTML.includes('pdf')) {
        const url = currentPreviewData.url;
        fullscreenContent.innerHTML = `
          <div style="width:100%; height:100%; border:none;">
            <iframe src="${url}#toolbar=0&navpanes=0" style="width:100%; height:100%; border:none;"></iframe>
          </div>
        `;
      } else {
        // For other content, just clone but remove height constraints
        let fullscreenHTML = originalHTML;
        // Remove any height constraints from the cloned content
        fullscreenHTML = fullscreenHTML.replace(/max-height:\s*\d+px/gi, 'max-height: 100%');
        fullscreenHTML = fullscreenHTML.replace(/height:\s*\d+px/gi, 'height: auto');
        fullscreenContent.innerHTML = fullscreenHTML;
      }
      
      if (title) title.textContent = `${currentPreviewData.filename} - Preview`;
      
      // Show modal
      modal.style.display = 'block';
      document.body.style.overflow = 'hidden'; // Prevent body scroll
      
      console.log('👁️  Opened fullscreen preview for:', currentPreviewData.filename);
    }
    
    function closeFullscreenPreview() {
      const modal = qs('#previewFullscreenModal');
      if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = ''; // Restore body scroll
        console.log('👁️  Closed fullscreen preview');
      }
    }
    
    function popoutPreview() {
      console.log('👁️  Popout requested with data:', currentPreviewData);
      
      if (!currentPreviewData.url) {
        // Try to get URL from controls if not in currentPreviewData
        const controls = qs('#previewControls');
        if (controls) {
          currentPreviewData.url = controls.getAttribute('data-url') || '';
          console.log('👁️  Retrieved URL from controls:', currentPreviewData.url);
        }
      }
      
      if (!currentPreviewData.url) {
        console.error('👁️  No URL available for popout');
        alert('Cannot open file in new window - no URL available');
        return;
      }
      
      const filename = currentPreviewData.filename || 'Document';
      const url = currentPreviewData.url;
      
      console.log('👁️  Opening URL in new window:', url);
      
      try {
        // Open in new window with proper window features
        const popup = window.open(url, '_blank', 'width=1000,height=800,scrollbars=yes,resizable=yes,toolbar=yes,menubar=no,status=yes');
        if (popup) {
          // Set title after a brief delay to ensure content loads
          setTimeout(() => {
            try {
              popup.document.title = filename;
            } catch(e) {
              // CORS may prevent title setting, that's ok
              console.log('👁️  Could not set popup title (CORS)');
            }
          }, 1000);
          console.log('👁️  Successfully opened preview in new window');
        } else {
          console.error('👁️  Popup was blocked');
          // Fallback: try to open in new tab
          const fallback = window.open(url, '_blank');
          if (fallback) {
            console.log('👁️  Fallback: opened in new tab');
          } else {
            console.error('👁️  Both popup and fallback blocked');
            alert('Popup blocked. Please allow popups for this site or use the "Open" link in metadata.');
          }
        }
      } catch(e) {
        console.error('👁️  Error opening popup:', e);
        alert('Error opening new window: ' + e.message);
      }
    }
    
    // Initialize preview controls
    try {
      const fullscreenBtn = qs('#previewFullscreenBtn');
      const popoutBtn = qs('#previewPopoutBtn');
      const fullscreenCloseBtn = qs('#fullscreenCloseBtn');
      const fullscreenPopoutBtn = qs('#fullscreenPopoutBtn');
      const fullscreenModal = qs('#previewFullscreenModal');
      
      if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', openFullscreenPreview);
      }
      if (popoutBtn) {
        popoutBtn.addEventListener('click', popoutPreview);
      }
      if (fullscreenCloseBtn) fullscreenCloseBtn.addEventListener('click', closeFullscreenPreview);
      if (fullscreenPopoutBtn) fullscreenPopoutBtn.addEventListener('click', popoutPreview);
      
      // Close fullscreen on ESC key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && fullscreenModal && fullscreenModal.style.display === 'block') {
          closeFullscreenPreview();
        }
      });
      
      // Close fullscreen on modal background click
      if (fullscreenModal) {
        fullscreenModal.addEventListener('click', (e) => {
          if (e.target === fullscreenModal) {
            closeFullscreenPreview();
          }
        });
      }
      
    } catch(e) {
      console.error('👁️  Preview controls initialization failed:', e);
    }
    
          // Controls will show automatically when a file is selected for preview
       
       // Admin check function - checks if current user has admin role
       async function isAdmin() {
         const username = localStorage.getItem('odras_user') || '';
         const isAdminUser = username === 'admin';
         
         console.log('👑 Checking admin status - username:', username, 'isAdmin:', isAdminUser);
         return isAdminUser;
    }
    function renderBasicMarkdown(src) {
      const esc = (s)=>String(s||'').replace(/[&<>]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;' }[c]));
      let s = esc(src);
      s = s.replace(/^######\s+(.*)$/gm, '<h6>$1</h6>')
           .replace(/^#####\s+(.*)$/gm, '<h5>$1</h5>')
           .replace(/^####\s+(.*)$/gm, '<h4>$1</h4>')
           .replace(/^###\s+(.*)$/gm, '<h3>$1</h3>')
           .replace(/^##\s+(.*)$/gm, '<h2>$1</h2>')
           .replace(/^#\s+(.*)$/gm, '<h1>$1</h1>')
           .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
           .replace(/\*(.+?)\*/g, '<em>$1</em>')
           .replace(/`([^`]+)`/g, '<code>$1</code>')
           .replace(/\n\n/g, '<br/><br/>');
      return `<div>${s}</div>`;
    }
    // Ensure file handlers are bound even if Files workbench is the initial active view
    try { setTimeout(() => { try { ensureFilesInitialized(); } catch(_) {} }, 0); } catch(_) {}

    // DAS dock: state, toggle, docking, resize, persistence
    (function(){
      const storageKey = 'odras_das_state';
      const panel = document.getElementById('dasPanel');
      const resizerX = document.getElementById('dasResizerX');
      const resizerY = document.getElementById('dasResizerY');
      const transcript = document.getElementById('dasTranscript');
      const promptInput = document.getElementById('dasPrompt');
      const sendBtn = document.getElementById('dasSendBtn');
      if (!panel) return;
      let state = { open: false, dock: 'right', width: 420, height: Math.max(300, Math.round(window.innerHeight * 0.4)) };
      try { const saved = JSON.parse(localStorage.getItem(storageKey) || '{}'); state = { ...state, ...saved }; } catch(_) {}
      function applyState() {
        panel.classList.remove('das-dock-left','das-dock-right','das-dock-bottom');
        if (state.open) panel.classList.add('active'); else panel.classList.remove('active');
        const dockCls = state.dock === 'left' ? 'das-dock-left' : (state.dock === 'bottom' ? 'das-dock-bottom' : 'das-dock-right');
        panel.classList.add(dockCls);
        document.documentElement.style.setProperty('--das-w', state.width + 'px');
        document.documentElement.style.setProperty('--das-h', state.height + 'px');
        // Body classes to shift layout
        document.body.classList.remove('das-open-left','das-open-right','das-open-bottom');
        if (state.open) {
          if (state.dock === 'left') document.body.classList.add('das-open-left');
          else if (state.dock === 'bottom') document.body.classList.add('das-open-bottom');
          else document.body.classList.add('das-open-right');
        }
      }
      function persist() { try { localStorage.setItem(storageKey, JSON.stringify(state)); } catch(_) {} }
      function toggleOpen() { state.open = !state.open; applyState(); persist(); }
      function setDock(pos) { state.dock = pos; applyState(); persist(); }
      // Resize handlers
      (function(){
        let dragging = false; let startX = 0; let startY = 0; let startW = 0; let startH = 0;
        function onMove(e) {
          if (!dragging) return;
          if (state.dock === 'bottom') {
            const dy = e.clientY - startY;
            const h = Math.max(200, startH - dy);
            state.height = h;
          } else {
            const dx = e.clientX - startX;
            let w = startW;
            if (state.dock === 'right') w = Math.max(260, startW - dx);
            if (state.dock === 'left') w = Math.max(260, startW + dx);
            state.width = w;
          }
          applyState();
        }
        function endDrag() {
          if (!dragging) return;
          dragging = false; persist();
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', endDrag);
        }
        function startDragX(e){ dragging = true; startX = e.clientX; startW = state.width; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', endDrag); e.preventDefault(); }
        function startDragY(e){ dragging = true; startY = e.clientY; startH = state.height; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', endDrag); e.preventDefault(); }
        if (resizerX) resizerX.addEventListener('mousedown', startDragX);
        if (resizerY) resizerY.addEventListener('mousedown', startDragY);
      })();
      // Minimal scaffold behavior
      if (sendBtn && promptInput && transcript) {
        sendBtn.addEventListener('click', () => {
          const text = (promptInput.value || '').trim(); if (!text) return;
          const div = document.createElement('div'); div.className='card'; div.textContent = 'You: ' + text;
          transcript.appendChild(div);
          promptInput.value = '';
        });
        promptInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') { e.preventDefault(); sendBtn.click(); } });
      }
      // Keyboard shortcuts: Alt+Shift+K toggle; Alt+Shift+Arrows to dock
      const onKey = (e) => {
        // Two toggles: Alt+Shift+D or Ctrl+Alt+D to avoid browser collisions
        const toggleCombo = ((e.altKey && e.shiftKey && (e.key === 'D' || e.key === 'd')) || (e.ctrlKey && e.altKey && (e.key === 'D' || e.key === 'd')));
        if (toggleCombo) { e.preventDefault(); toggleOpen(); return; }
        if (!state.open) return;
        const isAltShift = e.altKey && e.shiftKey;
        if (!isAltShift) return;
        if (e.key === 'ArrowLeft') { e.preventDefault(); setDock('left'); }
        else if (e.key === 'ArrowRight') { e.preventDefault(); setDock('right'); }
        else if (e.key === 'ArrowDown') { e.preventDefault(); setDock('bottom'); }
      };
      // Listen high in the stack to avoid being swallowed by focused elements
      window.addEventListener('keydown', onKey, true);
      // Initialize
      applyState();
    })();

    async function startWorkflowStartApi(processKey, projectId, fileIds, params) {
      try {
        const res = await fetch('/api/workflows/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...authHeader() },
          body: JSON.stringify({ processKey, projectId, fileIds, params })
        });
        const js = await res.json().catch(()=>({}));
        if (!res.ok || js.success === false) return { ok:false, error: (js && (js.detail || js.error)) || 'failed' };
        return { ok:true, runId: js.runId, url: js.camunda_url };
      } catch(e) { return { ok:false, error: String(e) }; }
    }

    // ========================================
    // KNOWLEDGE MANAGEMENT FUNCTIONALITY
    // ========================================

    async function loadKnowledgeAssets() {
      try {
        console.log('🧠 Loading knowledge assets...');
        const response = await fetch('/api/knowledge/assets', {
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to load knowledge assets: ${response.status}`);
        }

        const data = await response.json();
        console.log('🧠 Loaded knowledge assets:', data);
        
        displayKnowledgeAssets(data.assets || []);
        updateProcessingStatus();

      } catch (error) {
        console.error('❌ Error loading knowledge assets:', error);
        const listElement = document.getElementById('knowledgeAssetsList');
        if (listElement) {
          listElement.innerHTML = `
            <div class="muted" style="padding:20px; text-align:center; color:var(--err);">
              Error loading knowledge assets: ${error.message}<br/>
              <button class="btn" onclick="loadKnowledgeAssets()" style="margin-top:8px;">Try Again</button>
            </div>
          `;
        }
      }
    }

    function displayKnowledgeAssets(assets) {
      const listElement = document.getElementById('knowledgeAssetsList');
      if (!listElement) return;

      if (!assets || assets.length === 0) {
        listElement.innerHTML = `
          <div class="muted" style="padding:20px; text-align:center;">
            No knowledge assets yet.<br/>
            <small>Upload and process documents to begin building your knowledge base.</small>
          </div>
        `;
        return;
      }

      // Check if current user is admin (simple check based on token payload)
      const currentUser = getCurrentUser();
      const isAdmin = currentUser && currentUser.is_admin;

      const assetsHtml = assets.map(asset => {
        const stats = asset.processing_stats || {};
        const chunkCount = stats.chunk_count || 0;
        const tokenCount = stats.token_count || 0;
        const createdDate = new Date(asset.created_at).toLocaleDateString();
        
        // Public asset indicator
        const publicIndicator = asset.is_public ? 
          `<span style="background:#0f2f1f; color:#10b981; padding:2px 6px; border-radius:3px; font-size:10px; font-weight:600; margin-left:8px;">PUBLIC</span>` : '';
        
        // Action buttons
        const actionButtons = `
          <div class="asset-actions" style="display:flex; gap:4px; margin-top:8px; padding-top:8px; border-top:1px solid var(--border);">
            <button class="btn" style="padding:4px 8px; font-size:11px; background:#1e3a8a; color:#60a5fa;" 
                    onclick="event.stopPropagation(); viewAssetContent('${asset.id}')" title="View Content">
              📄 Content
            </button>
            <button class="btn" style="padding:4px 8px; font-size:11px; background:#dc2626; color:#f87171;" 
                    onclick="event.stopPropagation(); deleteAsset('${asset.id}', '${asset.title}')" title="Delete Asset">
              🗑️ Delete
            </button>
            ${isAdmin ? `
              <button class="btn" style="padding:4px 8px; font-size:11px; background:#7c3aed; color:#a78bfa;" 
                      onclick="event.stopPropagation(); toggleAssetPublic('${asset.id}', ${!asset.is_public})" 
                      title="${asset.is_public ? 'Make Private' : 'Make Public'}">
                ${asset.is_public ? '🔒 Private' : '🌐 Public'}
              </button>
            ` : ''}
          </div>
        `;
        
        return `
          <div class="knowledge-asset-card" style="background:#0b1220; border:1px solid var(--border); border-radius:6px; padding:12px; margin-bottom:8px; cursor:pointer;" 
               onclick="selectKnowledgeAsset('${asset.id}')">
            <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:8px;">
              <div style="flex:1;">
                <h4 style="margin:0 0 4px 0; color:var(--accent); display:flex; align-items:center;">
                  ${asset.title === 'unknown' ? (stats.filename || 'Untitled Asset') : asset.title}
                  ${publicIndicator}
                </h4>
                <div style="font-size:12px; color:var(--muted);">
                  ${asset.document_type} • ${createdDate}
                  ${asset.is_public && asset.made_public_by ? ` • Made public by ${asset.made_public_by}` : ''}
                </div>
              </div>
              <div style="text-align:right; font-size:11px; color:var(--muted);">
                <div>${chunkCount} chunk${chunkCount !== 1 ? 's' : ''}</div>
                <div>${tokenCount} tokens</div>
              </div>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center; font-size:11px;">
              <span class="status-badge status-${asset.status}" style="
                padding:2px 6px; border-radius:3px; font-weight:500;
                ${asset.status === 'active' ? 'background:#0f3d2c; color:#10b981;' : ''}
                ${asset.status === 'processing' ? 'background:#3d2f0f; color:#f59e0b;' : ''}
                ${asset.status === 'failed' ? 'background:#3d0f0f; color:#ef4444;' : ''}
              ">
                ${asset.status.toUpperCase()}
              </span>
              <div style="color:var(--muted);">
                Model: ${stats.embedding_model || 'N/A'}
              </div>
            </div>
            ${actionButtons}
          </div>
        `;
      }).join('');

      listElement.innerHTML = `
        <div style="margin-bottom:12px; font-size:12px; color:var(--muted);">
          Showing ${assets.length} knowledge asset${assets.length !== 1 ? 's' : ''}
          ${isAdmin ? '<span style="color:var(--accent);"> (Admin View)</span>' : ''}
        </div>
        ${assetsHtml}
      `;
    }

    async function selectKnowledgeAsset(assetId) {
      try {
        console.log('🧠 Loading knowledge asset details:', assetId);
        
        // Highlight selected asset
        document.querySelectorAll('.knowledge-asset-card').forEach(card => {
          card.style.borderColor = 'var(--border)';
        });
        event.target.closest('.knowledge-asset-card').style.borderColor = 'var(--accent)';

        const response = await fetch(`/api/knowledge/assets/${assetId}?include_chunks=true`, {
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to load asset details: ${response.status}`);
        }

        const asset = await response.json();
        displayKnowledgeAssetDetails(asset);

      } catch (error) {
        console.error('❌ Error loading asset details:', error);
        const detailsElement = document.getElementById('knowledgeDetailsContent');
        if (detailsElement) {
          detailsElement.innerHTML = `
            <div style="padding:20px; text-align:center; color:var(--err);">
              Error loading asset details: ${error.message}
            </div>
          `;
        }
      }
    }

    function displayKnowledgeAssetDetails(asset) {
      const detailsElement = document.getElementById('knowledgeDetailsContent');
      if (!detailsElement) return;

      const stats = asset.processing_stats || {};
      const chunks = asset.chunks || [];
      
      const detailsHtml = `
        <div style="padding:4px 0;">
          <h4 style="margin:0 0 12px 0; color:var(--accent);">
            ${asset.title === 'unknown' ? (stats.filename || 'Untitled Asset') : asset.title}
          </h4>
          
          <div style="display:grid; gap:12px; margin-bottom:16px;">
            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">DOCUMENT TYPE</div>
              <div style="font-size:13px;">${asset.document_type}</div>
            </div>
            
            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">PROCESSING STATS</div>
              <div style="font-size:12px;">
                • ${stats.chunk_count || 0} chunks<br/>
                • ${stats.token_count || 0} tokens<br/>
                • ${stats.embedding_model || 'N/A'} model<br/>
                • ${stats.chunking_strategy || 'N/A'} strategy
              </div>
            </div>

            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">FILE INFO</div>
              <div style="font-size:12px;">
                • Size: ${stats.original_size || 0} bytes<br/>
                • Type: ${stats.content_type || 'N/A'}<br/>
                • Extracted: ${stats.extracted_text_length || 0} chars
              </div>
            </div>

            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">TIMESTAMPS</div>
              <div style="font-size:12px;">
                Created: ${new Date(asset.created_at).toLocaleString()}<br/>
                Updated: ${new Date(asset.updated_at).toLocaleString()}
              </div>
            </div>

            ${asset.is_public ? `
              <div>
                <div style="font-size:11px; color:var(--muted); font-weight:600;">PUBLIC ACCESS</div>
                <div style="font-size:12px;">
                  <span style="color:#10b981; font-weight:600;">✓ Public Asset</span><br/>
                  ${asset.made_public_at ? `Made public: ${new Date(asset.made_public_at).toLocaleString()}<br/>` : ''}
                  ${asset.made_public_by ? `By: ${asset.made_public_by}` : ''}
                </div>
              </div>
            ` : `
              <div>
                <div style="font-size:11px; color:var(--muted); font-weight:600;">ACCESS</div>
                <div style="font-size:12px; color:var(--muted);">
                  🔒 Project Only
                </div>
              </div>
            `}
          </div>

          ${chunks.length > 0 ? `
            <div style="margin-top:16px;">
              <div style="font-size:11px; color:var(--muted); font-weight:600; margin-bottom:8px;">
                CONTENT CHUNKS (${chunks.length})
              </div>
              <div style="max-height:300px; overflow-y:auto; background:#0b1220; border:1px solid var(--border); border-radius:4px;">
                ${chunks.map((chunk, i) => `
                  <div style="padding:8px; border-bottom:1px solid var(--border);" title="Chunk ${chunk.sequence_number}">
                    <div style="font-size:10px; color:var(--muted); margin-bottom:4px;">
                      #${chunk.sequence_number} • ${chunk.token_count} tokens • ${chunk.chunk_type}
                    </div>
                    <div style="font-size:11px; line-height:1.4; max-height:60px; overflow:hidden;">
                      ${chunk.content.length > 200 ? chunk.content.substring(0, 200) + '...' : chunk.content}
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
          ` : ''}
        </div>
      `;

      detailsElement.innerHTML = detailsHtml;
    }

    async function updateProcessingStatus() {
      try {
        const response = await fetch('/api/knowledge/jobs', {
          headers: { ...authHeader() }
        });

        if (response.ok) {
          const jobs = await response.json();
          const statusElement = document.getElementById('knowledgeProcessingStatus');
          
          if (statusElement && Array.isArray(jobs)) {
            const activeJobs = jobs.filter(job => job.status === 'running');
            
            if (activeJobs.length > 0) {
              const jobsHtml = activeJobs.map(job => `
                <div style="margin-bottom:8px;">
                  <div style="font-size:12px; color:var(--accent);">
                    ${job.job_type} - ${job.progress_percent}%
                  </div>
                  <div style="background:#0b1220; border-radius:3px; height:6px; overflow:hidden;">
                    <div style="background:var(--accent); height:100%; width:${job.progress_percent}%; transition:width 0.3s;"></div>
                  </div>
                </div>
              `).join('');
              
              statusElement.innerHTML = jobsHtml;
            } else {
              statusElement.innerHTML = '<div class="muted">No processing jobs running</div>';
            }
          }
        }
      } catch (error) {
        console.error('Error updating processing status:', error);
      }
    }

    // Initialize knowledge management when the page loads
    function initializeKnowledgeManagement() {
      console.log('🧠 Initializing Knowledge Management...');

      // Bind refresh button
      const refreshBtn = document.getElementById('knowledgeRefreshBtn');
      if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
          console.log('🧠 Refresh button clicked');
          loadKnowledgeAssets();
        });
      }

      // Load knowledge assets if the knowledge workbench is active
      const knowledgeWorkbench = document.getElementById('wb-knowledge');
      if (knowledgeWorkbench && !knowledgeWorkbench.style.display) {
        loadKnowledgeAssets();
      }

      // Also load when switching to knowledge workbench
      const observer = new MutationObserver(() => {
        if (knowledgeWorkbench && knowledgeWorkbench.style.display !== 'none') {
          loadKnowledgeAssets();
        }
      });
      
      if (knowledgeWorkbench) {
        observer.observe(knowledgeWorkbench, { attributes: true, attributeFilter: ['style'] });
      }
    }

    // Auto-initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeKnowledgeManagement);
    } else {
      initializeKnowledgeManagement();
    }

    // Helper function to get current user info
    function getCurrentUser() {
      try {
        const token = localStorage.getItem('authToken');
        if (!token) return null;
        
        // Simple JWT decode (just for demo, in production use proper JWT library)
        const payload = JSON.parse(atob(token.split('.')[1]));
        return payload;
      } catch (error) {
        console.error('Error getting current user:', error);
        return null;
      }
    }

    // Function to view full asset content
    async function viewAssetContent(assetId) {
      try {
        console.log('🧠 Loading asset content:', assetId);
        
        const response = await fetch(`/api/knowledge/assets/${assetId}/content`, {
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to load content: ${response.status}`);
        }

        const contentData = await response.json();
        showContentModal(contentData);

      } catch (error) {
        console.error('❌ Error loading asset content:', error);
        alert('Error loading content: ' + error.message);
      }
    }

    // Function to show content in a modal
    function showContentModal(contentData) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
        background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; 
        z-index: 10000; padding: 20px;
      `;
      
      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; 
                    width: 90%; max-width: 1000px; height: 80vh; display: flex; flex-direction: column;">
          <div style="padding: 16px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0; color: var(--accent);">${contentData.title}</h3>
            <button onclick="this.closest('.content-modal').remove()" style="
              background: transparent; border: none; color: var(--muted); font-size: 24px; cursor: pointer;
            ">&times;</button>
          </div>
          <div style="padding: 16px; overflow-y: auto; flex: 1;">
            <div style="margin-bottom: 16px; font-size: 12px; color: var(--muted);">
              📄 ${contentData.document_type} • ${contentData.total_chunks} chunks • ${contentData.total_tokens} tokens
            </div>
            <div style="line-height: 1.6; white-space: pre-wrap; font-family: ui-monospace, monospace; font-size: 13px;">
              ${contentData.content}
            </div>
          </div>
        </div>
      `;
      
      modal.className = 'content-modal';
      document.body.appendChild(modal);
      
      // Close on backdrop click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }

    // Function to delete an asset
    async function deleteAsset(assetId, assetTitle) {
      const displayTitle = assetTitle === 'unknown' ? 'Untitled Asset' : assetTitle;
      
      if (!confirm(`Are you sure you want to delete "${displayTitle}"?\\n\\nThis will permanently remove the asset and all its chunks.`)) {
        return;
      }

      try {
        console.log('🧠 Deleting asset:', assetId);
        
        const response = await fetch(`/api/knowledge/assets/${assetId}`, {
          method: 'DELETE',
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to delete asset: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ Asset deleted successfully:', result);
        
        // Refresh the assets list
        loadKnowledgeAssets();
        
        // Clear details panel
        const detailsElement = document.getElementById('knowledgeDetailsContent');
        if (detailsElement) {
          detailsElement.innerHTML = `
            <div class="muted" style="padding:20px; text-align:center;">
              Select a knowledge asset to view details
            </div>
          `;
        }
        
        alert('Asset deleted successfully');

      } catch (error) {
        console.error('❌ Error deleting asset:', error);
        alert('Error deleting asset: ' + error.message);
      }
    }

    // Function to toggle asset public status (admin only)
    async function toggleAssetPublic(assetId, makePublic) {
      const action = makePublic ? 'make public' : 'make private';
      
      if (!confirm(`Are you sure you want to ${action} this knowledge asset?\\n\\n${makePublic ? 'Public assets can be viewed by all users across all projects.' : 'Private assets are only visible within their project.'}`)) {
        return;
      }

      try {
        console.log(`🧠 ${makePublic ? 'Making public' : 'Making private'} asset:`, assetId);
        
        const response = await fetch(`/api/knowledge/assets/${assetId}/public`, {
          method: 'PUT',
          headers: { 
            'Content-Type': 'application/json',
            ...authHeader() 
          },
          body: JSON.stringify({ is_public: makePublic })
        });

        if (!response.ok) {
          throw new Error(`Failed to update asset: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ Asset visibility updated:', result);
        
        // Refresh the assets list
        loadKnowledgeAssets();
        
        const status = makePublic ? 'public' : 'private';
        alert(`Asset is now ${status}`);

      } catch (error) {
        console.error('❌ Error updating asset visibility:', error);
        alert('Error updating asset: ' + error.message);
      }
    }

    // Make functions globally available
    window.loadKnowledgeAssets = loadKnowledgeAssets;
    window.selectKnowledgeAsset = selectKnowledgeAsset;
    window.viewAssetContent = viewAssetContent;
    window.deleteAsset = deleteAsset;
    window.toggleAssetPublic = toggleAssetPublic;

  </script>
</body>
</html>


