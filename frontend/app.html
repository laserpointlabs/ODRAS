<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ODRAS — UI Restart</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #0b1220;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #60a5fa;
      --border: #1f2937;
      --warn: #f59e0b;
      --ok: #10b981;
      --err: #ef4444;
      --iconbar-w: 56px;
      --tree-w: 320px;
      --tree-w-min: 220px;
      --tree-w-max: 520px;
      --onto-iconbar-w: 56px;
      --onto-tree-w: 300px;
      --onto-tree-w-min: 180px;
      --onto-tree-w-max: 520px;
      --onto-tree-collapsed-w: 40px;
      --onto-props-w: 300px;
      --onto-props-w-min: 200px;
      --onto-props-w-max: 520px;
      --onto-props-collapsed-w: 40px;
      --toolbar-h: 48px;
      --bottombar-h: 32px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, sans-serif; }
    .layout {
      display: grid;
      grid-template-rows: var(--toolbar-h) 1fr var(--bottombar-h);
      height: 100vh;
    }
    .topbar, .bottombar {
      display: flex; align-items: center; gap: 12px; padding: 0 12px;
      background: var(--panel); border-bottom: 1px solid var(--border);
    }
    .bottombar { border-top: 1px solid var(--border); border-bottom: none; color: var(--muted); gap: 16px; }
    .brand { font-weight: 600; letter-spacing: .5px; }
    .spacer { flex: 1; }
    .btn, select {
      background: #0b1220; color: var(--text); border: 1px solid var(--border);
      padding: 6px 10px; border-radius: 6px; cursor: pointer;
    }
    select { padding: 6px; }
    .content {
      display: grid; grid-template-columns: var(--iconbar-w) var(--tree-w) 6px 1fr; height: 100%;
    }
    .iconbar {
      background: var(--panel); border-right: 1px solid var(--border);
      display: flex; flex-direction: column; align-items: center; padding: 8px 6px; gap: 8px;
    }
    .icon {
      width: 40px; height: 40px; border-radius: 8px; border: 1px solid var(--border);
      background: var(--panel-2); display: grid; place-items: center; color: var(--muted);
      cursor: pointer;
    }
    .icon svg { width: 22px; height: 22px; stroke: currentColor; }
    .icon.active { color: var(--accent); border-color: var(--accent); }
    .tree {
      border-right: 1px solid var(--border); background: var(--panel-2);
      display: grid; grid-template-rows: auto 1fr; min-width: var(--tree-w-min); max-width: var(--tree-w-max);
      width: var(--tree-w);
    }
    .tree-header { padding: 10px; border-bottom: 1px solid var(--border); display: flex; gap: 8px; align-items: center; }
    .tree-scroll { overflow: auto; padding: 8px; }
    /* CAD-like tree view */
    .treeview [role="tree"] { list-style: none; margin: 0; padding: 4px; }
    .treeview [role="group"] { list-style: none; margin: 0; padding-left: 16px; border-left: 1px dashed var(--border); }
    .treeview li[role="treeitem"] { margin: 2px 0; outline: none; }
    .treeview li[role="treeitem"][aria-expanded="false"] > ul[role="group"] { display: none; }
    .node-row { display: flex; align-items: center; gap: 6px; padding: 4px 6px; border: 1px solid transparent; border-radius: 6px; cursor: default; }
    .node-row:hover { background: #0d1426; border-color: var(--border); }
    .node-row.selected { background: #0f1a33; border-color: var(--accent); }
    .twist { width: 12px; text-align: center; color: var(--muted); user-select: none; }
    li[role="treeitem"][aria-expanded="false"] > .node-row .twist::before { content: '▸'; }
    li[role="treeitem"][aria-expanded="true"] > .node-row .twist::before { content: '▾'; }
    li[role="treeitem"]:not([aria-expanded]) > .node-row .twist::before { content: '•'; opacity: .25; }
    .node-icon { width: 14px; height: 14px; border: 1px solid var(--border); border-radius: 3px; background: #0a1120; }
    .node-icon.folder { background: linear-gradient(180deg, #0f1a33, #0c1529); }
    .node-icon.req { background: #1b2a45; }
    .node-icon.doc { background: #1b2a45; border-style: dashed; }
    .node-icon.out { background: #1b2a45; border-color: #2a3b5f; }
    .node-icon.docreq { background: #263b61; border-color: #3b5a8f; }
    .node-icon.docknow { background: #2a3f5f; border-color: #4a6a9a; }
    .node-icon.onto { background: #22304f; border-color: #39507a; }
    .node-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .resizer {
      width: 6px; cursor: col-resize; background: transparent; position: relative;
    }
    .resizer::after { content: ""; position: absolute; inset: 0; }
    .main {
      padding: 12px; overflow: auto;
    }
    .workbench { display: none; }
    .workbench.active { display: block; }
    .status-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }
    .ok { background: var(--ok); } .warn { background: var(--warn); } .err { background: var(--err); }
    .muted { color: var(--muted); }
    /* Ontology Workbench */
    .ontology-toolbar { display: flex; gap: 8px; align-items: center; margin: 8px 0 12px 0; }
    #cy { width: 100%; min-width: 0; height: calc(100vh - var(--toolbar-h) - var(--bottombar-h) - 140px); min-height: 360px; border: 1px solid var(--border); border-radius: 8px; background: #0a0f1f; }
    .onto-layout { display: grid; grid-template-columns: var(--onto-tree-w) var(--onto-tree-divider-w, 6px) var(--onto-iconbar-w) minmax(0, 1fr) var(--onto-props-divider-w, 6px) var(--onto-props-w); gap: 0; align-items: stretch; overflow: hidden; width: 100%; }
    /* Inline editor for canvas labels */
    #ontoInlineEdit { position: fixed; z-index: 9999; display: none; background: #0b1220; color: #e5e7eb; border: 1px solid var(--accent); border-radius: 6px; padding: 4px 6px; font: inherit; }
    /* Fullscreen adjustments */
    #wb-ontology:fullscreen #cy { height: calc(100vh - 140px); }
    /* Context menu */
    .onto-menu { position: fixed; z-index: 9999; display: none; min-width: 160px; background: #0b1220; color: #e5e7eb; border: 1px solid var(--border); border-radius: 8px; box-shadow: 0 8px 24px rgba(0,0,0,.4); }
    .onto-menu button { width: 100%; background: transparent; color: #e5e7eb; border: none; text-align: left; padding: 8px 10px; cursor: pointer; }
    .onto-menu button:hover { background: #0f172a; }
    .connect-source { outline: 2px dashed var(--accent); outline-offset: 2px; }
    /* Pin children to explicit grid columns so hiding resizers doesn't shift layout */
    .onto-layout > .onto-tree { grid-column: 1; }
    .onto-layout > #ontoResizer { grid-column: 2; }
    .onto-layout > .onto-iconbar { grid-column: 3; }
    .onto-layout > #cy { grid-column: 4; }
    .onto-layout > #ontoPropsResizer { grid-column: 5; }
    .onto-layout > .onto-props { grid-column: 6; }
    .onto-iconbar { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 8px 6px; display: flex; flex-direction: column; align-items: center; gap: 8px; height: calc(100vh - var(--toolbar-h) - var(--bottombar-h) - 140px); }
    .onto-icon { width: 40px; height: 40px; border-radius: 8px; border: 1px solid var(--border); background: var(--panel-2); display: grid; place-items: center; color: var(--muted); cursor: grab; }
    .onto-icon svg { width: 22px; height: 22px; stroke: currentColor; }
    .onto-tree { border: 1px solid var(--border); background: var(--panel-2); border-radius: 8px; display: grid; grid-template-rows: auto 1fr; min-width: 0; }
    .onto-tree-header { padding: 8px; border-bottom: 1px solid var(--border); display: flex; gap: 8px; align-items: center; position: sticky; top: 0; z-index: 1; background: var(--panel-2); }
    .onto-tree-scroll { overflow: auto; padding: 8px; }
    .onto-treeview [role="tree"] { list-style: none; margin: 0; padding: 4px; }
    .onto-treeview [role="group"] { list-style: none; margin: 0; padding-left: 16px; border-left: 1px dashed var(--border); }
    .onto-treeview li[role="treeitem"] { margin: 2px 0; outline: none; }
    .onto-treeview li[role="treeitem"][aria-expanded="false"] > ul[role="group"] { display: none; }
    .onto-node-row { display: flex; align-items: center; gap: 6px; padding: 4px 6px; border: 1px solid transparent; border-radius: 6px; cursor: pointer; }
    .onto-node-row:hover { background: #0d1426; border-color: var(--border); }
    .onto-node-row.selected { background: #0f1a33; border-color: var(--accent); }
    .onto-twist { width: 12px; text-align: center; color: var(--muted); user-select: none; }
    li[role="treeitem"][aria-expanded="false"] > .onto-node-row .onto-twist::before { content: '▸'; }
    li[role="treeitem"][aria-expanded="true"] > .onto-node-row .onto-twist::before { content: '▾'; }
    li[role="treeitem"]:not([aria-expanded]) > .onto-node-row .onto-twist::before { content: '•'; opacity: .25; }
    .onto-node-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .onto-resizer { width: 6px; cursor: col-resize; background: transparent; position: relative; }
    .onto-resizer::after { content: ""; position: absolute; inset: 0; }
    /* Collapsed tree mode */
    #wb-ontology.onto-tree-collapsed .onto-tree { overflow: hidden; }
    #wb-ontology.onto-tree-collapsed .onto-tree-header .muted { display: none; }
    #wb-ontology.onto-tree-collapsed .onto-tree-scroll { display: none; }
    /* Keep the collapse chevron visible and prevent overlap */
    #wb-ontology.onto-tree-collapsed .onto-tree { z-index: 2; }
    .onto-iconbar { z-index: 1; }
    #wb-ontology.onto-tree-collapsed #ontoResizer { display: none; }
    /* Collapse behavior: shrink tree width to rail without affecting tools/canvas/props */
    #wb-ontology.onto-tree-collapsed { --onto-tree-w: var(--onto-tree-collapsed-w); --onto-tree-divider-w: 0px; }
    .iconbtn { background: #0b1220; color: var(--text); border: 1px solid var(--border); width: 28px; height: 28px; border-radius: 8px; display: grid; place-items: center; cursor: pointer; }
    .iconbtn svg { width: 16px; height: 16px; stroke: currentColor; transition: transform 160ms ease; }
    /* Left panel chevron: right when collapsed, left when expanded */
    #wb-ontology.onto-tree-collapsed #ontoTreeToggleIcon { transform: rotate(0deg); }
    #wb-ontology:not(.onto-tree-collapsed) #ontoTreeToggleIcon { transform: rotate(180deg); }
    #wb-ontology.onto-tree-collapsed .onto-tree-header { padding: 4px !important; justify-content: center !important; }

    /* Properties panel */
    .onto-props { border: 1px solid var(--border); background: var(--panel-2); border-radius: 8px; display: grid; grid-template-rows: auto 1fr; min-width: 0; }
    .onto-props-header { padding: 8px; border-bottom: 1px solid var(--border); display: flex; gap: 8px; align-items: center; position: sticky; top: 0; z-index: 1; background: var(--panel-2); justify-content: space-between; }
    .onto-props-scroll { overflow: auto; padding: 8px; }
    #wb-ontology.onto-props-collapsed .onto-props-header .muted { display: none; }
    #wb-ontology.onto-props-collapsed .onto-props-header { padding: 4px !important; justify-content: center !important; }
    #wb-ontology.onto-props-collapsed .onto-props-scroll { display: none; }
    #wb-ontology.onto-props-collapsed #ontoPropsResizer { display: none; }
    #wb-ontology.onto-props-collapsed { --onto-props-w: var(--onto-props-collapsed-w); --onto-props-divider-w: 0px; }
    #wb-ontology.onto-props-collapsed .onto-props { width: var(--onto-props-collapsed-w); min-width: var(--onto-props-collapsed-w); max-width: var(--onto-props-collapsed-w); }
    /* Right panel chevron: left when collapsed, right when expanded */
    #wb-ontology.onto-props-collapsed #ontoPropsToggleIcon { transform: rotate(180deg); }
    #wb-ontology:not(.onto-props-collapsed) #ontoPropsToggleIcon { transform: rotate(0deg); }
    .login {
      display: grid; place-items: center; height: calc(100vh - var(--toolbar-h) - var(--bottombar-h));
    }
    /* Keep login card narrow without constraining other cards */
    #authView .card { width: 360px; }
    .card { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 16px; }
    .row { display: grid; gap: 6px; margin-bottom: 10px; }
    input[type="text"], input[type="password"] {
      background: #0b1220; color: var(--text); border: 1px solid var(--border); padding: 8px; border-radius: 6px;
    }
  </style>
  <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/cytoscape-edgehandles@4.0.1/cytoscape-edgehandles.min.js"></script>
  </head>
  <body>
  <div id="app" class="layout">
    <div class="topbar">
      <div class="brand">ODRAS</div>
      <div class="spacer"></div>
      
      <div class="spacer"></div>
      <div id="userMenu" class="muted"></div>
      <button class="btn" id="logoutBtn">Logout</button>
    </div>

    <div id="authView" class="login" style="display:none;">
      <div class="card">
        <h3 style="margin:0 0 8px 0;">Sign in</h3>
        <div class="row"><label>Username</label><input id="u" type="text" /></div>
        <div class="row"><label>Password</label><input id="p" type="password" /></div>
        <button class="btn" id="loginBtn">Login</button>
        <div id="loginMsg" class="muted" style="margin-top:8px;"></div>
      </div>
    </div>

    <div id="mainView" class="content" style="display:none;">
      <nav class="iconbar" aria-label="Workbench">
        <div class="icon active" data-wb="ontology" title="Ontology" aria-label="Ontology">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="6" cy="6" r="2"/>
            <circle cx="18" cy="6" r="2"/>
            <circle cx="6" cy="18" r="2"/>
            <circle cx="18" cy="18" r="2"/>
            <path d="M8 6h8M6 8v8M18 8v8M8 18h8"/>
          </svg>
        </div>
        <div class="icon" data-wb="files" title="Files" aria-label="Files">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 7h5l2 2h11v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z"/>
          </svg>
        </div>
        <div class="icon" data-wb="embedding" title="Embedding" aria-label="Embedding">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 3l8 4-8 4-8-4 8-4z"/>
            <path d="M4 12l8 4 8-4"/>
            <path d="M4 16l8 4 8-4"/>
          </svg>
        </div>
        <div class="icon" data-wb="requirements" title="Requirements" aria-label="Requirements">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 7h11M9 12h11M9 17h11"/>
            <path d="M4 7l1 1 2-2M4 12l1 1 2-2M4 17l1 1 2-2"/>
          </svg>
        </div>
        <div class="icon" data-wb="graph" title="GraphDB" aria-label="GraphDB">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <ellipse cx="12" cy="5" rx="8" ry="3"/>
            <path d="M4 5v10c0 1.7 3.6 3 8 3s8-1.3 8-3V5"/>
            <path d="M4 12c0 1.7 3.6 3 8 3s8-1.3 8-3"/>
          </svg>
        </div>
        <div class="icon" data-wb="rag" title="RAG" aria-label="RAG">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="6"/>
            <path d="M20 20l-4-4"/>
          </svg>
        </div>
        <div class="icon" data-wb="process" title="Process" aria-label="Process">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <rect x="4" y="4" width="8" height="6" rx="1"/>
            <rect x="12" y="14" width="8" height="6" rx="1"/>
            <path d="M8 10v4M8 14h8M16 14v-4"/>
          </svg>
        </div>
        <div class="icon" data-wb="thread" title="Thread" aria-label="Thread">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <rect x="4" y="4" width="16" height="12" rx="2"/>
            <path d="M8 16l-4 4v-4"/>
            <path d="M8 8h8M8 12h6"/>
          </svg>
        </div>
        <div class="icon" data-wb="playground" title="Playground" aria-label="Playground">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 3h6"/>
            <path d="M10 3v4l-5 9a3 3 0 0 0 3 5h8a3 3 0 0 0 3-5l-5-9V3"/>
            <path d="M8 15h8"/>
          </svg>
        </div>
        <div class="icon" data-wb="admin" title="Admin" aria-label="Admin">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 3l8 4v6c0 5-5 8-8 8s-8-3-8-8V7l8-4z"/>
          </svg>
        </div>
      </nav>

      <aside class="tree" id="treePanel" aria-label="Project Tree">
        <div class="tree-header">
          <select id="projectSelect2" title="Active project"></select>
          <button class="btn" id="addNodeBtn" title="New Project">＋</button>
        </div>
        <div class="tree-scroll">
          <nav class="treeview" aria-label="Project">
            <ul role="tree" id="treeRoot" aria-label="Project tree"></ul>
          </nav>
        </div>
      </aside>
      <!-- Project context menu -->
      <div id="projectContextMenu" style="position:absolute; display:none; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding:4px; z-index: 9999; min-width: 220px;">
        <button id="projRenameBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Rename Project…</button>
        <button id="projArchiveBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Archive Project</button>
        <button id="projDeleteBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:#ef4444;">Delete Project</button>
        <hr style="border:none; border-top:1px solid var(--border); margin:6px 0;"/>
        <button id="projShowArchivedBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Archived…</button>
      </div>

      <div class="resizer" id="resizer" aria-hidden="true"></div>

      <main class="main">
        <section id="wb-ontology" class="workbench">
          <h2>Ontology Workbench</h2>
          <div class="ontology-toolbar">
            <span id="ontoGraphLabel" class="muted" style="max-width:55%; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">No graph selected</span>
            <div class="spacer"></div>
            <button class="btn" id="ontoLayoutBtn" title="Auto layout">Layout</button>
            <button class="btn" id="ontoFitBtn" title="Fit to view">Fit</button>
            <button class="btn" id="ontoFullscreenBtn" title="Enter fullscreen">Fullscreen</button>
            <button class="btn" id="ontoDeleteBtn" title="Delete selected">Delete</button>
            <button class="btn" id="ontoLinkIdenticalBtn" title="Link identical classes">Link</button>
            <button class="btn" id="ontoSaveBtn" title="Save ontology to Fuseki">Save</button>
            <button class="btn" id="ontoImportBtn" title="Import graph JSON">Import</button>
            <button class="btn" id="ontoExportBtn" title="Export graph JSON">Export</button>
            <input type="file" id="ontoImportFile" accept="application/json" style="display:none" />
          </div>
          <div id="ontoEmpty" class="card" style="margin-top:10px; display:none;">
            Create or Select an Ontology to begin
          </div>
          <div class="onto-layout" id="ontoLayoutSection">
            <aside class="onto-tree" aria-label="Ontology Tree">
              <div class="onto-tree-header" id="ontoTreeHeader" style="display:flex; justify-content:space-between; align-items:center;">
                <div class="muted">Ontology</div>
                <button class="iconbtn" id="ontoTreeToggle" title="Collapse">
                  <svg id="ontoTreeToggleIcon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M9 6l6 6-6 6"/></svg>
                </button>
              </div>
              <div class="onto-tree-scroll">
                <nav class="onto-treeview" aria-label="Ontology">
                  <ul role="tree" id="ontoTreeRoot" aria-label="Ontology tree"></ul>
                </nav>
              </div>
            </aside>
            <div class="onto-resizer" id="ontoResizer" aria-hidden="true"></div>
            <aside class="onto-iconbar" aria-label="Ontology Tools">
              <div class="onto-icon" draggable="true" data-onto-type="class" title="Class">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
              </div>
              <div class="onto-icon" draggable="true" data-onto-type="objectProperty" title="Object Property">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="12" r="3"/><circle cx="17" cy="12" r="3"/><path d="M10 12h4"/></svg>
              </div>
              <div class="onto-icon" draggable="true" data-onto-type="dataProperty" title="Data Property">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="12" r="3"/><rect x="14" y="9" width="6" height="6" rx="1"/></svg>
              </div>
              <div class="onto-icon" draggable="true" data-onto-type="note" title="Note">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h12l4 4v12H4z"/><path d="M16 4v4h4"/></svg>
              </div>
            </aside>
            <div id="cy" role="application" aria-label="Ontology Graph Canvas"></div>
            <div class="onto-resizer" id="ontoPropsResizer" aria-hidden="true"></div>
            <aside class="onto-props" aria-label="Properties Panel">
              <div class="onto-props-header" id="ontoPropsHeader">
                <div class="muted">Properties</div>
                <button class="iconbtn" id="ontoPropsToggle" title="Collapse">
                  <svg id="ontoPropsToggleIcon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M9 6l6 6-6 6"/></svg>
                </button>
              </div>
              <div class="onto-props-scroll">
                <form id="ontoPropsForm" style="display:grid; gap:8px;">
                  <div>
                    <label class="muted" for="propName">Name</label>
                    <input id="propName" type="text" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;" />
                  </div>
                  <div>
                    <label class="muted" for="propType">Type</label>
                    <select id="propType" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
                      <option value="class">Class</option>
                      <option value="objectProperty">Object Property</option>
                      <option value="dataProperty">Data Property</option>
                      <option value="note">Note</option>
                      <option value="model">Model</option>
                    </select>
                  </div>
                  <div>
                    <label class="muted" for="propAttrs">Attributes (JSON)</label>
                    <textarea id="propAttrs" rows="6" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;"></textarea>
                  </div>
                  <div style="display:flex; gap:8px;">
                    <button type="button" class="btn" id="propSaveBtn">Save</button>
                    <span id="propSaveStatus" class="muted"></span>
                  </div>
                </form>
              </div>
            </aside>
          </div>
          <input id="ontoInlineEdit" type="text" />
          <div id="ontoContextMenu" class="onto-menu">
            <button id="menuAddRel">Add relationship</button>
            <button id="menuAddDataProp">Add data property</button>
            <button id="menuCancel">Cancel</button>
          </div>
        </section>
        <section id="wb-files" class="workbench">
          <h2>File Management</h2>
          <div class="muted">Upload requirements and knowledge docs (MinIO).</div>
          <div id="filesToast" class="muted" style="margin-top:6px;"></div>
          <div class="files-toolbar" style="display:flex; gap:8px; align-items:center; margin:10px 0; flex-wrap:wrap;">
            <label class="muted" for="filesDocType">Type</label>
            <select id="filesDocType" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
              <option value="">All</option>
              <option value="requirements">Requirements</option>
              <option value="knowledge">Knowledge</option>
              <option value="unknown">Unknown</option>
            </select>
            <label class="muted" for="filesStatus">Status</label>
            <select id="filesStatus" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
              <option value="">Any</option>
              <option value="new">New</option>
              <option value="ingested">Ingested</option>
              <option value="embedded">Embedded</option>
            </select>
            <input id="filesTags" type="text" placeholder="tags (comma)" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px; min-width:200px;" />
            <button class="btn" id="filesRefreshBtn" title="Refresh">Refresh</button>
            <div class="spacer"></div>
            <button class="btn" id="filesBulkProcessBtn" title="Process selected">Process Selected</button>
            <button class="btn" id="filesBulkDeleteBtn" title="Delete selected">Delete Selected</button>
          </div>

          <div class="card" style="margin-top:8px;">
            <div class="muted">Upload or import by URL</div>
            <div style="display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap;">
              <input type="file" id="fileUploadInput" multiple style="display:none" />
              <button class="btn" id="fileChooseBtn" type="button">Choose Files</button>
              <input id="fileUrlInput" type="url" placeholder="https://example.com/doc.pdf" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px; min-width:320px;" />
              <button class="btn" id="fileUrlImportBtn">Import URL</button>
            </div>
            <div id="fileDropZone" tabindex="0" role="button" aria-label="Drop files or click to select" style="margin-top:10px; border:1px dashed var(--border); border-radius:8px; padding:16px; text-align:center; color:#9aa4b2; user-select:none; cursor:pointer;">
              Drag & drop files here, or use the Choose Files button above
            </div>
            <div id="uploadPreview" class="muted" style="margin-top:6px;"></div>
          </div>

          <div class="card" style="margin-top:10px; display:grid; grid-template-columns: minmax(420px, 1fr) 8px minmax(360px, 420px); gap:0; align-items:stretch;">
            <div style="display:grid; gap:10px;">
              <div>
                <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                  <div class="muted">Staged files</div>
                  <div style="display:flex; gap:8px; align-items:center;">
                    <button class="btn" id="filesUploadAllBtn" type="button">Upload All</button>
                    <button class="btn" id="filesClearStagedBtn" type="button">Clear</button>
                  </div>
                </div>
                <div id="stagedList" style="display:grid; gap:6px; margin-top:6px;"></div>
              </div>
              <div>
                <div class="muted" style="margin-bottom:6px;">Library</div>
                <div id="filesList" style="display:block; overflow:auto;"></div>
              </div>
            </div>
            <div style="width:8px; cursor:col-resize;" id="filesSplitResizer" aria-hidden="true"></div>
            <aside id="filePreviewPane" style="border-left:1px solid var(--border); padding-left:10px; overflow:auto;">
              <div class="muted" style="margin-bottom:6px;">Preview</div>
              <div id="fileMetaBox" class="card" style="margin-bottom:8px;">
                <div class="muted">Metadata</div>
                <div id="fileMetaContent" class="muted">Select a file to see metadata.</div>
              </div>
              <div class="card">
                <div class="muted" style="margin-bottom:6px;">Content</div>
                <div id="filePreviewContent" class="muted">Select a file to preview.</div>
              </div>
            </aside>
          </div>
        </section>
        <section id="wb-embedding" class="workbench">
          <h2>Embedding</h2>
          <div class="muted">Chunking, overlap, embedding model, storage settings.</div>
        </section>
        <section id="wb-requirements" class="workbench">
          <h2>Requirements</h2>
          <div class="muted">Extraction rules, SME review, LLM critique.</div>
        </section>
        <section id="wb-graph" class="workbench">
          <h2>Graph Explorer</h2>
          <div class="muted">Quick look into RDF store (SPARQL).
            <button class="btn" id="btnRefreshSummary" style="margin-left:8px;">Refresh Summary</button>
          </div>
          <div id="graphSummary" class="card" style="margin-top:10px;"></div>
          <div class="card" style="margin-top:10px;">
            <div class="muted">Run SPARQL (SELECT):</div>
            <textarea id="sparqlInput" rows="6" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:8px;">SELECT ?s ?p ?o WHERE { ?s ?p ?o } LIMIT 25</textarea>
            <div style="margin-top:6px; display:flex; gap:8px; align-items:center;">
              <button class="btn" id="btnRunSparql">Run</button>
              <span id="sparqlStatus" class="muted"></span>
            </div>
            <pre id="sparqlResult" style="margin-top:8px; white-space:pre-wrap;"></pre>
          </div>
        </section>
        <section id="wb-rag" class="workbench">
          <h2>RAG</h2>
          <div class="muted">Develop/test BPMN workflows with LLM help.</div>
        </section>
        <section id="wb-process" class="workbench">
          <h2>Process</h2>
          <div class="muted">Manage extraction BPMN processes.</div>
        </section>
        <section id="wb-thread" class="workbench">
          <h2>Thread Workbench</h2>
          <div class="muted">Chronological, project-scoped thread of tasks, user actions, and system events.</div>
        </section>
        <section id="wb-playground" class="workbench">
          <h2>LLM Playground</h2>
          <div class="muted">Ask questions, generate white papers, save to project.</div>
        </section>
        <section id="wb-admin" class="workbench">
          <h2>Admin</h2>
          <div class="muted">Users, projects overview (read-only for MVP).</div>
        </section>
      </main>
    </div>

    <div class="bottombar">
      <span><span class="status-dot ok"></span>Camunda</span>
      <span><span class="status-dot ok"></span>Fuseki</span>
      <span><span class="status-dot ok"></span>Vector</span>
      <span class="spacer"></span>
      <span class="muted">UI Restart Prototype</span>
    </div>
  </div>

  <script>
    const qs = (s, r = document) => r.querySelector(s);
    const qsa = (s, r = document) => Array.from(r.querySelectorAll(s));
    function debounce(fn, wait) {
      let t; return function(...args){ clearTimeout(t); t = setTimeout(()=>fn.apply(this,args), wait); };
    }
    // Ensure we persist canvas before unload/refresh
    window.addEventListener('beforeunload', () => { try { if (ontoState && ontoState.cy && activeOntologyIri) persistOntologyToLocalStorage(); } catch(_) {} });

    // Ontology workbench state
    const ontoState = { cy: null, eh: null, connectMode: false, clickConnectFrom: null, nextId: 1, currentPredicateType: 'objectProperty', isCanvasActive: false };
    let activeProject = null;
    let suppressWorkbenchSwitch = false;
    let activeOntologyIri = null;

    function updateOntoGraphLabel() {
      const el = qs('#ontoGraphLabel');
      if (!el) return;
      if (activeOntologyIri) {
        el.textContent = 'Graph: ' + activeOntologyIri;
        el.title = activeOntologyIri;
      } else {
        el.textContent = 'No graph selected';
        el.title = '';
      }
      // Toggle empty-state hint
      const empty = qs('#ontoEmpty');
      const layout = qs('#ontoLayoutSection');
      if (empty && layout) {
        const showEmpty = !activeOntologyIri;
        empty.style.display = showEmpty ? 'block' : 'none';
        layout.style.display = showEmpty ? 'none' : 'grid';
      }
    }

    function slugify(str) {
      try {
        return String(str || '')
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-+|-+$/g, '') || 'ontology';
      } catch (_) { return 'ontology'; }
    }

    function computeOntologyIri(projectId, name, version) {
      const pid = encodeURIComponent(projectId || 'project');
      const n = slugify(name || 'ontology');
      const ver = version ? ('/v' + encodeURIComponent(version)) : '';
      return `http://odras.local/onto/${pid}/${n}${ver}`;
    }

    function handleTreeSelection(li) {
      if (!li || !li.dataset) return;
      const type = li.dataset.nodeType || '';
      if (type === 'ontology') {
        const iri = li.dataset.iri;
        if (iri) {
          // Save previous active ontology canvas before switching
          const prevIri = activeOntologyIri;
          ensureOntologyInitialized();
          if (ontoState.cy && prevIri) {
            saveGraphToLocal(prevIri);
          }
          // Switch active ontology
          activeOntologyIri = iri;
          try {
            const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
            localStorage.setItem(`onto_active_iri__${pid}`, iri);
            // Set model name for properties panel based on discovered label or IRI tail
            const friendly = (li.dataset.label && li.dataset.label.trim()) || iri.split('/').pop() || iri;
            localStorage.setItem(`onto_model_name__${pid}`, friendly);
            // Also store display label and graph in model attributes
            let attrs = {};
            try { attrs = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}'); } catch(_) { attrs = {}; }
            attrs.displayLabel = friendly;
            attrs.graphIri = iri;
            localStorage.setItem(`onto_model_attrs__${pid}`, JSON.stringify(attrs));
            // Keep project-scoped label map in sync so the top node reflects selection
            try { saveOntologyLabel(iri, friendly); } catch(_) {}
          } catch(_) {}
          updateOntoGraphLabel();
          // Load new graph from local storage if present
          if (ontoState.cy) {
            // Avoid racing autosave during restore
            ontoState.suspendAutosave = true;
            try { ontoState.cy.elements().remove(); } catch(_) {}
            loadGraphFromLocal(iri);
            setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
          }
          // Show model-level props when nothing selected
          updatePropertiesPanelFromSelection();
          // Rebuild ontology tree (top node label and contents)
          try { refreshOntologyTree(); } catch(_) {}
          // Switch to Ontology workbench view unless suppressed during restore
          if (!suppressWorkbenchSwitch) {
            const ico = document.querySelector('.icon[data-wb="ontology"]');
            if (ico && !document.querySelector('#wb-ontology.workbench.active')) {
              ico.click();
            }
          }
          // Reflect in hash for deep-linking (preserve current workbench)
          try {
            const params = new URLSearchParams(location.hash.replace(/^#/, ''));
            const wb = localStorage.getItem('active_workbench') || 'ontology';
            params.set('wb', wb);
            params.set('graph', encodeURIComponent(iri));
            location.hash = params.toString();
          } catch(_) {}
        }
      }
    }
    function ensureOntologyInitialized() {
      if (ontoState.cy) return;
      const container = qs('#cy');
      if (!container) return;
      // Make canvas focusable for keyboard events (Delete)
      try { container.setAttribute('tabindex', '0'); container.style.outline = 'none'; } catch(_) {}
      try {
        if (window.cytoscape && (window.cytoscapeEdgehandles || window.edgehandles)) {
          const plugin = window.cytoscapeEdgehandles || window.edgehandles;
          if (plugin && typeof plugin === 'function') window.cytoscape.use(plugin);
        }
      } catch (_) {}
      ontoState.cy = cytoscape({
        container,
        layout: { name: 'grid', padding: 10, avoidOverlap: true },
        style: [
          { selector: 'node', style: {
            'shape': 'round-rectangle',
            'background-color': '#1b2a45',
            'border-color': '#2a3b5f',
            'border-width': 1,
            'label': 'data(label)',
            'color': '#e5e7eb',
            'font-size': 12,
            'text-wrap': 'wrap',
            'text-max-width': 180,
            'text-valign': 'center',
            'text-halign': 'center'
          }},
          { selector: 'node[type = "class"]', style: { 'width': 180, 'height': 56 } },
          { selector: 'node[type = "dataProperty"]', style: {
            'width': 160,
            'height': 48,
            'background-color': '#154e5a',
            'border-color': '#2ea3b0'
          } },
          { selector: 'edge', style: {
            'curve-style': 'bezier',
            'width': 2,
            'line-color': '#3b4a6b',
            'target-arrow-shape': 'triangle',
            'target-arrow-color': '#3b4a6b',
            'arrow-scale': 1,
            'label': 'data(predicate)',
            'color': '#e5e7eb',
            'font-size': 10,
            'text-rotation': 'autorotate',
            'text-background-color': '#0b1220',
            'text-background-opacity': 0.6,
            'text-background-padding': 2
          }},
          { selector: '.imported', style: {
            'opacity': 0.55
          }},
          { selector: 'edge.imported', style: { 'line-style': 'dashed' } },
          { selector: 'edge.imported-equivalence', style: {
            'line-style': 'dotted',
            'width': 1.5,
            'line-color': '#60a5fa',
            'label': '≡',
            'color': '#9ca3af',
            'font-size': 9,
            'text-background-opacity': 0
          } },
          { selector: 'node[type = "note"], .note', style: {
            'shape': 'round-rectangle',
            'background-color': '#2a1f0a',
            'border-color': '#8b5a1e',
            'border-style': 'dashed',
            'border-width': 1,
            'label': 'data(label)',
            'color': '#f5e6cc',
            'font-size': 12,
            'text-wrap': 'wrap',
            'text-max-width': 220,
            'text-valign': 'center',
            'text-halign': 'center',
            'width': 220, 'height': 80
          }},
          { selector: ':selected', style: {
            'border-color': '#60a5fa',
            'border-width': 2,
            'line-color': '#60a5fa',
            'target-arrow-color': '#60a5fa'
          }}
        ],
        elements: []
      });
      window._cy = ontoState.cy;
      ontoState.nextId = 1;
      // Focus canvas on interaction so Delete works reliably
      ontoState.cy.on('tap', () => { try { container.focus(); } catch(_) {} });
      ontoState.cy.on('select', () => { try { container.focus(); } catch(_) {} });
      try { container.addEventListener('keydown', handleDeleteKey); } catch(_) {}

      // Mark canvas active on any interaction
      ontoState.cy.on('tap', () => { ontoState.isCanvasActive = true; });

      if (typeof ontoState.cy.edgehandles === 'function') {
        ontoState.eh = ontoState.cy.edgehandles({
          handleSize: 8,
          handleNodes: 'node[type = "class"], node[type = "note"]',
          handleColor: '#60a5fa',
          handleOutlineColor: '#0b1220',
          handleOutlineWidth: 2,
          toggleOffOnLeave: true,
          enabled: true,
          edgeParams: () => ({ data: { predicate: 'relatedTo', type: 'objectProperty' } })
        });
        ontoState.cy.on('ehcomplete', (event, sourceNode, targetNode, addedEdge) => {
          try {
            const srcType = (sourceNode.data('type') || 'class');
            const tgtType = (targetNode.data('type') || 'class');
            const edgeType = (addedEdge && addedEdge.data('type')) || ontoState.currentPredicateType || 'objectProperty';
            let invalid = false;
            // Allow note -> class as 'note_for' (reverse if class->note used)
            if ((srcType === 'note' && (tgtType === 'class' || tgtType === 'dataProperty')) || ((srcType === 'class' || srcType === 'dataProperty') && tgtType === 'note')) {
              // Ensure direction note -> class
              if ((srcType === 'class' || srcType === 'dataProperty') && tgtType === 'note') {
                addedEdge.data('source', targetNode.id());
                addedEdge.data('target', sourceNode.id());
              }
              addedEdge.data('predicate', 'note_for');
              addedEdge.data('type', 'note');
            } else {
              // For object properties, only allow class→class
              if (edgeType === 'objectProperty' && (srcType !== 'class' || tgtType !== 'class')) invalid = true;
              // Disallow any other note edges
              if (srcType === 'note' || tgtType === 'note') invalid = true;
              if (invalid && addedEdge) { addedEdge.remove(); return; }
            }
          } catch(_) {}
          requestAnimationFrame(() => { refreshOntologyTree(); persistOntologyToLocalStorage(); });
        });
        ontoState.cy.on('select unselect add remove data free', () => {
          updatePropertiesPanelFromSelection();
          persistOntologyToLocalStorage();
        });
        // Persist overlay positions when moved
        ontoState.cy.on('free', 'node.imported', (ev) => {
          try {
            const n = ev.target; const imp = n.data('importSource');
            if (!imp || !activeOntologyIri) return;
            const curr = loadOverlayPositions(activeOntologyIri, imp);
            curr[n.id()] = n.position();
            saveOverlayPositions(activeOntologyIri, imp, curr);
          } catch(_) {}
        });
        // Persist overlay positions when moved
        ontoState.cy.on('free', 'node.imported', (ev) => {
          try {
            const n = ev.target; const imp = n.data('importSource');
            if (!imp || !activeOntologyIri) return;
            const curr = loadOverlayPositions(activeOntologyIri, imp);
            curr[n.id()] = n.position();
            saveOverlayPositions(activeOntologyIri, imp, curr);
          } catch(_) {}
        });
      } else {
        ontoState.cy.on('tap', 'node', (ev) => {
          if (!ontoState.connectMode) return;
          const node = ev.target;
          if (!ontoState.clickConnectFrom) {
            ontoState.clickConnectFrom = node.id();
          } else {
            const from = ontoState.clickConnectFrom;
            const to = node.id();
            if (from !== to) {
              const src = ontoState.cy.$(`#${from}`)[0];
              const tgt = ontoState.cy.$(`#${to}`)[0];
              const srcType = (src && (src.data('type')||'class')) || 'class';
              const tgtType = (tgt && (tgt.data('type')||'class')) || 'class';
              if (srcType !== 'note' && tgtType !== 'note' && srcType === 'class' && tgtType === 'class') {
                ontoState.cy.add({ group: 'edges', data: { id: `e${Date.now()}`, source: from, target: to, predicate: 'relatedTo', type: 'objectProperty' } });
                refreshOntologyTree();
                persistOntologyToLocalStorage();
              }
            }
            ontoState.clickConnectFrom = null;
          }
        });
        ontoState.cy.on('select unselect add remove data free', () => {
          updatePropertiesPanelFromSelection();
          persistOntologyToLocalStorage();
        });
      }

      // Background click clears selection and shows model-level props
      ontoState.cy.on('tap', (ev) => {
        if (ev.target === ontoState.cy) {
          ontoState.cy.$(':selected').unselect();
          updatePropertiesPanelFromSelection();
          hideMenu();
          clearConnectState();
        }
      });

      // Inline label editor on F2 or Enter when focused
      ontoState.cy.on('cxttap', 'node', (ev) => {
        const n = ev.target; const t = (n.data('type')||'class');
        const rect = qs('#cy').getBoundingClientRect();
        const rp = ev.renderedPosition || n.renderedPosition();
        // Configure menu per node type
        const menu = qs('#ontoContextMenu');
        if (!menu) return;
        const btnRel = qs('#menuAddRel');
        const btnDP = qs('#menuAddDataProp');
        if (t === 'note') {
          if (btnRel) btnRel.textContent = 'Link to class/property';
          if (btnDP) btnDP.style.display = 'none';
        } else {
          if (btnRel) btnRel.textContent = 'Add relationship';
          if (btnDP) btnDP.style.display = 'block';
        }
        showMenuAt(rect.left + rp.x + 6, rect.top + rp.y + 6);
        menu.dataset.nodeId = n.id();
        menu.dataset.nodeType = t;
      });
      function showInlineEditor(target) {
        const input = qs('#ontoInlineEdit'); if (!input) return;
        const pos = target.renderedPosition();
        const rect = qs('#cy').getBoundingClientRect();
        const current = target.isNode() ? (target.data('label') || '') : (target.data('predicate') || '');
        input.value = current;
        input.style.left = (rect.left + pos.x - Math.min(100, rect.width*0.2)) + 'px';
        input.style.top = (rect.top + pos.y - 12) + 'px';
        input.style.display = 'block';
        input.focus();
        input.select();
        function commit(save) {
          if (save) {
            const v = input.value.trim();
            if (target.isNode()) target.data('label', v || current);
            else target.data('predicate', v || current);
            refreshOntologyTree();
            persistOntologyToLocalStorage();
          }
          input.style.display = 'none';
          input.onkeydown = null; input.onblur = null;
        }
        input.onkeydown = (e) => {
          if (e.key === 'Enter') commit(true);
          else if (e.key === 'Escape') commit(false);
        };
        input.onblur = () => commit(true);
      }
      ontoState.cy.on('keydown', 'node,edge', (ev) => {
        if (ev.originalEvent && ev.originalEvent.key === 'F2') showInlineEditor(ev.target);
      });
      // Double-click to edit
      ontoState.cy.on('dblclick', 'node,edge', (ev) => showInlineEditor(ev.target));

      // Context menu actions
      document.addEventListener('click', (e) => {
        const menu = qs('#ontoContextMenu');
        if (!menu) return;
        if (e.target === qs('#menuCancel')) { hideMenu(); return; }
        if (e.target === qs('#menuAddRel')) {
          hideMenu();
          const id = menu.dataset.nodeId; if (!id) return;
          const node = ontoState.cy.$('#' + id)[0]; if (!node) return;
          const t = menu.dataset.nodeType || 'class';
          clearConnectState(); startConnectFrom(node); cmState.sourceType = t;
          return;
        }
        if (e.target === qs('#menuAddDataProp')) {
          hideMenu();
          const id = menu.dataset.nodeId; if (!id) return;
          const node = ontoState.cy.$('#' + id)[0]; if (!node) return;
          // Add a default data property node near the class
          const pos = node.position();
          const pid = `DP${Date.now()}`;
          const label = `Data Property ${Date.now()%1000}`;
          ontoState.cy.add({ group: 'nodes', data: { id: pid, label, type: 'dataProperty' }, position: { x: pos.x + 120, y: pos.y } });
          // Use objectProperty for the visual connector edge
          ontoState.cy.add({ group: 'edges', data: { id: `edp${Date.now()}`, source: id, target: pid, predicate: label, type: 'objectProperty' } });
          refreshOntologyTree(); persistOntologyToLocalStorage();
          return;
        }
      });
      // Clicking a target after 'Add relationship' completes the edge
      ontoState.cy.on('tap', 'node', (ev) => {
        const target = ev.target; if (!cmState.sourceId) return;
        const tgtType = (target.data('type')||'class');
        const source = ontoState.cy.$('#' + cmState.sourceId)[0]; if (!source) { clearConnectState(); return; }
        const srcType = cmState.sourceType || (source.data('type')||'class');
        if (source.id() !== target.id()) {
          if (srcType === 'note' && (tgtType === 'class' || tgtType === 'dataProperty')) {
            ontoState.cy.add({ group: 'edges', data: { id: `enote${Date.now()}`, source: source.id(), target: target.id(), predicate: 'note_for', type: 'note' } });
            refreshOntologyTree(); persistOntologyToLocalStorage();
          } else if (srcType === 'class' && tgtType === 'class') {
            ontoState.cy.add({ group: 'edges', data: { id: `e${Date.now()}`, source: source.id(), target: target.id(), predicate: 'relatedTo', type: 'objectProperty' } });
            refreshOntologyTree(); persistOntologyToLocalStorage();
          }
        }
        source.removeClass('connect-source');
        clearConnectState();
      });

      // Drag-and-drop from tool icons
      const icons = Array.from(document.querySelectorAll('.onto-icon'));
      icons.forEach(icon => {
        icon.addEventListener('dragstart', (ev) => {
          ev.dataTransfer.setData('text/onto-type', icon.getAttribute('data-onto-type') || 'class');
          try { ev.dataTransfer.effectAllowed = 'copy'; } catch(_) {}
        });
      });

      container.addEventListener('dragenter', (ev) => { ev.preventDefault(); });
      container.addEventListener('dragover', (ev) => { ev.preventDefault(); ontoState.isCanvasActive = true; try { ev.dataTransfer.dropEffect = 'copy'; } catch(_) {} });
      container.addEventListener('drop', (ev) => {
        ev.preventDefault();
        ontoState.isCanvasActive = true;
        const ontoType = ev.dataTransfer.getData('text/onto-type') || 'class';
        const rect = container.getBoundingClientRect();
        const renderedPos = { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
        const pan = ontoState.cy.pan();
        const zoom = ontoState.cy.zoom();
        const pos = { x: (renderedPos.x - pan.x) / zoom, y: (renderedPos.y - pan.y) / zoom };
        if (ontoType === 'class') {
          const label = `Class ${ontoState.nextId}`;
          const id = addClassNodeAt(label, pos);
          if (id) { ontoState.cy.$('#' + id).select(); }
        } else if (ontoType === 'objectProperty') {
          ontoState.currentPredicateType = 'objectProperty';
          setConnectMode(true);
          // With edgehandles enabled, user can drag handle from a class to another class
        } else if (ontoType === 'dataProperty') {
          const sel = ontoState.cy.nodes(':selected').filter(n => (n.data('type') || 'class') === 'class');
          if (sel.length !== 1) { return; }
          const prop = `Data Property ${Date.now()%1000}`;
          const pid = `DP${Date.now()}`;
          ontoState.cy.add({ group: 'nodes', data: { id: pid, label: prop, type: 'dataProperty' }, position: pos });
          // Link edge is a visual connector; keep it as objectProperty for consistency
          ontoState.cy.add({ group: 'edges', data: { id: `edp${Date.now()}`, source: sel[0].id(), target: pid, predicate: prop, type: 'objectProperty' } });
          refreshOntologyTree();
        } else if (ontoType === 'note') {
          const nid = `Note${Date.now()}`;
          const text = `Note ${nid.slice(-4)}`;
          ontoState.cy.add({ group: 'nodes', data: { id: nid, label: text, type: 'note' }, position: pos, classes: 'note' });
          // If exactly one class is selected, auto-link note -> class
          const sel = ontoState.cy.nodes(':selected').filter(n => (n.data('type')||'class') === 'class');
          if (sel && sel.length === 1) {
            ontoState.cy.add({ group: 'edges', data: { id: `enote${Date.now()}`, source: nid, target: sel[0].id(), predicate: 'note_for', type: 'note' } });
          }
          refreshOntologyTree(); persistOntologyToLocalStorage();
        }
        persistOntologyToLocalStorage();
      });
      // Bind autosave on edits (add/remove/data/position)
      try {
        const autosave = debounce(() => { try { if (activeOntologyIri) persistOntologyToLocalStorage(); } catch(_) {} }, 250);
        ontoState.cy.on('add remove data position', autosave);
        ontoState.autosaveBound = true;
      } catch(_) {}
    }

    function addClassNode(label) {
      ensureOntologyInitialized();
      const id = `Class${ontoState.nextId++}`;
      const x = 100 + Math.random() * 400;
      const y = 100 + Math.random() * 300;
      ontoState.cy.add({ group: 'nodes', data: { id, label, type: 'class' }, position: { x, y } });
      refreshOntologyTree();
      persistOntologyToLocalStorage();
    }

    function addClassNodeAt(label, position) {
      ensureOntologyInitialized();
      const id = `Class${ontoState.nextId++}`;
      ontoState.cy.add({ group: 'nodes', data: { id, label, type: 'class' }, position });
      refreshOntologyTree();
      persistOntologyToLocalStorage();
      return id;
    }

    function runAutoLayout() {
      ensureOntologyInitialized();
      const layout = ontoState.cy.layout({ name: 'cose', animate: 'end', animationDuration: 200 });
      layout.run();
    }

    function setConnectMode(enabled) {
      ensureOntologyInitialized();
      ontoState.connectMode = !!enabled;
      const btn = qs('#ontoConnectBtn');
      if (btn) btn.style.borderColor = enabled ? '#60a5fa' : 'var(--border)';
      if (ontoState.eh) {
        if (enabled) ontoState.eh.enableDrawMode(); else ontoState.eh.disableDrawMode();
      } else {
        if (!enabled) ontoState.clickConnectFrom = null;
      }
    }

    function exportOntologyJSON() {
      ensureOntologyInitialized();
      const nodes = ontoState.cy.nodes().map(n => ({ data: n.data(), position: n.position() }));
      const edges = ontoState.cy.edges().map(e => ({ data: e.data() }));
      const payload = { nodes, edges };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'ontology.json';
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
    }

    function slugId(text) {
      return String(text||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
    }

    function iriMapKey(graphIri) { return 'onto_iri_map__' + encodeURIComponent(graphIri); }
    function loadIriMap(graphIri) { try { return JSON.parse(localStorage.getItem(iriMapKey(graphIri))||'{}'); } catch(_) { return {}; } }
    function saveIriMap(graphIri, map) { try { localStorage.setItem(iriMapKey(graphIri), JSON.stringify(map||{})); } catch(_) {} }

    function toTurtle(graphIri, linkedPairsOpt) {
      // Build per-graph stable id→IRI map
      const iriMap = loadIriMap(graphIri);
      const lines = [
        '@prefix owl: <http://www.w3.org/2002/07/owl#> .',
        '@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .',
        (()=>{ try {
          const labels = loadOntologyLabelMap(activeProject);
          const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : null;
          const scopedName = pid ? (localStorage.getItem(`onto_model_name__${pid}`) || '') : '';
          const mapLabel = labels[graphIri] || '';
          const tail = (graphIri.split('/').pop()||graphIri);
          // Prefer the actively edited model name, then label map, then IRI tail
          const chosen = ((activeOntologyIri === graphIri && scopedName.trim()) || mapLabel || tail);
          const lbl = String(chosen||'');
          return `\n<${graphIri}> a owl:Ontology ; rdfs:label "${String(lbl||'').replace(/\\/g,'\\\\').replace(/"/g,'\\"')}" .\n`;
        } catch(_) { return `\n<${graphIri}> a owl:Ontology .\n`; } })()
      ];
      // Include owl:imports from local storage
      try {
        const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(graphIri)) || '[]');
        imports.forEach(imp => { lines.push(`<${graphIri}> <http://www.w3.org/2002/07/owl#imports> <${imp}> .`); });
      } catch(_) {}
      const nodes = ontoState.cy.nodes();
      const edges = ontoState.cy.edges();
      function nodeIri(n) {
        const id = n.id();
        if (iriMap[id]) return iriMap[id];
        const explicit = n.data('iri');
        if (explicit) { iriMap[id] = explicit; return explicit; }
        const base = slugId(n.data('label')||id)||id;
        const iri = `${graphIri}#${base}`;
        iriMap[id] = iri;
        return iri;
      }
      // Classes and data properties (exclude imported overlays)
      nodes.forEach(n => {
        if (n.hasClass && n.hasClass('imported')) return;
        const t = n.data('type')||'class';
        const iri = nodeIri(n);
        const label = (n.data('label')||'').replace(/\\/g,'\\\\').replace(/"/g,'\\"');
        if (t === 'class') {
          lines.push(`<${iri}> a owl:Class ; rdfs:label "${label}" .`);
        } else if (t === 'dataProperty') {
          lines.push(`<${iri}> a owl:DatatypeProperty ; rdfs:label "${label}" .`);
          const incoming = n.incomers('edge');
          if (incoming && incoming.length) {
            const src = incoming[0].source();
            const srcIri = nodeIri(src);
            lines.push(`<${iri}> rdfs:domain <${srcIri}> .`);
            lines.push(`<${iri}> rdfs:range <http://www.w3.org/2001/XMLSchema#string> .`);
          }
        }
      });
      // Object properties from edges
      const existingEquiv = new Set();
      edges.forEach(e => {
        if (e.hasClass && (e.hasClass('imported') || e.hasClass('imported-equivalence'))) return;
        const s = e.source(); const t = e.target();
        const pred = (e.data('predicate')||'relatedTo').replace(/\\/g,'\\\\').replace(/"/g,'\\"');
        const propIri = `${graphIri}#${slugId(pred)}`;
        const sIri = nodeIri(s); const tIri = nodeIri(t);
        const isData = (e.data('type')||'objectProperty') === 'dataProperty';
        const sType = (s.data('type')||'class'); const tType = (t.data('type')||'class');
        if (!isData) {
          if (sType === 'class' && tType === 'class') {
            // Treat special case for equivalence edges represented in UI as predicate 'equivalentClass'
            if (pred === 'equivalentClass' || pred === 'linked_by') {
              const key = `${sIri}|${tIri}`;
              if (!existingEquiv.has(key)) {
                existingEquiv.add(key);
                lines.push(`<${sIri}> owl:equivalentClass <${tIri}> .`);
              }
            } else {
              lines.push(`<${propIri}> a owl:ObjectProperty ; rdfs:label "${pred}" ; rdfs:domain <${sIri}> ; rdfs:range <${tIri}> .`);
            }
          } else if (sType === 'note' && (tType === 'class' || tType === 'dataProperty') && pred === 'note_for') {
            // Emit as annotation on target element
            const text = (s.data('label')||'').replace(/\\/g,'\\\\').replace(/"/g,'\\"');
            lines.push(`<${tIri}> rdfs:comment "${text}" .`);
          }
        }
      });
      // Add auto-computed equivalence pairs (no UI edges) if provided
      if (Array.isArray(linkedPairsOpt)) {
        linkedPairsOpt.forEach(p => {
          try {
            const n = p.baseNode; const targetIri = p.importIri;
            const sIri = nodeIri(n);
            const key = `${sIri}|${targetIri}`;
            if (!existingEquiv.has(key)) {
              existingEquiv.add(key);
              lines.push(`<${sIri}> owl:equivalentClass <${targetIri}> .`);
            }
          } catch(_) {}
        });
      }
      saveIriMap(graphIri, iriMap);
      return lines.join('\n');
    }

    // Compute linked_by pairs between base classes and imported graphs by label/local name
    async function computeLinkedByPairs(graphIri) {
      try {
        const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(graphIri)) || '[]');
        if (!imports || !imports.length || !ontoState.cy) return [];
        const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type')||'class') === 'class' && !n.hasClass('imported'));
        const norm = (s) => String(s||'').trim().toLowerCase();
        const baseByLabel = new Map();
        baseClasses.forEach(n => { baseByLabel.set(norm(n.data('label')||n.id()), n); });
        const pairs = [];
        for (const imp of imports) {
          const q = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?c ?label WHERE { GRAPH <${imp}> { ?c a owl:Class . OPTIONAL { ?c rdfs:label ?label } } }`;
          const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
          if (!res.ok) continue;
          const json = await res.json();
          const rows = (json && json.results && json.results.bindings) ? json.results.bindings : [];
          rows.forEach(b => {
            const iri = b.c && b.c.value; const label = b.label && b.label.value;
            const local = iri ? (iri.includes('#') ? iri.split('#').pop() : iri.split('/').pop()) : '';
            const key = norm(label || local);
            const base = baseByLabel.get(key);
            if (base && iri) pairs.push({ baseNode: base, importIri: iri });
          });
        }
        // Deduplicate pairs by base id + target iri
        const out = [];
        const seen = new Set();
        pairs.forEach(p => { const k = p.baseNode.id() + '|' + p.importIri; if (!seen.has(k)) { seen.add(k); out.push(p); } });
        return out;
      } catch(_) { return []; }
    }

    // Imported overlay visibility persistence
    function visibleImportsKey(graphIri) { return 'onto_imports_visible__' + encodeURIComponent(graphIri || ''); }
    function loadVisibleImports(graphIri) { try { return new Set(JSON.parse(localStorage.getItem(visibleImportsKey(graphIri)) || '[]')); } catch(_) { return new Set(); } }
    function saveVisibleImports(graphIri, set) { try { localStorage.setItem(visibleImportsKey(graphIri), JSON.stringify(Array.from(set || []))); } catch(_) {} }

    // Persist per-import overlay node positions
    function overlayPositionsKey(baseIri, importIri) { return 'onto_import_positions__' + encodeURIComponent(baseIri || '') + '__' + encodeURIComponent(importIri || ''); }
    function loadOverlayPositions(baseIri, importIri) { try { return JSON.parse(localStorage.getItem(overlayPositionsKey(baseIri, importIri)) || '{}'); } catch(_) { return {}; } }
    function saveOverlayPositions(baseIri, importIri, obj) { try { localStorage.setItem(overlayPositionsKey(baseIri, importIri), JSON.stringify(obj || {})); } catch(_) {} }

    async function fetchImportGraphSnapshot(importIri) {
      try {
        const qClasses = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?c ?label WHERE { GRAPH <${importIri}> { ?c a owl:Class . OPTIONAL { ?c rdfs:label ?label } } }`;
        const qProps = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?p ?pl ?d ?r WHERE { GRAPH <${importIri}> { ?p a owl:ObjectProperty . OPTIONAL { ?p rdfs:label ?pl } OPTIONAL { ?p rdfs:domain ?d } OPTIONAL { ?p rdfs:range ?r } } }`;
        const classesRes = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qClasses }) });
        const propsRes = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qProps }) });
        const classesJson = classesRes.ok ? await classesRes.json() : { results: { bindings: [] } };
        const propsJson = propsRes.ok ? await propsRes.json() : { results: { bindings: [] } };
        const cls = (classesJson.results?.bindings || []).map(b => ({ iri: b.c.value, label: (b.label && b.label.value) || (b.c.value.includes('#') ? b.c.value.split('#').pop() : b.c.value.split('/').pop()) }));
        const edges = [];
        (propsJson.results?.bindings || []).forEach(b => {
          const d = b.d && b.d.value; const r = b.r && b.r.value; if (!d || !r) return;
          const label = (b.pl && b.pl.value) || (b.p && b.p.value ? (b.p.value.includes('#') ? b.p.value.split('#').pop() : b.p.value.split('/').pop()) : 'relatedTo');
          edges.push({ sourceIri: d, targetIri: r, label });
        });
        return { classes: cls, edges };
      } catch(_) { return { classes: [], edges: [] }; }
    }

    async function overlayImportsRefresh() {
      try {
        if (!ontoState.cy || !activeOntologyIri) return;
        const visible = loadVisibleImports(activeOntologyIri);
        const visibleList = Array.from(visible);
        // Before removing overlays, snapshot positions for imports being hidden
        ontoState.cy.nodes('.imported').forEach(n => {
          const imp = n.data('importSource') || '';
          if (!visible.has(imp)) {
            const curr = loadOverlayPositions(activeOntologyIri, imp);
            curr[n.id()] = n.position();
            saveOverlayPositions(activeOntologyIri, imp, curr);
          }
        });
        // Remove overlays for imports no longer visible
        ontoState.cy.elements('.imported, .imported-equivalence').forEach(el => { if (!visible.has(el.data('importSource') || '')) el.remove(); });
        // Add overlays for newly visible imports
        for (const imp of visibleList) {
          const existing = ontoState.cy.elements('.imported').filter(e => (e.data('importSource') || '') === imp);
          if (existing && existing.length) continue;
          const snap = await fetchImportGraphSnapshot(imp);
          const added = [];
          // Compute a simple cluster origin to the right of the base graph to avoid overlap (notes included)
          const baseBBox = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).boundingBox();
          const orderIndex = Math.max(0, visibleList.indexOf(imp));
          const padX = 200, padY = 40, jitterX = orderIndex * 100, jitterY = orderIndex * 60;
          const safe = (n, f)=> (Number.isFinite(n) ? n : f);
          const originX = safe(baseBBox.x2, 0) + padX + jitterX;
          const originY = safe(baseBBox.y1, 0) + jitterY;
          const total = Math.max(1, snap.classes.length);
          const cols = Math.ceil(Math.sqrt(total));
          const spacing = 160;
          let nextIdx = 0;
          function nextPos() {
            const col = nextIdx % cols; const row = Math.floor(nextIdx / cols); nextIdx += 1;
            return { x: originX + col * spacing, y: originY + row * spacing };
          }
          // Add class nodes in a simple grid within the cluster; apply saved positions if available
          const savedPos = loadOverlayPositions(activeOntologyIri, imp);
          snap.classes.forEach(c => {
            const id = `imp:${imp}#${c.iri}`;
            if (ontoState.cy.$(`#${CSS.escape(id)}`).length) return;
            const pos = savedPos[id] ? savedPos[id] : nextPos();
            added.push(ontoState.cy.add({ group: 'nodes', data: { id, iri: c.iri, label: c.label, type: 'class', importSource: imp }, position: pos, classes: 'imported' }));
          });
          // Add edges where both endpoints available; create missing nodes on demand
          let idx = 0;
          snap.edges.forEach(e => {
            const sid = `imp:${imp}#${e.sourceIri}`;
            const tid = `imp:${imp}#${e.targetIri}`;
            if (!ontoState.cy.$(`#${CSS.escape(sid)}`).length) {
              const label = e.sourceIri.includes('#') ? e.sourceIri.split('#').pop() : e.sourceIri.split('/').pop();
              const pos = savedPos[sid] ? savedPos[sid] : nextPos();
              added.push(ontoState.cy.add({ group: 'nodes', data: { id: sid, iri: e.sourceIri, label, type: 'class', importSource: imp }, position: pos, classes: 'imported' }));
            }
            if (!ontoState.cy.$(`#${CSS.escape(tid)}`).length) {
              const label = e.targetIri.includes('#') ? e.targetIri.split('#').pop() : e.targetIri.split('/').pop();
              const pos = savedPos[tid] ? savedPos[tid] : nextPos();
              added.push(ontoState.cy.add({ group: 'nodes', data: { id: tid, iri: e.targetIri, label, type: 'class', importSource: imp }, position: pos, classes: 'imported' }));
            }
            added.push(ontoState.cy.add({ group: 'edges', data: { id: `impE${Date.now()}_${idx++}`, source: sid, target: tid, predicate: e.label, type: 'objectProperty', importSource: imp }, classes: 'imported' }));
          });
          // Make overlays semi-interactive for positioning: allow drag, but don't select or edit
          added.forEach(el => {
            try {
              if (el.isNode && el.isNode()) {
                el.selectable(false); el.grabbable(true); el.locked(false);
              } else {
                el.selectable(false); el.grabbable(false); el.locked(true);
              }
            } catch(_) {}
          });

          // Add owl:equivalentClass visual links between base and imported nodes (by label/local name)
          try {
            const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type')||'class')==='class' && !n.hasClass('imported'));
            const imported = ontoState.cy.nodes().filter(n => (n.data('type')||'class')==='class' && n.hasClass('imported') && (n.data('importSource')||'')===imp);
            const byKey = (s)=>String(s||'').trim().toLowerCase();
            const baseMap = new Map(); baseClasses.forEach(n => baseMap.set(byKey(n.data('label')||n.id()), n));
            let idx2 = 0;
            imported.forEach(n => {
              const key = byKey(n.data('label')||n.id());
              const base = baseMap.get(key);
              if (base) {
                const eid = `impEq${Date.now()}_${idx2++}`;
                ontoState.cy.add({ group: 'edges', data: { id: eid, source: base.id(), target: n.id(), predicate: 'equivalentClass', type: 'objectProperty', importSource: imp }, classes: 'imported imported-equivalence' });
              }
            });
          } catch(_) {}
        }
        // Do not persist imported overlays to base local storage
        refreshOntologyTree();
      } catch(_) {}
    }

    // Context menu helpers
    let cmState = { visible: false, sourceId: null };
    function showMenuAt(x, y) {
      const m = qs('#ontoContextMenu'); if (!m) return;
      m.style.left = x + 'px'; m.style.top = y + 'px'; m.style.display = 'block'; cmState.visible = true;
    }
    function hideMenu() { const m = qs('#ontoContextMenu'); if (!m) return; m.style.display = 'none'; cmState.visible = false; }
    function startConnectFrom(node) {
      cmState.sourceId = node.id();
      node.addClass('connect-source');
    }
    function clearConnectState() {
      if (cmState.sourceId && ontoState.cy) {
        const n = ontoState.cy.$('#' + cmState.sourceId);
        if (n) n.removeClass('connect-source');
      }
      cmState.sourceId = null;
    }

    // Ensure new class IDs do not collide with existing nodes after imports/loads
    function recomputeNextId() {
      try {
        if (!ontoState || !ontoState.cy) return;
        let maxNum = 0;
        ontoState.cy.nodes().forEach(n => {
          try {
            const nid = (n && typeof n.id === 'function') ? n.id() : '';
            const m = /^Class(\d+)$/.exec(String(nid || ''));
            if (m) {
              const num = parseInt(m[1], 10);
              if (!isNaN(num)) maxNum = Math.max(maxNum, num);
            }
          } catch(_) {}
        });
        ontoState.nextId = Math.max(1, maxNum + 1);
      } catch(_) {}
    }

    function importOntologyJSON(obj) {
      ensureOntologyInitialized();
      if (!obj || !Array.isArray(obj.nodes) || !Array.isArray(obj.edges)) return;
      // Clear only base elements, keep imported overlays intact
      ontoState.cy.elements().filter(el => !el.hasClass('imported') && !el.hasClass('imported-equivalence')).remove();
      // Migration guard: filter out any overlays accidentally saved to JSON
      const isOverlayNode = (n) => {
        try {
          const d = (n && n.data) ? n.data : {};
          const id = String(d.id || '');
          const cls = String(n.classes || d.classes || '');
          return !!d.importSource || id.startsWith('imp:') || cls.includes('imported');
        } catch(_) { return false; }
      };
      const baseNodes = (obj.nodes || []).filter(n => !isOverlayNode(n));
      const baseNodeIds = new Set(baseNodes.map(n => (n.data && n.data.id) || ''));
      const baseEdges = (obj.edges || []).filter(e => {
        try {
          const d = (e && e.data) ? e.data : {};
          const cls = String(e.classes || d.classes || '');
          if (d.importSource || cls.includes('imported')) return false;
          if (String(d.predicate || '').toLowerCase() === 'equivalentclass') return false;
          return baseNodeIds.has(d.source) && baseNodeIds.has(d.target);
        } catch(_) { return false; }
      });
      // Add back base nodes and edges only
      ontoState.cy.add(baseNodes.map(n => ({ group: 'nodes', data: n.data, position: n.position })));
      ontoState.cy.add(baseEdges.map(e => ({ group: 'edges', data: e.data })));
      ontoState.cy.fit();
      refreshOntologyTree();
      persistOntologyToLocalStorage();
      // Update ID counter so new classes get unique IDs
      recomputeNextId();
    }

    // Auth/UI gating
    const tokenKey = 'odras_token';
    const userKey = 'odras_user';
    function showAuth(show) {
      qs('#authView').style.display = show ? 'grid' : 'none';
      qs('#mainView').style.display = show ? 'none' : 'grid';
    }
    async function initAuth() {
      const token = localStorage.getItem(tokenKey);
      if (!token) { showAuth(true); return; }
      const me = await fetch('/api/auth/me', { headers: { Authorization: 'Bearer ' + token }}).then(r=>r.json()).catch(()=>null);
      if (!me || me.error) { showAuth(true); return; }
      qs('#userMenu').textContent = me.username + (me.is_admin ? ' (admin)' : '');
      showAuth(false);
      // Restore last active workbench before loading projects
      try {
        const hashWB = (()=>{ try { const p = new URLSearchParams(location.hash.replace(/^#/, '')); return p.get('wb') || ''; } catch(_) { return ''; } })();
        const wb = hashWB || localStorage.getItem('active_workbench') || 'ontology';
        // Activate matching icon and section
        const icon = qs(`.icon[data-wb="${wb}"]`);
        if (icon) {
          qsa('.icon').forEach(i => i.classList.remove('active')); icon.classList.add('active');
          qsa('.workbench').forEach(w => w.classList.remove('active'));
          const sec = qs('#wb-' + wb); if (sec) sec.classList.add('active');
        }
        // If no workbench got activated (e.g., missing section), default to ontology
        if (!document.querySelector('.workbench.active')) {
          const fallback = qs('.icon[data-wb="ontology"]');
          if (fallback) fallback.click();
        }
      } catch(_) {}
      // Initialize Cytoscape BEFORE loading projects so restore can occur during renderTree
      ensureOntologyInitialized();
      // If Files workbench is already active from restore, initialize its handlers now
      try { if (document.querySelector('#wb-files.workbench.active')) { ensureFilesInitialized(); } } catch(_) {}
      await loadProjects();
      refreshOntologyTree();
      // Bind Files workbench handlers proactively so Choose Files works immediately
      try { ensureFilesInitialized(); } catch(_) {}
      // Restore ontology tree collapsed state
      try {
        // Restore left project tree width
        const uiMainTreeW = parseInt(localStorage.getItem('ui_main_tree_w') || '0', 10);
        if (uiMainTreeW) document.documentElement.style.setProperty('--tree-w', uiMainTreeW + 'px');
        // Restore ontology left tree width
        const ontoTreeW = parseInt(localStorage.getItem('onto_tree_w') || '0', 10);
        if (ontoTreeW) document.documentElement.style.setProperty('--onto-tree-w', ontoTreeW + 'px');
        const treeCollapsed = localStorage.getItem('onto_tree_collapsed') === '1';
        if (treeCollapsed) {
          const sec = qs('#wb-ontology');
          if (sec && !sec.classList.contains('onto-tree-collapsed')) sec.classList.add('onto-tree-collapsed');
          const icon = qs('#ontoTreeToggleIcon');
          if (icon) icon.innerHTML = '<path d="M9 6l6 6-6 6"/>';
        }
        const propsCollapsed = localStorage.getItem('onto_props_collapsed') === '1';
        if (propsCollapsed) {
          const sec = qs('#wb-ontology');
          if (sec && !sec.classList.contains('onto-props-collapsed')) sec.classList.add('onto-props-collapsed');
          const icon = qs('#ontoPropsToggleIcon');
          if (icon) icon.innerHTML = '<path d="M15 6l-6 6 6 6"/>';
        }
        // Ensure icon SVGs match classes and allow CSS rotation animation to apply
        const treeIcon = qs('#ontoTreeToggleIcon');
        if (treeIcon && !treeCollapsed) treeIcon.innerHTML = '<path d="M15 6l-6 6 6 6"/>';
        const propsIcon = qs('#ontoPropsToggleIcon');
        if (propsIcon && !propsCollapsed) propsIcon.innerHTML = '<path d="M9 6l6 6-6 6"/>';
        const savedW = parseInt(localStorage.getItem('onto_props_w') || '0', 10);
        if (savedW) document.documentElement.style.setProperty('--onto-props-w', savedW + 'px');
        // Do not load any graph here; renderTree handles per-project restore safely
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      } catch(_) {}
    }
    qs('#loginBtn').onclick = async () => {
      const username = qs('#u').value.trim();
      const password = qs('#p').value;
      qs('#loginMsg').textContent = 'Signing in...';
      const res = await fetch('/api/auth/login', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ username, password }) });
      const json = await res.json();
      if (res.ok && json.token) {
        localStorage.setItem(tokenKey, json.token);
        localStorage.setItem(userKey, username);
        qs('#loginMsg').textContent = '';
        initAuth();
      } else {
        qs('#loginMsg').textContent = json.error || 'Login failed';
      }
    };
    qs('#logoutBtn').onclick = () => { localStorage.removeItem(tokenKey); localStorage.removeItem(userKey); activeOntologyIri = null; updateOntoGraphLabel(); try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {} showAuth(true); };

    // Projects
    async function loadProjects() {
      const token = localStorage.getItem(tokenKey);
      const res = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token }});
      const json = await res.json();
      const raw = json.projects || [];
      // Normalize backend shape to { id, name }
      const list = raw.map(p => ({
        id: p.id || p.project_id || p.projectId,
        name: p.name || p.project_name || 'Project'
      })).filter(p => !!p.id);
      const selects = [qs('#projectSelect2')];
      if (list.length) {
        // restore previously selected project if available
        const savedPid = (localStorage.getItem('active_project_id') || '').trim();
        let selected = list[0];
        if (savedPid) {
          const found = list.find(p => p.id === savedPid);
          if (found) selected = found;
        }
        selects.forEach(sel => { if (sel) { sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join(''); sel.disabled = false; sel.value = selected.id; } });
        await renderTree(selected);
      } else {
        // No projects: clear tree and show empty state
        selects.forEach(sel => { if (sel) { sel.innerHTML = '<option value="" disabled selected>Create Project...</option>'; sel.disabled = true; } });
        await renderTree({ id: null, name: '' });
      }
    }
    (function(){
      const npb = qs('#newProjectBtn');
      if (!npb) return;
      npb.onclick = async () => {
        const name = prompt('Project name'); if (!name) return;
        const token = localStorage.getItem(tokenKey);
        const res = await fetch('/api/projects', { method:'POST', headers:{'Content-Type':'application/json', Authorization: 'Bearer ' + token}, body: JSON.stringify({ name }) });
        let pid = '';
        let pname = name;
        if (res.ok) {
          const js = await res.json().catch(()=>({}));
          const proj = js.project || js;
          pid = (proj && (proj.id || proj.project_id || proj.projectId)) || '';
          pname = (proj && proj.name) || name;
          if (pid) try { localStorage.setItem('active_project_id', pid); } catch(_) {}
        }
        // Reload projects, select the created one, and render it
        const pr = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token }}).then(r=>r.json()).catch(()=>({projects:[]}));
        const raw = pr.projects || [];
        const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' })).filter(p => !!p.id);
        const sel = qs('#projectSelect2');
        if (sel) {
          sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
          if (pid && list.find(p => p.id === pid)) sel.value = pid; else if (list.length) sel.value = list[0].id;
          sel.disabled = !list.length;
        }
        const selected = pid ? { id: pid, name: pname } : (list[0] || { id: null, name: '' });
        await renderTree(selected);
      };
    })();
    ['#projectSelect2'].forEach(id => {
      const sel = qs(id); if (!sel) return;
      sel.addEventListener('change', async (e) => {
        const pid = e.target.value;
        try { localStorage.setItem('active_project_id', pid); } catch(_) {}
        const token = localStorage.getItem(tokenKey);
        // Save current ontology canvas before switching projects
        try { if (ontoState && ontoState.cy && activeOntologyIri) saveGraphToLocal(activeOntologyIri); } catch(_) {}
        const res = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token }});
        const json = await res.json();
        const raw = json.projects || [];
        const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' }));
        const proj = list.find(p => p.id === pid);
        if (proj) { activeOntologyIri = null; updateOntoGraphLabel(); await renderTree(proj); }
      });
    });

    // Plus button near project selector creates a new project
    (function(){
      const btn = qs('#addNodeBtn');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        const name = prompt('Project name'); if (!name) return;
        const token = localStorage.getItem(tokenKey);
        const res = await fetch('/api/projects', { method:'POST', headers:{'Content-Type':'application/json', Authorization: 'Bearer ' + token}, body: JSON.stringify({ name }) });
        if (res.ok) {
          // Reload and select the newly created project
          const pr = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token }}).then(r=>r.json()).catch(()=>({projects:[]}));
          const raw = pr.projects || [];
          const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' })).filter(p => !!p.id);
          const sel = qs('#projectSelect2');
          if (sel && list.length) {
            sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
            const js = await res.json().catch(()=>({}));
            const proj = js.project || js;
            const pid = (proj && (proj.id || proj.project_id || proj.projectId)) || list[list.length - 1].id;
            sel.value = pid;
            try { localStorage.setItem('active_project_id', pid); } catch(_) {}
            sel.disabled = false;
            // Save current ontology canvas before switching projects
            try { if (ontoState && ontoState.cy && activeOntologyIri) saveGraphToLocal(activeOntologyIri); } catch(_) {}
            const selected = list.find(p => p.id === pid) || list[list.length - 1];
            await renderTree(selected);
          }
        }
      });
    })();

    // Workbench switching
    qsa('.icon').forEach(el => el.onclick = () => {
      qsa('.icon').forEach(i => i.classList.remove('active')); el.classList.add('active');
      const wb = el.getAttribute('data-wb');
      qsa('.workbench').forEach(w => w.classList.remove('active'));
      qs('#wb-' + wb).classList.add('active');
      // Persist selected workbench
      try { localStorage.setItem('active_workbench', wb); } catch(_) {}
      // Reflect in hash
      try {
        const params = new URLSearchParams(location.hash.replace(/^#/, ''));
        params.set('wb', wb);
        location.hash = params.toString();
      } catch(_) {}
      if (wb === 'graph') refreshGraphSummary();
      if (wb === 'ontology') { ensureOntologyInitialized(); if (ontoState.cy) ontoState.cy.resize(); }
      if (wb === 'files') { ensureFilesInitialized(); }
    });

    // Tree collapsible sections
    qsa('.section > button').forEach(btn => {
      btn.onclick = (e) => {
        const sec = e.currentTarget.parentElement;
        const expanded = sec.getAttribute('aria-expanded') !== 'false';
        sec.setAttribute('aria-expanded', expanded ? 'false' : 'true');
      };
    });

    // Resizer
    (function(){
      const res = qs('#resizer');
      const panel = qs('#treePanel');
      let dragging = false;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => {
        dragging = false;
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tree-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tree-w-max'));
        let w = e.clientX - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--iconbar-w'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty('--tree-w', w + 'px');
        try { localStorage.setItem('ui_main_tree_w', String(w)); } catch(_) {}
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    // Ontology panel resizer
    (function(){
      const res = qs('#ontoResizer');
      const panelWidthProp = '--onto-tree-w';
      let dragging = false;
      if (!res) return;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => {
        dragging = false;
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const layout = qs('#wb-ontology .onto-layout'); if (!layout) return;
        const layoutRect = layout.getBoundingClientRect();
        // Grid columns: [tree][divider][iconbar][canvas][divider][props]
        // If tree is collapsed, divider width is 0; math still uses layout left
        let w = e.clientX - layoutRect.left;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-tree-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-tree-w-max'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty(panelWidthProp, w + 'px');
        try { localStorage.setItem('onto_tree_w', String(w)); } catch(_) {}
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    // Properties panel resizer
    (function(){
      const res = qs('#ontoPropsResizer');
      let dragging = false;
      if (!res) return;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => dragging = false);
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const layoutRect = qs('#wb-ontology .onto-layout')?.getBoundingClientRect();
        if (!layoutRect) return;
        let w = layoutRect.right - e.clientX;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-props-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-props-w-max'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty('--onto-props-w', w + 'px');
        try { localStorage.setItem('onto_props_w', String(w)); } catch(_) {}
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    async function renderTree(project) {
      activeProject = project && project.id ? project : null;
      // Reset active ontology when switching context or when no project
      activeOntologyIri = null;
      updateOntoGraphLabel();
      try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {}
      // Restore per-project active ontology selection (label only)
      try {
        const pid = project && (project.id || project.project_id);
        const savedIri = localStorage.getItem(`onto_active_iri__${pid}`);
        if (savedIri) {
          activeOntologyIri = savedIri;
          updateOntoGraphLabel();
          // Ensure properties panel model name reflects the saved active ontology
          try {
            const labels = loadOntologyLabelMap(project);
            const pid2 = (project && (project.id || project.project_id)) ? (project.id || project.project_id) : 'default';
            const friendly = (labels[savedIri] && String(labels[savedIri]).trim()) || (savedIri.split('/').pop() || savedIri);
            localStorage.setItem(`onto_model_name__${pid2}`, friendly);
            let attrs = {};
            try { attrs = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid2}`) || '{}'); } catch(_) { attrs = {}; }
            attrs.displayLabel = friendly; attrs.graphIri = savedIri;
            localStorage.setItem(`onto_model_attrs__${pid2}`, JSON.stringify(attrs));
            updatePropertiesPanelFromSelection();
          } catch(_) {}
          // Attempt to load saved canvas for this active IRI
          try {
            if (ontoState.cy) {
              ontoState.suspendAutosave = true;
              ontoState.cy.elements().remove();
              loadGraphFromLocal(savedIri);
              setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
            }
          } catch(_) {}
        }
      } catch(_) {}
      const root = qs('#treeRoot');
      const makeItem = (id, label, iconCls, children = [], dataAttrs = {}) => {
        const hasChildren = children && children.length > 0;
        const li = document.createElement('li');
        li.setAttribute('role', 'treeitem');
        if (hasChildren) li.setAttribute('aria-expanded', 'true');
        li.dataset.nodeId = id;
        Object.keys(dataAttrs || {}).forEach(k => { li.dataset[k] = dataAttrs[k]; });

        const row = document.createElement('div');
        row.className = 'node-row';
        row.tabIndex = 0;
        row.onclick = (e) => { selectNode(li); handleTreeSelection(li); };
        row.onkeydown = (e) => handleKey(e, li);
        // Inline rename on double-click for ontology nodes
        row.ondblclick = (e) => {
          if (li.dataset.nodeType === 'ontology') {
            const current = (li.dataset.label || row.querySelector('.node-label')?.textContent || '').trim();
            const name = prompt('Rename ontology label', current);
            if (!name || name.trim() === current) return;
            try {
              const payload = { graph: li.dataset.iri, label: name.trim() };
              const token = localStorage.getItem(tokenKey);
              fetch('/api/ontologies/label', { method: 'PUT', headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token }, body: JSON.stringify(payload) })
                .then(async (res) => {
                  if (!res.ok) throw new Error('rename failed');
                  const newLabel = name.trim();
                  row.querySelector('.node-label').textContent = newLabel; li.dataset.label = newLabel; saveOntologyLabel(li.dataset.iri, newLabel);
                  if (activeOntologyIri === li.dataset.iri) {
                    const pid = project.id || project.project_id || 'default';
                    localStorage.setItem(`onto_model_name__${pid}`, newLabel);
                    try {
                      let attrs = {};
                      try { attrs = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}'); } catch(_) { attrs = {}; }
                      attrs.displayLabel = newLabel;
                      localStorage.setItem(`onto_model_attrs__${pid}`, JSON.stringify(attrs));
                    } catch(_) {}
                    updateOntoGraphLabel();
                    // Immediately update properties panel model name
                    try { updatePropertiesPanelFromSelection(); } catch(_) {}
                    // Immediately reflect in Ontology tree view without a full tree reload
                    try { refreshOntologyTree(); } catch(_) {}
                  }
                  // Avoid immediate server re-fetch that could race and overwrite the fresh label
                })
                .catch(()=>{ alert('Rename failed'); });
            } catch(_) {}
          }
        };

        const twist = document.createElement('span'); twist.className = 'twist';
        if (hasChildren) {
          twist.onclick = (e) => { e.stopPropagation(); toggleNode(li); };
        }
        row.appendChild(twist);

        const icon = document.createElement('span'); icon.className = 'node-icon ' + iconCls; row.appendChild(icon);
        const text = document.createElement('span'); text.className = 'node-label'; text.textContent = label; row.appendChild(text);
        li.appendChild(row);

        if (hasChildren) {
          const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
          children.forEach(ch => ul.appendChild(ch));
          li.appendChild(ul);
        }
        return li;
      };

      const reqItems = ((project && project.requirements) || []).map((r, idx) => {
        const rid = r.id || `SP-${String(idx + 1).padStart(3, '0')}`;
        const label = rid; // ID only
        return makeItem(rid, label, 'req');
      });
      const docReqItems = (project && project.documents && project.documents.requirements ? project.documents.requirements : []).map(d => makeItem(d.id || d.name, d.name || d.id, 'docreq'));
      const docKnowItems = (project && project.documents && project.documents.knowledge ? project.documents.knowledge : []).map(d => makeItem(d.id || d.name, d.name || d.id, 'docknow'));
      const outItems = ((project && (project.artifacts || project.outputs)) || []).map(o => makeItem(o.id || o.name, o.name || o.id, 'out'));

      // Ontology tree: discover from Fuseki
      let ontologyNode = null;
      try {
        const pid = project && (project.id || project.project_id);
        const res = await fetch(`/api/ontologies${pid ? `?project=${encodeURIComponent(pid)}` : ''}`);
        const json = await res.json();
        const onts = Array.isArray(json.ontologies) ? json.ontologies : [];
        const labelsMap = loadOntologyLabelMap(project);
        const ontoItems = onts.map((o, idx) => {
          const serverLabel = (o.label && String(o.label).trim()) || '';
          const mapLabel = (labelsMap[o.graphIri] && String(labelsMap[o.graphIri]).trim()) || '';
          const displayLabel = mapLabel || serverLabel || o.graphIri;
          const li = makeItem(
            `ontology-${idx}-${o.graphIri}`,
            displayLabel,
            'onto',
            [],
            { nodeType: 'ontology', iri: o.graphIri, label: displayLabel }
          );
          // Enable dragging this ontology into the Imports node
          const row = li.querySelector('.node-row');
          if (row) {
            row.setAttribute('draggable', 'true');
            row.addEventListener('dragstart', (ev) => {
              try { ev.dataTransfer.setData('text/graph-iri', o.graphIri); ev.dataTransfer.effectAllowed = 'copy'; } catch(_) {}
            });
          }
          // Initialize label map from server only if missing
          if (!mapLabel && serverLabel) {
            try { saveOntologyLabel(o.graphIri, serverLabel); } catch(_) {}
          }
          return li;
        });
        if (ontoItems.length) {
          ontologyNode = makeItem('ontology', 'Ontology', 'folder', ontoItems);
        } else {
          // No ontologies: ensure empty state is shown
          activeOntologyIri = null;
          updateOntoGraphLabel();
          ontologyNode = makeItem('ontology', 'Ontology', 'folder', []);
        }
      } catch (_) {
        // Network/SPARQL error: show a placeholder item
        ontologyNode = makeItem('ontology', 'Ontology', 'folder', [
          makeItem('onto-error', 'Discovery unavailable', 'onto')
        ]);
      }

      const projectDisplay = (project && (project.name || project.id)) ? (project.name || project.id) : '';
      const projectInfo = makeItem('project-info', `Project: ${projectDisplay}`, 'folder');
      // Enable delete on main tree top node when project is selected
      try {
        const row = projectInfo.querySelector('.node-row');
        if (row && project && (project.id || project.project_id)) {
          // Context menu binding
          row.oncontextmenu = (ev) => {
            ev.preventDefault();
            const menu = qs('#projectContextMenu'); if (!menu) return;
            menu.style.display = 'block';
            menu.style.left = ev.pageX + 'px';
            menu.style.top = ev.pageY + 'px';
            const hide = () => { menu.style.display = 'none'; document.removeEventListener('click', hide, { capture: true }); };
            setTimeout(() => { document.addEventListener('click', hide, { capture: true }); }, 0);
            const pid = project.id || project.project_id;
            const token = localStorage.getItem(tokenKey);
            const archiveBtn = qs('#projArchiveBtn');
            const deleteBtn = qs('#projDeleteBtn');
            const showArchivedBtn = qs('#projShowArchivedBtn');
            const renameBtn = qs('#projRenameBtn');
            if (renameBtn) renameBtn.onclick = async () => {
              try {
                const currentName = (project && (project.name || '')) || '';
                const newName = prompt('Rename project', currentName);
                if (!newName || newName.trim() === currentName) return;
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token },
                  body: JSON.stringify({ name: newName.trim() })
                });
                if (res.ok) {
                  await loadProjects();
                } else {
                  const t = await res.text().catch(()=>String(res.status));
                  alert('Rename failed: ' + t);
                }
              } finally { hide(); }
            };
            if (archiveBtn) archiveBtn.onclick = async () => {
              try {
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}/archive`, { method: 'POST', headers: { Authorization: 'Bearer ' + token }});
                if (res.ok) { try { localStorage.removeItem('active_project_id'); } catch(_) {} await loadProjects(); }
                else { const t = await res.text().catch(()=>String(res.status)); alert('Archive failed: ' + t); }
              } finally { hide(); }
            };
            if (deleteBtn) deleteBtn.onclick = async () => {
              try {
                if (!confirm('Delete this project? This does not delete external artifacts.')) return;
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token }});
                if (res.ok) { try { localStorage.removeItem('active_project_id'); } catch(_) {} await loadProjects(); }
                else { const t = await res.text().catch(()=>String(res.status)); alert('Delete failed: ' + t); }
              } finally { hide(); }
            };
            if (showArchivedBtn) showArchivedBtn.onclick = async () => {
              try {
                const res = await fetch('/api/projects?state=archived', { headers: { Authorization: 'Bearer ' + token }});
                const json = await res.json();
                const rows = (json.projects || []).map(p => ({ id: p.project_id || p.id, name: p.name || 'Project' })).filter(p => p.id);
                const overlay = document.createElement('div');
                overlay.style.position='fixed'; overlay.style.inset='0'; overlay.style.background='rgba(0,0,0,0.4)'; overlay.style.zIndex='9998';
                const panel = document.createElement('div'); panel.style.position='fixed'; panel.style.top='20%'; panel.style.left='50%'; panel.style.transform='translateX(-50%)'; panel.style.background='var(--panel)'; panel.style.border='1px solid var(--border)'; panel.style.borderRadius='12px'; panel.style.padding='12px'; panel.style.minWidth='420px'; panel.style.zIndex='9999';
                panel.innerHTML = `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;"><strong>Archived Projects</strong><button id="archClose" class="btn">Close</button></div><div id="archList"></div>`;
                document.body.appendChild(overlay); document.body.appendChild(panel);
                const close = ()=>{ try { document.body.removeChild(panel); document.body.removeChild(overlay); } catch(_) {} };
                panel.querySelector('#archClose').onclick = close; overlay.onclick = close;
                const listEl = panel.querySelector('#archList');
                if (!rows.length) { listEl.innerHTML = '<div class="muted">No archived projects.</div>'; return; }
                listEl.innerHTML = rows.map(r => `<div style="display:flex; justify-content:space-between; align-items:center; border:1px solid var(--border); border-radius:8px; padding:8px; margin-bottom:6px;"><span>${r.name}</span><div><button class="btn" data-restore="${r.id}">Restore</button></div></div>`).join('');
                listEl.addEventListener('click', async (e)=>{
                  const btn = e.target.closest('button[data-restore]'); if (!btn) return;
                  const rid = btn.getAttribute('data-restore');
                  const rr = await fetch(`/api/projects/${encodeURIComponent(rid)}/restore`, { method:'POST', headers:{ Authorization:'Bearer ' + token }});
                  if (rr.ok) {
                    try { localStorage.setItem('active_project_id', rid); } catch(_) {}
                    close();
                    await loadProjects();
                  } else {
                    const t = await rr.text().catch(()=>String(rr.status)); alert('Restore failed: ' + t);
                  }
                });
              } finally { hide(); }
            };
          };
          row.onkeydown = async (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
              e.preventDefault();
              const pid = project.id || project.project_id;
              const token = localStorage.getItem(tokenKey);
              if (!confirm('Delete this project? This does not delete external artifacts.')) return;
              const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token }});
              if (res.ok) {
                try { localStorage.removeItem('active_project_id'); } catch(_) {}
                await loadProjects();
              } else {
                const t = await res.text().catch(()=>String(res.status));
                alert('Delete failed: ' + t);
              }
            }
          };
        }
      } catch(_) {}
      const docsReqNode = makeItem('documents-requirements', 'Requirements Documents', 'folder', docReqItems);
      const docsKnowNode = makeItem('documents-knowledge', 'Knowledge Documents', 'folder', docKnowItems);
      const docsChildren = [];
      if (docReqItems.length) docsChildren.push(docsReqNode);
      if (docKnowItems.length) docsChildren.push(docsKnowNode);
      const docsNode = makeItem('documents', 'Documents', 'folder', docsChildren);
      const reqNode = makeItem('requirements', 'Extracted Requirements', 'folder', reqItems);
      const outNode = makeItem('artifacts', 'Artifacts', 'folder', outItems);

      root.innerHTML = '';
      // If no project, show minimal empty tree
      root.innerHTML = '';
      if (project && (project.id || project.project_id)) {
        [projectInfo, ontologyNode, docsNode, reqNode, outNode].filter(Boolean).forEach(n => root.appendChild(n));
      }

      // Auto-restore previously selected ontology for this project, if available
      try {
        const pid = project && (project.id || project.project_id);
        const savedIri = pid ? localStorage.getItem(`onto_active_iri__${pid}`) : null;
        const treeEl = qs('#treeRoot');
        if (savedIri && treeEl) {
          const li = Array.from(treeEl.querySelectorAll('li[role="treeitem"]')).find(el => el.dataset && el.dataset.iri === savedIri);
          if (li) {
            // Restore canvas first (if we have saved content), then select the ontology to sync panels
            try {
              if (ontoState.cy) {
                ontoState.suspendAutosave = true;
                ontoState.cy.elements().remove();
                loadGraphFromLocal(savedIri);
                setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
              }
            } catch(_) {}
            selectNode(li);
            // Prevent workbench switching when restoring selection on load
            suppressWorkbenchSwitch = true;
            try { handleTreeSelection(li); } finally { suppressWorkbenchSwitch = false; }
          } else {
            // Saved IRI no longer present; reset to empty state
            activeOntologyIri = null;
            updateOntoGraphLabel();
            try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {}
            refreshOntologyTree();
          }
        } else {
          // No saved selection for this project
          activeOntologyIri = null;
          updateOntoGraphLabel();
          try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {}
          refreshOntologyTree();
        }
      } catch(_) {}

      // Add plus button on Ontology section header (right side)
      try {
        const ontoSection = Array.from(root.children).find(li => li.querySelector('.node-label')?.textContent === 'Ontology');
        const headerRow = ontoSection ? ontoSection.querySelector('.node-row') : null;
        if (headerRow && !headerRow.querySelector('.tree-add-btn')) {
          const addBtn = document.createElement('button');
          addBtn.className = 'btn tree-add-btn';
          addBtn.title = 'New Ontology';
          addBtn.textContent = '+';
          addBtn.style.marginLeft = '8px';
          addBtn.onclick = async (e) => {
            e.stopPropagation();
            if (!project || !(project.id || project.project_id)) { alert('Create a project first'); return; }
            const disp = prompt('Display label for new ontology'); if (!disp) return;
            const base = slugify(disp) || `ontology-${Date.now()}`;
            const label = disp;
            try {
              const token = localStorage.getItem(tokenKey);
              const pid2 = project.id || project.project_id;
              const res = await fetch('/api/ontologies', { method: 'POST', headers: { 'Content-Type':'application/json', Authorization: 'Bearer ' + token }, body: JSON.stringify({ project: pid2, name: base, label }) });
              if (!res.ok) {
                const msg = await res.text().catch(()=>String(res.status));
                alert('Create ontology failed: ' + msg);
                return;
              }
              const created = await res.json();
              if (created && created.graphIri) {
                try { saveOntologyLabel(created.graphIri, created.label || label); } catch(_) {}
              }
              await renderTree(project);
              // Ensure label is shown and select the created ontology (guard for valid response)
              if (created && created.graphIri) {
                const newRoot = qs('#treeRoot');
                const li = Array.from(newRoot.querySelectorAll('li[role="treeitem"]')).find(el => el.dataset && el.dataset.iri === created.graphIri);
                // Update top node label immediately
                try {
                  const ontoTop = qs('#ontoTreeRoot .onto-node-label');
                  if (ontoTop) ontoTop.textContent = created.label || label;
                } catch(_) {}
                if (li) {
                  const lbl = li.querySelector('.node-label'); if (lbl) lbl.textContent = created.label || label;
                  li.dataset.label = created.label || label;
                  selectNode(li);
                  handleTreeSelection(li);
                } else {
                  // Fallback: set selection and force refresh display
                  activeOntologyIri = created.graphIri;
                  updateOntoGraphLabel();
                  refreshOntologyTree();
                }
              }
            } catch(_) {}
          };
          headerRow.appendChild(addBtn);
        }
      } catch(_) {}

      // Handle Delete key for ontology deletion
      root.addEventListener('keydown', async (e) => {
        if (e.key === 'Delete' || e.keyCode === 46) {
          const sel = root.querySelector('.node-row.selected');
          if (!sel) return;
          const li = sel.closest('li[role="treeitem"]');
          if (!li || li.dataset.nodeType !== 'ontology') return;
          const iri = li.dataset.iri;
          if (!iri) return;
          try {
            const url = `/api/ontologies?graph=${encodeURIComponent(iri)}`;
            const token = localStorage.getItem(tokenKey);
            const res = await fetch(url, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token } });
            if (res.ok) {
              await renderTree(project);
              if (activeOntologyIri === iri) { activeOntologyIri = null; updateOntoGraphLabel(); ensureOntologyInitialized(); ontoState.cy?.elements().remove(); refreshOntologyTree(); }
            }
          } catch(_) {}
        }
      });
    }

    async function refreshGraphSummary() {
      const el = qs('#graphSummary'); if (!el) return;
      el.textContent = 'Loading summary...';
      try {
        const res = await fetch('/api/ontology/summary');
        const json = await res.json();
        if (json.rows) {
          el.innerHTML = json.rows.map(r => `<div class="row"><span class="muted">${r.type}</span> — ${r.count}</div>`).join('') || '<div class="muted">No data</div>';
        } else {
          el.textContent = json.error || 'No data';
        }
      } catch (e) { el.textContent = 'Error loading summary'; }
    }
    (function(){
      const btnS = () => qs('#btnRefreshSummary');
      const btnQ = () => qs('#btnRunSparql');
      document.addEventListener('click', async (e) => {
        if (e.target === btnS()) {
          refreshGraphSummary();
        } else if (e.target === btnQ()) {
          const q = (qs('#sparqlInput')?.value) || '';
          const st = qs('#sparqlStatus'); const out = qs('#sparqlResult');
          st.textContent = 'Running...'; out.textContent = '';
          try {
            const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
            const json = await res.json();
            if (res.ok) { out.textContent = JSON.stringify(json, null, 2); st.textContent = 'OK'; }
            else { out.textContent = JSON.stringify(json, null, 2); st.textContent = 'Error'; }
          } catch (err) { out.textContent = String(err); st.textContent = 'Error'; }
        }
      });
    })();

    function refreshOntologyTree() {
      const root = qs('#ontoTreeRoot');
      if (!root || !ontoState.cy) return;
      const classes = ontoState.cy.nodes().filter(n => n.visible() && (n.data('type') || 'class') === 'class' && !n.hasClass('imported'));
      const importedClasses = ontoState.cy.nodes().filter(n => n.visible() && (n.data('type') || 'class') === 'class' && n.hasClass('imported'));
      const notes = ontoState.cy.nodes().filter(n => n.visible() && (n.data('type') || '') === 'note' && !n.hasClass('imported'));
      // Simple grouping: Classes as top-level; edges shown under a "Relationships" group per class
      root.innerHTML = '';
      const makeItem = (label, expanded = true, children = []) => {
        const li = document.createElement('li');
        li.setAttribute('role', 'treeitem');
        if (children.length) li.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        const row = document.createElement('div'); row.className = 'onto-node-row';
        const twist = document.createElement('span'); twist.className = 'onto-twist'; if (children.length) twist.onclick = (e)=>{ e.stopPropagation(); li.setAttribute('aria-expanded', li.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'); };
        const text = document.createElement('span'); text.className = 'onto-node-label'; text.textContent = label;
        row.appendChild(twist); row.appendChild(text); li.appendChild(row);
        if (children.length) {
          const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
          children.forEach(c => ul.appendChild(c));
          li.appendChild(ul);
        }
        return li;
      };
      const items = [];
      classes.forEach(cls => {
        const label = cls.data('label') || cls.id();
        const outEdges = cls.outgoers('edge');
        const rels = outEdges.map(e => {
          const other = e.target();
          const pred = e.data('predicate') || 'relatedTo';
          const type = e.data('type') || 'objectProperty';
          return makeItem(`${pred} → ${(other.data('label') || other.id())} (${type})`, false, []);
        });
        items.push(makeItem(label, false, rels));
      });
      if (importedClasses.length) {
        const importedChildren = importedClasses.map(cls => makeItem((cls.data('label')||cls.id()) + ' (imported)', false, []));
        items.push(makeItem('Imported Classes', true, importedChildren));
      }
      if (notes.length) {
        const noteChildren = notes.map(n => makeItem(n.data('label') || n.id(), false, []));
        items.push(makeItem('Notes', true, noteChildren));
      }
      const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
      items.forEach(i => ul.appendChild(i));
      // Root level
      const rootItem = document.createElement('li'); rootItem.setAttribute('role', 'treeitem'); rootItem.setAttribute('aria-expanded', 'true');
      const row = document.createElement('div'); row.className = 'onto-node-row';
      const twist = document.createElement('span'); twist.className = 'onto-twist'; twist.onclick = (e)=>{ e.stopPropagation(); rootItem.setAttribute('aria-expanded', rootItem.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'); };
      const text = document.createElement('span'); text.className = 'onto-node-label';
      (function(){
        try {
          const labels = loadOntologyLabelMap(activeProject);
          let modelName = 'Ontology';
          const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
          const scopedName = localStorage.getItem(`onto_model_name__${pid}`) || '';
          if (scopedName.trim()) modelName = scopedName.trim();
          else if (activeOntologyIri) {
            modelName = (labels[activeOntologyIri] && String(labels[activeOntologyIri]).trim()) || (activeOntologyIri.split('/').pop() || 'Ontology');
          }
          text.textContent = modelName;
        } catch(_) { text.textContent = 'Ontology'; }
      })();
      row.appendChild(twist); row.appendChild(text); rootItem.appendChild(row); rootItem.appendChild(ul);
      // (Do not delete projects here; project deletion is handled in the main tree top node in renderTree)
      root.innerHTML = '';
      root.appendChild(rootItem);

      // Imports node specific to current ontology
      try {
        const importsKey = 'onto_imports__' + encodeURIComponent(activeOntologyIri || '');
        const imports = JSON.parse(localStorage.getItem(importsKey) || '[]');
        const importsRoot = document.createElement('li'); importsRoot.setAttribute('role','treeitem'); importsRoot.setAttribute('aria-expanded','true');
        const row = document.createElement('div'); row.className = 'onto-node-row'; const tw = document.createElement('span'); tw.className = 'onto-twist'; const lbl = document.createElement('span'); lbl.className='onto-node-label'; lbl.textContent='Imports'; row.appendChild(tw); row.appendChild(lbl); importsRoot.appendChild(row);
        const ul = document.createElement('ul'); ul.setAttribute('role','group');
        function removeImport(iri) {
          const key = 'onto_imports__' + encodeURIComponent(activeOntologyIri || '');
          try {
            const curr = new Set(JSON.parse(localStorage.getItem(key) || '[]'));
            if (curr.has(iri)) { curr.delete(iri); localStorage.setItem(key, JSON.stringify(Array.from(curr))); refreshOntologyTree(); }
          } catch(_) {}
        }
        async function friendlyImportName(iri) {
          try {
            const q = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?label WHERE { GRAPH <${iri}> { <${iri}> a owl:Ontology . OPTIONAL { <${iri}> rdfs:label ?label } } }`;
            const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
            if (!res.ok) throw new Error('sparql');
            const json = await res.json();
            const b = json.results && json.results.bindings && json.results.bindings[0];
            const lbl = b && b.label && b.label.value;
            return (lbl && lbl.trim()) || (iri.split('/').pop() || iri);
          } catch(_) { return iri.split('/').pop() || iri; }
        }
        async function importEquivCount(importIri) {
          try {
            if (!ontoState.cy) return 0;
            const norm = s => String(s||'').trim().toLowerCase();
            const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type')||'class') === 'class' && !n.hasClass('imported'));
            const baseByLabel = new Map();
            baseClasses.forEach(n => { baseByLabel.set(norm(n.data('label')||n.id()), n); });
            const q = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?c ?label WHERE { GRAPH <${importIri}> { ?c a owl:Class . OPTIONAL { ?c rdfs:label ?label } } }`;
            const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
            if (!res.ok) return 0;
            const json = await res.json();
            const rows = (json && json.results && json.results.bindings) ? json.results.bindings : [];
            const matched = new Set();
            rows.forEach(b => {
              const iri = b.c && b.c.value; const label = b.label && b.label.value;
              const local = iri ? (iri.includes('#') ? iri.split('#').pop() : iri.split('/').pop()) : '';
              const key = norm(label || local);
              if (baseByLabel.has(key) && iri) matched.add(iri);
            });
            return matched.size;
          } catch(_) { return 0; }
        }
        const visibleSet = loadVisibleImports(activeOntologyIri);
        imports.forEach(async g => {
          const li = document.createElement('li'); li.setAttribute('role','treeitem'); li.dataset.importIri = g;
          const r=document.createElement('div'); r.className='onto-node-row'; r.tabIndex = 0;
          const cb=document.createElement('input'); cb.type='checkbox'; cb.style.marginRight = '6px'; cb.checked = visibleSet.has(g);
          const t=document.createElement('span'); t.className='onto-twist';
          const l=document.createElement('span'); l.className='onto-node-label';
          const name = await friendlyImportName(g);
          const cnt = await importEquivCount(g);
          l.textContent = `${name}${cnt ? ` (${cnt})` : ''}`;
          cb.addEventListener('change', async () => {
            const vis = loadVisibleImports(activeOntologyIri);
            if (cb.checked) vis.add(g); else vis.delete(g);
            saveVisibleImports(activeOntologyIri, vis);
            await overlayImportsRefresh();
          });
          r.onclick = (e)=>{ Array.from(ul.querySelectorAll('.onto-node-row')).forEach(n=>n.classList.remove('selected')); r.classList.add('selected'); };
          r.onkeydown = (e)=>{ const key=e.key||e.code; if (key==='Delete' || key==='Backspace') { e.preventDefault(); removeImport(g); } };
          r.appendChild(cb); r.appendChild(t); r.appendChild(l);
          li.appendChild(r); ul.appendChild(li);
        });
        importsRoot.appendChild(ul);
        root.appendChild(importsRoot);
        // Enable drop to import
        row.addEventListener('dragover', (e)=>{ e.preventDefault(); });
        row.addEventListener('drop', async (e)=>{
          e.preventDefault();
          const draggedIri = e.dataTransfer.getData('text/graph-iri');
          if (!draggedIri) return;
          const list = new Set(imports);
          if (!list.has(draggedIri)) { list.add(draggedIri); localStorage.setItem(importsKey, JSON.stringify(Array.from(list))); refreshOntologyTree(); }
          // Overlay imported classes (placeholder: we only list; loading remote triples is OW-2)
        });
      } catch(_) {}
    }

    // (empty-state banner removed)

    function updatePropertiesPanelFromSelection() {
      const form = qs('#ontoPropsForm'); if (!form || !ontoState.cy) return;
      const sel = ontoState.cy.$(':selected');
      const nameEl = qs('#propName');
      const typeEl = qs('#propType');
      const attrsEl = qs('#propAttrs');
      if (sel.length === 1 && sel[0].isNode()) {
        const n = sel[0];
        nameEl.value = n.data('label') || n.id();
        typeEl.value = n.data('type') || 'class';
        attrsEl.value = JSON.stringify(n.data('attrs') || {}, null, 2);
      } else if (sel.length === 1 && sel[0].isEdge()) {
        const e = sel[0];
        nameEl.value = e.data('predicate') || e.id();
        typeEl.value = e.data('type') || 'objectProperty';
        attrsEl.value = JSON.stringify(e.data('attrs') || {}, null, 2);
      } else {
        const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
        nameEl.value = localStorage.getItem(`onto_model_name__${pid}`) || 'Ontology Model';
        typeEl.value = 'model';
        try {
          const json = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}');
          attrsEl.value = JSON.stringify(json, null, 2);
        } catch(_) { attrsEl.value = '{}'; }
      }
    }

    function persistOntologyToLocalStorage() {
      if (!ontoState.cy) return;
      if (ontoState.suspendAutosave) return;
      try {
        const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({ data: n.data(), position: n.position() }));
        const edges = ontoState.cy.edges().filter(e => !e.hasClass('imported')).map(e => ({ data: e.data() }));
        if (activeOntologyIri) {
          localStorage.setItem(storageKeyForGraph(activeOntologyIri), JSON.stringify({ nodes, edges }));
        }
      } catch(_) {}
    }

    // graphKeyForActive not used; per-project keys are used via storageKeyForGraph
    function attrsFromModel() {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      try { return JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}'); } catch(_) { return {}; }
    }
    function loadOntologyLabelMap(project) {
      const pid = project?.id || project?.project_id || (activeProject && (activeProject.id || activeProject.project_id)) || 'default';
      try { return JSON.parse(localStorage.getItem(`onto_label_map__${pid}`) || '{}'); } catch(_) { return {}; }
    }
    function saveOntologyLabel(graphIri, label) {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      try { const m = loadOntologyLabelMap(activeProject); m[graphIri] = label; localStorage.setItem(`onto_label_map__${pid}`, JSON.stringify(m)); } catch(_) {}
    }
    function storageKeyForGraph(iri) {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      return `onto_graph__${pid}__` + encodeURIComponent(iri);
    }
    function saveGraphToLocal(graphIri) {
      try {
        const nodes = ontoState.cy ? ontoState.cy.nodes().jsons() : [];
        const edges = ontoState.cy ? ontoState.cy.edges().jsons() : [];
        localStorage.setItem(storageKeyForGraph(graphIri), JSON.stringify({ nodes, edges }));
      } catch(_) {}
    }
    function loadGraphFromLocal(graphIri) {
      try {
        const json = localStorage.getItem(storageKeyForGraph(graphIri));
        if (!json) return;
        const data = JSON.parse(json);
        if (!ontoState.cy) return;
        ontoState.cy.elements().remove();
        ontoState.cy.add(data.nodes || []);
        ontoState.cy.add(data.edges || []);
        // After loading, ensure nextId is advanced beyond existing ClassNNN
        recomputeNextId();
        requestAnimationFrame(()=>{ ontoState.cy.fit(); });
      } catch(_) {}
    }

    // Ontology toolbar events and import handling
    (function(){
      document.addEventListener('click', async (e) => {
        if (e.target === qs('#ontoLayoutBtn')) {
          runAutoLayout();
        } else if (e.target === qs('#ontoFitBtn')) {
          try { if (ontoState.cy) ontoState.cy.fit(undefined, 20); } catch(_) {}
        } else if (e.target === qs('#ontoFullscreenBtn')) {
          try {
            const sec = qs('#wb-ontology');
            if (!sec) return;
            if (!document.fullscreenElement) {
              if (sec.requestFullscreen) await sec.requestFullscreen();
            } else {
              if (document.exitFullscreen) await document.exitFullscreen();
            }
          } catch(_) {}
        } else if (e.target === qs('#ontoSaveBtn')) {
          try {
            if (!activeOntologyIri) { alert('Select an ontology to save.'); return; }
            // Compute auto linked_by pairs from imports
            const pairs = await computeLinkedByPairs(activeOntologyIri);
            const ttl = toTurtle(activeOntologyIri, pairs);
            const res = await fetch(`/api/ontology/save?graph=${encodeURIComponent(activeOntologyIri)}`, { method: 'POST', headers: { 'Content-Type': 'text/turtle' }, body: ttl });
            const json = await res.json().catch(()=>({}));
            if (res.ok) alert('Saved to Fuseki'); else alert('Save failed: ' + (json.detail || res.status));
          } catch (err) { alert('Save error: ' + err.message); }
        } else if (e.target.closest && e.target.closest('#ontoLinkIdenticalBtn')) {
          // Preview: count equivalent class links that will be saved (no UI edges yet)
          try {
            if (!activeOntologyIri || !ontoState.cy) return;
            const pairs = await computeLinkedByPairs(activeOntologyIri);
            if (pairs.length) alert(`Will save ${pairs.length} owl:equivalentClass links on Save.`);
            else alert('No identical classes found');
          } catch (err) { console.error(err); alert('Link check failed'); }
        } else if (e.target === qs('#ontoExportBtn')) {
          exportOntologyJSON();
        } else if (e.target === qs('#ontoImportBtn')) {
          const inp = qs('#ontoImportFile'); if (inp) inp.click();
        } else if (e.target === qs('#ontoTreeToggle') || e.target === qs('#ontoTreeToggleIcon')) {
          const sec = qs('#wb-ontology');
          if (!sec) return;
          const collapsed = sec.classList.toggle('onto-tree-collapsed');
          const icon = qs('#ontoTreeToggleIcon');
          if (icon) {
            // Left panel: show right chevron when collapsed, left chevron when expanded
            icon.innerHTML = collapsed
              ? '<path d="M9 6l6 6-6 6"/>'
              : '<path d="M15 6l-6 6 6 6"/>';
          }
          try { localStorage.setItem('onto_tree_collapsed', collapsed ? '1' : '0'); } catch(_) {}
          requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
        } else if (e.target === qs('#ontoPropsToggle') || e.target.closest('#ontoPropsToggle')) {
          const sec = qs('#wb-ontology');
          if (!sec) return;
          const collapsed = sec.classList.toggle('onto-props-collapsed');
          const icon = qs('#ontoPropsToggleIcon');
          if (icon) {
            // Right panel: show left chevron when collapsed, right chevron when expanded
            icon.innerHTML = collapsed
              ? '<path d="M15 6l-6 6 6 6"/>'
              : '<path d="M9 6l6 6-6 6"/>';
          }
          try { localStorage.setItem('onto_props_collapsed', collapsed ? '1' : '0'); } catch(_) {}
          // Wait for reflow before resizing Cytoscape so it fits the new grid
          requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
        } else if (e.target === qs('#propSaveBtn')) {
          // Save properties
          try {
            if (!ontoState.cy) return;
            const sel = ontoState.cy.$(':selected');
            const nameEl = qs('#propName');
            const typeEl = qs('#propType');
            const attrsEl = qs('#propAttrs');
            if (sel.length === 1 && sel[0].isNode()) {
              const n = sel[0];
              n.data('label', nameEl.value.trim() || n.data('label'));
              n.data('type', typeEl.value || n.data('type'));
              const parsed = JSON.parse(attrsEl.value || '{}');
              n.data('attrs', parsed);
            } else if (sel.length === 1 && sel[0].isEdge()) {
              const ed = sel[0];
              ed.data('predicate', nameEl.value.trim() || ed.data('predicate'));
              ed.data('type', typeEl.value || ed.data('type'));
              const parsed = JSON.parse(attrsEl.value || '{}');
              ed.data('attrs', parsed);
            } else {
              localStorage.setItem('onto_model_name', nameEl.value.trim() || 'Ontology Model');
              try { localStorage.setItem('onto_model_attrs', JSON.stringify(JSON.parse(attrsEl.value || '{}'))); } catch(_) { localStorage.setItem('onto_model_attrs', '{}'); }
            }
            refreshOntologyTree();
            persistOntologyToLocalStorage();
            const st = qs('#propSaveStatus'); if (st) { st.textContent = 'Saved'; setTimeout(()=>{ const s=qs('#propSaveStatus'); if (s) s.textContent=''; }, 1000); }
          } catch (_) {
            const st = qs('#propSaveStatus'); if (st) { st.textContent = 'Error'; setTimeout(()=>{ const s=qs('#propSaveStatus'); if (s) s.textContent=''; }, 1200); }
          }
        }
      });
      // Keep Cytoscape sized correctly in fullscreen and update button title
      document.addEventListener('fullscreenchange', () => {
        const btn = qs('#ontoFullscreenBtn');
        if (btn) btn.title = document.fullscreenElement ? 'Exit fullscreen' : 'Enter fullscreen';
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      const header = qs('#ontoTreeHeader');
      if (header) header.addEventListener('dblclick', (e) => {
        const toggleBtn = qs('#ontoTreeToggle');
        if (toggleBtn) toggleBtn.click();
      });
      const propsHeader = qs('#ontoPropsHeader');
      if (propsHeader) propsHeader.addEventListener('dblclick', (e) => {
        const toggleBtn = qs('#ontoPropsToggle');
        if (toggleBtn) toggleBtn.click();
      });
      const fileInput = () => qs('#ontoImportFile');
      document.addEventListener('change', async (e) => {
        if (e.target === fileInput()) {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          try {
            const text = await file.text();
            const json = JSON.parse(text);
            importOntologyJSON(json);
          } catch (_) {
            alert('Invalid ontology JSON');
          } finally {
            e.target.value = '';
          }
        }
      });
    })();

    window.addEventListener('resize', () => { if (ontoState.cy) ontoState.cy.resize(); });

    function getSampleProject() {
      return {
        id: 'demo',
        name: 'Sample Project',
        ontology: {
          base: { id: 'BASE-ONTO', name: 'Base Ontology', versions: ['1.0', '1.1'] },
          systems: {
            base: { id: 'SYS-BASE', name: 'Systems Ontology', versions: ['0.1', '0.2'] },
            imports: [
              { id: 'GEO', name: 'Geo Ontology', versions: ['2023-09', '2024-02'] },
              { id: 'RELY', name: 'Reliability Ontology', versions: ['1.0'] },
              { id: 'ORG', name: 'Organization Ontology', versions: ['0.9'] }
            ]
          }
        },
        requirements: [
          { id: 'R-001', title: 'The system shall ingest documents and extract requirements.' },
          { id: 'R-002', title: 'The system should support ontology-based tagging of entities.' },
          { id: 'R-003', title: 'The system must store outputs in RDF, GraphDB, and Vector Store.' }
        ],
        documents: {
          requirements: [
            { id: 'RD-01', name: 'Concept of Operations.pdf' },
            { id: 'RD-02', name: 'Capabilities Development Document.docx' }
          ],
          knowledge: [
            { id: 'KD-01', name: 'Requirements Development Instructions.md' },
            { id: 'KD-02', name: 'Industry Spec MIL-STD-961E.pdf' }
          ]
        },
        artifacts: [
          { id: 'ART-01', name: 'White Paper - Initial Draft.md' },
          { id: 'ART-02', name: 'System Architecture Diagram.png' }
        ]
      };
    }

    function toggleNode(li) {
      const exp = li.getAttribute('aria-expanded');
      if (exp === null) return;
      li.setAttribute('aria-expanded', exp === 'true' ? 'false' : 'true');
    }

    function selectNode(li) {
      qsa('.node-row').forEach(r => r.classList.remove('selected'));
      const row = li.querySelector('.node-row');
      if (row) row.classList.add('selected');
    }

    function handleKey(e, li) {
      const LEFT = 37, UP = 38, RIGHT = 39, DOWN = 40, ENTER = 13, SPACE = 32;
      const exp = li.getAttribute('aria-expanded');
      switch (e.keyCode) {
        case LEFT:
          if (exp === 'true') { toggleNode(li); } else { focusParent(li); }
          e.preventDefault(); break;
        case RIGHT:
          if (exp === 'false') { toggleNode(li); } else { focusFirstChild(li); }
          e.preventDefault(); break;
        case UP:
          focusPrev(li); e.preventDefault(); break;
        case DOWN:
          focusNext(li); e.preventDefault(); break;
        case ENTER:
        case SPACE:
          selectNode(li); handleTreeSelection(li); e.preventDefault(); break;
      }
    }

    function focusParent(li) {
      const parentLi = li.parentElement.closest('li[role="treeitem"]');
      if (parentLi) (parentLi.querySelector('.node-row') || parentLi).focus();
    }
    function focusFirstChild(li) {
      const child = li.querySelector('ul[role="group"] > li[role="treeitem"] .node-row');
      if (child) child.focus();
    }
    function visibleTreeItems() {
      const acc = [];
      function addVisible(container) {
        const items = Array.from(container.children).filter(n => n.matches('li[role="treeitem"]'));
        items.forEach(li => {
          acc.push(li);
          const exp = li.getAttribute('aria-expanded');
          if (exp === 'true') {
            const group = li.querySelector('ul[role="group"]');
            if (group) addVisible(group);
          }
        });
      }
      addVisible(qs('#treeRoot'));
      return acc;
    }
    function focusPrev(li) {
      const list = visibleTreeItems();
      const idx = list.indexOf(li);
      if (idx > 0) (list[idx - 1].querySelector('.node-row') || list[idx - 1]).focus();
    }
    function focusNext(li) {
      const list = visibleTreeItems();
      const idx = list.indexOf(li);
      if (idx >= 0 && idx < list.length - 1) (list[idx + 1].querySelector('.node-row') || list[idx + 1]).focus();
    }

    // Boot
    initAuth();
    // Per-project restore happens inside renderTree; avoid global restore that can clobber state
    // Save shortcut Ctrl/Cmd+S
    document.addEventListener('keydown', async (e) => {
      const isSave = (e.key === 's' || e.key === 'S') && (e.ctrlKey || e.metaKey);
      if (!isSave) return;
      e.preventDefault();
      try {
        if (!activeOntologyIri) { alert('Select an ontology to save.'); return; }
        const ttl = toTurtle(activeOntologyIri);
        const res = await fetch(`/api/ontology/save?graph=${encodeURIComponent(activeOntologyIri)}`, { method: 'POST', headers: { 'Content-Type': 'text/turtle' }, body: ttl });
        const json = await res.json().catch(()=>({}));
        if (res.ok) alert('Saved to Fuseki'); else alert('Save failed: ' + (json.detail || res.status));
      } catch (err) { alert('Save error: ' + err.message); }
    }, false);

    // Delete selected canvas entities (nodes/edges) for current ontology only
    function performDelete() {
      if (!(qs('#wb-ontology') && qs('#wb-ontology').classList.contains('active'))) return false;
      if (!ontoState.cy) return false;
      const sel = ontoState.cy.$(':selected');
      if (!sel || sel.length === 0) return false;
      ontoState.cy.remove(sel);
      refreshOntologyTree();
      persistOntologyToLocalStorage();
      return true;
    }
    function handleDeleteKey(e) {
      const key = e.key || e.code;
      const tgt = e.target;
      const isTyping = tgt && (tgt.tagName === 'INPUT' || tgt.tagName === 'TEXTAREA' || tgt.isContentEditable);
      const inline = qs('#ontoInlineEdit');
      const inlineVisible = inline ? (getComputedStyle(inline).display !== 'none') : false;
      if (isTyping || inlineVisible) return;
      if ((key === 'Delete' || key === 'Backspace') && ontoState.cy) {
        const ok = performDelete();
        if (ok) { e.preventDefault(); e.stopPropagation(); }
      }
    }
    document.addEventListener('keydown', handleDeleteKey, false);
    window.addEventListener('keydown', handleDeleteKey, true);
    // Keyup fallback in case keydown is intercepted by browser/OS
    document.addEventListener('keyup', handleDeleteKey, false);
    // Toolbar delete
    document.addEventListener('click', (e) => {
      if (e.target === qs('#ontoDeleteBtn')) {
        performDelete();
      }
    });

    // Files workbench state + helpers
    const filesState = { initialized: false, lastFiles: [], staged: [], library: [], sortBy: 'name', sortDir: 'asc' };
    function toast(msg, isError=false) {
      const el = qs('#filesToast'); if (!el) return;
      el.textContent = msg || '';
      el.style.color = isError ? '#ef4444' : '#9aa4b2';
      if (!msg) return;
      setTimeout(()=>{ if (el.textContent === msg) el.textContent=''; }, 3000);
    }
    function renderFilesList(items) {
      const list = qs('#filesList'); if (!list) return;
      list.innerHTML = '';
      const arr = Array.isArray(items) ? items : [];
      if (!arr.length) {
        const div = document.createElement('div');
        div.className = 'muted';
        div.textContent = 'No files yet. Upload or import to begin.';
        list.appendChild(div);
        return;
      }
      const toBadge = (text) => `<span style="border:1px solid var(--border); padding:2px 6px; border-radius:6px; font-size:12px;">${text}</span>`;
      const rows = arr.map(meta => {
        const name = meta.filename || meta.name || 'file';
        const id = meta.file_id || meta.id || '';
        const tags = meta.tags || {};
        const status = tags.status || 'new';
        const size = meta.size || 0;
        const sizeStr = size ? `${size}` : '';
        const created = meta.created_at ? new Date(meta.created_at).toLocaleString() : '';
        return `<tr>
          <td style="width:32px; text-align:center;"><input type="checkbox" class="file-select" data-id="${id}" /></td>
          <td><div style="display:flex; flex-direction:column;"><span style="font-weight:600;">${name}</span><span class="muted" style="font-size:12px;">${id}</span></div></td>
          <td>${toBadge(docType)}</td>
          <td>${toBadge(status)}</td>
          <td style="text-align:right;">${sizeStr}</td>
          <td class="muted" style="font-size:12px;">${created}</td>
          <td style="text-align:right;">
            <button class="btn" data-action="process" data-id="${id}">Process</button>
            <button class="btn" data-action="url" data-id="${id}">URL</button>
            <button class="btn" data-action="delete" data-id="${id}">Delete</button>
          </td>
        </tr>`;
      }).join('');
      list.innerHTML = `
        <div style="overflow:auto;">
          <table style="width:100%; border-collapse:separate; border-spacing:0 6px;">
            <thead>
              <tr>
                <th style="width:32px;"><input type="checkbox" id="filesSelectAll" /></th>
                <th data-sort="name" style="cursor:pointer;">Name</th>
                <th data-sort="type" style="cursor:pointer;">Type</th>
                <th data-sort="status" style="cursor:pointer;">Status</th>
                <th data-sort="size" style="text-align:right; cursor:pointer;">Size</th>
                <th>Uploaded</th>
                <th style="text-align:right;">Actions</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>`;
      // Sorting handlers
      const thead = list.querySelector('thead');
      if (thead) thead.addEventListener('click', (e) => {
        const th = e.target.closest('[data-sort]'); if (!th) return;
        const key = th.getAttribute('data-sort');
        if (filesState.sortBy === key) filesState.sortDir = (filesState.sortDir === 'asc' ? 'desc' : 'asc');
        else { filesState.sortBy = key; filesState.sortDir = 'asc'; }
        // Re-sort current state
        try { renderFilesList(sortItems(filesState.library)); } catch(_) {}
      });
      const selAll = list.querySelector('#filesSelectAll');
      if (selAll) selAll.addEventListener('change', () => {
        list.querySelectorAll('.file-select').forEach(cb => { cb.checked = selAll.checked; });
      });
      // Click to select and preview
      list.querySelectorAll('tbody tr').forEach(tr => {
        tr.addEventListener('click', async (e) => {
          if (e.target.closest('button')) return;
          const cb = tr.querySelector('.file-select');
          const id = cb ? cb.getAttribute('data-id') : '';
          if (!id) return;
          cb.checked = true;
          await updateFilePreview(id);
        });
      });
      // Delegate actions
      list.onclick = async (e) => {
        const btn = e.target.closest('button[data-action]');
        if (!btn) return;
        const id = btn.getAttribute('data-id');
        const action = btn.getAttribute('data-action');
        if (!id) return;
        if (action === 'delete') {
          if (!confirm('Delete this file?')) return;
          const ok = await deleteStoredFileViaApi(id);
          if (ok) { toast('Deleted'); loadLibraryFromApi(); } else { toast('Delete failed', true); }
        } else if (action === 'url') {
          const url = await getFileUrlViaApi(id);
          if (url) { try { await navigator.clipboard.writeText(url); toast('URL copied'); } catch(_) { window.open(url, '_blank'); } }
        } else if (action === 'process') {
          const ok = await processFileViaApi(id);
          if (ok) toast('Process started'); else toast('Process failed', true);
        }
      };
      // Bulk buttons
      try {
        const bulkDelete = qs('#filesBulkDeleteBtn');
        const bulkProcess = qs('#filesBulkProcessBtn');
        const selectedIds = () => Array.from(list.querySelectorAll('.file-select:checked')).map(c => c.getAttribute('data-id'));
        if (bulkDelete) bulkDelete.onclick = async () => {
          const ids = selectedIds(); if (!ids.length) { toast('No files selected', true); return; }
          if (!confirm(`Delete ${ids.length} file(s)?`)) return;
          let ok = 0; for (const id of ids) { if (await deleteStoredFileViaApi(id)) ok++; }
          toast(`Deleted ${ok}/${ids.length}`); loadLibraryFromApi();
        };
        if (bulkProcess) bulkProcess.onclick = async () => {
          const ids = selectedIds(); if (!ids.length) { toast('No files selected', true); return; }
          let ok = 0; for (const id of ids) { if (await processFileViaApi(id)) ok++; }
          toast(`Started ${ok}/${ids.length}`);
        };
      } catch(_) {}
    }
    function renderStagedList() {
      const list = qs('#stagedList'); if (!list) return;
      list.innerHTML = '';
      if (!filesState.staged.length) {
        const div = document.createElement('div'); div.className = 'muted'; div.textContent = 'No staged files.'; list.appendChild(div); return;
      }
      filesState.staged.forEach((f, idx) => {
        const row = document.createElement('div'); row.className = 'card'; row.style.display='grid'; row.style.gridTemplateColumns='1fr auto'; row.style.alignItems='center'; row.style.padding='8px';
        const left = document.createElement('div'); left.innerHTML = `<strong>${f.name}</strong> <span class="muted">${f.size} bytes</span>`;
        const actions = document.createElement('div');
        const rem = document.createElement('button'); rem.className='btn'; rem.textContent='Remove'; rem.onclick=()=>{ filesState.staged.splice(idx,1); renderStagedList(); };
        actions.appendChild(rem);
        row.appendChild(left); row.appendChild(actions);
        list.appendChild(row);
      });
    }
    function previewSelectedFiles(fileList) {
      const el = qs('#uploadPreview'); if (!el) return;
      if (!fileList || !fileList.length) { el.textContent = ''; return; }
      const names = Array.from(fileList).map(f => `${f.name} (${f.size} bytes)`).join(', ');
      el.textContent = `Selected: ${names}`;
    }
    function ensureFilesInitialized() {
      if (filesState.initialized) return;
      filesState.initialized = true;
      const input = qs('#fileUploadInput');
      const choose = qs('#fileChooseBtn');
      const drop = qs('#fileDropZone');
      const urlInput = qs('#fileUrlInput');
      const urlBtn = qs('#fileUrlImportBtn');
      const refreshBtn = qs('#filesRefreshBtn');
      const docType = qs('#filesDocType');
      const statusSel = qs('#filesStatus');
      const tags = qs('#filesTags');
      function authHeader() {
        try { const t = localStorage.getItem('odras_token'); return t ? { Authorization: 'Bearer ' + t } : {}; } catch(_) { return {}; }
      }
      function currentProjectId() {
        try { const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : localStorage.getItem('active_project_id'); return pid || ''; } catch(_) { return ''; }
      }
      async function uploadOne(fileMeta) {
        const pid = currentProjectId(); if (!pid) { toast('Select a project first', true); return false; }
        const fd = new FormData();
        fd.append('file', fileMeta);
        fd.append('project_id', pid);
        try {
          const t = (tags && tags.value || '').trim();
          const list = t ? t.split(',').map(s=>s.trim()).filter(Boolean) : [];
          const tagObj = { docType: (docType && docType.value) || 'unknown', status: 'new' };
          if (list.length) tagObj.userTags = list;
          fd.append('tags', JSON.stringify(tagObj));
        } catch(_) {}
        try {
          const res = await fetch('/api/files/upload', { method: 'POST', headers: { ...authHeader() }, body: fd });
          const js = await res.json().catch(()=>({}));
          if (!res.ok || js.success === false) { throw new Error(js.error || 'upload failed'); }
          return true;
        } catch (err) {
          return false;
        }
      }
      async function loadLibraryFromApi() {
        const pid = currentProjectId(); if (!pid) { renderFilesList([]); return; }
        try {
          const res = await fetch(`/api/files?project_id=${encodeURIComponent(pid)}`, { headers: { ...authHeader() } });
          const js = await res.json();
          let items = js && js.files ? js.files : [];
          // Client-side filters
          const wantType = (docType && docType.value) || '';
          const wantStatus = (statusSel && statusSel.value) || '';
          const tagFilter = (tags && tags.value || '').trim().toLowerCase();
          const filtered = items.filter(m => {
            const t = m.tags || {};
            const okType = !wantType || (t.docType || 'unknown') === wantType;
            const okStatus = !wantStatus || (t.status || 'new') === wantStatus;
            const okTags = !tagFilter || JSON.stringify(t).toLowerCase().includes(tagFilter);
            return okType && okStatus && okTags;
          });
          filesState.library = filtered;
          renderFilesList(sortItems(filtered));
        } catch(_) { renderFilesList([]); }
      }
      function sortItems(items) {
        const arr = Array.from(items || []);
        const dir = filesState.sortDir === 'desc' ? -1 : 1;
        const key = filesState.sortBy || 'name';
        const get = (m) => {
          const tags = m.tags || {};
          if (key === 'name') return (m.filename || '').toLowerCase();
          if (key === 'type') return (tags.docType || '').toLowerCase();
          if (key === 'status') return (tags.status || '').toLowerCase();
          if (key === 'size') return Number(m.size || 0);
          return (m.filename || '').toLowerCase();
        };
        arr.sort((a,b)=>{ const av=get(a), bv=get(b); if (av<bv) return -1*dir; if (av>bv) return 1*dir; return 0; });
        return arr;
      }
      if (input) {
        input.addEventListener('change', (e) => {
          const files = e.target.files;
          previewSelectedFiles(files);
          filesState.lastFiles = Array.from(files || []);
          filesState.staged.push(...filesState.lastFiles);
          renderStagedList();
          const n = filesState.lastFiles.length; if (n) toast(`${n} file(s) staged. Click Upload All to upload.`);
        });
      }
      if (choose && input) {
        choose.addEventListener('click', ()=> input.click());
      }
      if (drop) {
        ;['dragenter','dragover'].forEach(ev => drop.addEventListener(ev, (e)=>{ e.preventDefault(); drop.style.background = '#0f1628'; }));
        ;['dragleave','drop'].forEach(ev => drop.addEventListener(ev, (e)=>{ e.preventDefault(); drop.style.background = 'transparent'; }));
        drop.addEventListener('drop', (e) => {
          const dt = e.dataTransfer; const files = dt && dt.files ? dt.files : [];
          previewSelectedFiles(files);
          filesState.lastFiles = Array.from(files || []);
          filesState.staged.push(...filesState.lastFiles);
          renderStagedList();
          const n = filesState.lastFiles.length; if (n) toast(`${n} file(s) staged. Click Upload All to upload.`);
        });
        drop.addEventListener('click', ()=>{ if (input) input.click(); });
        drop.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); if (input) input.click(); } });
      }
      if (urlBtn && urlInput) {
        urlBtn.addEventListener('click', () => {
          const u = (urlInput.value || '').trim();
          const el = qs('#uploadPreview');
          if (!u) { toast('Please enter a URL', true); if (el) el.textContent=''; return; }
          try { new URL(u); } catch(_) { toast('Invalid URL', true); return; }
          if (el) el.textContent = `URL ready: ${u}`;
          toast('URL staged for import');
        });
      }
      const uploadAll = qs('#filesUploadAllBtn');
      const clearStaged = qs('#filesClearStagedBtn');
      if (clearStaged) clearStaged.addEventListener('click', ()=>{ filesState.staged = []; renderStagedList(); previewSelectedFiles([]); });
      if (uploadAll) uploadAll.addEventListener('click', async ()=>{
        if (!filesState.staged.length) { toast('Nothing to upload', true); return; }
        const total = filesState.staged.length; let ok = 0;
        for (const f of filesState.staged) { const res = await uploadOne(f); if (res) ok++; }
        toast(`Uploaded ${ok}/${total}`);
        filesState.staged = []; renderStagedList(); previewSelectedFiles([]);
        loadLibraryFromApi();
      });
      const triggerRefresh = () => {
        loadLibraryFromApi();
      };
      if (refreshBtn) refreshBtn.addEventListener('click', triggerRefresh);
      if (docType) docType.addEventListener('change', triggerRefresh);
      if (statusSel) statusSel.addEventListener('change', triggerRefresh);
      if (tags) tags.addEventListener('keyup', (e)=>{ if (e.key === 'Enter') triggerRefresh(); });
      // Initial empty list
      loadLibraryFromApi();
      renderStagedList();
    }
    async function deleteStoredFileViaApi(fileId) {
      try { const res = await fetch(`/api/files/${encodeURIComponent(fileId)}`, { method: 'DELETE' }); return res.ok; } catch(_) { return false; }
    }
    async function getFileUrlViaApi(fileId) {
      try { const res = await fetch(`/api/files/${encodeURIComponent(fileId)}/url`); const js = await res.json(); return (js && js.url) ? js.url : (js && js.success && js.file_id ? js.url : null); } catch(_) { return null; }
    }
    async function processFileViaApi(fileId) {
      try { const fd = new FormData(); const res = await fetch(`/api/files/${encodeURIComponent(fileId)}/process`, { method: 'POST', body: fd }); return res.ok; } catch(_) { return false; }
    }
    async function updateFilePreview(fileId) {
      try {
        const url = await getFileUrlViaApi(fileId);
        const pane = qs('#filePreviewContent'); if (!pane) return;
        const metaPane = qs('#fileMetaContent');
        if (!url) { pane.textContent = 'Preview unavailable.'; if (metaPane) metaPane.textContent=''; return; }
        // Derive extension
        const ext = (function(){ try { const u=new URL(url); const p=u.pathname.toLowerCase(); const m=p.match(/\.([a-z0-9]+)$/); return m?m[1]:''; } catch(_) { return ''; } })();
        // Try HEAD for content-type
        let contentType = '';
        try { const head = await fetch(url, { method: 'HEAD' }); contentType = head.headers.get('Content-Type') || ''; } catch(_) {}
        // Render minimal metadata
        try {
          if (metaPane) metaPane.innerHTML = `<div style="display:grid; gap:4px;">
            <div><strong>File ID:</strong> ${fileId}</div>
            <div><strong>URL:</strong> <a href="${url}" target="_blank">Open</a></div>
            <div><strong>Type:</strong> ${contentType || ext || 'unknown'}</div>
          </div>`;
        } catch(_) {}
        // PDF inline
        if (ext === 'pdf' || (contentType && contentType.includes('pdf'))) {
          pane.innerHTML = `<embed src="${url}" type="application/pdf" style="width:100%; height:60vh;" />`;
          return;
        }
        // Image inline
        if (['png','jpg','jpeg','gif','webp','bmp','svg'].includes(ext) || (contentType && contentType.startsWith('image/'))) {
          pane.innerHTML = `<img src="${url}" alt="preview" style="max-width:100%; height:auto;" />`;
          return;
        }
        // CSV table (first ~40 rows)
        if (ext === 'csv' || (contentType && contentType.includes('csv'))) {
          const res = await fetch(url);
          if (!res.ok) { pane.textContent = 'Preview unavailable.'; return; }
          const text = await res.text();
          const lines = text.split(/\r?\n/).slice(0, 40);
          const cells = lines.map(l => l.split(',').map(x => x.replace(/&/g,'&amp;').replace(/</g,'&lt;')));
          const header = cells.shift() || [];
          const rows = cells.map(row => `<tr>${row.map(c=>`<td>${c}</td>`).join('')}</tr>`).join('');
          pane.innerHTML = `<div style="overflow:auto;"><table style="width:100%; border-collapse:collapse;"><thead><tr>${header.map(h=>`<th style=\"text-align:left; border-bottom:1px solid var(--border);\">${h}</th>`).join('')}</tr></thead><tbody>${rows}</tbody></table></div>`;
          return;
        }
        // Markdown quick render
        if (['md','markdown'].includes(ext) || (contentType && contentType.includes('markdown'))) {
          const res = await fetch(url);
          if (!res.ok) { pane.textContent = 'Preview unavailable.'; return; }
          const text = await res.text();
          const html = renderBasicMarkdown(text.slice(0, 100000));
          pane.innerHTML = html;
          return;
        }
        // Fallback text preview
        const res = await fetch(url, { method: 'GET' });
        if (!res.ok) { pane.textContent = 'Preview unavailable.'; return; }
        const buf = await res.arrayBuffer();
        const bytes = new Uint8Array(buf).slice(0, 100000);
        let text = '';
        try { text = new TextDecoder('utf-8', { fatal: false }).decode(bytes); } catch(_) { text = ''; }
        const safe = (s)=>String(s||'').replace(/[&<>]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;' }[c]));
        pane.innerHTML = text ? `<pre style="white-space:pre-wrap;">${safe(text)}</pre>` : 'Binary or unsupported preview. Use URL to download.';
      } catch(_) {
        const pane = qs('#filePreviewContent'); if (pane) pane.textContent = 'Preview error.';
      }
    }
    function renderBasicMarkdown(src) {
      const esc = (s)=>String(s||'').replace(/[&<>]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;' }[c]));
      let s = esc(src);
      s = s.replace(/^######\s+(.*)$/gm, '<h6>$1</h6>')
           .replace(/^#####\s+(.*)$/gm, '<h5>$1</h5>')
           .replace(/^####\s+(.*)$/gm, '<h4>$1</h4>')
           .replace(/^###\s+(.*)$/gm, '<h3>$1</h3>')
           .replace(/^##\s+(.*)$/gm, '<h2>$1</h2>')
           .replace(/^#\s+(.*)$/gm, '<h1>$1</h1>')
           .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
           .replace(/\*(.+?)\*/g, '<em>$1</em>')
           .replace(/`([^`]+)`/g, '<code>$1</code>')
           .replace(/\n\n/g, '<br/><br/>');
      return `<div>${s}</div>`;
    }
    // Ensure file handlers are bound even if Files workbench is the initial active view
    try { setTimeout(() => { try { ensureFilesInitialized(); } catch(_) {} }, 0); } catch(_) {}
  </script>
</body>
</html>


