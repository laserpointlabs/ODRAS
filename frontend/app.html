<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ODRAS — UI Restart</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #0b1220;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #60a5fa;
      --border: #1f2937;
      --warn: #f59e0b;
      --ok: #10b981;
      --err: #ef4444;
      --iconbar-w: 56px;
      --tree-w: 320px;
      --tree-w-min: 220px;
      --tree-w-max: 520px;
      --onto-iconbar-w: 56px;
      --onto-tree-w: 300px;
      --onto-tree-w-min: 180px;
      --onto-tree-w-max: 520px;
      --onto-tree-collapsed-w: 40px;
      --onto-props-w: 300px;
      --onto-props-w-min: 200px;
      --onto-props-w-max: 520px;
      --onto-props-collapsed-w: 40px;
      --toolbar-h: 48px;
      --bottombar-h: 32px;
      /* DAS (Digital Assistant Service) */
      --das-w: 420px;
      --das-h: 40vh;
      --das-toolbar-h: 40px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, sans-serif; }
    .layout {
      display: grid;
      grid-template-rows: var(--toolbar-h) 1fr var(--bottombar-h);
      height: 100vh;
    }
    .topbar, .bottombar {
      display: flex; align-items: center; gap: 12px; padding: 0 12px;
      background: var(--panel); border-bottom: 1px solid var(--border);
    }
    .bottombar { border-top: 1px solid var(--border); border-bottom: none; color: var(--muted); gap: 16px; }
    .brand { font-weight: 600; letter-spacing: .5px; }
    .spacer { flex: 1; }
    
    /* Installation Info Styling */
    .installation-info {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--muted);
      font-size: 12px;
    }
    .install-org {
      font-weight: 500;
      color: var(--text);
    }
    .install-type {
      background: var(--panel-2);
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid var(--border);
      text-transform: uppercase;
      font-size: 10px;
      font-weight: 500;
    }
    .install-office {
      color: var(--muted);
      font-style: italic;
    }
    .btn, select {
      background: #0b1220; color: var(--text); border: 1px solid var(--border);
      padding: 6px 10px; border-radius: 6px; cursor: pointer;
    }
    .btn:hover {
      background: var(--panel); border-color: var(--accent);
    }
    #previewFullscreenBtn:hover, #previewPopoutBtn:hover {
      background: var(--accent); color: white; border-color: var(--accent);
    }
    #fileDropZone:hover {
      background: rgba(15, 22, 40, 0.5) !important;
      border-color: #6b7280 !important;
    }
    select { padding: 6px; }
    .content {
      display: grid; grid-template-columns: var(--iconbar-w) var(--tree-w) 6px 1fr; height: 100%;
    }
    .iconbar {
      background: var(--panel); border-right: 1px solid var(--border);
      display: flex; flex-direction: column; align-items: center; padding: 8px 6px; gap: 8px;
    }
    .icon {
      width: 40px; height: 40px; border-radius: 8px; border: 1px solid var(--border);
      background: var(--panel-2); display: grid; place-items: center; color: var(--muted);
      cursor: pointer;
    }
    .icon svg { width: 22px; height: 22px; stroke: currentColor; }
    .icon.active { color: var(--accent); border-color: var(--accent); }
    .tree {
      border-right: 1px solid var(--border); background: var(--panel-2);
      display: grid; grid-template-rows: auto 1fr; min-width: var(--tree-w-min); max-width: var(--tree-w-max);
      width: var(--tree-w);
    }
    .tree-header { padding: 10px; border-bottom: 1px solid var(--border); display: flex; gap: 8px; align-items: center; }
    .tree-scroll { overflow: auto; padding: 8px; }
    /* CAD-like tree view */
    .treeview [role="tree"] { list-style: none; margin: 0; padding: 4px; }
    .treeview [role="group"] { list-style: none; margin: 0; padding-left: 16px; border-left: 1px dashed var(--border); }
    .treeview li[role="treeitem"] { margin: 2px 0; outline: none; }
    .treeview li[role="treeitem"][aria-expanded="false"] > ul[role="group"] { display: none; }
    .node-row { display: flex; align-items: center; gap: 6px; padding: 4px 6px; border: 1px solid transparent; border-radius: 6px; cursor: default; }
    .node-row:hover { background: #0d1426; border-color: var(--border); }
    .node-row.selected { background: #0f1a33; border-color: var(--accent); }
    .twist { width: 12px; text-align: center; color: var(--muted); user-select: none; }
    li[role="treeitem"][aria-expanded="false"] > .node-row .twist::before { content: '▸'; }
    li[role="treeitem"][aria-expanded="true"] > .node-row .twist::before { content: '▾'; }
    li[role="treeitem"]:not([aria-expanded]) > .node-row .twist::before { content: '•'; opacity: .25; }
    .node-icon { width: 14px; height: 14px; border: 1px solid var(--border); border-radius: 3px; background: #0a1120; }
    .node-icon.folder { background: linear-gradient(180deg, #0f1a33, #0c1529); }
    .node-icon.req { background: #1b2a45; }
    .node-icon.doc { background: #1b2a45; border-style: dashed; }
    .node-icon.out { background: #1b2a45; border-color: #2a3b5f; }
    .node-icon.docreq { background: #263b61; border-color: #3b5a8f; }
    .node-icon.docknow { background: #2a3f5f; border-color: #4a6a9a; }
    .node-icon.onto { background: #22304f; border-color: #39507a; }
    .node-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .resizer {
      width: 6px; cursor: col-resize; background: transparent; position: relative;
    }
    .resizer::after { content: ""; position: absolute; inset: 0; }
    .main {
      padding: 8px 8px 0 8px; 
      overflow: hidden; 
      height: calc(100vh - var(--toolbar-h) - var(--bottombar-h)); 
      display: flex; 
      flex-direction: column;
    }
    .workbench { display: none; }
    .workbench.active { display: flex; flex-direction: column; flex: 1; min-height: 0; }
    .workbench.active .onto-layout { flex: 1; min-height: 0; }
    
    /* Admin workbench specific styling for scrollable content */
    #wb-admin.workbench.active {
      overflow-y: auto;
      padding: 16px;
      padding-bottom: 32px; /* Extra bottom padding to ensure last section is fully visible */
    }
    
    /* Files workbench specific styling for scrollable content */
    #wb-files.workbench.active {
      overflow-y: auto;
      padding: 16px;
      padding-bottom: 32px; /* Extra bottom padding to ensure upload area is accessible */
    }
    .status-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }
    .ok { background: var(--ok); } .warn { background: var(--warn); } .err { background: var(--err); }
    .muted { color: var(--muted); }
    
    /* Collapsible sections */
    .section { margin-bottom: 16px; }
    .section-header { 
      width: 100%; 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      padding: 12px 16px; 
      background: var(--panel-2); 
      border: 1px solid var(--border); 
      border-radius: 8px; 
      cursor: pointer; 
      font-weight: 600; 
      color: var(--text);
      transition: background-color 0.2s ease;
    }
    .section-header:hover { background: var(--panel); }
    .section-toggle { 
      transition: transform 0.2s ease; 
      font-size: 0.8em; 
      color: var(--muted); 
    }
    .section.collapsed .section-toggle { transform: rotate(-90deg); }
    .section-content { 
      padding: 16px; 
      border: 1px solid var(--border); 
      border-top: none; 
      border-radius: 0 0 8px 8px; 
      background: var(--panel); 
    }
    .section.collapsed .section-content { display: none; }
    /* Ontology Workbench Header */
    .ontology-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-bottom: 8px;
      flex: 0 0 auto;
    }
    
    .header-left {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .workbench-title {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }
    
    .graph-label {
      color: var(--muted);
      font-size: 13px;
      font-weight: 500;
      max-width: 400px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* Menu Bar */
    .header-menu {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .menu-group {
      position: relative;
    }
    
    .menu-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .menu-btn:hover {
      background: var(--panel-2);
      border-color: var(--accent);
    }
    
    .menu-btn .menu-icon {
      width: 16px;
      height: 16px;
      stroke: currentColor;
    }
    
    .menu-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      min-width: 200px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,.4);
      padding: 8px 0;
      z-index: 1000;
      display: none;
    }
    
    .menu-group:hover .menu-dropdown {
      display: block;
    }
    
    .menu-label {
      padding: 8px 12px 4px 12px;
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .menu-select {
      width: calc(100% - 24px);
      margin: 0 12px 8px 12px;
      padding: 6px 8px;
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 12px;
    }
    
    .menu-item {
      width: 100%;
      padding: 8px 12px;
      background: transparent;
      color: var(--text);
      border: none;
      text-align: left;
      font-size: 13px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    
    .menu-item:hover {
      background: var(--panel);
    }
    #cy { width: 100%; min-width: 0; height: 100%; border: 1px solid var(--border); border-radius: 8px; background: #0a0f1f; }
    .onto-layout { display: grid; grid-template-columns: var(--onto-tree-w) var(--onto-tree-divider-w, 4px) var(--onto-iconbar-w) minmax(0, 1fr) var(--onto-props-divider-w, 4px) var(--onto-props-w); grid-template-rows: 1fr; gap: 0; align-items: stretch; overflow: hidden; width: 100%; flex: 1 1 auto; min-height: 0; }
    /* Inline editor for canvas labels */
    #ontoInlineEdit { position: fixed; z-index: 9999; display: none; background: #0b1220; color: #e5e7eb; border: 1px solid var(--accent); border-radius: 6px; padding: 4px 6px; font: inherit; }
    /* Fullscreen adjustments */
    #wb-ontology:fullscreen #cy { height: calc(100vh - 140px); }
    /* Context menu */
    .onto-menu { 
      position: fixed; 
      z-index: 9999; 
      display: none; 
      min-width: 180px; 
      background: var(--panel-2); 
      color: var(--text); 
      border: 1px solid var(--border); 
      border-radius: 8px; 
      box-shadow: 0 8px 24px rgba(0,0,0,.4);
      padding: 4px 0;
    }
    
    .menu-section {
      padding: 4px 0;
    }
    
    .menu-item {
      width: 100%;
      background: transparent;
      color: var(--text);
      border: none;
      text-align: left;
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      transition: background-color 0.2s ease;
    }
    
    .menu-item:hover {
      background: var(--panel);
    }
    
    .menu-item-secondary {
      color: var(--muted);
    }
    
    .menu-item-secondary:hover {
      color: var(--text);
    }
    
    .menu-icon {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      flex-shrink: 0;
    }
    
    .menu-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }
    
    /* IRI Display */
    .iri-display {
      margin-top: 6px;
      margin-bottom: 8px;
      padding: 4px 8px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 4px;
      height: 28px;
      flex: 0 0 auto;
      overflow: hidden;
    }
    
    .iri-content {
      display: flex;
      align-items: center;
      gap: 6px;
      height: 100%;
    }
    
    .iri-label {
      font-size: 0.8em;
      font-weight: 500;
      color: var(--muted);
      white-space: nowrap;
    }
    
    .iri-value {
      font-family: 'Courier New', monospace;
      font-size: 0.75em;
      color: #60a5fa;
      word-break: break-all;
      flex: 1;
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .iri-copy-btn {
      padding: 2px 6px;
      font-size: 0.7em;
      display: none;
      flex-shrink: 0;
    }
    
    /* Empty state */
    .onto-empty-state {
      margin-top: 10px;
      display: none;
      text-align: center;
      padding: 20px;
      color: var(--muted);
    }
    .connect-source { outline: 2px dashed var(--accent); outline-offset: 2px; }
    /* Pin children to explicit grid columns so hiding resizers doesn't shift layout */
    .onto-layout > .onto-tree { grid-column: 1; }
    .onto-layout > #ontoResizer { grid-column: 2; }
    .onto-layout > .onto-iconbar { grid-column: 3; }
    .onto-layout > #cy { grid-column: 4; }
    .onto-layout > #ontoPropsResizer { grid-column: 5; }
    .onto-layout > .onto-props { grid-column: 6; }
    .onto-iconbar { background: var(--panel); border: 1px solid var(--border); border-radius: 6px; padding: 6px 4px; display: flex; flex-direction: column; align-items: center; gap: 6px; height: 100%; overflow: auto; }
    .onto-icon { width: 40px; height: 40px; border-radius: 8px; border: 1px solid var(--border); background: var(--panel-2); display: grid; place-items: center; color: var(--muted); cursor: grab; }
    .onto-icon svg { width: 22px; height: 22px; stroke: currentColor; }
    .onto-tree { border: 1px solid var(--border); background: var(--panel-2); border-radius: 8px; display: grid; grid-template-rows: auto minmax(0, 1fr); min-width: 0; height: 100%; overflow: hidden; min-height: 0; }
    .onto-tree-header { 
      padding: 6px; 
      border-bottom: 1px solid var(--border); 
      display: flex; 
      gap: 6px; 
      align-items: center; 
      justify-content: space-between;
      position: sticky; 
      top: 0; 
      z-index: 1; 
      background: var(--panel-2); 
    }
    .onto-tree-controls { display: flex; gap: 4px; align-items: center; }
    .class-visibility-toggle {
      background: none;
      border: none;
      color: var(--muted);
      cursor: pointer;
      padding: 2px 4px;
      margin-left: 4px;
      border-radius: 3px;
      font-size: 12px;
      transition: opacity 0.2s ease;
    }
    .class-visibility-toggle:hover {
      background: var(--border);
      color: var(--text);
    }
    
    /* Pseudo-import node styling */
    .pseudo-import {
      background-color: #e3f2fd !important;
      border: 2px solid #2196f3 !important;
      border-style: dashed !important;
      font-style: italic !important;
    }
    
    .pseudo-equivalence {
      stroke: #2196f3 !important;
      stroke-dasharray: 5,5 !important;
      stroke-width: 2px !important;
    }
    .onto-tree-scroll { overflow: auto; padding: 6px; height: 100%; min-height: 0; }
    .onto-treeview [role="tree"] { list-style: none; margin: 0; padding: 4px; }
    .onto-treeview [role="group"] { list-style: none; margin: 0; padding-left: 16px; border-left: 1px dashed var(--border); }
    .onto-treeview li[role="treeitem"] { margin: 2px 0; outline: none; }
    .onto-treeview li[role="treeitem"][aria-expanded="false"] > ul[role="group"] { display: none; }
    .onto-node-row { display: flex; align-items: center; gap: 6px; padding: 4px 6px; border: 1px solid transparent; border-radius: 6px; cursor: pointer; }
    .onto-node-row:hover { background: #0d1426; border-color: var(--border); }
    .onto-node-row.selected { background: #0f1a33; border-color: var(--accent); }
    .onto-twist { width: 12px; text-align: center; color: var(--muted); user-select: none; }
    li[role="treeitem"][aria-expanded="false"] > .onto-node-row .onto-twist::before { content: '▸'; }
    li[role="treeitem"][aria-expanded="true"] > .onto-node-row .onto-twist::before { content: '▾'; }
    li[role="treeitem"]:not([aria-expanded]) > .onto-node-row .onto-twist::before { content: '•'; opacity: .25; }
    .onto-node-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .onto-resizer { width: 6px; cursor: col-resize; background: transparent; position: relative; }
    .onto-resizer::after { content: ""; position: absolute; inset: 0; }
    /* Collapsed tree mode */
    #wb-ontology.onto-tree-collapsed .onto-tree { overflow: hidden; }
    #wb-ontology.onto-tree-collapsed .onto-tree-header .muted { display: none; }
    #wb-ontology.onto-tree-collapsed .onto-tree-scroll { display: none; }
    /* Keep the collapse chevron visible and prevent overlap */
    #wb-ontology.onto-tree-collapsed .onto-tree { z-index: 2; }
    .onto-iconbar { z-index: 1; }
    #wb-ontology.onto-tree-collapsed #ontoResizer { display: none; }
    /* Collapse behavior: shrink tree width to rail without affecting tools/canvas/props */
    #wb-ontology.onto-tree-collapsed { --onto-tree-w: var(--onto-tree-collapsed-w); --onto-tree-divider-w: 0px; }
    .iconbtn { background: #0b1220; color: var(--text); border: 1px solid var(--border); width: 28px; height: 28px; border-radius: 8px; display: grid; place-items: center; cursor: pointer; }
    .iconbtn svg { width: 16px; height: 16px; stroke: currentColor; transition: transform 160ms ease; }
    /* Left panel chevron: right when collapsed, left when expanded */
    #wb-ontology.onto-tree-collapsed #ontoTreeToggleIcon { transform: rotate(0deg); }
    #wb-ontology:not(.onto-tree-collapsed) #ontoTreeToggleIcon { transform: rotate(180deg); }
    #wb-ontology.onto-tree-collapsed .onto-tree-header { padding: 4px !important; justify-content: center !important; }

    /* Properties panel */
    .onto-props { border: 1px solid var(--border); background: var(--panel-2); border-radius: 8px; display: grid; grid-template-rows: auto minmax(0, 1fr); min-width: 0; height: 100%; overflow: hidden; min-height: 0; }
    .onto-props-header { 
      padding: 6px; 
      border-bottom: 1px solid var(--border); 
      display: flex; 
      gap: 6px; 
      align-items: center; 
      justify-content: space-between;
      position: sticky; 
      top: 0; 
      z-index: 1; 
      background: var(--panel-2); 
    }
    
    /* Properties form styling */
    .props-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
    }
    
    .props-section {
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      background: var(--panel);
    }
    
    .props-section-title {
      margin: 0 0 12px 0;
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
    }
    
    .props-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    
    .props-section-actions {
      display: flex;
      gap: 4px;
    }
    
    .form-group {
      margin-bottom: 12px;
    }
    
    .form-group:last-child {
      margin-bottom: 0;
    }
    
    .form-label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
      font-weight: 500;
      color: var(--muted);
    }
    
    .form-input,
    .form-select {
      width: 100%;
      padding: 8px 10px;
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 13px;
      transition: border-color 0.2s ease;
    }
    
    .form-text-display {
      width: 100%;
      padding: 8px 10px;
      background: var(--panel-2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 13px;
      min-height: 20px;
      display: flex;
      align-items: center;
    }
    
    .form-input:focus,
    .form-select:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .attrs-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .props-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }
    
    .save-status {
      font-size: 12px;
      color: var(--muted);
    }
    
    .onto-props-scroll { overflow: auto; padding: 6px; height: 100%; min-height: 0; }
    #wb-ontology.onto-props-collapsed .onto-props-header .muted { display: none; }
    #wb-ontology.onto-props-collapsed .onto-props-header { padding: 4px !important; justify-content: center !important; }
    #wb-ontology.onto-props-collapsed .onto-props-scroll { display: none; }
    #wb-ontology.onto-props-collapsed #ontoPropsResizer { display: none; }
    #wb-ontology.onto-props-collapsed { --onto-props-w: var(--onto-props-collapsed-w); --onto-props-divider-w: 0px; }
    #wb-ontology.onto-props-collapsed .onto-props { width: var(--onto-props-collapsed-w); min-width: var(--onto-props-collapsed-w); max-width: var(--onto-props-collapsed-w); }
    /* Right panel chevron: left when collapsed, right when expanded */
    #wb-ontology.onto-props-collapsed #ontoPropsToggleIcon { transform: rotate(0deg); }
    #wb-ontology:not(.onto-props-collapsed) #ontoPropsToggleIcon { transform: rotate(180deg); }
    
    .login {
      display: grid; place-items: center; height: calc(100vh - var(--toolbar-h) - var(--bottombar-h));
    }
    /* Keep login card narrow without constraining other cards */
    #authView .card { width: 360px; }
    .card { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 16px; }
    .row { display: grid; gap: 6px; margin-bottom: 10px; }
    input[type="text"], input[type="password"] {
      background: #0b1220; color: var(--text); border: 1px solid var(--border); padding: 8px; border-radius: 6px;
    }
    /* DAS dock styles */
    .das-panel {
      position: fixed;
      z-index: 9000;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      display: none;
      color: var(--text);
    }
    .das-panel.active { display: grid; grid-template-rows: var(--das-toolbar-h) 1fr; }
    .das-toolbar {
      height: var(--das-toolbar-h);
      display: flex; gap: 8px; align-items: center;
      padding: 6px 10px;
      border-bottom: 1px solid var(--border);
      background: var(--panel-2);
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
    }
    .das-body { padding: 8px; overflow: auto; }
    .das-dock-right { right: 8px; top: 0; bottom: 0; width: var(--das-w); }
    .das-dock-left { left: 8px; top: 0; bottom: 0; width: var(--das-w); }
    .das-dock-bottom { left: 8px; right: 8px; bottom: 8px; height: var(--das-h); }
    .das-resizer-x { position: absolute; top: 0; bottom: 0; width: 6px; cursor: col-resize; }
    .das-resizer-y { position: absolute; left: 0; right: 0; height: 6px; cursor: row-resize; }
    .das-dock-right .das-resizer-x { left: -3px; }
    .das-dock-left .das-resizer-x { right: -3px; }
    .das-dock-bottom .das-resizer-y { top: -3px; }
    .das-toolbar .spacer { flex: 1; }
    .das-help { font-size: 12px; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60%; }
    /* When DAS is open, shift the app layout to avoid overlap */
    body.das-open-right #app { margin-right: calc(var(--das-w) + 16px); }
    body.das-open-left #app { margin-left: calc(var(--das-w) + 16px); }
    body.das-open-bottom #app { padding-bottom: calc(var(--das-h) + 16px); }
    
    /* Modal styling */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }
    
    .modal > div {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    
    .modal h3 {
      margin: 0 0 20px 0;
      color: var(--text);
      font-size: 1.25rem;
      font-weight: 600;
    }
    
    .modal label {
      display: block;
      margin-bottom: 4px;
      font-weight: 500;
      color: var(--text);
    }
    
    .modal input,
    .modal select,
    .modal textarea {
      width: 100%;
      padding: 8px 12px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 14px;
    }
    
    .modal input:focus,
    .modal select:focus,
    .modal textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.1);
    }
    
    .modal textarea {
      resize: vertical;
      min-height: 80px;
    }
    
    .modal > div {
      position: relative;
    }
    
    .modal .button-group {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    
    .modal .button-group .btn {
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 500;
      min-width: 100px;
      border-radius: 6px;
      transition: all 0.2s ease;
    }
    
    .modal .button-group .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    /* Modal content structure */
    .modal-content {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      max-width: 600px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 24px 16px 24px;
      border-bottom: 1px solid var(--border);
    }
    
    .modal-header h3 {
      margin: 0;
      color: var(--text);
      font-size: 1.25rem;
      font-weight: 600;
    }
    
    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--muted);
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    
    .modal-close:hover {
      color: var(--text);
      background: var(--panel-2);
    }
    
    .modal-body {
      padding: 20px 24px;
    }
    
    .modal-footer {
      padding: 16px 24px 20px 24px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    
    .modal-footer .btn {
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 500;
      min-width: 100px;
      border-radius: 6px;
    }
  </style>
  <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/cytoscape-edgehandles@4.0.1/cytoscape-edgehandles.min.js"></script>
  </head>
  <body>
  <div id="app" class="layout">
    <div class="topbar">
      <div class="brand">AVIAN-ODRAS</div>
      <div class="spacer"></div>
      
      <!-- Installation Configuration Display -->
      <div id="installationInfo" class="installation-info">
        <div id="installOrg" class="install-org"></div>
        <div id="installType" class="install-type"></div>
        <div id="installOffice" class="install-office"></div>
      </div>
      
      <div class="spacer"></div>
      <div id="userMenu" class="muted"></div>
      <button class="btn" id="logoutBtn">Logout</button>
    </div>

    <div id="authView" class="login" style="display:none;">
      <div class="card">
        <h3 style="margin:0 0 8px 0;">Sign in</h3>
        <div class="row"><label>Username</label><input id="u" type="text" /></div>
        <div class="row"><label>Password</label><input id="p" type="password" /></div>
        <button class="btn" id="loginBtn">Login</button>
        <div id="loginMsg" class="muted" style="margin-top:8px;"></div>
      </div>
    </div>

    <div id="mainView" class="content" style="display:none;">
      <nav class="iconbar" aria-label="Workbench">
        <div class="icon" data-wb="project" title="Project Info" aria-label="Project Information">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14,2 14,8 20,8"/>
            <line x1="16" y1="13" x2="8" y2="13"/>
            <line x1="16" y1="17" x2="8" y2="17"/>
            <polyline points="10,9 9,9 8,9"/>
          </svg>
        </div>
        <div class="icon active" data-wb="ontology" title="Ontology" aria-label="Ontology">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="6" cy="6" r="2"/>
            <circle cx="18" cy="6" r="2"/>
            <circle cx="6" cy="18" r="2"/>
            <circle cx="18" cy="18" r="2"/>
            <path d="M8 6h8M6 8v8M18 8v8M8 18h8"/>
          </svg>
        </div>
        <div class="icon" data-wb="files" title="Files" aria-label="Files">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 7h5l2 2h11v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z"/>
          </svg>
        </div>
        <div class="icon" data-wb="knowledge" title="Knowledge Management" aria-label="Knowledge Management">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"/>
            <path d="M12 1v6"/>
            <path d="M12 17v6"/>
            <path d="m4.2 4.2 4.2 4.2"/>
            <path d="m15.6 15.6 4.2 4.2"/>
            <path d="M1 12h6"/>
            <path d="M17 12h6"/>
            <path d="m4.2 19.8 4.2-4.2"/>
            <path d="m15.6 8.4 4.2-4.2"/>
          </svg>
        </div>
        <div class="icon" data-wb="requirements" title="Requirements" aria-label="Requirements">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 7h11M9 12h11M9 17h11"/>
            <path d="M4 7l1 1 2-2M4 12l1 1 2-2M4 17l1 1 2-2"/>
          </svg>
        </div>
        <div class="icon" data-wb="graph" title="GraphDB" aria-label="GraphDB">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <ellipse cx="12" cy="5" rx="8" ry="3"/>
            <path d="M4 5v10c0 1.7 3.6 3 8 3s8-1.3 8-3V5"/>
            <path d="M4 12c0 1.7 3.6 3 8 3s8-1.3 8-3"/>
          </svg>
        </div>
        <div class="icon" data-wb="rag" title="RAG" aria-label="RAG">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="6"/>
            <path d="M20 20l-4-4"/>
          </svg>
        </div>
        <div class="icon" data-wb="process" title="Process" aria-label="Process">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <rect x="4" y="4" width="8" height="6" rx="1"/>
            <rect x="12" y="14" width="8" height="6" rx="1"/>
            <path d="M8 10v4M8 14h8M16 14v-4"/>
          </svg>
        </div>
        <div class="icon" data-wb="thread" title="Thread" aria-label="Thread">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <rect x="4" y="4" width="16" height="12" rx="2"/>
            <path d="M8 16l-4 4v-4"/>
            <path d="M8 8h8M8 12h6"/>
          </svg>
        </div>
        <div class="icon" data-wb="playground" title="Playground" aria-label="Playground">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 3h6"/>
            <path d="M10 3v4l-5 9a3 3 0 0 0 3 5h8a3 3 0 0 0 3-5l-5-9V3"/>
            <path d="M8 15h8"/>
          </svg>
        </div>
        <div class="icon" data-wb="admin" title="Admin" aria-label="Admin">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 3l8 4v6c0 5-5 8-8 8s-8-3-8-8V7l8-4z"/>
          </svg>
        </div>
      </nav>

      <aside class="tree" id="treePanel" aria-label="Project Tree">
        <div class="tree-header">
          <select id="projectSelect2" title="Active project"></select>
          <button class="btn" id="addNodeBtn" title="New Project">＋</button>
        </div>
        <div class="tree-scroll">
          <nav class="treeview" aria-label="Project">
            <ul role="tree" id="treeRoot" aria-label="Project tree"></ul>
          </nav>
        </div>
      </aside>
      <!-- Project context menu -->
      <div id="projectContextMenu" style="position:absolute; display:none; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding:4px; z-index: 9999; min-width: 220px;">
        <button id="projRenameBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Rename Project…</button>
        <button id="projArchiveBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Archive Project</button>
        <button id="projDeleteBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:#ef4444;">Delete Project</button>
        <hr style="border:none; border-top:1px solid var(--border); margin:6px 0;"/>
        <button id="projShowArchivedBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Archived…</button>
      </div>
      
      <!-- Ontology context menu -->
      <div id="ontologyContextMenu" style="position:absolute; display:none; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding:4px; z-index: 9999; min-width: 220px;">
        <button id="ontoRenameBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Rename Ontology…</button>
        <button id="ontoToggleReferenceBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:var(--text);">Toggle Reference Status</button>
        <button id="ontoDeleteBtn" class="btn" style="width:100%; text-align:left; background:none; border:none; padding:8px; color:#ef4444;">Delete Ontology</button>
      </div>

      <div class="resizer" id="resizer" aria-hidden="true"></div>

      <main class="main">
        <section id="wb-ontology" class="workbench">
          <div class="ontology-header">
            <!-- Graph Info and Title -->
            <div class="header-left">
              <h2 class="workbench-title">Ontology Workbench</h2>
              <span id="ontoGraphLabel" class="graph-label">No graph selected</span>
            </div>
            
            <!-- Menu Bar -->
            <div class="header-menu">
              <div class="menu-group">
                <button class="menu-btn" id="ontoLayoutMenuBtn">
                  <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <line x1="9" y1="9" x2="15" y2="9"/>
                    <line x1="9" y1="15" x2="15" y2="15"/>
                  </svg>
                  Layout
                </button>
                <div class="menu-dropdown" id="ontoLayoutMenu">
                  <div class="menu-section">
                    <div class="menu-label">Layout Algorithm</div>
                    <select id="ontoLayoutSelector" class="menu-select">
                      <option value="cose">Force-Directed (CoSE)</option>
                      <option value="dagre">Hierarchical (Dagre)</option>
                      <option value="concentric">Concentric</option>
                      <option value="breadthfirst">Breadthfirst</option>
                      <option value="circle">Circle</option>
                      <option value="grid">Grid</option>
                      <option value="cola">Constraint-Based</option>
                      <option value="spread">Spread</option>
                    </select>
                    <button class="menu-item" id="ontoLayoutBtn">Apply Layout</button>
                  </div>
                  <div class="menu-divider"></div>
                  <div class="menu-section">
                    <button class="menu-item" id="ontoQuickCoseBtn">Quick CoSE</button>
                    <button class="menu-item" id="ontoQuickDagreBtn">Quick Dagre</button>
                  </div>
                </div>
              </div>
              
              <div class="menu-group">
                <button class="menu-btn" id="ontoViewMenuBtn">
                  <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                    <circle cx="12" cy="12" r="3"/>
                  </svg>
                  View
                </button>
                <div class="menu-dropdown" id="ontoViewMenu">
                  <button class="menu-item" id="ontoFitBtn">Fit to View</button>
                  <button class="menu-item" id="ontoFullscreenBtn">Fullscreen</button>
                  <button class="menu-item" id="ontoForceRefreshBtn">Refresh</button>
                  <div class="menu-divider"></div>
                  <button class="menu-item" id="ontoClearCacheBtn">Clear Cache</button>
                </div>
              </div>
              
              <div class="menu-group">
                <button class="menu-btn" id="ontoEditMenuBtn">
                  <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                  </svg>
                  Edit
                </button>
                <div class="menu-dropdown" id="ontoEditMenu">
                  <button class="menu-item" id="ontoDeleteBtn">Delete Selected</button>
                  <button class="menu-item" id="ontoLinkIdenticalBtn">Link Identical Classes</button>
                </div>
              </div>
              
              <div class="menu-group">
                <button class="menu-btn" id="ontoFileMenuBtn">
                  <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14,2 14,8 20,8"/>
                  </svg>
                  File
                </button>
                <div class="menu-dropdown" id="ontoFileMenu">
                  <button class="menu-item" id="ontoSaveBtn">Save Ontology</button>
                  <div class="menu-divider"></div>
                  <button class="menu-item" id="ontoImportBtn">Import JSON</button>
                  <button class="menu-item" id="ontoExportBtn">Export JSON</button>
                  <input type="file" id="ontoImportFile" accept="application/json" style="display:none" />
                </div>
              </div>
            </div>
          </div>
          <div id="ontoEmpty" class="card onto-empty-state">
            Create or Select an Ontology to begin
          </div>
          <div class="onto-layout" id="ontoLayoutSection">
            <aside class="onto-tree" aria-label="Ontology Tree">
              <div class="onto-tree-header" id="ontoTreeHeader">
                <div class="muted">Ontology</div>
                <div class="onto-tree-controls">
                  <button class="iconbtn" id="ontoVisibilityToggle" title="Toggle Visibility">
                    <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                      <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                      <circle cx="12" cy="12" r="3"/>
                    </svg>
                  </button>
                <button class="iconbtn" id="ontoTreeToggle" title="Collapse">
                  <svg id="ontoTreeToggleIcon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M9 6l6 6-6 6"/></svg>
                </button>
                </div>
              </div>
              <div class="onto-tree-scroll">
                <nav class="onto-treeview" aria-label="Ontology">
                  <ul role="tree" id="ontoTreeRoot" aria-label="Ontology tree"></ul>
                </nav>
              </div>
            </aside>
            <div class="onto-resizer" id="ontoResizer" aria-hidden="true"></div>
            <aside class="onto-iconbar" aria-label="Ontology Tools">
              <div class="onto-icon" draggable="true" data-onto-type="class" title="Class">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
              </div>
              <div class="onto-icon" draggable="true" data-onto-type="dataProperty" title="Data Property">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="12" r="3"/><rect x="14" y="9" width="6" height="6" rx="1"/></svg>
              </div>
              <div class="onto-icon" draggable="true" data-onto-type="note" title="Note">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h12l4 4v12H4z"/><path d="M16 4v4h4"/></svg>
              </div>
            </aside>
            <div id="cy" role="application" aria-label="Ontology Graph Canvas"></div>
            <div class="onto-resizer" id="ontoPropsResizer" aria-hidden="true"></div>
            <aside class="onto-props" aria-label="Properties Panel">
              <div class="onto-props-header" id="ontoPropsHeader">
                <div class="muted">Properties</div>
                <button class="iconbtn" id="ontoPropsToggle" title="Collapse">
                  <svg id="ontoPropsToggleIcon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M9 6l6 6-6 6"/></svg>
                </button>
              </div>
              <div class="onto-props-scroll">
                <form id="ontoPropsForm" class="props-form">
                  <!-- Basic Properties -->
                  <div class="props-section">
                    <h4 class="props-section-title">Basic Properties</h4>
                    <div class="form-group">
                      <label class="form-label" for="propName">Name</label>
                      <input id="propName" type="text" class="form-input" placeholder="Enter name..." />
                    </div>
                    <div class="form-group">
                      <label class="form-label" for="propType">Type</label>
                      <div id="propType" class="form-text-display">
                        <span id="propTypeValue">Class</span>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Annotations -->
                  <div class="props-section">
                    <div class="props-section-header">
                      <h4 class="props-section-title">Annotations</h4>
                      <div class="props-section-actions">
                        <button type="button" id="addAttrBtn" class="btn btn-sm">+ Add</button>
                        <button type="button" id="resetAttrsBtn" class="btn btn-sm">Reset</button>
                      </div>
                    </div>
                    <div id="propAttrsContainer" class="attrs-container">
                      <!-- Dynamic annotation fields will be inserted here -->
                    </div>
                  </div>
                  
                  <!-- Actions -->
                  <div class="props-actions">
                    <button type="button" class="btn btn-primary" id="propSaveBtn">Save Changes</button>
                    <span id="propSaveStatus" class="save-status"></span>
                  </div>
                </form>
              </div>
            </aside>
          </div>
          <input id="ontoInlineEdit" type="text" />
          <div id="ontoContextMenu" class="onto-menu">
            <div class="menu-section">
              <button id="menuAddRel" class="menu-item">
                <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="7" cy="12" r="3"/><circle cx="17" cy="12" r="3"/><path d="M10 12h4"/>
                </svg>
                Add Relationship
              </button>
              <button id="menuAddDataProp" class="menu-item">
                <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="7" cy="12" r="3"/><rect x="14" y="9" width="6" height="6" rx="1"/>
                </svg>
                Add Data Property
              </button>
            </div>
            <div class="menu-divider"></div>
            <div class="menu-section">
              <button id="menuCancel" class="menu-item menu-item-secondary">Cancel</button>
            </div>
          </div>
          
          <!-- Element IRI Display at bottom - fixed height -->
          <div id="ontoElementIriContainer" class="iri-display">
            <div class="iri-content">
              <span class="iri-label">IRI:</span>
              <span id="ontoElementIri" class="iri-value" title="Click to copy IRI to clipboard">No element selected</span>
              <button id="ontoCopyIriBtn" class="btn btn-sm iri-copy-btn" title="Copy IRI to clipboard">Copy</button>
            </div>
          </div>
        </section>
        <section id="wb-files" class="workbench">
          <h2>File Management</h2>
          <div class="muted">Upload requirements and knowledge docs (MinIO).</div>
          <div class="card" style="margin-top:8px;">
            <div class="muted" style="font-weight:600; margin-bottom:6px;">How it works</div>
            <ol style="margin:0; padding-left:18px; color:#9aa4b2;">
              <li>Upload files (drag & drop or choose files)</li>
              <li>Files are automatically processed for knowledge</li>
              <li>View processing status in the Library section</li>
            </ol>
          </div>
          <div id="filesToast" class="muted" style="margin-top:6px;"></div>
          <div class="files-toolbar" style="display:flex; gap:8px; align-items:center; margin:10px 0; flex-wrap:wrap;">
            <label class="muted" for="filesDocType">Type</label>
            <select id="filesDocType" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
              <option value="">All Types</option>
              <option value="requirements">Requirements</option>
              <option value="knowledge">Knowledge</option>
              <option value="reference">Reference</option>
              <option value="specification">Specification</option>
              <option value="unknown">Unknown</option>
            </select>
            <label class="muted" for="filesStatus">Status</label>
            <select id="filesStatus" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
              <option value="">Any</option>
              <option value="new">New</option>
              <option value="ingested">Ingested</option>
              <option value="embedded">Embedded</option>
            </select>
            <input id="filesTags" type="text" placeholder="tags (comma)" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px; min-width:200px;" />
            <label class="muted"><input type="checkbox" id="filesIncludePublic" /> Include public files</label>
            <button class="btn" id="filesRefreshBtn" title="Refresh">Refresh</button>
            <div class="spacer"></div>
            <button class="btn" id="filesBulkProcessBtn" title="Extract requirements using BPMN workflows">📋 Extract Requirements</button>
            <button class="btn" id="filesBulkDeleteBtn" title="Delete selected">Delete Selected</button>

          </div>

          <div class="card" style="margin-top:8px;">
            <div class="muted">Upload or import by URL</div>
            <div style="display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap;">
              <input type="file" id="fileUploadInput" multiple style="display:none" />
              <button class="btn" id="fileChooseBtn" type="button">Choose Files</button>
              <input id="fileUrlInput" type="url" placeholder="https://example.com/doc.pdf" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px; min-width:320px;" />
              <button class="btn" id="fileUrlImportBtn">Import URL</button>
            </div>
            <div id="fileDropZone" tabindex="0" role="button" aria-label="Drop files or click to select" style="margin-top:10px; border:2px dashed var(--border); border-radius:8px; padding:20px; text-align:center; color:#9aa4b2; user-select:none; cursor:pointer; background:rgba(15, 22, 40, 0.3); transition:all 0.2s ease;">
              Drag & drop files here, or use the Choose Files button above

            </div>
            <div id="uploadPreview" class="muted" style="margin-top:6px;"></div>
          </div>

          <div class="card" style="margin-top:10px; display:grid; grid-template-columns: minmax(420px, 1fr) 8px minmax(360px, 420px); gap:0; align-items:stretch;">
            <div style="display:grid; gap:10px;">
              <div>
                <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                  <div class="muted">Staged files</div>
                  <div style="display:flex; gap:8px; align-items:center;">
                    <button class="btn" id="filesUploadAllBtn" type="button">Upload All</button>
                    <button class="btn" id="filesClearStagedBtn" type="button">Clear</button>
                  </div>
                </div>
                
                <!-- Document Type Selector for Staged Files -->
                <div id="stagedDocTypeSelector" style="display:none; margin:6px 0; padding:8px; background:var(--panel-2); border:1px solid var(--border); border-radius:6px;">
                  <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                    <span class="muted" style="font-size:12px;">Set document type for upload:</span>
                    <select id="stagedDocType" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:4px 8px; font-size:12px;">
                      <option value="unknown">Unknown</option>
                      <option value="requirements">Requirements</option>
                      <option value="knowledge">Knowledge</option>
                      <option value="reference">Reference</option>
                      <option value="specification">Specification</option>
                    </select>
                    <button class="btn" id="setStagedDocType" style="padding:4px 8px; font-size:12px;">Apply to All Staged</button>
                    <span class="muted" style="font-size:11px;" id="stagedDocTypeHint">Files will be uploaded with this document type</span>
                  </div>
                </div>
                
                <!-- Automatic Knowledge Processing Options -->
                <div id="knowledgeProcessingOptions" style="display:none; margin:6px 0; padding:8px; background:rgba(34, 197, 94, 0.1); border:1px solid #22c55e; border-radius:6px;">
                  <div style="margin-bottom:8px;">
                    <div class="muted" style="font-size:11px; color:var(--muted);">
                      Files are processed for knowledge with intelligent defaults
                    </div>
                  </div>
                  <div id="knowledgeProcessingConfig" style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                    <div>
                      <label class="muted" style="font-size:10px; display:block; margin-bottom:2px;">Embedding Model:</label>
                      <select id="embeddingModel" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:4px; padding:2px 4px; font-size:10px; width:100%;">
                        <option value="all-MiniLM-L6-v2">all-MiniLM-L6-v2 (Fast)</option>
                        <option value="all-mpnet-base-v2">all-mpnet-base-v2 (Better)</option>
                      </select>
                    </div>
                    <div>
                      <label class="muted" style="font-size:10px; display:block; margin-bottom:2px;">Chunking Strategy:</label>
                      <select id="chunkingStrategy" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:4px; padding:2px 4px; font-size:10px; width:100%;">
                        <option value="">Smart Default</option>
                        <option value="hybrid">Hybrid</option>
                        <option value="semantic">Semantic</option>
                        <option value="fixed">Fixed Size</option>
                      </select>
                    </div>
                  </div>
                </div>
                
                <div id="stagedList" style="display:grid; gap:6px; margin-top:6px;"></div>
              </div>
              <div>
                <div class="muted" style="margin-bottom:6px;">Library</div>
                <div id="filesList" style="display:block; overflow:auto;"></div>
              </div>
            </div>
            <div style="width:8px; cursor:col-resize;" id="filesSplitResizer" aria-hidden="true"></div>
            <aside id="filePreviewPane" style="border-left:1px solid var(--border); padding-left:10px; overflow:auto;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                <div class="muted">Preview</div>
                <div id="previewControls" style="display:flex; gap:6px; align-items:center;">
                  <button class="btn" id="previewFullscreenBtn" title="Fullscreen preview" style="min-width:auto; padding:6px 8px; font-size:14px; background:var(--panel-2); border:1px solid var(--border); color:var(--text);">⛶</button>
                  <button class="btn" id="previewPopoutBtn" title="Open in new window" style="display:none; min-width:auto; padding:6px 8px; font-size:14px; background:var(--panel-2); border:1px solid var(--border); color:var(--text);">↗</button>
                </div>
              </div>
              <div id="fileMetaBox" class="card" style="margin-bottom:8px;">
                <div class="muted">Metadata</div>
                <div id="fileMetaContent" class="muted">Select a file to see metadata.</div>
              </div>
              <div class="card">
                <div class="muted" style="margin-bottom:6px;">Content</div>
                <div id="filePreviewContent" class="muted">Select a file to preview.</div>
              </div>
              <div class="card" style="margin-top:8px;">
                <div class="muted" style="margin-bottom:6px;">Recent Runs</div>
                <div id="fileRunsContent" class="muted">No runs yet.</div>
              </div>
            </aside>
          </div>
        </section>
        
        <!-- Files: Ingestion Params Modal -->
        <div id="ingestParamsModal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); z-index:9999;">
          <div style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:10px; width:460px; max-width:90vw; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,0.4);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <h3 style="margin:0; font-size:16px;">🧠 Knowledge Processing Parameters</h3>
              <button class="btn" id="ingestParamsCloseBtn" style="min-width:auto;">✕</button>
            </div>
            <div style="display:grid; gap:10px;">
              <div style="display:grid; gap:6px;">
                <label class="muted">Chunking</label>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                  <div>
                    <label class="muted" for="ing_chunk_size">Size (tokens)</label>
                    <input id="ing_chunk_size" type="number" value="350" min="50" max="2000" step="10" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;" />
                  </div>
                  <div>
                    <label class="muted" for="ing_chunk_overlap">Overlap (tokens)</label>
                    <input id="ing_chunk_overlap" type="number" value="50" min="0" max="500" step="5" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;" />
                  </div>
                </div>
                <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
                  <label><input type="checkbox" id="ing_respect_headings" checked /> Respect headings</label>
                  <label><input type="checkbox" id="ing_join_short" checked /> Join short paragraphs</label>
                  <label><input type="checkbox" id="ing_split_code" checked /> Split code blocks</label>
                </div>
              </div>
              <div style="display:grid; gap:6px;">
                <label class="muted">Embedding</label>
                <select id="ing_model_id" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;">
                  <option value="simple-hasher">Simple Hasher (Testing)</option>
                  <option value="all-MiniLM-L6-v2" selected>all-MiniLM-L6-v2 (384 dim)</option>
                  <option value="all-mpnet-base-v2">all-mpnet-base-v2 (768 dim)</option>
                  <option value="text-embedding-3-small">OpenAI text-embedding-3-small (1536 dim)</option>
                  <option value="text-embedding-3-large">OpenAI text-embedding-3-large (3072 dim)</option>
                </select>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                  <div>
                    <label class="muted" for="ing_batch_size">Batch size</label>
                    <input id="ing_batch_size" type="number" value="64" min="1" max="1000" step="1" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px;" />
                  </div>
                  <div style="display:flex; align-items:center; padding-top:20px;">
                <label><input type="checkbox" id="ing_normalize" checked /> Normalize vectors</label>
                  </div>
                </div>
              </div>
              <div style="display:flex; gap:8px; justify-content:flex-end;">
                <button class="btn" id="ingestParamsCancelBtn" style="background: var(--muted);">Cancel</button>
                <button class="btn" id="ingestParamsStartBtn">Start</button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Fullscreen Preview Modal -->
        <div id="previewFullscreenModal" style="position:fixed; inset:0; display:none; background:rgba(0,0,0,0.95); z-index:10000; padding:20px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <div id="fullscreenPreviewTitle" style="color:#e5e7eb; font-weight:600; font-size:16px;">Document Preview</div>
            <div style="display:flex; gap:8px;">
              <button class="btn" id="fullscreenPopoutBtn" title="Open in new window" style="display:none; min-width:auto; padding:6px 12px;">↗ Popout</button>
              <button class="btn" id="fullscreenCloseBtn" title="Close fullscreen" style="min-width:auto; padding:6px 12px;">✕ Close</button>
            </div>
          </div>
          <div id="fullscreenPreviewContent" style="width:100%; height:calc(100vh - 80px); background:var(--panel); border:1px solid var(--border); border-radius:8px; overflow:hidden;">
            <!-- Preview content will be cloned here -->
          </div>
        </div>
        
        <section id="wb-knowledge" class="workbench">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <div>
              <h2>Knowledge Management</h2>
              <div class="muted">All uploaded files are automatically transformed into searchable knowledge with AI-powered insights</div>
            </div>
            <div style="display:flex; gap:8px; align-items:center;">
              <button class="btn" id="knowledgeRefreshBtn">Refresh</button>
              <div class="muted" style="font-size:11px; color:#22c55e; display:flex; align-items:center; gap:4px;">
                ⚙️ Auto-processing enabled
              </div>
            </div>
          </div>

          <div style="display:grid; grid-template-columns: 2fr 1fr; gap:20px; height:calc(100vh - 200px);">
            <!-- Main Knowledge Area -->
            <div style="display:flex; flex-direction:column; gap:16px;">
              <!-- Knowledge Assets List -->
              <div style="flex:1; background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:16px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                  <h3 style="margin:0;">Knowledge Assets</h3>
                  <div style="display:flex; gap:8px; align-items:center;">
                    <input type="text" id="knowledgeSearchInput" placeholder="Search knowledge..." style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:6px 10px; width:200px;"/>
                  </div>
                </div>
                <div id="knowledgeAssetsList" style="height:calc(100% - 60px); overflow-y:auto;">
                  <div class="muted" style="padding:20px; text-align:center;">
                    No knowledge assets yet.<br/>
                    <small>Upload and process documents to begin building your knowledge base.</small>
                  </div>
                </div>
              </div>

              <!-- Processing Status -->
              <div style="background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:16px; height:120px;">
                <h4 style="margin:0 0 8px 0;">Processing Status</h4>
                <div id="knowledgeProcessingStatus">
                  <div class="muted">No processing jobs running</div>
                </div>
              </div>
            </div>

            <!-- Knowledge Panel -->
            <div style="background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:16px; display:flex; flex-direction:column;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                <h4 style="margin:0;">Knowledge Details</h4>
                <div style="display:flex; gap:4px;">
                  <button class="btn" id="knowledgeQueryBtn" title="Query Knowledge" style="min-width:auto; padding:4px 8px; font-size:16px;">🔍</button>
                  <button class="btn" id="knowledgeGraphBtn" title="View Graph" style="min-width:auto; padding:4px 8px; font-size:16px;">🕸️</button>
                </div>
              </div>
              <div id="knowledgeDetailsContent" style="flex:1; overflow-y:auto;">
                <div class="muted" style="padding:20px; text-align:center;">
                  Select a knowledge asset to view details
                </div>
              </div>
            </div>
          </div>
        </section>
        <section id="wb-requirements" class="workbench">
          <h2>Requirements</h2>
          <div class="muted">Extraction rules, SME review, LLM critique.</div>
        </section>
        <section id="wb-graph" class="workbench">
          <h2>Graph Explorer</h2>
          <div class="muted">Quick look into RDF store (SPARQL).
            <button class="btn" id="btnRefreshSummary" style="margin-left:8px;">Refresh Summary</button>
          </div>
          <div id="graphSummary" class="card" style="margin-top:10px;"></div>
          <div class="card" style="margin-top:10px;">
            <div class="muted">Run SPARQL (SELECT):</div>
            <textarea id="sparqlInput" rows="6" style="width:100%; background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:8px;">SELECT ?s ?p ?o WHERE { ?s ?p ?o } LIMIT 25</textarea>
            <div style="margin-top:6px; display:flex; gap:8px; align-items:center;">
              <button class="btn" id="btnRunSparql">Run</button>
              <span id="sparqlStatus" class="muted"></span>
            </div>
            <pre id="sparqlResult" style="margin-top:8px; white-space:pre-wrap;"></pre>
          </div>
        </section>
        <section id="wb-rag" class="workbench">
          <h2>RAG</h2>
          <div class="muted">Develop/test BPMN workflows with LLM help.</div>
        </section>
        <section id="wb-process" class="workbench">
          <h2>Process</h2>
          <div class="muted">Manage extraction BPMN processes.</div>
        </section>
        <section id="wb-thread" class="workbench">
          <h2>Thread Workbench</h2>
          <div class="muted">Chronological, project-scoped thread of tasks, user actions, and system events.</div>
        </section>
        <section id="wb-playground" class="workbench">
          <h2>LLM Playground</h2>
          <div class="muted">Ask questions, generate white papers, save to project.</div>
        </section>
        <section id="wb-project" class="workbench">
          <h2>Project Information</h2>
          <div class="muted">Current project details and metadata.</div>
          
          <!-- Project Details Card -->
          <div style="margin-top: 20px;">
            <div id="projectInfoCard" style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 20px;">
              <div style="text-align: center; color: var(--muted);">No project selected</div>
            </div>
          </div>
        </section>

        <section id="wb-admin" class="workbench">
          <h2>Admin</h2>
          <div class="muted">Namespace management and system administration.</div>
          
          <!-- Installation Configuration Section -->
          <div style="margin-top: 20px;">
            <h3 style="margin: 0 0 16px 0; color: var(--text);">Installation Configuration</h3>
            <div id="installationConfig" style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                <div>
                  <label><strong>Organization:</strong></label>
                  <div id="configOrganization" class="muted">Loading...</div>
                </div>
                <div>
                  <label><strong>Base URI:</strong></label>
                  <div id="configBaseUri" class="muted">Loading...</div>
                </div>
                <div>
                  <label><strong>Type:</strong></label>
                  <div id="configType" class="muted">Loading...</div>
                </div>
                <div>
                  <label><strong>Program Office:</strong></label>
                  <div id="configProgramOffice" class="muted">Loading...</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Prefix Management Section -->
          <div class="section collapsed">
            <div class="section-header" onclick="toggleSection(this)" style="cursor: pointer; padding: 10px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: bold; color: var(--text);">Prefix Management</span>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button class="btn" onclick="loadPrefixes()">Refresh Prefixes</button>
                <button class="btn" onclick="showCreatePrefixModal()">Create Prefix</button>
              </div>
              
              <!-- Prefix List -->
              <div id="prefixList" style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                <div style="text-align: center; color: var(--muted);">Loading prefixes...</div>
              </div>
            </div>
          </div>

          <!-- Domain Management Section -->
          <div class="section collapsed">
            <div class="section-header" onclick="toggleSection(this)" style="cursor: pointer; padding: 10px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: bold; color: var(--text);">Domain Management</span>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button class="btn" onclick="loadDomains()">Refresh Domains</button>
                <button class="btn" onclick="showCreateDomainModal()">Create Domain</button>
              </div>
              
              <!-- Domain List -->
              <div id="domainList" style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                <div style="text-align: center; color: var(--muted);">Loading domains...</div>
              </div>
            </div>
          </div>

          <!-- Namespace Management Section -->
          <div class="section collapsed">
            <div class="section-header" onclick="toggleSection(this)" style="cursor: pointer; padding: 10px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: bold; color: var(--text);">Namespace Management</span>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button class="btn" onclick="loadNamespaces()">Refresh Namespaces</button>
                <button class="btn" onclick="showCreateNamespaceModal()">Create Namespace</button>
              </div>
              
              <!-- Namespace List -->
              <div id="namespaceList" style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                <div style="text-align: center; color: var(--muted);">Loading namespaces...</div>
              </div>
            </div>
          </div>

          <!-- User Management Section -->
          <div class="section collapsed">
            <div class="section-header" onclick="toggleSection(this)" style="cursor: pointer; padding: 10px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: bold; color: var(--text);">User Management</span>
              <span class="section-toggle" style="font-size: 14px;">▶</span>
            </div>
            <div class="section-content" style="display: none;">
              <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <button class="btn" onclick="loadUsers()">Refresh Users</button>
                <button class="btn" onclick="showCreateUserModal()">Create User</button>
                <button class="btn" onclick="showChangePasswordModal()">Change My Password</button>
                <label style="display: flex; align-items: center; gap: 8px; margin-left: auto;">
                  <input type="checkbox" id="showInactiveUsers" onchange="loadUsers()" style="margin: 0;">
                  <span style="color: var(--text); font-size: 14px;">Show inactive users</span>
                </label>
              </div>
              
              <!-- User List -->
              <div id="userList" style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                <div style="text-align: center; color: var(--muted);">Loading users...</div>
              </div>
            </div>
          </div>

        </section>
      </main>
    </div>

    <div class="bottombar">
      <span><span class="status-dot ok"></span>Camunda</span>
      <span><span class="status-dot ok"></span>Fuseki</span>
      <span><span class="status-dot ok"></span>Vector</span>
      <span class="spacer"></span>
      <span id="currentNamespace" class="muted" style="font-family: monospace; font-size: 12px;">No project selected</span>
      <span class="spacer"></span>
      <span class="muted">UI Restart Prototype</span>
    </div>
  </div>

  <!-- DAS docked panel scaffold -->
  <section id="dasPanel" class="das-panel das-dock-right" aria-label="Digital Assistant">
    <div class="das-toolbar">
      <strong>DAS</strong>
      <span class="muted" id="dasStatus" style="margin-left:8px;">Idle</span>
      <div class="spacer"></div>
      <span class="das-help">Ctrl+Alt+D (or Alt+Shift+D) to toggle; <br>Alt+Shift+←/→/↓ to dock</span>
    </div>
    <div class="das-body" id="dasBody">
      <div class="card" style="margin-bottom:8px;">
        <div class="row" style="grid-template-columns: 1fr auto; align-items:center;">
          <input type="text" id="dasPrompt" placeholder="Type a prompt..." />
          <button class="btn" id="dasSendBtn" type="button">Send</button>
        </div>
        <div class="muted">Scaffold only — integration pending.</div>
      </div>
      <div id="dasTranscript" style="display:grid; gap:8px;"></div>
    </div>
    <div class="das-resizer-x" id="dasResizerX" aria-hidden="true"></div>
    <div class="das-resizer-y" id="dasResizerY" aria-hidden="true"></div>
  </section>

  <script>
    const qs = (s, r = document) => r.querySelector(s);
    const qsa = (s, r = document) => Array.from(r.querySelectorAll(s));
    function debounce(fn, wait) {
      let t; return function(...args){ clearTimeout(t); t = setTimeout(()=>fn.apply(this,args), wait); };
    }
    // Ensure we persist canvas before unload/refresh
    window.addEventListener('beforeunload', () => { try { if (ontoState && ontoState.cy && activeOntologyIri) persistOntologyToLocalStorage(); } catch(_) {} });

    // Ontology workbench state
    const ontoState = { 
      cy: null, 
      eh: null, 
      connectMode: false, 
      clickConnectFrom: null, 
      nextId: 1, 
      currentPredicateType: 'objectProperty', 
      isCanvasActive: false,
      suspendAutosave: false,
      autosaveBound: false,
       visibilityState: {
         classes: true,
         dataProperties: true,
         notes: true,
         edges: true,
         imported: true
       },
       collapsedImports: new Set(), // Track which imports are collapsed
       elementVisibility: {}, // Track individual element visibility {elementId: true/false}
       activeNamedView: null, // Track currently active named view
       beforeViewState: null // Track state before applying any named view
    };
    let activeProject = null;
    let suppressWorkbenchSwitch = false;
    let activeOntologyIri = null;
    
    // URL state management
    function updateURL(projectId = null, workbench = null) {
      try {
        const url = new URL(window.location);
        if (projectId) {
          url.searchParams.set('project', projectId);
        } else {
          url.searchParams.delete('project');
        }
        if (workbench) {
          url.searchParams.set('wb', workbench);
        } else {
          url.searchParams.delete('wb');
        }
        window.history.replaceState({}, '', url);
      } catch (error) {
        console.warn('Failed to update URL:', error);
      }
    }
    
    function getURLState() {
      try {
        const url = new URL(window.location);
        return {
          projectId: url.searchParams.get('project'),
          workbench: url.searchParams.get('wb')
        };
      } catch (error) {
        console.warn('Failed to read URL state:', error);
        return { projectId: null, workbench: null };
      }
    }

    function updateOntoGraphLabel() {
      const el = qs('#ontoGraphLabel');
      if (!el) return;
      if (activeOntologyIri) {
        el.textContent = 'Graph: ' + activeOntologyIri;
        el.title = activeOntologyIri;
      } else {
        el.textContent = 'No graph selected';
        el.title = '';
      }
      
      // Also update element IRI display when graph changes
      updateElementIriDisplay();
      
      // Toggle empty-state hint
      const empty = qs('#ontoEmpty');
      const layout = qs('#ontoLayoutSection');
      if (empty && layout) {
        const showEmpty = !activeOntologyIri;
        empty.style.display = showEmpty ? 'block' : 'none';
        layout.style.display = showEmpty ? 'none' : 'grid';
      }
    }

    function slugify(str) {
      try {
        return String(str || '')
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-+|-+$/g, '') || 'ontology';
      } catch (_) { return 'ontology'; }
    }

    // Installation configuration - loaded from API
    let INSTALLATION_CONFIG = {
      organization: "ODRAS Development",
      baseUri: "http://odras.local",  // Will be loaded from API
      prefix: "odras",
      type: "development"  // navy, airforce, army, industry, research, etc.
    };

    // Load installation configuration from API
    async function loadInstallationConfig() {
      try {
        const response = await fetch('/api/installation/config');
        if (response.ok) {
          const config = await response.json();
          INSTALLATION_CONFIG = { ...INSTALLATION_CONFIG, ...config };
          console.log('🔧 Loaded installation config:', INSTALLATION_CONFIG);
          updateInstallationConfigDisplay();
        }
      } catch (error) {
        console.warn('⚠️ Failed to load installation config, using defaults:', error);
        updateInstallationConfigDisplay();
      }
    }

    // Load config on page load
    loadInstallationConfig();

    // Update installation config display
    function updateInstallationConfigDisplay() {
      // Update admin panel display
      document.getElementById('configOrganization').textContent = INSTALLATION_CONFIG.organization;
      document.getElementById('configBaseUri').textContent = INSTALLATION_CONFIG.baseUri;
      document.getElementById('configType').textContent = INSTALLATION_CONFIG.type;
      
      // Update topbar display
      const installOrg = document.getElementById('installOrg');
      const installType = document.getElementById('installType');
      const installOffice = document.getElementById('installOffice');
      
      if (installOrg) installOrg.textContent = INSTALLATION_CONFIG.organization || 'ODRAS';
      if (installType) installType.textContent = INSTALLATION_CONFIG.type || 'development';
      if (installOffice) installOffice.textContent = INSTALLATION_CONFIG.programOffice || '';
      document.getElementById('configProgramOffice').textContent = INSTALLATION_CONFIG.programOffice || 'N/A';
    }

    // Load namespaces for project ontology creation
    async function loadNamespacesForProject(selectElement) {
      try {
        const response = await fetch('/api/admin/namespaces/available/namespaces');
        if (response.ok) {
          const namespaces = await response.json();
          
          selectElement.innerHTML = '<option value="">Select a namespace...</option>' +
            namespaces.map(ns => `<option value="${ns.id}">${ns.name} (${ns.type}) - ${ns.description || 'No description'}</option>`).join('');
        } else {
          console.error('Failed to load namespaces:', response.status, response.statusText);
          selectElement.innerHTML = '<option value="">Error loading namespaces</option>';
        }
      } catch (error) {
        console.error('Error loading namespaces:', error);
        selectElement.innerHTML = '<option value="">Error loading namespaces</option>';
      }
    }

    // View ontologies in a namespace
    async function viewNamespaceOntologies(namespaceId, namespaceName) {
      try {
        // For now, show a simple modal with placeholder content
        // In a full implementation, this would fetch actual ontologies from the namespace
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div>
            <h3>Ontologies in ${namespaceName}</h3>
            <div style="margin: 20px 0; padding: 16px; background: var(--panel-2); border-radius: 6px; border: 1px solid var(--border);">
              <div style="text-align: center; color: var(--muted);">
                <p>This feature will show all ontologies created using the "${namespaceName}" namespace.</p>
                <p>Currently, this is a placeholder. In a full implementation, this would:</p>
                <ul style="text-align: left; margin: 16px 0;">
                  <li>Query the database for ontologies using this namespace</li>
                  <li>Show ontology details, creation dates, and owners</li>
                  <li>Allow viewing and editing of individual ontologies</li>
                  <li>Show URI structure and namespace usage</li>
                </ul>
              </div>
            </div>
            <div class="button-group">
              <button onclick="this.closest('.modal').remove()" class="btn" style="background: var(--muted);">Close</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      } catch (error) {
        console.error('Error viewing namespace ontologies:', error);
        alert(`Error viewing namespace ontologies: ${error.message}`);
      }
    }

    // Delete a namespace
    async function deleteNamespace(namespaceId, namespaceName) {
      try {
        // Confirm deletion
        if (!confirm(`Are you sure you want to delete the namespace "${namespaceName}"?\n\nThis action cannot be undone.`)) {
          return;
        }

        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/admin/namespaces/${namespaceId}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const result = await response.json();
          alert(`Namespace "${namespaceName}" deleted successfully.`);
          // Refresh the namespace list
          loadNamespaces();
        } else {
          const error = await response.json();
          alert(`Error deleting namespace: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error deleting namespace:', error);
        alert('Error deleting namespace: ' + error.message);
      }
    }

    // Auto-generate namespace name and path based on prefix and type
    function updateNamespaceFields() {
      const typeSelect = document.getElementById('nsType');
      const nameInput = document.getElementById('nsName');
      const pathInput = document.getElementById('nsPath');
      
      if (!typeSelect || !nameInput || !pathInput) return;
      
      // Use the ordered prefixes
      const selectedPrefixes = selectedPrefixOrder;
      const type = typeSelect.value;
      
      if (selectedPrefixes.length === 0) {
        nameInput.value = '';
        pathInput.value = '';
        return;
      }
      
      // Generate name as prefix1-prefix2-type (or just prefix-type if single)
      const prefixString = selectedPrefixes.join('-');
      const name = `${prefixString}-${type}`;
      nameInput.value = name;
      
      // Generate path based on type and selected prefixes
      let path = '';
      const prefixPath = selectedPrefixes.join('/');
      
      // Simplified, consistent logic: type always comes after the prefix path
      switch (type) {
        case 'core':
          path = `${prefixPath}/core`;
          break;
        case 'service':
          path = `${prefixPath}/service`;
          break;
        case 'domain':
          path = `${prefixPath}/domain`;
          break;
        case 'program':
          path = `${prefixPath}/program`;
          break;
        case 'project':
          path = `${prefixPath}/project`;
          break;
        case 'industry':
          path = `${prefixPath}/industry`;
          break;
        case 'vocab':
          path = `${prefixPath}/vocab`;
          break;
        case 'shapes':
          path = `${prefixPath}/shapes`;
          break;
        case 'align':
          path = `${prefixPath}/align`;
          break;
        default:
          path = `${prefixPath}/${type}`;
      }
      
      pathInput.value = path;
    }

    // Simplified ontology creation - inherits project namespace
    async function showCreateOntologyModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div>
          <h3>Create New Ontology</h3>
          
          <div style="margin-bottom: 16px;">
            <label>Current Project Namespace:</label>
            <div id="modalNamespaceDisplay" style="padding: 8px; background: var(--panel-2); border: 1px solid var(--border); border-radius: 4px; font-family: monospace; color: var(--muted);">
              Loading project namespace...
            </div>
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Ontologies inherit their project's namespace automatically
            </div>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Ontology Name:</label>
            <input type="text" id="simpleOntologyName" placeholder="e.g., flight-control" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);" />
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Title:</label>
            <input type="text" id="simpleOntologyTitle" placeholder="e.g., Flight Control System Ontology" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);" />
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Description:</label>
            <textarea id="simpleOntologyDescription" placeholder="Brief description of the ontology" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text); height: 80px; resize: vertical;"></textarea>
          </div>
          
          <div class="button-group">
            <button onclick="this.closest('.modal').remove()" class="btn" style="background: var(--muted);">Cancel</button>
            <button onclick="createSimpleOntology()" class="btn" style="background: var(--accent); color: white; border-color: var(--accent);">Create Ontology</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Load current project's namespace for display
      loadCurrentProjectNamespace(document.getElementById('modalNamespaceDisplay'));
    }

    async function createSimpleOntology() {
      try {
        const name = document.getElementById('simpleOntologyName').value.trim();
        const title = document.getElementById('simpleOntologyTitle').value.trim();
        const description = document.getElementById('simpleOntologyDescription').value.trim();
        
        if (!name) {
          alert('Please enter an ontology name');
          return;
        }
        
        const currentProjectId = localStorage.getItem('active_project_id');
        if (!currentProjectId) {
          alert('No project selected - select a project first');
          return;
        }
        
        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }
        
        console.log('🔧 Creating ontology with inherited namespace:', {
          name, title, description, project: currentProjectId
        });
        
        const response = await fetch('/api/ontologies', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            project: currentProjectId,
            name: name,
            label: title || name,
            description: description || null
            // No namespace_id - will be inherited from project
          })
        });
        
        if (response.ok) {
          const newOntology = await response.json();
          console.log('🔧 Created ontology:', newOntology);
          document.querySelector('.modal').remove();
          
          // Refresh ontology list or switch to new ontology
          // This will depend on your existing ontology management code
          alert('Ontology created successfully!');
          
          // Reload the current project to show the new ontology
          window.location.reload();
        } else {
          const error = await response.json();
          console.error('🔧 Error creating ontology:', error);
          alert(`Error creating ontology: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error creating ontology:', error);
        alert('Error creating ontology: ' + error.message);
      }
    }

    function updateOntoUriPreview() {
      const type = document.getElementById('ontologyNamespaceType').value;
      const name = document.getElementById('ontologyName').value || 'ontology';
      
      let uri = INSTALLATION_CONFIG.baseUri;
      
      if (type === 'core') {
        uri += `/core/${name}`;
      } else if (type === 'domain') {
        const domain = document.getElementById('ontologyDomain').value || 'domain';
        uri += `/${domain}/${name}`;
      } else if (type === 'program') {
        const program = document.getElementById('ontologyProgram').value || 'program';
        uri += `/${program}/core/${name}`;
      } else if (type === 'project') {
        const program = document.getElementById('ontologyProgram').value || 'program';
        const project = document.getElementById('ontologyProject').value || 'project';
        uri += `/${program}/${project}/${name}`;
      } else if (type === 'se') {
        const seDomain = document.getElementById('ontologySeDomain').value || 'se-domain';
        uri += `/se/${seDomain}/${name}`;
      } else if (type === 'mission') {
        const missionType = document.getElementById('ontologyMissionType').value || 'mission-type';
        uri += `/mission/${missionType}/${name}`;
      } else if (type === 'platform') {
        const platformType = document.getElementById('ontologyPlatformType').value || 'platform-type';
        uri += `/platform/${platformType}/${name}`;
      } else {
        uri += `/${name}`;
      }
      
      document.getElementById('ontologyUriPreview').textContent = uri;
    }

    async function createOntology() {
      try {
        const type = document.getElementById('ontologyNamespaceType').value;
        const name = document.getElementById('ontologyName').value;
        const title = document.getElementById('ontologyTitle').value || name;
        const description = document.getElementById('ontologyDescription').value;
        
        if (!name) {
          alert('Please enter an ontology name');
          return;
        }
        
        // Generate the URI
        let uri = INSTALLATION_CONFIG.baseUri;
        let projectId = 'core';
        
        if (type === 'core') {
          uri += `/core/${name}`;
          projectId = 'core';
        } else if (type === 'domain') {
          const domain = document.getElementById('ontologyDomain').value || 'domain';
          uri += `/${domain}/${name}`;
          projectId = `domain-${domain}`;
        } else if (type === 'program') {
          const program = document.getElementById('ontologyProgram').value || 'program';
          uri += `/${program}/core/${name}`;
          projectId = `program-${program}`;
        } else if (type === 'project') {
          const program = document.getElementById('ontologyProgram').value || 'program';
          const project = document.getElementById('ontologyProject').value || 'project';
          uri += `/${program}/${project}/${name}`;
          projectId = `project-${program}-${project}`;
        } else if (type === 'se') {
          const seDomain = document.getElementById('ontologySeDomain').value || 'se-domain';
          uri += `/se/${seDomain}/${name}`;
          projectId = `se-${seDomain}`;
        } else if (type === 'mission') {
          const missionType = document.getElementById('ontologyMissionType').value || 'mission-type';
          uri += `/mission/${missionType}/${name}`;
          projectId = `mission-${missionType}`;
        } else if (type === 'platform') {
          const platformType = document.getElementById('ontologyPlatformType').value || 'platform-type';
          uri += `/platform/${platformType}/${name}`;
          projectId = `platform-${platformType}`;
        } else {
          uri += `/${name}`;
          projectId = 'general';
        }
        
        // Create the ontology
        const response = await authenticatedFetch('/api/ontology', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            project: projectId,
            name: name,
            label: title,
            description: description,
            is_reference: true  // These are reference ontologies
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          console.log('✅ Ontology created:', result);
          document.querySelector('.modal').remove();
          await loadNamespaces();
          alert('Ontology created successfully!');
        } else {
          const error = await response.text();
          throw new Error(`HTTP ${response.status}: ${error}`);
        }
      } catch (error) {
        console.error('Error creating ontology:', error);
        alert(`Error creating ontology: ${error.message}`);
      }
    }

    function computeOntologyIri(projectId, name, version) {
      // This function generates project-scoped ontology URIs following the namespace design
      // Pattern: {base_uri}/{namespace_path}/{project_uuid}/ontologies/{name}
      console.log('⚠️ computeOntologyIri called - this may be generating old-format URIs');
      console.log('Project ID:', projectId, 'Name:', name, 'Version:', version);
      
      // For now, return a simple placeholder - the backend ResourceURIService should handle proper URI generation
      const pid = encodeURIComponent(projectId || 'project');
      const n = slugify(name || 'ontology');
      const ver = version ? ('/v' + encodeURIComponent(version)) : '';
      
      // Note: This is a legacy pattern - proper URIs should come from backend ResourceURIService
      const uri = `${INSTALLATION_CONFIG.baseUri}/legacy/${pid}/${n}${ver}`;
      console.log('⚠️ Generated legacy URI:', uri, '(should be replaced by backend service)');
      return uri;
    }

    async function handleTreeSelection(li) {
      if (!li || !li.dataset) return;
      const type = li.dataset.nodeType || '';
      
      if (type === 'ontology') {
        const iri = li.dataset.iri;
        if (iri) {
          // Save previous active ontology canvas before switching
          const prevIri = activeOntologyIri;
          ensureOntologyInitialized();
          if (ontoState.cy && prevIri) {
            saveGraphToLocal(prevIri);
          }
          // Switch active ontology
          activeOntologyIri = iri;
          try {
            const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
            localStorage.setItem(`onto_active_iri__${pid}`, iri);
            // Set model name for properties panel based on discovered label or IRI tail
            const friendly = (li.dataset.label && li.dataset.label.trim()) || iri.split('/').pop() || iri;
            localStorage.setItem(`onto_model_name__${pid}`, friendly);
            // Also store display label, graph, and namespace in model attributes
            let attrs = {};
            try { attrs = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}'); } catch(_) { attrs = {}; }
            attrs.displayLabel = friendly;
            attrs.graphIri = iri;
            // Set namespace based on installation configuration
            attrs.namespace = iri;  // Use the actual graph IRI as namespace
            localStorage.setItem(`onto_model_attrs__${pid}`, JSON.stringify(attrs));
            // Keep project-scoped label map in sync so the top node reflects selection
            try { saveOntologyLabel(iri, friendly); } catch(_) {}
            
            // Load collapsed imports state for this ontology
            ontoState.collapsedImports = loadCollapsedImports(iri);
            
            // Load visibility state for this ontology
            ontoState.visibilityState = loadVisibilityState(iri);
            
            // Load individual element visibility for this ontology
            ontoState.elementVisibility = loadElementVisibility(iri);
          } catch(_) {}
          updateOntoGraphLabel();
          // Load new graph from local storage if present, otherwise fetch from API
          if (ontoState.cy) {
            // Avoid racing autosave during restore
            ontoState.suspendAutosave = true;
            try { ontoState.cy.elements().remove(); } catch(_) {}
            await loadGraphFromLocalOrAPI(iri);
            // Refresh overlay imports to restore visible imported ontologies
            await overlayImportsRefresh();
            // Apply saved visibility states after overlay refresh
            updateCanvasVisibility();
            setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
          }
          // Show model-level props when nothing selected
          updatePropertiesPanelFromSelection();
          // Rebuild ontology tree (top node label and contents)
          try { refreshOntologyTree(); } catch(_) {}
          // Switch to Ontology workbench view unless suppressed during restore
          if (!suppressWorkbenchSwitch) {
            const ico = document.querySelector('.icon[data-wb="ontology"]');
            if (ico && !document.querySelector('#wb-ontology.workbench.active')) {
              ico.click();
            }
          }
          // Reflect in hash for deep-linking (preserve current workbench)
          try {
            const params = new URLSearchParams(location.hash.replace(/^#/, ''));
            const wb = localStorage.getItem('active_workbench') || 'ontology';
            params.set('wb', wb);
            params.set('graph', encodeURIComponent(iri));
            location.hash = params.toString();
          } catch(_) {}
        }
      } else if (type === 'class' || type === 'dataProperty' || type === 'note') {
        // Handle individual element selection
        const nodeId = li.dataset.nodeId;
        if (nodeId && ontoState.cy) {
          // Clear current selection
          ontoState.cy.$(':selected').unselect();
          
          // Find and select the corresponding node in the canvas (escape special characters in ID)
          const node = ontoState.cy.$(`#${CSS.escape(nodeId)}`);
          if (node.length > 0) {
            node.select();
            
            // Center the view on the selected node
            ontoState.cy.animate({
              center: { eles: node },
              zoom: Math.max(ontoState.cy.zoom(), 0.8) // Ensure minimum zoom level
            }, {
              duration: 300
            });
            
            // Update properties panel with selected element data
            updatePropertiesPanelFromSelection();
          } else {
            console.log('🔍 Could not find node with ID:', nodeId);
          }
        }
      } else if (type === 'namedView') {
          // Handle named view selection with toggle functionality
          const viewId = li.dataset.viewId;
          if (viewId) {
            const views = loadNamedViews(activeOntologyIri);
            const view = views.find(v => v.id === viewId);
            if (view) {
              if (ontoState.activeNamedView === viewId) {
                // Toggle off - restore original state before any named views
                console.log('🔍 Toggling off named view:', view.name, 'returning to original state');
                if (ontoState.beforeViewState) {
                  restoreOriginalState();
                } else {
                  ontoState.activeNamedView = null;
                  refreshOntologyTree();
                }
              } else {
                // Capture current state as "before state" if this is the first named view applied
                if (!ontoState.activeNamedView && !ontoState.beforeViewState) {
                  console.log('🔍 Capturing current state before applying first named view');
                  ontoState.beforeViewState = captureCurrentView('__original_state__');
                }
                
                // Apply the view
                console.log('🔍 Applying named view:', view.name, 'with visible imports:', view.visibleImports);
                restoreView(view);
              }
            }
          }
        } else if (type === 'edge') {
        // Handle edge selection
        const edgeId = li.dataset.edgeId;
        if (edgeId && ontoState.cy) {
          // Clear current selection
          ontoState.cy.$(':selected').unselect();
          
          // Find and select the corresponding edge in the canvas (escape special characters in ID)
          const edge = ontoState.cy.$(`#${CSS.escape(edgeId)}`);
          if (edge.length > 0) {
            edge.select();
            
            // Center the view on the selected edge
            ontoState.cy.animate({
              center: { eles: edge },
              zoom: Math.max(ontoState.cy.zoom(), 0.8)
            }, {
              duration: 300
            });
            
            // Update properties panel with selected element data
            updatePropertiesPanelFromSelection();
          } else {
            console.log('🔍 Could not find edge with ID:', edgeId);
          }
        }
      }
    }
    function ensureOntologyInitialized() {
      if (ontoState.cy) return;
      const container = qs('#cy');
      if (!container) return;
      // Make canvas focusable for keyboard events (Delete)
      try { container.setAttribute('tabindex', '0'); container.style.outline = 'none'; } catch(_) {}
      try {
        if (window.cytoscape && (window.cytoscapeEdgehandles || window.edgehandles)) {
          const plugin = window.cytoscapeEdgehandles || window.edgehandles;
          if (plugin && typeof plugin === 'function') window.cytoscape.use(plugin);
        }
      } catch (_) {}
      ontoState.cy = cytoscape({
        container,
        layout: { name: 'grid', padding: 10, avoidOverlap: true },
        style: [
          { selector: 'node', style: {
            'shape': 'round-rectangle',
            'background-color': '#1b2a45',
            'border-color': '#2a3b5f',
            'border-width': 1,
            'label': 'data(label)',
            'color': '#e5e7eb',
            'font-size': 12,
            'text-wrap': 'wrap',
            'text-max-width': 180,
            'text-valign': 'center',
            'text-halign': 'center'
          }},
          { selector: 'node[type = "class"]', style: { 'width': 180, 'height': 56 } },
          { selector: 'node[type = "dataProperty"]', style: {
            'width': 160,
            'height': 48,
            'background-color': '#154e5a',
            'border-color': '#2ea3b0'
          } },
          { selector: 'edge', style: {
            'curve-style': 'bezier',
            'width': 2,
            'line-color': '#3b4a6b',
            'target-arrow-shape': 'triangle',
            'target-arrow-color': '#3b4a6b',
            'arrow-scale': 1,
            'label': 'data(predicate)',
            'color': '#e5e7eb',
            'font-size': 10,
            'text-rotation': 'autorotate',
            'text-background-color': '#0b1220',
            'text-background-opacity': 0.6,
            'text-background-padding': 2
          }},
          { selector: '.imported', style: {
            'opacity': 0.55
          }},
          { selector: 'edge.imported', style: { 'line-style': 'dashed' } },
          { selector: 'edge.imported-equivalence', style: {
            'line-style': 'dotted',
            'width': 1.5,
            'line-color': '#60a5fa',
            'label': '≡',
            'color': '#9ca3af',
            'font-size': 9,
            'text-background-opacity': 0
          } },
          { selector: 'node[type = "note"], .note', style: {
            'shape': 'round-rectangle',
            'background-color': function(ele) {
              const noteType = ele.data('attrs') && ele.data('attrs').noteType;
              return getNoteTypeStyle(noteType || 'Note').backgroundColor;
            },
            'border-color': function(ele) {
              const noteType = ele.data('attrs') && ele.data('attrs').noteType;
              return getNoteTypeStyle(noteType || 'Note').borderColor;
            },
            'border-style': 'solid',
            'border-width': 2,
            'label': function(ele) { 
              const noteType = ele.data('attrs') && ele.data('attrs').noteType;
              const symbol = getNoteTypeStyle(noteType || 'Note').symbol;
              const content = ele.data('attrs') && ele.data('attrs').content;
              const text = content || ele.data('label') || 'Note';
              return symbol + ' ' + text; 
            },
            'color': function(ele) {
              const noteType = ele.data('attrs') && ele.data('attrs').noteType;
              return getNoteTypeStyle(noteType || 'Note').textColor;
            },
            'font-size': 12,
            'text-wrap': 'wrap',
            'text-max-width': 220,
            'text-valign': 'center',
            'text-halign': 'center',
            'width': 220, 'height': 80
          }},
          { selector: ':selected', style: {
            'border-color': '#60a5fa',
            'border-width': 2,
            'line-color': '#60a5fa',
            'target-arrow-color': '#60a5fa'
          }}
        ],
        elements: []
      });
      window._cy = ontoState.cy;
      ontoState.nextId = 1;
      // Focus canvas on interaction so Delete works reliably
      ontoState.cy.on('tap', () => { try { container.focus(); } catch(_) {} });
      ontoState.cy.on('select', () => { try { container.focus(); } catch(_) {} });
      try { container.addEventListener('keydown', handleDeleteKey); } catch(_) {}

      // Mark canvas active on any interaction
      ontoState.cy.on('tap', () => { ontoState.isCanvasActive = true; });

      if (typeof ontoState.cy.edgehandles === 'function') {
        ontoState.eh = ontoState.cy.edgehandles({
          handleSize: 8,
          handleNodes: 'node[type = "class"], node[type = "note"]',
          handleColor: '#60a5fa',
          handleOutlineColor: '#0b1220',
          handleOutlineWidth: 2,
          toggleOffOnLeave: true,
          enabled: true,
          edgeParams: () => ({ data: { predicate: 'relatedTo', type: 'objectProperty' } })
        });
        ontoState.cy.on('ehcomplete', (event, sourceNode, targetNode, addedEdge) => {
          try {
            const srcType = (sourceNode.data('type') || 'class');
            const tgtType = (targetNode.data('type') || 'class');
            const edgeType = (addedEdge && addedEdge.data('type')) || ontoState.currentPredicateType || 'objectProperty';
            let invalid = false;
            // Allow note -> class as 'note_for' (reverse if class->note used)
            if ((srcType === 'note' && (tgtType === 'class' || tgtType === 'dataProperty')) || ((srcType === 'class' || srcType === 'dataProperty') && tgtType === 'note')) {
              // Ensure direction note -> class
              if ((srcType === 'class' || srcType === 'dataProperty') && tgtType === 'note') {
                addedEdge.data('source', targetNode.id());
                addedEdge.data('target', sourceNode.id());
              }
              addedEdge.data('predicate', 'note_for');
              addedEdge.data('type', 'note');
            } else {
              // For object properties, only allow class→class
              if (edgeType === 'objectProperty' && (srcType !== 'class' || tgtType !== 'class')) invalid = true;
              // Disallow any other note edges
              if (srcType === 'note' || tgtType === 'note') invalid = true;
              if (invalid && addedEdge) { addedEdge.remove(); return; }
            }
          } catch(_) {}
          requestAnimationFrame(() => { refreshOntologyTree(); persistOntologyToLocalStorage(); });
        });
        ontoState.cy.on('select unselect add remove data free', () => {
          updatePropertiesPanelFromSelection();
          persistOntologyToLocalStorage();
          
          // Highlight corresponding tree item when canvas selection changes
          const selected = ontoState.cy.$(':selected');
          if (selected.length === 1) {
            const element = selected[0];
            if (element.isNode()) {
              highlightTreeItem(element.id(), 'node');
            } else if (element.isEdge()) {
              highlightTreeItem(element.id(), 'edge');
            }
          } else {
            // Clear tree selection when nothing is selected on canvas
            qsa('.node-row').forEach(r => r.classList.remove('selected'));
          }
        });
        // Persist overlay positions when moved
        ontoState.cy.on('free', 'node.imported', (ev) => {
          try {
            const n = ev.target; const imp = n.data('importSource');
            if (!imp || !activeOntologyIri) return;
            const curr = loadOverlayPositions(activeOntologyIri, imp);
            curr[n.id()] = n.position();
            console.log('🔍 Saving position for', n.id(), ':', n.position(), 'in import', imp);
            saveOverlayPositions(activeOntologyIri, imp, curr);
          } catch(_) {}
        });
        // Persist overlay positions when moved
        ontoState.cy.on('free', 'node.imported', (ev) => {
          try {
            const n = ev.target; const imp = n.data('importSource');
            if (!imp || !activeOntologyIri) return;
            const curr = loadOverlayPositions(activeOntologyIri, imp);
            curr[n.id()] = n.position();
            console.log('🔍 Saving position for', n.id(), ':', n.position(), 'in import', imp);
            saveOverlayPositions(activeOntologyIri, imp, curr);
          } catch(_) {}
        });
      } else {
        ontoState.cy.on('tap', 'node', (ev) => {
          if (!ontoState.connectMode) return;
          const node = ev.target;
          if (!ontoState.clickConnectFrom) {
            ontoState.clickConnectFrom = node.id();
          } else {
            const from = ontoState.clickConnectFrom;
            const to = node.id();
            if (from !== to) {
              const src = ontoState.cy.$(`#${from}`)[0];
              const tgt = ontoState.cy.$(`#${to}`)[0];
              const srcType = (src && (src.data('type')||'class')) || 'class';
              const tgtType = (tgt && (tgt.data('type')||'class')) || 'class';
              if (srcType !== 'note' && tgtType !== 'note' && srcType === 'class' && tgtType === 'class') {
                const edgeAttrs = addCreationMetadata({});
                ontoState.cy.add({ group: 'edges', data: { id: `e${Date.now()}`, source: from, target: to, predicate: 'relatedTo', type: 'objectProperty', attrs: edgeAttrs } });
                refreshOntologyTree();
                persistOntologyToLocalStorage();
              }
            }
            ontoState.clickConnectFrom = null;
          }
        });
        ontoState.cy.on('select unselect add remove data free', () => {
          updatePropertiesPanelFromSelection();
          persistOntologyToLocalStorage();
          
          // Highlight corresponding tree item when canvas selection changes
          const selected = ontoState.cy.$(':selected');
          if (selected.length === 1) {
            const element = selected[0];
            if (element.isNode()) {
              highlightTreeItem(element.id(), 'node');
            } else if (element.isEdge()) {
              highlightTreeItem(element.id(), 'edge');
            }
          } else {
            // Clear tree selection when nothing is selected on canvas
            qsa('.node-row').forEach(r => r.classList.remove('selected'));
          }
        });
      }

      // Background click clears selection and shows model-level props
      ontoState.cy.on('tap', (ev) => {
        if (ev.target === ontoState.cy) {
          ontoState.cy.$(':selected').unselect();
          updatePropertiesPanelFromSelection();
          hideMenu();
          clearConnectState();
        }
      });

      // Inline label editor on F2 or Enter when focused
      ontoState.cy.on('cxttap', 'node', (ev) => {
        const n = ev.target; const t = (n.data('type')||'class');
        const rect = qs('#cy').getBoundingClientRect();
        const rp = ev.renderedPosition || n.renderedPosition();
        // Configure menu per node type
        const menu = qs('#ontoContextMenu');
        if (!menu) return;
        const btnRel = qs('#menuAddRel');
        const btnDP = qs('#menuAddDataProp');
        if (t === 'note') {
          if (btnRel) {
            btnRel.innerHTML = `
              <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="7" cy="12" r="3"/><circle cx="17" cy="12" r="3"/><path d="M10 12h4"/>
              </svg>
              Link to Class/Property
            `;
          }
          if (btnDP) btnDP.style.display = 'none';
        } else {
          if (btnRel) {
            btnRel.innerHTML = `
              <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="7" cy="12" r="3"/><circle cx="17" cy="12" r="3"/><path d="M10 12h4"/>
              </svg>
              Add Relationship
            `;
          }
          if (btnDP) btnDP.style.display = 'block';
        }
        showMenuAt(rect.left + rp.x + 6, rect.top + rp.y + 6);
        menu.dataset.nodeId = n.id();
        menu.dataset.nodeType = t;
      });
      function showInlineEditor(target) {
        // Don't allow editing of imported elements
        if (target.hasClass('imported')) {
          console.log('🔍 Cannot edit imported element:', target.data('label'));
          return;
        }
        
        const input = qs('#ontoInlineEdit'); if (!input) return;
        const pos = target.renderedPosition();
        const rect = qs('#cy').getBoundingClientRect();
        const current = target.isNode() ? (target.data('label') || '') : (target.data('predicate') || '');
        input.value = current;
        input.style.left = (rect.left + pos.x - Math.min(100, rect.width*0.2)) + 'px';
        input.style.top = (rect.top + pos.y - 12) + 'px';
        input.style.display = 'block';
        input.focus();
        input.select();
        function commit(save) {
          if (save) {
            const v = input.value.trim();
            if (target.isNode()) {
              target.data('label', v || current);
              // Update modification metadata for inline label changes
              const currentAttrs = target.data('attrs') || {};
              const updatedAttrs = updateModificationMetadata(currentAttrs);
              target.data('attrs', updatedAttrs);
            } else {
              target.data('predicate', v || current);
              // Update modification metadata for inline predicate changes
              const currentAttrs = target.data('attrs') || {};
              const updatedAttrs = updateModificationMetadata(currentAttrs);
              target.data('attrs', updatedAttrs);
            }
            refreshOntologyTree();
            persistOntologyToLocalStorage();
          }
          input.style.display = 'none';
          input.onkeydown = null; input.onblur = null;
        }
        input.onkeydown = (e) => {
          if (e.key === 'Enter') commit(true);
          else if (e.key === 'Escape') commit(false);
        };
        input.onblur = () => commit(true);
      }
      ontoState.cy.on('keydown', 'node,edge', (ev) => {
        if (ev.originalEvent && ev.originalEvent.key === 'F2') showInlineEditor(ev.target);
      });
      // Double-click to edit
      ontoState.cy.on('dblclick', 'node,edge', (ev) => showInlineEditor(ev.target));

      // Context menu actions
      document.addEventListener('click', (e) => {
        const menu = qs('#ontoContextMenu');
        if (!menu) return;
        if (e.target === qs('#menuCancel')) { hideMenu(); return; }
        if (e.target === qs('#menuAddRel')) {
          hideMenu();
          const id = menu.dataset.nodeId; if (!id) return;
          const node = ontoState.cy.$('#' + id)[0]; if (!node) return;
          const t = menu.dataset.nodeType || 'class';
          clearConnectState(); startConnectFrom(node); cmState.sourceType = t;
          return;
        }
        if (e.target === qs('#menuAddDataProp')) {
          hideMenu();
          const id = menu.dataset.nodeId; if (!id) return;
          const node = ontoState.cy.$('#' + id)[0]; if (!node) return;
          // Add a default data property node near the class
          const pos = node.position();
          const pid = `DP${Date.now()}`;
          const label = `Data Property ${Date.now()%1000}`;
          const dpAttrs = addCreationMetadata({});
          ontoState.cy.add({ group: 'nodes', data: { id: pid, label, type: 'dataProperty', attrs: dpAttrs }, position: { x: pos.x + 120, y: pos.y } });
          // Use objectProperty for the visual connector edge
          const edgeAttrs = addCreationMetadata({});
          ontoState.cy.add({ group: 'edges', data: { id: `edp${Date.now()}`, source: id, target: pid, predicate: label, type: 'objectProperty', attrs: edgeAttrs } });
          refreshOntologyTree(); persistOntologyToLocalStorage();
          return;
        }
      });
      // Clicking a target after 'Add relationship' completes the edge
      ontoState.cy.on('tap', 'node', (ev) => {
        const target = ev.target; if (!cmState.sourceId) return;
        const tgtType = (target.data('type')||'class');
        const source = ontoState.cy.$('#' + cmState.sourceId)[0]; if (!source) { clearConnectState(); return; }
        const srcType = cmState.sourceType || (source.data('type')||'class');
        if (source.id() !== target.id()) {
          if (srcType === 'note' && (tgtType === 'class' || tgtType === 'dataProperty')) {
            const edgeAttrs = addCreationMetadata({});
            ontoState.cy.add({ group: 'edges', data: { id: `enote${Date.now()}`, source: source.id(), target: target.id(), predicate: 'note_for', type: 'note', attrs: edgeAttrs } });
            refreshOntologyTree(); persistOntologyToLocalStorage();
          } else if (srcType === 'class' && tgtType === 'class') {
            const edgeAttrs = addCreationMetadata({});
            ontoState.cy.add({ group: 'edges', data: { id: `e${Date.now()}`, source: source.id(), target: target.id(), predicate: 'relatedTo', type: 'objectProperty', attrs: edgeAttrs } });
            refreshOntologyTree(); persistOntologyToLocalStorage();
          }
        }
        source.removeClass('connect-source');
        clearConnectState();
      });

      // Drag-and-drop from tool icons
      const icons = Array.from(document.querySelectorAll('.onto-icon'));
      icons.forEach(icon => {
        icon.addEventListener('dragstart', (ev) => {
          ev.dataTransfer.setData('text/onto-type', icon.getAttribute('data-onto-type') || 'class');
          try { ev.dataTransfer.effectAllowed = 'copy'; } catch(_) {}
        });
      });

      container.addEventListener('dragenter', (ev) => { ev.preventDefault(); });
      container.addEventListener('dragover', (ev) => { ev.preventDefault(); ontoState.isCanvasActive = true; try { ev.dataTransfer.dropEffect = 'copy'; } catch(_) {} });
      container.addEventListener('drop', async (ev) => {
        ev.preventDefault();
        ontoState.isCanvasActive = true;
        const ontoType = ev.dataTransfer.getData('text/onto-type') || 'class';
        const rect = container.getBoundingClientRect();
        const renderedPos = { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
        const pan = ontoState.cy.pan();
        const zoom = ontoState.cy.zoom();
        const pos = { x: (renderedPos.x - pan.x) / zoom, y: (renderedPos.y - pan.y) / zoom };
        if (ontoType === 'class') {
          const label = `Class ${ontoState.nextId}`;
          const id = await addClassNodeAt(label, pos);
          if (id) { ontoState.cy.$('#' + id).select(); }
        } else if (ontoType === 'objectProperty') {
          ontoState.currentPredicateType = 'objectProperty';
          setConnectMode(true);
          // With edgehandles enabled, user can drag handle from a class to another class
        } else if (ontoType === 'dataProperty') {
          const sel = ontoState.cy.nodes(':selected').filter(n => (n.data('type') || 'class') === 'class');
          if (sel.length !== 1) { return; }
          const prop = `Data Property ${Date.now()%1000}`;
          const pid = `DP${Date.now()}`;
          const dpAttrs = addCreationMetadata({});
          ontoState.cy.add({ group: 'nodes', data: { id: pid, label: prop, type: 'dataProperty', attrs: dpAttrs }, position: pos });
          // Link edge is a visual connector; keep it as objectProperty for consistency
          const edgeAttrs = addCreationMetadata({});
          ontoState.cy.add({ group: 'edges', data: { id: `edp${Date.now()}`, source: sel[0].id(), target: pid, predicate: prop, type: 'objectProperty', attrs: edgeAttrs } });
          refreshOntologyTree();
        } else if (ontoType === 'note') {
          const nid = `Note${Date.now()}`;
          const text = `Note ${nid.slice(-4)}`;
          
          // Add note with proper metadata
          const attrs = addCreationMetadata({ 
            noteType: 'Note',
            author: getCurrentUsername() // Keep legacy field for backward compatibility
          });
          
          ontoState.cy.add({ 
            group: 'nodes', 
            data: { 
              id: nid, 
              label: text, 
              type: 'note', 
              attrs 
            }, 
            position: pos, 
            classes: 'note' 
          });
          // If exactly one class is selected, auto-link note -> class
          const sel = ontoState.cy.nodes(':selected').filter(n => (n.data('type')||'class') === 'class');
          if (sel && sel.length === 1) {
            const edgeAttrs = addCreationMetadata({});
            ontoState.cy.add({ group: 'edges', data: { id: `enote${Date.now()}`, source: nid, target: sel[0].id(), predicate: 'note_for', type: 'note', attrs: edgeAttrs } });
          }
          refreshOntologyTree(); persistOntologyToLocalStorage();
        }
        persistOntologyToLocalStorage();
      });
      // Bind autosave on edits (add/remove/data/position)
      try {
        const autosave = debounce(() => { try { if (activeOntologyIri) persistOntologyToLocalStorage(); } catch(_) {} }, 250);
        ontoState.cy.on('add remove data position', autosave);
        ontoState.autosaveBound = true;
        
        // Update modification metadata when elements are moved
        ontoState.cy.on('position', 'node', (evt) => {
          try {
            const node = evt.target;
            if (!node.hasClass('imported')) { // Don't update metadata for imported elements
              const currentAttrs = node.data('attrs') || {};
              const updatedAttrs = updateModificationMetadata(currentAttrs);
              node.data('attrs', updatedAttrs);
            }
          } catch(_) {}
        });
      } catch(_) {}
      
      // Initialize element IRI display
      updateElementIriDisplay();
    }

    async function addClassNode(label) {
      ensureOntologyInitialized();
      const id = `Class${ontoState.nextId++}`;
      const x = 100 + Math.random() * 400;
      const y = 100 + Math.random() * 300;
      
      // Add to Cytoscape graph first with metadata
      const attrs = addCreationMetadata({});
      ontoState.cy.add({ group: 'nodes', data: { id, label, type: 'class', attrs }, position: { x, y } });
      
      // Call backend API to persist to Fuseki with correct graph context
      try {
        const graphUri = activeOntologyIri;
        const url = graphUri ? `/api/ontology/classes?graph=${encodeURIComponent(graphUri)}` : '/api/ontology/classes';
        
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('odras_token')}`
          },
          body: JSON.stringify({
            name: id,
            label: label,
            comment: ''
          })
        });
        
        if (response.ok) {
          console.log('✅ Class created in Fuseki:', label);
        } else {
          console.error('❌ Failed to create class in Fuseki:', response.status, response.statusText);
        }
      } catch (error) {
        console.error('❌ Error creating class in Fuseki:', error);
      }
      
      refreshOntologyTree();
      persistOntologyToLocalStorage();
    }

    async function addClassNodeAt(label, position) {
      ensureOntologyInitialized();
      const id = `Class${ontoState.nextId++}`;
      
      // Add to Cytoscape graph first with metadata
      const attrs = addCreationMetadata({});
      ontoState.cy.add({ group: 'nodes', data: { id, label, type: 'class', attrs }, position });
      
      // Call backend API to persist to Fuseki with correct graph context
      try {
        const graphUri = activeOntologyIri;
        const url = graphUri ? `/api/ontology/classes?graph=${encodeURIComponent(graphUri)}` : '/api/ontology/classes';
        
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('odras_token')}`
          },
          body: JSON.stringify({
            name: id,
            label: label,
            comment: ''
          })
        });
        
        if (response.ok) {
          console.log('✅ Class created in Fuseki:', label);
        } else {
          console.error('❌ Failed to create class in Fuseki:', response.status, response.statusText);
        }
      } catch (error) {
        console.error('❌ Error creating class in Fuseki:', error);
      }
      
      refreshOntologyTree();
      persistOntologyToLocalStorage();
      return id;
    }

    function runAutoLayout() {
      // Legacy function - now uses advanced layout
      runAdvancedLayout('cose');
    }

    function runAdvancedLayout(layoutType) {
      ensureOntologyInitialized();
      if (!ontoState.cy) return;

      let layoutOptions = {
        animate: true,
        animationDuration: 800,
        animationEasing: 'ease-out'
      };

      switch (layoutType) {
        case 'grid':
          layoutOptions = {
            ...layoutOptions,
            name: 'grid',
            cols: Math.ceil(Math.sqrt(ontoState.cy.nodes().length)),
            rows: Math.ceil(ontoState.cy.nodes().length / Math.ceil(Math.sqrt(ontoState.cy.nodes().length))),
            spacingFactor: 1.5
          };
          break;

        case 'circle':
          layoutOptions = {
            ...layoutOptions,
            name: 'circle',
            radius: Math.max(200, ontoState.cy.nodes().length * 30),
            spacingFactor: 1.2
          };
          break;

        case 'concentric':
          layoutOptions = {
            ...layoutOptions,
            name: 'concentric',
            concentric: (node) => {
              // Use node degree as concentric level
              return node.degree();
            },
            levelWidth: (nodes) => {
              return Math.max(100, nodes.length * 20);
            },
            spacingFactor: 1.5
          };
          break;

        case 'breadthfirst':
          layoutOptions = {
            ...layoutOptions,
            name: 'breadthfirst',
            directed: true,
            spacingFactor: 1.5,
            avoidOverlap: true,
            nodeDimensionsIncludeLabels: true
          };
          break;

        case 'cose':
          layoutOptions = {
            ...layoutOptions,
            name: 'cose',
            idealEdgeLength: 150,
            nodeOverlap: 20,
            refresh: 20,
            fit: true,
            padding: 30,
            randomize: false,
            componentSpacing: 100,
            nodeRepulsion: 400000,
            edgeElasticity: 100,
            nestingFactor: 5,
            gravity: 80,
            numIter: 1000,
            initialTemp: 200,
            coolingFactor: 0.95,
            minTemp: 1.0
          };
          break;

        case 'dagre':
          layoutOptions = {
            ...layoutOptions,
            name: 'dagre',
            rankDir: 'TB', // Top to Bottom
            rankSep: 100,
            nodeSep: 50,
            edgeSep: 10,
            ranker: 'tight-tree'
          };
          break;

        case 'cola':
          layoutOptions = {
            ...layoutOptions,
            name: 'cola',
            animate: true,
            refresh: 1,
            maxSimulationTime: 4000,
            ungrabifyWhileSimulating: false,
            fit: true,
            padding: 30,
            randomize: false,
            avoidOverlap: true,
            handleDisconnected: true,
            convergenceThreshold: 0.01,
            nodeSpacing: 20,
            flow: { axis: 'y', minSeparation: 30 },
            alignment: undefined,
            gapInequalities: undefined,
            centerGraph: true
          };
          break;

        case 'spread':
          layoutOptions = {
            ...layoutOptions,
            name: 'spread',
            minDist: 100,
            expandingFactor: -1.0,
            maxExpandingIterations: 4,
            maxContractingIterations: 4,
            initialTemp: 200,
            finalTemp: 0.1,
            coolingFactor: 0.99
          };
          break;

        default:
          console.warn('Unknown layout type:', layoutType);
          layoutOptions.name = 'cose';
      }

      try {
        const layout = ontoState.cy.layout(layoutOptions);
      layout.run();
        
        // Fit the graph after layout completes
        setTimeout(() => {
          ontoState.cy.fit(undefined, 20);
        }, layoutOptions.animationDuration + 100);
        
      } catch (error) {
        console.error('Layout error:', error);
        // Fallback to basic cose layout
        const fallbackLayout = ontoState.cy.layout({ 
          name: 'cose', 
          animate: true, 
          animationDuration: 500 
        });
        fallbackLayout.run();
      }
    }

    function setConnectMode(enabled) {
      ensureOntologyInitialized();
      ontoState.connectMode = !!enabled;
      const btn = qs('#ontoConnectBtn');
      if (btn) btn.style.borderColor = enabled ? '#60a5fa' : 'var(--border)';
      if (ontoState.eh) {
        if (enabled) ontoState.eh.enableDrawMode(); else ontoState.eh.disableDrawMode();
      } else {
        if (!enabled) ontoState.clickConnectFrom = null;
      }
    }

    function ensureAttributesExist() {
      // Ensure all nodes have an attrs property
      ontoState.cy.nodes().forEach(n => {
        if (!n.data('attrs')) {
          n.data('attrs', {});
        }
      });
      
      // Ensure all edges have an attrs property
      ontoState.cy.edges().forEach(e => {
        if (!e.data('attrs')) {
          e.data('attrs', {});
        }
      });
    }

    // Ontology loading progress indicator functions
    function showOntologyLoadingIndicator() {
      // Remove any existing indicator
      hideOntologyLoadingIndicator();
      
      // Create loading overlay
      const overlay = document.createElement('div');
      overlay.id = 'ontology-loading-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      `;
      
      const container = document.createElement('div');
      container.style.cssText = `
        background: white;
        border-radius: 12px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        text-align: center;
        min-width: 300px;
        max-width: 500px;
      `;
      
      const title = document.createElement('h3');
      title.textContent = 'Loading Ontology';
      title.style.cssText = `
        margin: 0 0 20px 0;
        color: #333;
        font-size: 18px;
        font-weight: 600;
      `;
      
      const progressBar = document.createElement('div');
      progressBar.style.cssText = `
        width: 100%;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 15px;
      `;
      
      const progressFill = document.createElement('div');
      progressFill.id = 'ontology-progress-fill';
      progressFill.style.cssText = `
        height: 100%;
        background: linear-gradient(90deg, #4CAF50, #45a049);
        width: 0%;
        transition: width 0.3s ease;
        border-radius: 4px;
      `;
      
      const statusText = document.createElement('div');
      statusText.id = 'ontology-status-text';
      statusText.textContent = 'Initializing...';
      statusText.style.cssText = `
        color: #666;
        font-size: 14px;
        margin-bottom: 10px;
      `;
      
      const progressText = document.createElement('div');
      progressText.id = 'ontology-progress-text';
      progressText.textContent = '0%';
      progressText.style.cssText = `
        color: #999;
        font-size: 12px;
      `;
      
      progressBar.appendChild(progressFill);
      container.appendChild(title);
      container.appendChild(progressBar);
      container.appendChild(statusText);
      container.appendChild(progressText);
      overlay.appendChild(container);
      document.body.appendChild(overlay);
    }

    function updateOntologyLoadingProgress(status, percentage) {
      const statusText = document.getElementById('ontology-status-text');
      const progressText = document.getElementById('ontology-progress-text');
      const progressFill = document.getElementById('ontology-progress-fill');
      
      if (statusText) statusText.textContent = status;
      if (progressText) progressText.textContent = `${percentage}%`;
      if (progressFill) progressFill.style.width = `${percentage}%`;
    }

    function hideOntologyLoadingIndicator() {
      const overlay = document.getElementById('ontology-loading-overlay');
      if (overlay) {
        overlay.remove();
      }
    }

    // Lazy load additional metadata when user clicks on elements
    async function loadAdditionalMetadataForElement(elementId, graphIri) {
      try {
        // Check if we already have rich metadata for this element
        const element = ontoState.cy.getElementById(elementId);
        if (!element || element.data('attrs')?.definition) {
          return; // Already loaded or element doesn't exist
        }

        // Fetch additional metadata for this specific element
        const query = `
          PREFIX owl: <http://www.w3.org/2002/07/owl#>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX dc11: <http://purl.org/dc/elements/1.1/>
          SELECT ?label ?comment ?definition ?example ?identifier WHERE {
            GRAPH <${graphIri}> { 
              <${elementId}> rdfs:label ?label .
              OPTIONAL { <${elementId}> rdfs:comment ?comment }
              OPTIONAL { <${elementId}> skos:definition ?definition }
              OPTIONAL { <${elementId}> skos:example ?example }
              OPTIONAL { <${elementId}> dc11:identifier ?identifier }
            } 
          }`;

        const response = await authenticatedFetch('/api/ontology/sparql', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query })
        });

        if (response.ok) {
          const result = await response.json();
          if (result.results?.bindings?.length > 0) {
            const binding = result.results.bindings[0];
            const attrs = element.data('attrs') || {};
            
            // Add the additional metadata
            if (binding.definition) attrs.definition = binding.definition.value;
            if (binding.example) attrs.example = binding.example.value;
            if (binding.identifier) attrs.identifier = binding.identifier.value;
            if (binding.comment) attrs.comment = binding.comment.value;
            
            element.data('attrs', attrs);
            
            // Update the properties panel if this element is selected
            if (ontoState.selectedElement && ontoState.selectedElement.id() === elementId) {
              updatePropertiesPanelFromSelection();
            }
          }
        }
      } catch (error) {
        console.error('Error loading additional metadata:', error);
      }
    }

    function exportOntologyJSON() {
      ensureOntologyInitialized();
      ensureAttributesExist(); // Make sure all elements have attrs property
      const nodes = ontoState.cy.nodes().map(n => ({ data: n.data(), position: n.position() }));
      const edges = ontoState.cy.edges().map(e => ({ data: e.data() }));
      const payload = { nodes, edges };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'ontology.json';
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
    }

    function slugId(text) {
      return String(text||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
    }

    function iriMapKey(graphIri) { return 'onto_iri_map__' + encodeURIComponent(graphIri); }
    function loadIriMap(graphIri) { try { return JSON.parse(localStorage.getItem(iriMapKey(graphIri))||'{}'); } catch(_) { return {}; } }
    function saveIriMap(graphIri, map) { try { localStorage.setItem(iriMapKey(graphIri), JSON.stringify(map||{})); } catch(_) {} }

    function toTurtle(graphIri, linkedPairsOpt) {
      // Build per-graph stable id→IRI map
      const iriMap = loadIriMap(graphIri);
      const lines = [
        '@prefix owl: <http://www.w3.org/2002/07/owl#> .',
        '@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .',
        (()=>{ try {
          const labels = loadOntologyLabelMap(activeProject);
          const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : null;
          const scopedName = pid ? (localStorage.getItem(`onto_model_name__${pid}`) || '') : '';
          const mapLabel = labels[graphIri] || '';
          const tail = (graphIri.split('/').pop()||graphIri);
          // Prefer the actively edited model name, then label map, then IRI tail
          const chosen = ((activeOntologyIri === graphIri && scopedName.trim()) || mapLabel || tail);
          const lbl = String(chosen||'');
          return `\n<${graphIri}> a owl:Ontology ; rdfs:label "${String(lbl||'').replace(/\\/g,'\\\\').replace(/"/g,'\\"')}" .\n`;
        } catch(_) { return `\n<${graphIri}> a owl:Ontology .\n`; } })()
      ];
      // Include owl:imports from local storage
      try {
        const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(graphIri)) || '[]');
        imports.forEach(imp => { lines.push(`<${graphIri}> <http://www.w3.org/2002/07/owl#imports> <${imp}> .`); });
      } catch(_) {}
      const nodes = ontoState.cy.nodes();
      const edges = ontoState.cy.edges();
      function nodeIri(n) {
        const id = n.id();
        if (iriMap[id]) return iriMap[id];
        const explicit = n.data('iri');
        if (explicit) { iriMap[id] = explicit; return explicit; }
        
        // Use model namespace instead of graph IRI for element IRIs
        const modelNamespace = getModelNamespace();
        const base = slugId(n.data('label')||id)||id;
        const iri = `${modelNamespace}#${base}`;
        iriMap[id] = iri;
        return iri;
      }
      // Classes and data properties (exclude imported overlays)
      nodes.forEach(n => {
        if (n.hasClass && n.hasClass('imported')) return;
        const t = n.data('type')||'class';
        const iri = nodeIri(n);
        const label = (n.data('label')||'').replace(/\\/g,'\\\\').replace(/"/g,'\\"');
        if (t === 'class') {
          lines.push(`<${iri}> a owl:Class ; rdfs:label "${label}" .`);
        } else if (t === 'dataProperty') {
          lines.push(`<${iri}> a owl:DatatypeProperty ; rdfs:label "${label}" .`);
          const incoming = n.incomers('edge');
          if (incoming && incoming.length) {
            const src = incoming[0].source();
            const srcIri = nodeIri(src);
            lines.push(`<${iri}> rdfs:domain <${srcIri}> .`);
            lines.push(`<${iri}> rdfs:range <http://www.w3.org/2001/XMLSchema#string> .`);
          }
        }
      });
      // Object properties from edges
      const existingEquiv = new Set();
      edges.forEach(e => {
        if (e.hasClass && (e.hasClass('imported') || e.hasClass('imported-equivalence'))) return;
        const s = e.source(); const t = e.target();
        const pred = (e.data('predicate')||'relatedTo').replace(/\\/g,'\\\\').replace(/"/g,'\\"');
        const modelNamespace = getModelNamespace();
        const propIri = `${modelNamespace}#${slugId(pred)}`;
        const sIri = nodeIri(s); const tIri = nodeIri(t);
        const isData = (e.data('type')||'objectProperty') === 'dataProperty';
        const sType = (s.data('type')||'class'); const tType = (t.data('type')||'class');
        if (!isData) {
          if (sType === 'class' && tType === 'class') {
            // Treat special case for equivalence edges represented in UI as predicate 'equivalentClass'
            if (pred === 'equivalentClass' || pred === 'linked_by') {
              const key = `${sIri}|${tIri}`;
              if (!existingEquiv.has(key)) {
                existingEquiv.add(key);
                lines.push(`<${sIri}> owl:equivalentClass <${tIri}> .`);
              }
            } else {
              lines.push(`<${propIri}> a owl:ObjectProperty ; rdfs:label "${pred}" ; rdfs:domain <${sIri}> ; rdfs:range <${tIri}> .`);
            }
          } else if (sType === 'note' && (tType === 'class' || tType === 'dataProperty') && pred === 'note_for') {
            // Emit as annotation on target element
            const text = (s.data('label')||'').replace(/\\/g,'\\\\').replace(/"/g,'\\"');
            lines.push(`<${tIri}> rdfs:comment "${text}" .`);
          }
        }
      });
      // Add auto-computed equivalence pairs (no UI edges) if provided
      if (Array.isArray(linkedPairsOpt)) {
        linkedPairsOpt.forEach(p => {
          try {
            const n = p.baseNode; const targetIri = p.importIri;
            const sIri = nodeIri(n);
            const key = `${sIri}|${targetIri}`;
            if (!existingEquiv.has(key)) {
              existingEquiv.add(key);
              lines.push(`<${sIri}> owl:equivalentClass <${targetIri}> .`);
            }
          } catch(_) {}
        });
      }
      saveIriMap(graphIri, iriMap);
      return lines.join('\n');
    }

    // Compute linked_by pairs between base classes and imported graphs by label/local name
    async function computeLinkedByPairs(graphIri) {
      try {
        const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(graphIri)) || '[]');
        if (!imports || !imports.length || !ontoState.cy) return [];
        const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type')||'class') === 'class' && !n.hasClass('imported'));
        const norm = (s) => String(s||'').trim().toLowerCase();
        const baseByLabel = new Map();
        baseClasses.forEach(n => { baseByLabel.set(norm(n.data('label')||n.id()), n); });
        const pairs = [];
        for (const imp of imports) {
          const q = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?c ?label WHERE { GRAPH <${imp}> { ?c a owl:Class . OPTIONAL { ?c rdfs:label ?label } } }`;
          const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
          if (!res.ok) continue;
          const json = await res.json();
          const rows = (json && json.results && json.results.bindings) ? json.results.bindings : [];
          rows.forEach(b => {
            const iri = b.c && b.c.value; const label = b.label && b.label.value;
            const local = iri ? (iri.includes('#') ? iri.split('#').pop() : iri.split('/').pop()) : '';
            const key = norm(label || local);
            const base = baseByLabel.get(key);
            if (base && iri) pairs.push({ baseNode: base, importIri: iri });
          });
        }
        // Deduplicate pairs by base id + target iri
        const out = [];
        const seen = new Set();
        pairs.forEach(p => { const k = p.baseNode.id() + '|' + p.importIri; if (!seen.has(k)) { seen.add(k); out.push(p); } });
        return out;
      } catch(_) { return []; }
    }

    // Imported overlay visibility persistence
    function visibleImportsKey(graphIri) { return 'onto_imports_visible__' + encodeURIComponent(graphIri || ''); }
    function loadVisibleImports(graphIri) { try { return new Set(JSON.parse(localStorage.getItem(visibleImportsKey(graphIri)) || '[]')); } catch(_) { return new Set(); } }
    function saveVisibleImports(graphIri, set) { try { localStorage.setItem(visibleImportsKey(graphIri), JSON.stringify(Array.from(set || []))); } catch(_) {} }

    // Reference ontology selector
    async function showReferenceOntologySelector() {
      try {
        const token = localStorage.getItem(tokenKey);
        const res = await fetch('/api/ontologies/reference', {
          headers: { Authorization: 'Bearer ' + token }
        });
        
        if (!res.ok) {
          throw new Error('Failed to fetch reference ontologies');
        }
        
        const json = await res.json();
        const referenceOntologies = json.reference_ontologies || [];
        
        // Create overlay
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.inset = '0';
        overlay.style.background = 'rgba(0,0,0,0.4)';
        overlay.style.zIndex = '9998';
        
        const panel = document.createElement('div');
        panel.style.position = 'fixed';
        panel.style.top = '10%';
        panel.style.left = '50%';
        panel.style.transform = 'translateX(-50%)';
        panel.style.background = 'var(--panel)';
        panel.style.border = '1px solid var(--border)';
        panel.style.borderRadius = '12px';
        panel.style.padding = '20px';
        panel.style.minWidth = '600px';
        panel.style.maxWidth = '80vw';
        panel.style.maxHeight = '80vh';
        panel.style.overflow = 'auto';
        panel.style.zIndex = '9999';
        
        panel.innerHTML = `
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <h3 style="margin:0;">Import Reference Ontology</h3>
            <button id="refOntClose" class="btn" style="background: var(--muted);">Close</button>
          </div>
          
          
          <!-- Existing Reference Ontologies Section -->
          <div>
            <h4 style="margin:0 0 12px 0;">📚 Existing Reference Ontologies</h4>
            <div id="refOntList" style="max-height:300px; overflow-y:auto;">
              ${referenceOntologies.length === 0 ? 
                '<div style="text-align:center; color:var(--muted); padding:20px;">No reference ontologies available</div>' :
                referenceOntologies.map(onto => `
                  <div style="display:flex; justify-content:space-between; align-items:center; border:1px solid var(--border); border-radius:8px; padding:12px; margin-bottom:8px; cursor:pointer;" 
                       data-graph-iri="${onto.graph_iri}" class="ref-onto-item">
                    <div>
                      <div style="font-weight:500;">${onto.label || onto.graph_iri.split('/').pop()}</div>
                      <div style="font-size:0.9em; color:var(--muted);">${onto.project_name} • ${onto.graph_iri}</div>
                    </div>
                    <button class="btn" data-graph-iri="${onto.graph_iri}">Import</button>
                  </div>
                `).join('')
              }
            </div>
          </div>
        `;
        
        document.body.appendChild(overlay);
        document.body.appendChild(panel);
        
        const close = () => {
          try {
            document.body.removeChild(panel);
            document.body.removeChild(overlay);
          } catch(_) {}
        };
        
        panel.querySelector('#refOntClose').onclick = close;
        overlay.onclick = close;
        
        
        // Add hover effects for existing ontologies
        panel.querySelectorAll('.ref-onto-item').forEach(item => {
          item.onmouseover = () => item.style.background = 'var(--hover)';
          item.onmouseout = () => item.style.background = 'transparent';
        });
        
        // Handle import clicks for existing ontologies
        const listEl = panel.querySelector('#refOntList');
        listEl.addEventListener('click', async (e) => {
          const btn = e.target.closest('button[data-graph-iri]');
          if (!btn) return;
          
          const graphIri = btn.getAttribute('data-graph-iri');
          const importsKey = 'onto_imports__' + encodeURIComponent(activeOntologyIri || '');
          
          try {
            const curr = new Set(JSON.parse(localStorage.getItem(importsKey) || '[]'));
            console.log('🔍 Current imports:', Array.from(curr));
            console.log('🔍 Adding import:', graphIri);
            if (!curr.has(graphIri)) {
              curr.add(graphIri);
              localStorage.setItem(importsKey, JSON.stringify(Array.from(curr)));
              console.log('🔍 Import added, refreshing tree...');
              refreshOntologyTree();
              toast('Reference ontology imported successfully');
            } else {
              console.log('🔍 Import already exists');
              toast('Reference ontology already imported', true);
            }
            close();
          } catch(err) {
            console.error('🔍 Error importing reference ontology:', err);
            toast('Failed to import reference ontology', true);
          }
        });
        
      } catch(err) {
        toast('Failed to load reference ontologies', true);
      }
    }

    // Persist per-import overlay node positions
    function overlayPositionsKey(baseIri, importIri) { return 'onto_import_positions__' + encodeURIComponent(baseIri || '') + '__' + encodeURIComponent(importIri || ''); }
    function loadOverlayPositions(baseIri, importIri) { try { return JSON.parse(localStorage.getItem(overlayPositionsKey(baseIri, importIri)) || '{}'); } catch(_) { return {}; } }
    function saveOverlayPositions(baseIri, importIri, obj) { try { localStorage.setItem(overlayPositionsKey(baseIri, importIri), JSON.stringify(obj || {})); } catch(_) {} }

    // Collapsed imports persistence
    function collapsedImportsKey(baseIri) { return 'onto_collapsed_imports__' + encodeURIComponent(baseIri || ''); }
    function loadCollapsedImports(baseIri) { 
      try { 
        const data = localStorage.getItem(collapsedImportsKey(baseIri));
        return data ? new Set(JSON.parse(data)) : new Set(); 
      } catch(_) { 
        return new Set(); 
      } 
    }
    function saveCollapsedImports(baseIri, collapsedSet) { 
      try { 
        localStorage.setItem(collapsedImportsKey(baseIri), JSON.stringify(Array.from(collapsedSet))); 
      } catch(_) {} 
    }

    // Pseudo-node positions persistence
    function pseudoNodePositionsKey(baseIri) { return 'onto_pseudo_positions__' + encodeURIComponent(baseIri || ''); }
    function loadPseudoNodePositions(baseIri) { 
      try { 
        return JSON.parse(localStorage.getItem(pseudoNodePositionsKey(baseIri)) || '{}'); 
      } catch(_) { 
        return {}; 
      } 
    }
    function savePseudoNodePositions(baseIri, positions) { 
      try { 
        localStorage.setItem(pseudoNodePositionsKey(baseIri), JSON.stringify(positions || {})); 
      } catch(_) {} 
    }

    // Visibility state persistence
    function visibilityStateKey(baseIri) { return 'onto_visibility_state__' + encodeURIComponent(baseIri || ''); }
    function loadVisibilityState(baseIri) { 
      try { 
        const saved = JSON.parse(localStorage.getItem(visibilityStateKey(baseIri)) || '{}');
        return {
          classes: saved.classes !== undefined ? saved.classes : true,
          dataProperties: saved.dataProperties !== undefined ? saved.dataProperties : true,
          notes: saved.notes !== undefined ? saved.notes : true,
          edges: saved.edges !== undefined ? saved.edges : true,
          imported: saved.imported !== undefined ? saved.imported : true
        };
      } catch(_) { 
        return {
          classes: true,
          dataProperties: true,
          notes: true,
          edges: true,
          imported: true
        }; 
      } 
    }
    function saveVisibilityState(baseIri, state) { 
      try { 
        localStorage.setItem(visibilityStateKey(baseIri), JSON.stringify(state || {})); 
      } catch(_) {} 
    }

    // Individual element visibility persistence
    function elementVisibilityKey(baseIri) { return 'onto_element_visibility__' + encodeURIComponent(baseIri || ''); }
    function loadElementVisibility(baseIri) { 
      try { 
        return JSON.parse(localStorage.getItem(elementVisibilityKey(baseIri)) || '{}'); 
      } catch(_) { 
        return {}; 
      } 
    }
    function saveElementVisibility(baseIri, visibility) { 
      try { 
        localStorage.setItem(elementVisibilityKey(baseIri), JSON.stringify(visibility || {})); 
      } catch(_) {} 
    }

    async function fetchImportGraphSnapshot(importIri) {
      try {
        // First try to get data from local storage (consistent with importEquivCount)
        const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
        const importKey = `onto_graph__${pid}__` + encodeURIComponent(importIri);
        let importData = localStorage.getItem(importKey);
        
        if (!importData) {
          console.log('🔍 No local storage data found for import snapshot, attempting to load from API:', importIri);
          try {
            // Try to load the imported ontology data from API
            const token = localStorage.getItem(tokenKey);
            const apiUrl = `/api/ontology/?graph=${encodeURIComponent(importIri)}`;
            const response = await fetch(apiUrl, {
              headers: token ? { 'Authorization': `Bearer ${token}` } : {}
            });
            
            if (response.ok) {
              const ontologyData = await response.json();
              console.log('🔍 Loaded imported ontology from API for snapshot:', ontologyData);
              console.log('🔍 Snapshot API response structure - classes:', ontologyData.classes);
              console.log('🔍 Snapshot API response structure - object_properties:', ontologyData.object_properties);
              
              // Convert to Cytoscape format and save to local storage
              // Use a simpler conversion since we don't have rich metadata
              // The API response has the data nested in a 'data' property
              const actualOntologyData = ontologyData.data || ontologyData;
              const cytoscapeData = convertOntologyToCytoscape(actualOntologyData);
              console.log('🔍 Snapshot converted cytoscape data:', cytoscapeData);
              const storageData = {
                nodes: cytoscapeData.nodes || [],
                edges: cytoscapeData.edges || [],
                timestamp: Date.now(),
                source: 'api'
              };
              
              localStorage.setItem(importKey, JSON.stringify(storageData));
              importData = JSON.stringify(storageData);
              console.log('🔍 Saved imported ontology data to local storage for snapshot');
            } else {
              console.log('🔍 Failed to load imported ontology from API for snapshot:', response.status);
              // Fall through to SPARQL fallback
            }
          } catch (err) {
            console.error('🔍 Error loading imported ontology for snapshot:', err);
            // Fall through to SPARQL fallback
          }
        }
        
        // Check if cached data is empty and force reload
        if (importData) {
          const cachedData = JSON.parse(importData);
          if (cachedData.nodes && cachedData.nodes.length === 0 && cachedData.edges && cachedData.edges.length === 0) {
            console.log('🔍 Snapshot cached data is empty, forcing reload from API:', importIri);
            try {
              const token = localStorage.getItem(tokenKey);
              const apiUrl = `/api/ontology/?graph=${encodeURIComponent(importIri)}`;
              const response = await fetch(apiUrl, {
                headers: token ? { 'Authorization': `Bearer ${token}` } : {}
              });
              
              if (response.ok) {
                const ontologyData = await response.json();
                console.log('🔍 Snapshot reloaded imported ontology from API:', ontologyData);
                console.log('🔍 Snapshot reload API response structure - classes:', ontologyData.classes);
                console.log('🔍 Snapshot reload API response structure - object_properties:', ontologyData.object_properties);
                
                // Convert to Cytoscape format and save to local storage
                // The API response has the data nested in a 'data' property
                const actualOntologyData = ontologyData.data || ontologyData;
                console.log('🔍 Snapshot reload actual ontology data being passed to convertOntologyToCytoscape:', actualOntologyData);
                console.log('🔍 Snapshot reload actualOntologyData.classes:', actualOntologyData.classes);
                const cytoscapeData = convertOntologyToCytoscape(actualOntologyData);
                console.log('🔍 Snapshot reload converted cytoscape data:', cytoscapeData);
                const storageData = {
                  nodes: cytoscapeData.nodes || [],
                  edges: cytoscapeData.edges || [],
                  timestamp: Date.now(),
                  source: 'api'
                };
                
                localStorage.setItem(importKey, JSON.stringify(storageData));
                importData = JSON.stringify(storageData);
                console.log('🔍 Snapshot reloaded and saved imported ontology data to local storage');
              } else {
                console.log('🔍 Failed to reload imported ontology from API for snapshot:', response.status);
              }
            } catch (err) {
              console.error('🔍 Error reloading imported ontology for snapshot:', err);
            }
          }
        }
        
        if (importData) {
          console.log('🔍 Using local storage data for import snapshot:', importIri);
          const importOntology = JSON.parse(importData);
          console.log('🔍 Import ontology data:', importOntology);
          const importNodes = importOntology.nodes || [];
          const importEdges = importOntology.edges || [];
          console.log('🔍 Import nodes count:', importNodes.length);
          console.log('🔍 Import edges count:', importEdges.length);
          
          // Convert Cytoscape nodes to snapshot format
          const classes = importNodes
            .filter(node => (node.data && node.data.type === 'class') || !node.data?.type)
            .map(node => {
              console.log('🔍 Import node data:', node);
              return {
                iri: node.data?.iri || node.id,
                label: node.data?.label || node.data?.id || node.id,
                comment: node.data?.comment || '',
                attrs: node.data?.attrs || {}
              };
            });
          
          // Convert Cytoscape edges to snapshot format
          const edges = importEdges
            .filter(edge => edge.data && edge.data.source && edge.data.target)
            .map(edge => ({
              sourceIri: edge.data.source,
              targetIri: edge.data.target,
              label: edge.data.predicate || 'relatedTo',
              attrs: edge.data.attrs || {}
            }));
          
          console.log('🔍 Processed edges count:', edges.length);
          
          console.log('🔍 Final import classes:', classes);
          classes.forEach((cls, i) => {
            console.log(`🔍 Class ${i}:`, cls);
          });
          return { classes, edges, importNodes };
        }
        
        // Fallback to SPARQL if no local storage data
        console.log('🔍 No local storage data, using SPARQL for import snapshot:', importIri);
        const qClasses = `
          PREFIX owl: <http://www.w3.org/2002/07/owl#>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX dc11: <http://purl.org/dc/elements/1.1/>
          PREFIX dcterms: <http://purl.org/dc/terms/>
          PREFIX obo: <http://purl.obolibrary.org/obo/>
          SELECT ?c ?label ?comment ?definition ?example ?identifier ?subclassOf ?equivalentClass WHERE {
            GRAPH <${importIri}> { 
              ?c a owl:Class . 
              OPTIONAL { ?c rdfs:label ?label }
              OPTIONAL { ?c rdfs:comment ?comment }
              OPTIONAL { ?c skos:definition ?definition }
              OPTIONAL { ?c skos:example ?example }
              OPTIONAL { ?c dc11:identifier ?identifier }
              OPTIONAL { ?c rdfs:subClassOf ?subclassOf }
              OPTIONAL { ?c owl:equivalentClass ?equivalentClass }
            } 
          }`;
        
        const qProps = `
          PREFIX owl: <http://www.w3.org/2002/07/owl#>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX dc11: <http://purl.org/dc/elements/1.1/>
          PREFIX dcterms: <http://purl.org/dc/terms/>
          SELECT ?p ?label ?comment ?definition ?example ?identifier ?domain ?range ?inverseOf ?subPropertyOf ?equivalentProperty ?propertyType WHERE {
            GRAPH <${importIri}> { 
              ?p a owl:ObjectProperty . 
              OPTIONAL { ?p rdfs:label ?label }
              OPTIONAL { ?p rdfs:comment ?comment }
              OPTIONAL { ?p skos:definition ?definition }
              OPTIONAL { ?p skos:example ?example }
              OPTIONAL { ?p dc11:identifier ?identifier }
              OPTIONAL { ?p rdfs:domain ?domain }
              OPTIONAL { ?p rdfs:range ?range }
              OPTIONAL { ?p owl:inverseOf ?inverseOf }
              OPTIONAL { ?p rdfs:subPropertyOf ?subPropertyOf }
              OPTIONAL { ?p owl:equivalentProperty ?equivalentProperty }
              OPTIONAL { ?p a ?propertyType }
            } 
          }`;
        
        const classesRes = await authenticatedFetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qClasses }) });
        const propsRes = await authenticatedFetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qProps }) });
        const classesJson = classesRes.ok ? await classesRes.json() : { results: { bindings: [] } };
        const propsJson = propsRes.ok ? await propsRes.json() : { results: { bindings: [] } };
        
        // Enhanced class processing with rich metadata
        const cls = (classesJson.results?.bindings || []).map(b => {
          const iri = b.c.value;
          const label = (b.label && b.label.value) || (iri.includes('#') ? iri.split('#').pop() : iri.split('/').pop());
          const attrs = {};
          
          // Store all available metadata
          if (b.comment && b.comment.value) attrs.comment = b.comment.value;
          if (b.definition && b.definition.value) attrs.definition = b.definition.value;
          if (b.example && b.example.value) attrs.example = b.example.value;
          if (b.identifier && b.identifier.value) attrs.identifier = b.identifier.value;
          if (b.subclassOf && b.subclassOf.value) attrs.subclassOf = b.subclassOf.value;
          if (b.equivalentClass && b.equivalentClass.value) attrs.equivalentClass = b.equivalentClass.value;
          
          return { iri, label, attrs };
        });
        
        // Enhanced property processing with rich metadata
        const edges = [];
        (propsJson.results?.bindings || []).forEach(b => {
          const p = b.p.value;
          const label = (b.label && b.label.value) || (p.includes('#') ? p.split('#').pop() : p.split('/').pop());
          const attrs = {};
          
          // Store all available metadata
          if (b.comment && b.comment.value) attrs.comment = b.comment.value;
          if (b.definition && b.definition.value) attrs.definition = b.definition.value;
          if (b.example && b.example.value) attrs.example = b.example.value;
          if (b.identifier && b.identifier.value) attrs.identifier = b.identifier.value;
          if (b.domain && b.domain.value) attrs.domain = b.domain.value;
          if (b.range && b.range.value) attrs.range = b.range.value;
          if (b.inverseOf && b.inverseOf.value) attrs.inverseOf = b.inverseOf.value;
          if (b.subPropertyOf && b.subPropertyOf.value) attrs.subPropertyOf = b.subPropertyOf.value;
          if (b.equivalentProperty && b.equivalentProperty.value) attrs.equivalentProperty = b.equivalentProperty.value;
          if (b.propertyType && b.propertyType.value) attrs.propertyType = b.propertyType.value;
          
          // Create edges for domain-range relationships
          if (b.domain && b.range) {
            edges.push({ 
              sourceIri: b.domain.value, 
              targetIri: b.range.value, 
              label,
              predicate: p,
              attrs
            });
          }
        });
        
        return { classes: cls, edges };
      } catch(_) { return { classes: [], edges: [] }; }
    }

    async function overlayImportsRefresh() {
      try {
        if (!ontoState.cy || !activeOntologyIri) {
          console.log('🔍 overlayImportsRefresh: No cytoscape instance or active ontology');
          return;
        }
        
        const visible = loadVisibleImports(activeOntologyIri);
        const visibleList = Array.from(visible);
        console.log('🔍 overlayImportsRefresh: Visible imports:', visibleList);
        
        // Before removing overlays, snapshot positions for imports being hidden
        try {
        ontoState.cy.nodes('.imported').forEach(n => {
          const imp = n.data('importSource') || '';
          if (!visible.has(imp)) {
            const curr = loadOverlayPositions(activeOntologyIri, imp);
            curr[n.id()] = n.position();
            saveOverlayPositions(activeOntologyIri, imp, curr);
          }
        });
        } catch (err) {
          console.error('🔍 Error saving overlay positions:', err);
        }
        
        // Remove overlays for imports no longer visible
        try {
          const elementsToRemove = ontoState.cy.elements('.imported, .imported-equivalence').filter(el => {
            const importSource = el.data('importSource') || '';
            return !visible.has(importSource);
          });
          console.log('🔍 overlayImportsRefresh: Removing', elementsToRemove.length, 'elements');
          elementsToRemove.remove();
        } catch (err) {
          console.error('🔍 Error removing overlay elements:', err);
        }
        // Add overlays for newly visible imports
        for (const imp of visibleList) {
          const existing = ontoState.cy.elements('.imported').filter(e => (e.data('importSource') || '') === imp);
          if (existing && existing.length) continue;
          const snap = await fetchImportGraphSnapshot(imp);
          const added = [];
          // Compute a simple cluster origin to the right of the base graph to avoid overlap (notes included)
          const baseBBox = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).boundingBox();
          const orderIndex = Math.max(0, visibleList.indexOf(imp));
          const padX = 200, padY = 40, jitterX = orderIndex * 100, jitterY = orderIndex * 60;
          const safe = (n, f)=> (Number.isFinite(n) ? n : f);
          const originX = safe(baseBBox.x2, 0) + padX + jitterX;
          const originY = safe(baseBBox.y1, 0) + jitterY;
          const total = Math.max(1, snap.classes.length);
          const cols = Math.ceil(Math.sqrt(total));
          const spacing = 160;
          let nextIdx = 0;
          function nextPos() {
            const col = nextIdx % cols; const row = Math.floor(nextIdx / cols); nextIdx += 1;
            return { x: originX + col * spacing, y: originY + row * spacing };
          }
          // Add class nodes in a simple grid within the cluster; apply saved positions if available
          const savedPos = loadOverlayPositions(activeOntologyIri, imp);
          console.log('🔍 Loading saved positions for import:', imp, savedPos);
          const isCollapsed = ontoState.collapsedImports.has(imp);
          
          if (isCollapsed) {
            // Create pseudo-node for collapsed import
            const importData = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(activeOntologyIri || '')) || '[]').find(importData => importData.iri === imp);
            const importName = importData?.label || imp.split('/').pop() || imp;
            
            // Check if pseudo-node already exists
            const pseudoNodeId = `pseudo-import-${CSS.escape(imp)}`;
            const existingPseudoNode = ontoState.cy.$(`#${CSS.escape(pseudoNodeId)}`);
            
            if (existingPseudoNode.length === 0) {
              // Load saved position for pseudo-node
              const pseudoPositions = loadPseudoNodePositions(activeOntologyIri);
              let position = pseudoPositions[pseudoNodeId];
              
              if (!position) {
                // Calculate center position for pseudo-node if no saved position
                const baseBBox = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).boundingBox();
                const orderIndex = Math.max(0, visibleList.indexOf(imp));
                const padX = 200, jitterX = orderIndex * 100, jitterY = orderIndex * 60;
                const safe = (n, f)=> (Number.isFinite(n) ? n : f);
                position = {
                  x: safe(baseBBox.x2, 0) + padX + jitterX,
                  y: safe(baseBBox.y1, 0) + jitterY
                };
              }
              
              const pseudoNode = ontoState.cy.add({
                group: 'nodes',
                data: {
                  id: pseudoNodeId,
                  label: importName,
                  type: 'import',
                  importSource: imp,
                  isPseudo: true,
                  attrs: {}
                },
                position: position,
                classes: 'imported pseudo-import'
              });
              added.push(pseudoNode);
            }
          } else {
            // Create all imported nodes normally
          snap.classes.forEach((c, index) => {
            // Use the original node ID from the local storage data if available, otherwise generate one
            const originalId = snap.importNodes?.[index]?.data?.id || `Class${index + 1}`;
            const id = `imp:${imp}#${originalId}`;
              console.log('🔍 Creating imported node with ID:', id, 'originalId:', originalId, 'from snapNode:', snap.importNodes?.[index]);
            if (ontoState.cy.$(`#${CSS.escape(id)}`).length) return;
            const pos = savedPos[id] ? savedPos[id] : nextPos();
              console.log('🔍 Position for', id, ':', pos, 'saved:', !!savedPos[id], 'savedPos keys:', Object.keys(savedPos));
              // Generate proper IRI for imported element using import source namespace
              const elementIri = c.iri || `${imp}#${slugId(c.label) || originalId}`;
              console.log('🔍 Creating imported node:', c.label, 'with IRI:', elementIri, 'from data:', c);
              const node = ontoState.cy.add({ group: 'nodes', data: { id, iri: elementIri, label: c.label, type: 'class', importSource: imp, attrs: c.attrs || {} }, position: pos, classes: 'imported' });
              added.push(node);
            });
          }
          if (isCollapsed) {
            // For collapsed imports, create equivalence edges from pseudo-node to base classes
            const pseudoNodeId = `pseudo-import-${CSS.escape(imp)}`;
            const pseudoNode = ontoState.cy.$(`#${CSS.escape(pseudoNodeId)}`);
            
            if (pseudoNode.length > 0) {
              // Find equivalence relationships by matching imported class labels with base class labels
              const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type')||'class')==='class' && !n.hasClass('imported'));
              const byKey = (s)=>String(s||'').trim().toLowerCase();
              const baseMap = new Map(); 
              baseClasses.forEach(n => baseMap.set(byKey(n.data('label')||n.id()), n));
              
              // Create equivalence edges for each imported class that matches a base class
              snap.classes.forEach(c => {
                const key = byKey(c.label);
                const baseNode = baseMap.get(key);
                if (baseNode) {
                  const equivEdgeId = `pseudo-equiv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                  const equivEdge = ontoState.cy.add({
                    group: 'edges',
                    data: {
                      id: equivEdgeId,
                      source: pseudoNodeId,
                      target: baseNode.id(),
                      predicate: 'equivalentClass',
                      type: 'objectProperty',
                      importSource: imp,
                      isPseudo: true,
                      attrs: {}
                    },
                    classes: 'imported imported-equivalence pseudo-equivalence'
                  });
                  added.push(equivEdge);
                }
              });
            }
          } else {
          // Add edges where both endpoints available; create missing nodes on demand
          let idx = 0;
          snap.edges.forEach(e => {
            const sid = `imp:${imp}#${e.sourceIri}`;
            const tid = `imp:${imp}#${e.targetIri}`;
            if (!ontoState.cy.$(`#${CSS.escape(sid)}`).length) {
              const label = e.sourceIri.includes('#') ? e.sourceIri.split('#').pop() : e.sourceIri.split('/').pop();
              const pos = savedPos[sid] ? savedPos[sid] : nextPos();
                // Use the actual sourceIri as the element IRI
              added.push(ontoState.cy.add({ group: 'nodes', data: { id: sid, iri: e.sourceIri, label, type: 'class', importSource: imp, attrs: e.attrs || {} }, position: pos, classes: 'imported' }));
            }
            if (!ontoState.cy.$(`#${CSS.escape(tid)}`).length) {
              const label = e.targetIri.includes('#') ? e.targetIri.split('#').pop() : e.targetIri.split('/').pop();
              const pos = savedPos[tid] ? savedPos[tid] : nextPos();
                // Use the actual targetIri as the element IRI
              added.push(ontoState.cy.add({ group: 'nodes', data: { id: tid, iri: e.targetIri, label, type: 'class', importSource: imp, attrs: e.attrs || {} }, position: pos, classes: 'imported' }));
            }
              const edge = ontoState.cy.add({ group: 'edges', data: { id: `impE${Date.now()}_${idx++}`, source: sid, target: tid, predicate: e.label, type: 'objectProperty', importSource: imp, attrs: e.attrs || {} }, classes: 'imported' });
              added.push(edge);
          });
          }
          // Make overlays semi-interactive for positioning: allow drag, but don't select or edit
          added.forEach(el => {
            try {
              if (el.isNode && el.isNode()) {
                el.selectable(true); el.grabbable(true); el.locked(false); // Allow selection for imported elements
              } else {
                el.selectable(false); el.grabbable(false); el.locked(true);
              }
            } catch(_) {}
          });
          
          // Add position saving for pseudo-nodes
          added.filter(el => el.data('isPseudo')).forEach(el => {
            el.on('free', () => {
              const pseudoPositions = loadPseudoNodePositions(activeOntologyIri);
              pseudoPositions[el.id()] = { x: el.position('x'), y: el.position('y') };
              savePseudoNodePositions(activeOntologyIri, pseudoPositions);
            });
          });
          
          // Add position saving for imported nodes
          added.filter(el => el.isNode && el.isNode() && el.hasClass('imported') && !el.data('isPseudo')).forEach(el => {
            el.on('free', () => {
              const imp = el.data('importSource');
              if (!imp || !activeOntologyIri) return;
              const curr = loadOverlayPositions(activeOntologyIri, imp);
              curr[el.id()] = el.position();
              console.log('🔍 Saving position for imported element', el.id(), ':', el.position(), 'in import', imp);
              saveOverlayPositions(activeOntologyIri, imp, curr);
            });
          });

          // Add owl:equivalentClass visual links between base and imported nodes (by label/local name)
          // Only create equivalence edges for expanded imports
          if (!isCollapsed) {
          try {
            const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type')||'class')==='class' && !n.hasClass('imported'));
            const imported = ontoState.cy.nodes().filter(n => (n.data('type')||'class')==='class' && n.hasClass('imported') && (n.data('importSource')||'')===imp);
            const byKey = (s)=>String(s||'').trim().toLowerCase();
            const baseMap = new Map(); baseClasses.forEach(n => baseMap.set(byKey(n.data('label')||n.id()), n));
            let idx2 = 0;
            imported.forEach(n => {
              const key = byKey(n.data('label')||n.id());
              const base = baseMap.get(key);
              if (base) {
                const eid = `impEq${Date.now()}_${idx2++}`;
                  const equivEdge = ontoState.cy.add({ group: 'edges', data: { id: eid, source: base.id(), target: n.id(), predicate: 'equivalentClass', type: 'objectProperty', importSource: imp, attrs: {} }, classes: 'imported imported-equivalence' });
                  added.push(equivEdge);
              }
            });
          } catch(_) {}
          }
        }
        // Do not persist imported overlays to base local storage
        refreshOntologyTree();
      } catch(err) {
        console.error('🔍 Error in overlayImportsRefresh:', err);
        // Don't let the error crash the app
      }
    }

    // Context menu helpers
    let cmState = { visible: false, sourceId: null };
    function showMenuAt(x, y) {
      const m = qs('#ontoContextMenu'); if (!m) return;
      m.style.left = x + 'px'; m.style.top = y + 'px'; m.style.display = 'block'; cmState.visible = true;
    }
    function hideMenu() { const m = qs('#ontoContextMenu'); if (!m) return; m.style.display = 'none'; cmState.visible = false; }
    function startConnectFrom(node) {
      cmState.sourceId = node.id();
      node.addClass('connect-source');
    }
    function clearConnectState() {
      if (cmState.sourceId && ontoState.cy) {
        const n = ontoState.cy.$('#' + cmState.sourceId);
        if (n) n.removeClass('connect-source');
      }
      cmState.sourceId = null;
    }

    // Ensure new class IDs do not collide with existing nodes after imports/loads
    function recomputeNextId() {
      try {
        if (!ontoState || !ontoState.cy) return;
        let maxNum = 0;
        ontoState.cy.nodes().forEach(n => {
          try {
            const nid = (n && typeof n.id === 'function') ? n.id() : '';
            const m = /^Class(\d+)$/.exec(String(nid || ''));
            if (m) {
              const num = parseInt(m[1], 10);
              if (!isNaN(num)) maxNum = Math.max(maxNum, num);
            }
          } catch(_) {}
        });
        ontoState.nextId = Math.max(1, maxNum + 1);
      } catch(_) {}
    }

    function importOntologyJSON(obj) {
      ensureOntologyInitialized();
      if (!obj || !Array.isArray(obj.nodes) || !Array.isArray(obj.edges)) return;
      // Clear only base elements, keep imported overlays intact
      ontoState.cy.elements().filter(el => !el.hasClass('imported') && !el.hasClass('imported-equivalence')).remove();
      // Migration guard: filter out any overlays accidentally saved to JSON
      const isOverlayNode = (n) => {
        try {
          const d = (n && n.data) ? n.data : {};
          const id = String(d.id || '');
          const cls = String(n.classes || d.classes || '');
          return !!d.importSource || id.startsWith('imp:') || cls.includes('imported');
        } catch(_) { return false; }
      };
      const baseNodes = (obj.nodes || []).filter(n => !isOverlayNode(n));
      const baseNodeIds = new Set(baseNodes.map(n => (n.data && n.data.id) || ''));
      const baseEdges = (obj.edges || []).filter(e => {
        try {
          const d = (e && e.data) ? e.data : {};
          const cls = String(e.classes || d.classes || '');
          if (d.importSource || cls.includes('imported')) return false;
          if (String(d.predicate || '').toLowerCase() === 'equivalentclass') return false;
          return baseNodeIds.has(d.source) && baseNodeIds.has(d.target);
        } catch(_) { return false; }
      });
      // Add back base nodes and edges only
      ontoState.cy.add(baseNodes.map(n => ({ group: 'nodes', data: n.data, position: n.position })));
      ontoState.cy.add(baseEdges.map(e => ({ group: 'edges', data: e.data })));
      ontoState.cy.fit();
      refreshOntologyTree();
      persistOntologyToLocalStorage();
      // Update ID counter so new classes get unique IDs
      recomputeNextId();
    }

    // Auth/UI gating
    const tokenKey = 'odras_token';
    const userKey = 'odras_user';
    function showAuth(show) {
      qs('#authView').style.display = show ? 'grid' : 'none';
      qs('#mainView').style.display = show ? 'none' : 'grid';
    }
    
    // Global authentication state
    let isAuthenticated = false;
    let authCheckInProgress = false;
    
    // Enhanced fetch wrapper that handles authentication
    async function authenticatedFetch(url, options = {}) {
      const token = localStorage.getItem(tokenKey);
      
      // Add authorization header if token exists
      if (token) {
        options.headers = {
          ...options.headers,
          'Authorization': `Bearer ${token}`
        };
      }
      
      try {
        const response = await fetch(url, options);
        
        // Check for 401 Unauthorized
        if (response.status === 401) {
          console.warn('Authentication failed (401), redirecting to login...');
          handleAuthFailure();
          throw new Error('Authentication required');
        }
        
        return response;
      } catch (error) {
        // Re-throw the error for the caller to handle
        throw error;
      }
    }
    
    // Handle authentication failure
    function handleAuthFailure() {
      if (authCheckInProgress) return; // Prevent multiple simultaneous auth checks
      
      authCheckInProgress = true;
      isAuthenticated = false;
      
      // Clear stored auth data
      localStorage.removeItem(tokenKey);
        localStorage.removeItem(userKey);
      localStorage.removeItem('user'); // Clear full user object
      
      // Clear UI state
        qs('#userMenu').textContent = '';
      activeOntologyIri = null;
      updateOntoGraphLabel();
      
      // Hide admin UI elements since user is no longer authenticated
      updateAdminUIVisibility(false);
      
      // Show login screen
      showAuth(true);
      
      // Show notification
      if (window.toast) {
        window.toast('Session expired. Please log in again.', true);
      }
      
      authCheckInProgress = false;
    }
    
    // Periodic authentication check
    let authCheckInterval = null;
    function startAuthMonitoring() {
      // Check auth status every 30 seconds
      authCheckInterval = setInterval(async () => {
        if (!isAuthenticated) return;
        
        try {
          const token = localStorage.getItem(tokenKey);
          if (!token) {
            handleAuthFailure();
            return;
          }
          
        const response = await fetch('/api/auth/me', { 
            headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!response.ok) {
            handleAuthFailure();
          }
        } catch (error) {
          console.warn('Auth check failed:', error);
          handleAuthFailure();
        }
      }, 30000); // Check every 30 seconds
    }
    
    function stopAuthMonitoring() {
      if (authCheckInterval) {
        clearInterval(authCheckInterval);
        authCheckInterval = null;
      }
    }
    async function initAuth() {
      const token = localStorage.getItem(tokenKey);
      if (!token) { 
        showAuth(true); 
        isAuthenticated = false;
        stopAuthMonitoring();
        // Clear any stale user data
          localStorage.removeItem(userKey);
        localStorage.removeItem('user'); // Clear full user object
          qs('#userMenu').textContent = '';
          return;
        }
      
      try {
        const response = await authenticatedFetch('/api/auth/me');
        
        const me = await response.json();
        if (!me || me.error || !me.username) {
          // Invalid response, clear auth and show login
          handleAuthFailure();
          return;
        }
        
        // Success - user is authenticated
        isAuthenticated = true;
        localStorage.setItem(userKey, me.username);
        localStorage.setItem('user', JSON.stringify(me)); // Store full user object for context menu
        qs('#userMenu').textContent = me.username + (me.is_admin ? ' (admin)' : '');
        showAuth(false);
        
        // Update admin UI elements visibility
        updateAdminUIVisibility(me.is_admin);
        
        // Start monitoring authentication status
        startAuthMonitoring();
      } catch (error) {
        // Network or other error, clear auth and show login
        console.error('Auth check failed:', error);
        handleAuthFailure();
        return;
      }
      // Restore last active workbench before loading projects
      try {
        const urlState = getURLState();
        const hashWB = (()=>{ try { const p = new URLSearchParams(location.hash.replace(/^#/, '')); return p.get('wb') || ''; } catch(_) { return ''; } })();
        const wb = urlState.workbench || hashWB || localStorage.getItem('active_workbench') || 'ontology';
        // Activate matching icon and section
        const icon = qs(`.icon[data-wb="${wb}"]`);
        if (icon) {
          qsa('.icon').forEach(i => i.classList.remove('active')); icon.classList.add('active');
          qsa('.workbench').forEach(w => w.classList.remove('active'));
          const sec = qs('#wb-' + wb); if (sec) sec.classList.add('active');
        }
        // If no workbench got activated (e.g., missing section), default to ontology
        if (!document.querySelector('.workbench.active')) {
          const fallback = qs('.icon[data-wb="ontology"]');
          if (fallback) fallback.click();
        }
        
        // Update admin UI visibility based on current user
        try {
          const userData = JSON.parse(localStorage.getItem('user') || '{}');
          updateAdminUIVisibility(userData.is_admin || false);
        } catch (e) {
          console.error('Failed to parse user data for admin UI visibility:', e);
          updateAdminUIVisibility(false);
        }
        
        // Load admin data if admin workbench is active
        if (wb === 'admin') {
          loadPrefixes();
          loadDomains();
          loadUsers(); // Load user management data
          // Only load namespaces if user is authenticated
          const token = localStorage.getItem('odras_token');
          if (token) {
            loadNamespaces();
          }
        }
      } catch(_) {}
      // Initialize Cytoscape BEFORE loading projects so restore can occur during renderTree
      ensureOntologyInitialized();
      // If Files workbench is already active from restore, initialize its handlers now
      try { if (document.querySelector('#wb-files.workbench.active')) { ensureFilesInitialized(); } } catch(_) {}
      await loadProjects();
      // Load project info if project workbench is active (this is now handled in loadProjects)
      // but we'll keep this as a fallback
      try { if (document.querySelector('#wb-project.workbench.active')) { loadProjectInfo(); } } catch(_) {}
      refreshOntologyTree();
      // Bind Files workbench handlers proactively so Choose Files works immediately
      try { ensureFilesInitialized(); } catch(_) {}
      // Restore ontology tree collapsed state
      try {
        // Restore left project tree width
        const uiMainTreeW = parseInt(localStorage.getItem('ui_main_tree_w') || '0', 10);
        if (uiMainTreeW) document.documentElement.style.setProperty('--tree-w', uiMainTreeW + 'px');
        // Restore ontology left tree width
        const ontoTreeW = parseInt(localStorage.getItem('onto_tree_w') || '0', 10);
        if (ontoTreeW) document.documentElement.style.setProperty('--onto-tree-w', ontoTreeW + 'px');
        const treeCollapsed = localStorage.getItem('onto_tree_collapsed') === '1';
        if (treeCollapsed) {
          const sec = qs('#wb-ontology');
          if (sec && !sec.classList.contains('onto-tree-collapsed')) sec.classList.add('onto-tree-collapsed');
          const icon = qs('#ontoTreeToggleIcon');
          if (icon) icon.innerHTML = '<path d="M9 6l6 6-6 6"/>';
        }
        const propsCollapsed = localStorage.getItem('onto_props_collapsed') === '1';
        if (propsCollapsed) {
          const sec = qs('#wb-ontology');
          if (sec && !sec.classList.contains('onto-props-collapsed')) sec.classList.add('onto-props-collapsed');
          const icon = qs('#ontoPropsToggleIcon');
          if (icon) icon.innerHTML = '<path d="M15 6l-6 6 6 6"/>';
        }
        // Ensure icon SVGs match classes and allow CSS rotation animation to apply
        const treeIcon = qs('#ontoTreeToggleIcon');
        if (treeIcon && !treeCollapsed) treeIcon.innerHTML = '<path d="M15 6l-6 6 6 6"/>';
        const propsIcon = qs('#ontoPropsToggleIcon');
        if (propsIcon && !propsCollapsed) propsIcon.innerHTML = '<path d="M9 6l6 6-6 6"/>';
        const savedW = parseInt(localStorage.getItem('onto_props_w') || '0', 10);
        if (savedW) document.documentElement.style.setProperty('--onto-props-w', savedW + 'px');
        // Do not load any graph here; renderTree handles per-project restore safely
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      } catch(_) {}
    }
    qs('#loginBtn').onclick = async () => {
      const username = qs('#u').value.trim();
      const password = qs('#p').value;
      qs('#loginMsg').textContent = 'Signing in...';
      
      try {
        const res = await fetch('/api/auth/login', { 
          method:'POST', 
          headers:{'Content-Type':'application/json'}, 
          body: JSON.stringify({ username, password }) 
        });
      const json = await res.json();
        
      if (res.ok && json.token) {
        localStorage.setItem(tokenKey, json.token);
        localStorage.setItem(userKey, username);
        qs('#loginMsg').textContent = '';
          await initAuth();
      } else {
        qs('#loginMsg').textContent = json.error || 'Login failed';
        }
      } catch (error) {
        console.error('Login error:', error);
        qs('#loginMsg').textContent = 'Login failed: ' + error.message;
      }
    };
    qs('#logoutBtn').onclick = async () => { 
      // Call backend logout endpoint to invalidate token
      const token = localStorage.getItem(tokenKey);
      if (token) {
        try {
          await fetch('/api/auth/logout', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` }
          });
        } catch (error) {
          console.warn('Logout API call failed:', error);
          // Continue with local logout even if API call fails
        }
      }
      
      // Clear user-specific data from localStorage but preserve URL state
      try {
        // Don't clear active_project_id - let URL state handle it
        localStorage.removeItem('active_ontology_iri');
        localStorage.removeItem('onto_state');
      } catch (error) {
        console.warn('Failed to clear localStorage:', error);
      }
      
      isAuthenticated = false;
      stopAuthMonitoring();
      localStorage.removeItem(tokenKey); 
      localStorage.removeItem(userKey); 
      localStorage.removeItem('user'); // Clear full user object 
      activeOntologyIri = null; 
      updateOntoGraphLabel(); 
      try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {} 
      qs('#userMenu').textContent = '';  // Clear user display
      showAuth(true); 
    };

    // Projects
    async function loadProjects() {
      const res = await authenticatedFetch('/api/projects');
      const json = await res.json();
      const raw = json.projects || [];
      // Normalize backend shape to { id, name }
      const list = raw.map(p => ({
        id: p.id || p.project_id || p.projectId,
        name: p.name || p.project_name || 'Project'
      })).filter(p => !!p.id);
      const selects = [qs('#projectSelect2')];
      if (list.length) {
        // Check URL state first, then localStorage, then default to first project
        const urlState = getURLState();
        const savedPid = (localStorage.getItem('active_project_id') || '').trim();
        const urlProjectId = urlState.projectId;
        
        let selected = list[0];
        let projectIdToUse = null;
        
        // Priority: URL state > localStorage > first available project
        if (urlProjectId) {
          const found = list.find(p => p.id === urlProjectId);
          if (found) {
            selected = found;
            projectIdToUse = urlProjectId;
            console.log('Using project from URL:', urlProjectId);
          } else {
            console.warn('URL project ID not accessible, falling back to localStorage');
          }
        }
        
        if (!projectIdToUse && savedPid) {
          const found = list.find(p => p.id === savedPid);
          if (found) {
            selected = found;
            projectIdToUse = savedPid;
            console.log('Using project from localStorage:', savedPid);
          } else {
            // Saved project ID not found in accessible projects - clear it
            console.warn('Saved project ID not accessible, clearing selection');
            try {
              localStorage.removeItem('active_project_id');
            } catch (error) {
              console.warn('Failed to clear project selection:', error);
            }
          }
        }
        
        // Update localStorage and URL to match selected project
        if (projectIdToUse) {
          try {
            localStorage.setItem('active_project_id', projectIdToUse);
            updateURL(projectIdToUse);
          } catch (error) {
            console.warn('Failed to update project state:', error);
          }
        }
        
        // Update namespace display for initial project
        if (selected) {
          updateNamespaceDisplay(selected.id);
        }
        selects.forEach(sel => { if (sel) { sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join(''); sel.disabled = false; sel.value = selected.id; } });
        await renderTree(selected);
        
        // Load project info if project workbench is active
        if (document.querySelector('#wb-project.workbench.active')) {
          // Small delay to ensure project selection is fully established
          setTimeout(() => {
            loadProjectInfo();
          }, 100);
        }
      } else {
        // No projects: clear tree and show empty state
        console.warn('No accessible projects found, clearing project selection');
        try {
          localStorage.removeItem('active_project_id');
        } catch (error) {
          console.warn('Failed to clear project selection:', error);
        }
        selects.forEach(sel => { if (sel) { sel.innerHTML = '<option value="" disabled selected>Create Project...</option>'; sel.disabled = true; } });
        await renderTree({ id: null, name: '' });
      }
    }
    (function(){
      const npb = qs('#newProjectBtn');
      if (!npb) return;
      npb.onclick = async () => {
        const name = prompt('Project name'); if (!name) return;
        const token = localStorage.getItem(tokenKey);
        const res = await fetch('/api/projects', { method:'POST', headers:{'Content-Type':'application/json', Authorization: 'Bearer ' + token}, body: JSON.stringify({ name }) });
        let pid = '';
        let pname = name;
        if (res.ok) {
          const js = await res.json().catch(()=>({}));
          const proj = js.project || js;
          pid = (proj && (proj.id || proj.project_id || proj.projectId)) || '';
          pname = (proj && proj.name) || name;
          if (pid) try { localStorage.setItem('active_project_id', pid); } catch(_) {}
        }
        // Reload projects, select the created one, and render it
        const pr = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token }}).then(r=>r.json()).catch(()=>({projects:[]}));
        const raw = pr.projects || [];
        const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' })).filter(p => !!p.id);
        const sel = qs('#projectSelect2');
        if (sel) {
          sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
          if (pid && list.find(p => p.id === pid)) sel.value = pid; else if (list.length) sel.value = list[0].id;
          sel.disabled = !list.length;
        }
        const selected = pid ? { id: pid, name: pname } : (list[0] || { id: null, name: '' });
        await renderTree(selected);
      };
    })();
    ['#projectSelect2'].forEach(id => {
      const sel = qs(id); if (!sel) return;
      sel.addEventListener('change', async (e) => {
        const pid = e.target.value;
        try { 
          localStorage.setItem('active_project_id', pid);
          updateURL(pid); // Update URL with new project
        } catch(_) {}
        const token = localStorage.getItem(tokenKey);
        // Save current ontology canvas before switching projects
        try { if (ontoState && ontoState.cy && activeOntologyIri) saveGraphToLocal(activeOntologyIri); } catch(_) {}
        const res = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token }});
        const json = await res.json();
        const raw = json.projects || [];
        const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' }));
        const proj = list.find(p => p.id === pid);
        if (proj) { 
          activeOntologyIri = null; 
          updateOntoGraphLabel(); 
          await renderTree(proj); 
          updateNamespaceDisplay(pid);
          // Update project info page if it's active
          if (document.querySelector('#wb-project.workbench.active')) {
            loadProjectInfo();
          }
        }
      });
    });

    // Plus button near project selector creates a new project
    (function(){
      const btn = qs('#addNodeBtn');
      if (!btn) return;
      btn.addEventListener('click', () => {
        showCreateProjectModal();
      });
    })();

    // Workbench switching
    qsa('.icon').forEach(el => el.onclick = () => {
      qsa('.icon').forEach(i => i.classList.remove('active')); el.classList.add('active');
      const wb = el.getAttribute('data-wb');
      qsa('.workbench').forEach(w => w.classList.remove('active'));
      qs('#wb-' + wb).classList.add('active');
      
      // Load data when switching to specific workbenches
      if (wb === 'admin') {
        loadPrefixes();
        loadDomains();
        // Only load namespaces if user is authenticated
        const token = localStorage.getItem('odras_token');
        if (token) {
          loadNamespaces();
        }
      } else if (wb === 'project') {
        // For project workbench, load project info if we have a project selected
        const currentProjectId = localStorage.getItem('active_project_id');
        if (currentProjectId) {
          loadProjectInfo();
        }
      }
      
      // Persist selected workbench and update URL
      try { 
        localStorage.setItem('active_workbench', wb);
        const currentProjectId = localStorage.getItem('active_project_id');
        updateURL(currentProjectId, wb); // Update URL with workbench
      } catch(_) {}
      // Reflect in hash
      try {
        const params = new URLSearchParams(location.hash.replace(/^#/, ''));
        params.set('wb', wb);
        location.hash = params.toString();
      } catch(_) {}
      if (wb === 'graph') refreshGraphSummary();
      if (wb === 'ontology') { ensureOntologyInitialized(); if (ontoState.cy) ontoState.cy.resize(); }
      if (wb === 'files') { 
        ensureFilesInitialized(); 
        // Load library when files workbench becomes active
        try { 
          if (window.loadLibraryFromApi) {
            setTimeout(() => window.loadLibraryFromApi(), 100); // Small delay to ensure auth/project context is ready
          }
        } catch(_) {} 
      }
    });

    // Tree collapsible sections
    qsa('.section > button').forEach(btn => {
      btn.onclick = (e) => {
        const sec = e.currentTarget.parentElement;
        const expanded = sec.getAttribute('aria-expanded') !== 'false';
        sec.setAttribute('aria-expanded', expanded ? 'false' : 'true');
      };
    });

          // Admin section toggle function
      function toggleSection(header) {
        console.log('🔄 Toggling section...', header);
        const section = header.closest('.section');
        console.log('Section found:', section);
        if (!section) {
          console.error('❌ Section not found');
          return;
        }
        
        const content = section.querySelector('.section-content');
        console.log('Content found:', content);
        if (!content) {
          console.error('❌ Content not found');
          return;
        }
        
        const isCollapsed = section.classList.contains('collapsed');
        console.log('Currently collapsed:', isCollapsed);
        
        // Toggle the collapsed class
        section.classList.toggle('collapsed');
        
        // Toggle display style based on collapsed state
        if (section.classList.contains('collapsed')) {
          content.style.display = 'none';
        } else {
          content.style.display = 'block';
        }
        
        // Update the toggle icon
        const icon = header.querySelector('.section-toggle');
        console.log('Icon found:', icon);
        if (icon) {
          const newIcon = section.classList.contains('collapsed') ? '▶' : '▼';
          icon.textContent = newIcon;
          console.log('✅ Section toggled, icon updated to:', newIcon);
        } else {
          console.error('❌ Icon not found');
        }
      }

    // Resizer
    (function(){
      const res = qs('#resizer');
      const panel = qs('#treePanel');
      let dragging = false;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => {
        dragging = false;
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tree-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tree-w-max'));
        let w = e.clientX - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--iconbar-w'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty('--tree-w', w + 'px');
        try { localStorage.setItem('ui_main_tree_w', String(w)); } catch(_) {}
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    // Ontology panel resizer
    (function(){
      const res = qs('#ontoResizer');
      const panelWidthProp = '--onto-tree-w';
      let dragging = false;
      if (!res) return;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => {
        dragging = false;
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const layout = qs('#wb-ontology .onto-layout'); if (!layout) return;
        const layoutRect = layout.getBoundingClientRect();
        // Grid columns: [tree][divider][iconbar][canvas][divider][props]
        // If tree is collapsed, divider width is 0; math still uses layout left
        let w = e.clientX - layoutRect.left;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-tree-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-tree-w-max'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty(panelWidthProp, w + 'px');
        try { localStorage.setItem('onto_tree_w', String(w)); } catch(_) {}
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    // Properties panel resizer
    (function(){
      const res = qs('#ontoPropsResizer');
      let dragging = false;
      if (!res) return;
      res.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => dragging = false);
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const layoutRect = qs('#wb-ontology .onto-layout')?.getBoundingClientRect();
        if (!layoutRect) return;
        let w = layoutRect.right - e.clientX;
        const min = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-props-w-min'));
        const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--onto-props-w-max'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty('--onto-props-w', w + 'px');
        try { localStorage.setItem('onto_props_w', String(w)); } catch(_) {}
        if (ontoState.cy) ontoState.cy.resize();
      });
    })();

    async function renderTree(project) {
      activeProject = project && project.id ? project : null;
      // Reset active ontology when switching context or when no project
      activeOntologyIri = null;
      updateOntoGraphLabel();
      try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {}
      // Restore per-project active ontology selection (label only)
      try {
        const pid = project && (project.id || project.project_id);
        const savedIri = localStorage.getItem(`onto_active_iri__${pid}`);
        if (savedIri) {
          activeOntologyIri = savedIri;
          updateOntoGraphLabel();
          // Ensure properties panel model name reflects the saved active ontology
          try {
            const labels = loadOntologyLabelMap(project);
            const pid2 = (project && (project.id || project.project_id)) ? (project.id || project.project_id) : 'default';
            const friendly = (labels[savedIri] && String(labels[savedIri]).trim()) || (savedIri.split('/').pop() || savedIri);
            localStorage.setItem(`onto_model_name__${pid2}`, friendly);
            let attrs = {};
            try { attrs = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid2}`) || '{}'); } catch(_) { attrs = {}; }
            attrs.displayLabel = friendly; 
            attrs.graphIri = savedIri;
            // Set namespace based on installation configuration
            attrs.namespace = iri;  // Use the actual graph IRI as namespace
            localStorage.setItem(`onto_model_attrs__${pid2}`, JSON.stringify(attrs));
            updatePropertiesPanelFromSelection();
          } catch(_) {}
          // Attempt to load saved canvas for this active IRI
          try {
            if (ontoState.cy) {
              ontoState.suspendAutosave = true;
              ontoState.cy.elements().remove();
              loadGraphFromLocal(savedIri);
              setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
            }
          } catch(_) {}
        }
      } catch(_) {}
      const root = qs('#treeRoot');
      const makeItem = (id, label, iconCls, children = [], dataAttrs = {}) => {
        const hasChildren = children && children.length > 0;
        const li = document.createElement('li');
        li.setAttribute('role', 'treeitem');
        if (hasChildren) li.setAttribute('aria-expanded', 'true');
        li.dataset.nodeId = id;
        Object.keys(dataAttrs || {}).forEach(k => { li.dataset[k] = dataAttrs[k]; });

        const row = document.createElement('div');
        row.className = 'node-row';
        row.tabIndex = 0;
        row.onclick = async (e) => { selectNode(li); await handleTreeSelection(li); };
        row.onkeydown = (e) => handleKey(e, li);
        // Inline rename on double-click for ontology nodes
        row.ondblclick = (e) => {
          if (li.dataset.nodeType === 'ontology') {
            const current = (li.dataset.label || row.querySelector('.node-label')?.textContent || '').trim();
            const name = prompt('Rename ontology label', current);
            if (!name || name.trim() === current) return;
            try {
              const payload = { graph: li.dataset.iri, label: name.trim() };
              const token = localStorage.getItem(tokenKey);
              fetch('/api/ontologies/label', { method: 'PUT', headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token }, body: JSON.stringify(payload) })
                .then(async (res) => {
                  if (!res.ok) throw new Error('rename failed');
                  const newLabel = name.trim();
                  row.querySelector('.node-label').textContent = newLabel; li.dataset.label = newLabel; saveOntologyLabel(li.dataset.iri, newLabel);
                  if (activeOntologyIri === li.dataset.iri) {
                    const pid = project.id || project.project_id || 'default';
                    localStorage.setItem(`onto_model_name__${pid}`, newLabel);
                    try {
                      let attrs = {};
                      try { attrs = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}'); } catch(_) { attrs = {}; }
                      attrs.displayLabel = newLabel;
                      // Ensure namespace matches the graph IRI
                      if (!attrs.namespace || attrs.namespace.endsWith('/ontology')) {
                        attrs.namespace = li.dataset.iri || activeOntologyIri;
                      }
                      localStorage.setItem(`onto_model_attrs__${pid}`, JSON.stringify(attrs));
                    } catch(_) {}
                    updateOntoGraphLabel();
                    // Immediately update properties panel model name
                    try { updatePropertiesPanelFromSelection(); } catch(_) {}
                    // Immediately reflect in Ontology tree view without a full tree reload
                    try { refreshOntologyTree(); } catch(_) {}
                  }
                  // Avoid immediate server re-fetch that could race and overwrite the fresh label
                })
                .catch(()=>{ alert('Rename failed'); });
            } catch(_) {}
          }
        };

        const twist = document.createElement('span'); twist.className = 'twist';
        if (hasChildren) {
          twist.onclick = (e) => { e.stopPropagation(); toggleNode(li); };
        }
        row.appendChild(twist);

        const icon = document.createElement('span'); icon.className = 'node-icon ' + iconCls; row.appendChild(icon);
        const text = document.createElement('span'); text.className = 'node-label'; text.textContent = label; row.appendChild(text);
        li.appendChild(row);

        if (hasChildren) {
          const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
          children.forEach(ch => ul.appendChild(ch));
          li.appendChild(ul);
        }
        return li;
      };

      const reqItems = ((project && project.requirements) || []).map((r, idx) => {
        const rid = r.id || `SP-${String(idx + 1).padStart(3, '0')}`;
        const label = rid; // ID only
        return makeItem(rid, label, 'req');
      });
      const docReqItems = (project && project.documents && project.documents.requirements ? project.documents.requirements : []).map(d => makeItem(d.id || d.name, d.name || d.id, 'docreq'));
      const docKnowItems = (project && project.documents && project.documents.knowledge ? project.documents.knowledge : []).map(d => makeItem(d.id || d.name, d.name || d.id, 'docknow'));
      const outItems = ((project && (project.artifacts || project.outputs)) || []).map(o => makeItem(o.id || o.name, o.name || o.id, 'out'));

      // Ontology tree: discover from Fuseki
      let ontologyNode = null;
      try {
        const pid = project && (project.id || project.project_id);
        const res = await fetch(`/api/ontologies${pid ? `?project=${encodeURIComponent(pid)}` : ''}`);
        const json = await res.json();
        const onts = Array.isArray(json.ontologies) ? json.ontologies : [];
        const labelsMap = loadOntologyLabelMap(project);
        const ontoItems = onts.map((o, idx) => {
          const serverLabel = (o.label && String(o.label).trim()) || '';
          const mapLabel = (labelsMap[o.graphIri] && String(labelsMap[o.graphIri]).trim()) || '';
          const displayLabel = mapLabel || serverLabel || o.graphIri;
          const isReference = o.is_reference || false;
          const referenceIndicator = isReference ? ' 📚' : '';
          const li = makeItem(
            `ontology-${idx}-${o.graphIri}`,
            displayLabel + referenceIndicator,
            'onto',
            [],
            { nodeType: 'ontology', iri: o.graphIri, label: displayLabel, isReference: isReference }
          );
          // Enable dragging this ontology into the Imports node
          const row = li.querySelector('.node-row');
          if (row) {
            row.setAttribute('draggable', 'true');
            row.addEventListener('dragstart', (ev) => {
              try { ev.dataTransfer.setData('text/graph-iri', o.graphIri); ev.dataTransfer.effectAllowed = 'copy'; } catch(_) {}
            });
            
            // Add context menu for ontology nodes (admin only)
            row.oncontextmenu = (ev) => {
              ev.preventDefault();
              console.log('🔍 Right-click detected on ontology node:', o.graphIri);
              
              const menu = qs('#ontologyContextMenu'); 
              if (!menu) {
                console.log('❌ Ontology context menu not found');
                return;
              }
              
              // Check if user is admin
              const user = JSON.parse(localStorage.getItem('user') || '{}');
              console.log('👤 Current user:', user);
              console.log('🔍 User is_admin:', user.is_admin);
              
              // Temporarily allow all users to test the context menu
              // if (!user.is_admin) {
              //   console.log('❌ User is not admin, context menu disabled');
              //   return;
              // }
              
              console.log('✅ Showing context menu (admin check temporarily disabled)');
              
              menu.style.display = 'block';
              menu.style.left = ev.pageX + 'px';
              menu.style.top = ev.pageY + 'px';
              
              const hide = () => { 
                menu.style.display = 'none'; 
                document.removeEventListener('click', hide, { capture: true }); 
              };
              setTimeout(() => { document.addEventListener('click', hide, { capture: true }); }, 0);
              
              // Set up context menu actions
              const renameBtn = qs('#ontoRenameBtn');
              const toggleRefBtn = qs('#ontoToggleReferenceBtn');
              const deleteBtn = qs('#ontoDeleteBtn');
              
              if (renameBtn) {
                renameBtn.onclick = async () => {
                  hide();
                  const current = displayLabel;
                  const name = prompt('Rename ontology label', current);
                  if (!name || name.trim() === current) return;
                  try {
                    const payload = { graph: o.graphIri, label: name.trim() };
                    const token = localStorage.getItem(tokenKey);
                    const res = await fetch('/api/ontologies/label', { 
                      method: 'PUT', 
                      headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token }, 
                      body: JSON.stringify(payload) 
                    });
                    if (res.ok) {
                      row.querySelector('.node-label').textContent = name.trim() + referenceIndicator;
                      li.dataset.label = name.trim();
                      saveOntologyLabel(o.graphIri, name.trim());
                      await renderTree(project);
                    } else {
                      alert('Rename failed');
                    }
                  } catch(_) {
                    alert('Rename failed');
                  }
                };
              }
              
              if (toggleRefBtn) {
                const currentRefStatus = isReference;
                toggleRefBtn.textContent = currentRefStatus ? 'Remove Reference Status' : 'Mark as Reference';
                toggleRefBtn.onclick = async () => {
                  hide();
                  try {
                    const payload = { graph: o.graphIri, is_reference: !currentRefStatus };
                    const token = localStorage.getItem(tokenKey);
                    const res = await fetch('/api/ontologies/reference', { 
                      method: 'PUT', 
                      headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token }, 
                      body: JSON.stringify(payload) 
                    });
                    if (res.ok) {
                      await renderTree(project);
                    } else {
                      alert('Failed to update reference status');
                    }
                  } catch(_) {
                    alert('Failed to update reference status');
                  }
                };
              }
              
              if (deleteBtn) {
                deleteBtn.onclick = async () => {
                  hide();
                  if (confirm(`Delete ontology "${displayLabel}"?`)) {
                    try {
                      const token = localStorage.getItem(tokenKey);
                      const res = await fetch(`/api/ontologies?graph=${encodeURIComponent(o.graphIri)}`, { 
                        method: 'DELETE', 
                        headers: { Authorization: 'Bearer ' + token } 
                      });
                      if (res.ok) {
                        // Clear local storage for this ontology
                        try {
                          localStorage.removeItem(storageKeyForGraph(o.graphIri));
                          console.log('🗑️ Cleared local storage for deleted ontology:', o.graphIri);
                        } catch (e) {
                          console.warn('Failed to clear local storage:', e);
                        }
                        
                        await renderTree(project);
                        if (activeOntologyIri === o.graphIri) { 
                          activeOntologyIri = null; 
                          updateOntoGraphLabel(); 
                          ensureOntologyInitialized(); 
                          ontoState.cy?.elements().remove(); 
                          refreshOntologyTree(); 
                        }
                      } else {
                        alert('Delete failed');
                      }
                    } catch(_) {
                      alert('Delete failed');
                    }
                  }
                };
              }
            };
          }
          // Initialize label map from server only if missing
          if (!mapLabel && serverLabel) {
            try { saveOntologyLabel(o.graphIri, serverLabel); } catch(_) {}
          }
          return li;
        });
        if (ontoItems.length) {
          ontologyNode = makeItem('ontology', 'Ontology', 'folder', ontoItems);
        } else {
          // No ontologies: ensure empty state is shown
          activeOntologyIri = null;
          updateOntoGraphLabel();
          ontologyNode = makeItem('ontology', 'Ontology', 'folder', []);
        }
      } catch (_) {
        // Network/SPARQL error: show a placeholder item
        ontologyNode = makeItem('ontology', 'Ontology', 'folder', [
          makeItem('onto-error', 'Discovery unavailable', 'onto')
        ]);
      }

      const projectDisplay = (project && (project.name || project.id)) ? (project.name || project.id) : '';
      const projectInfo = makeItem('project-info', `Project: ${projectDisplay}`, 'folder');
      // Enable delete on main tree top node when project is selected
      try {
        const row = projectInfo.querySelector('.node-row');
        if (row && project && (project.id || project.project_id)) {
          // Click handler to open project information page
          row.onclick = (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            
            // Switch to project workbench
            const projectIcon = qs('#wb-project');
            if (projectIcon) {
              // Remove active class from all workbenches
              qsa('.workbench').forEach(wb => wb.classList.remove('active'));
              qsa('.icon').forEach(icon => icon.classList.remove('active'));
              
              // Add active class to project workbench
              projectIcon.classList.add('active');
              qs('#wb-project').classList.add('active');
              
              // Update localStorage and URL
              try { 
                localStorage.setItem('active_workbench', 'project');
                const currentProjectId = localStorage.getItem('active_project_id');
                updateURL(currentProjectId, 'project');
              } catch(_) {}
              
              // Load project information
              loadProjectInfo();
            }
          };
          
          // Context menu binding
          row.oncontextmenu = (ev) => {
            ev.preventDefault();
            const menu = qs('#projectContextMenu'); if (!menu) return;
            menu.style.display = 'block';
            menu.style.left = ev.pageX + 'px';
            menu.style.top = ev.pageY + 'px';
            const hide = () => { menu.style.display = 'none'; document.removeEventListener('click', hide, { capture: true }); };
            setTimeout(() => { document.addEventListener('click', hide, { capture: true }); }, 0);
            const pid = project.id || project.project_id;
            const token = localStorage.getItem(tokenKey);
            const archiveBtn = qs('#projArchiveBtn');
            const deleteBtn = qs('#projDeleteBtn');
            const showArchivedBtn = qs('#projShowArchivedBtn');
            const renameBtn = qs('#projRenameBtn');
            if (renameBtn) renameBtn.onclick = async () => {
              try {
                const currentName = (project && (project.name || '')) || '';
                const newName = prompt('Rename project', currentName);
                if (!newName || newName.trim() === currentName) return;
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token },
                  body: JSON.stringify({ name: newName.trim() })
                });
                if (res.ok) {
                  // Verify via API that the rename persisted
                  try {
                    const vr = await fetch(`/api/projects/${encodeURIComponent(pid)}`, { headers: { Authorization: 'Bearer ' + token }});
                    if (vr.ok) {
                      const vj = await vr.json();
                      const vproj = vj.project || vj;
                      const serverName = (vproj.name || vproj.project_name || '').trim();
                      if (serverName !== newName.trim()) {
                        alert('Rename saved but verification failed: expected "' + newName.trim() + '", got "' + serverName + '". UI will refresh.');
                      }
                    } else {
                      const t = await vr.text().catch(()=>String(vr.status));
                      alert('Rename saved, but verification request failed: ' + t);
                    }
                  } catch (_) {
                    // Non-fatal verification error
                  }
                  await loadProjects();
                } else {
                  const t = await res.text().catch(()=>String(res.status));
                  alert('Rename failed: ' + t);
                }
              } finally { hide(); }
            };
            if (archiveBtn) archiveBtn.onclick = async () => {
              try {
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}/archive`, { method: 'POST', headers: { Authorization: 'Bearer ' + token }});
                if (res.ok) { try { localStorage.removeItem('active_project_id'); } catch(_) {} await loadProjects(); }
                else { const t = await res.text().catch(()=>String(res.status)); alert('Archive failed: ' + t); }
              } finally { hide(); }
            };
            if (deleteBtn) deleteBtn.onclick = async () => {
              try {
                if (!confirm('Delete this project? This does not delete external artifacts.')) return;
                const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token }});
                if (res.ok) { try { localStorage.removeItem('active_project_id'); } catch(_) {} await loadProjects(); }
                else { const t = await res.text().catch(()=>String(res.status)); alert('Delete failed: ' + t); }
              } finally { hide(); }
            };
            if (showArchivedBtn) showArchivedBtn.onclick = async () => {
              try {
                const res = await fetch('/api/projects?state=archived', { headers: { Authorization: 'Bearer ' + token }});
                const json = await res.json();
                const rows = (json.projects || []).map(p => ({ id: p.project_id || p.id, name: p.name || 'Project' })).filter(p => p.id);
                const overlay = document.createElement('div');
                overlay.style.position='fixed'; overlay.style.inset='0'; overlay.style.background='rgba(0,0,0,0.4)'; overlay.style.zIndex='9998';
                const panel = document.createElement('div'); panel.style.position='fixed'; panel.style.top='20%'; panel.style.left='50%'; panel.style.transform='translateX(-50%)'; panel.style.background='var(--panel)'; panel.style.border='1px solid var(--border)'; panel.style.borderRadius='12px'; panel.style.padding='12px'; panel.style.minWidth='420px'; panel.style.zIndex='9999';
                panel.innerHTML = `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;"><strong>Archived Projects</strong><button id="archClose" class="btn">Close</button></div><div id="archList"></div>`;
                document.body.appendChild(overlay); document.body.appendChild(panel);
                const close = ()=>{ try { document.body.removeChild(panel); document.body.removeChild(overlay); } catch(_) {} };
                panel.querySelector('#archClose').onclick = close; overlay.onclick = close;
                const listEl = panel.querySelector('#archList');
                if (!rows.length) { listEl.innerHTML = '<div class="muted">No archived projects.</div>'; return; }
                listEl.innerHTML = rows.map(r => `<div style="display:flex; justify-content:space-between; align-items:center; border:1px solid var(--border); border-radius:8px; padding:8px; margin-bottom:6px;"><span>${r.name}</span><div><button class="btn" data-restore="${r.id}">Restore</button></div></div>`).join('');
                listEl.addEventListener('click', async (e)=>{
                  const btn = e.target.closest('button[data-restore]'); if (!btn) return;
                  const rid = btn.getAttribute('data-restore');
                  const rr = await fetch(`/api/projects/${encodeURIComponent(rid)}/restore`, { method:'POST', headers:{ Authorization:'Bearer ' + token }});
                  if (rr.ok) {
                    try { localStorage.setItem('active_project_id', rid); } catch(_) {}
                    close();
                    await loadProjects();
                  } else {
                    const t = await rr.text().catch(()=>String(rr.status)); alert('Restore failed: ' + t);
                  }
                });
              } finally { hide(); }
            };
          };
          row.onkeydown = async (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
              e.preventDefault();
              const pid = project.id || project.project_id;
              const token = localStorage.getItem(tokenKey);
              if (!confirm('Delete this project? This does not delete external artifacts.')) return;
              const res = await fetch(`/api/projects/${encodeURIComponent(pid)}`, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token }});
              if (res.ok) {
                try { localStorage.removeItem('active_project_id'); } catch(_) {}
                await loadProjects();
              } else {
                const t = await res.text().catch(()=>String(res.status));
                alert('Delete failed: ' + t);
              }
            }
          };
        }
      } catch(_) {}
      const docsReqNode = makeItem('documents-requirements', 'Requirements Documents', 'folder', docReqItems);
      const docsKnowNode = makeItem('documents-knowledge', 'Knowledge Documents', 'folder', docKnowItems);
      const docsChildren = [];
      if (docReqItems.length) docsChildren.push(docsReqNode);
      if (docKnowItems.length) docsChildren.push(docsKnowNode);
      const docsNode = makeItem('documents', 'Documents', 'folder', docsChildren);
      const reqNode = makeItem('requirements', 'Extracted Requirements', 'folder', reqItems);
      const outNode = makeItem('artifacts', 'Artifacts', 'folder', outItems);

      root.innerHTML = '';
      // If no project, show minimal empty tree
      root.innerHTML = '';
      if (project && (project.id || project.project_id)) {
        [projectInfo, ontologyNode, docsNode, reqNode, outNode].filter(Boolean).forEach(n => root.appendChild(n));
      }

      // Auto-restore previously selected ontology for this project, if available
      try {
        const pid = project && (project.id || project.project_id);
        const savedIri = pid ? localStorage.getItem(`onto_active_iri__${pid}`) : null;
        const treeEl = qs('#treeRoot');
        if (savedIri && treeEl) {
          const li = Array.from(treeEl.querySelectorAll('li[role="treeitem"]')).find(el => el.dataset && el.dataset.iri === savedIri);
          if (li) {
            // Restore canvas first (if we have saved content), then select the ontology to sync panels
            try {
              if (ontoState.cy) {
                ontoState.suspendAutosave = true;
                ontoState.cy.elements().remove();
                loadGraphFromLocal(savedIri);
                setTimeout(() => { ontoState.suspendAutosave = false; }, 50);
              }
            } catch(_) {}
            selectNode(li);
            // Prevent workbench switching when restoring selection on load
            suppressWorkbenchSwitch = true;
            try { await handleTreeSelection(li); } finally { suppressWorkbenchSwitch = false; }
          } else {
            // Saved IRI no longer present; reset to empty state
            activeOntologyIri = null;
            updateOntoGraphLabel();
            try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {}
            refreshOntologyTree();
          }
        } else {
          // No saved selection for this project
          activeOntologyIri = null;
          updateOntoGraphLabel();
          try { if (ontoState.cy) ontoState.cy.elements().remove(); } catch(_) {}
          refreshOntologyTree();
        }
      } catch(_) {}

      // Add plus button on Ontology section header (right side)
      try {
        const ontoSection = Array.from(root.children).find(li => li.querySelector('.node-label')?.textContent === 'Ontology');
        const headerRow = ontoSection ? ontoSection.querySelector('.node-row') : null;
        if (headerRow && !headerRow.querySelector('.tree-add-btn')) {
          const addBtn = document.createElement('button');
          addBtn.className = 'btn tree-add-btn';
          addBtn.title = 'New Ontology';
          addBtn.textContent = '+';
          addBtn.style.marginLeft = '8px';
          addBtn.onclick = async (e) => {
            e.stopPropagation();
            if (!project || !(project.id || project.project_id)) { alert('Create a project first'); return; }
            
            // Check if user is admin
            const token = localStorage.getItem(tokenKey);
            let isAdmin = false;
            try {
              const userRes = await fetch('/api/auth/me', { headers: { Authorization: 'Bearer ' + token } });
              if (userRes.ok) {
                const user = await userRes.json();
                isAdmin = user.is_admin || false;
                console.log('User admin status:', isAdmin, user);
              }
            } catch (err) {
              console.error('Failed to get user info:', err);
            }
            
            // Create dialog for ontology creation
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.4)';
            overlay.style.zIndex = '9998';
            
            const panel = document.createElement('div');
            panel.style.position = 'fixed';
            panel.style.top = '30%';
            panel.style.left = '50%';
            panel.style.transform = 'translateX(-50%)';
            panel.style.background = 'var(--panel)';
            panel.style.border = '1px solid var(--border)';
            panel.style.borderRadius = '12px';
            panel.style.padding = '20px';
            panel.style.minWidth = '400px';
            panel.style.zIndex = '9999';
            
            panel.innerHTML = `
              <div style="margin-bottom:16px;">
                <h3 style="margin:0 0 16px 0;">Create or Import Ontology</h3>
                
                <!-- Creation/Import Mode Toggle -->
                <div style="margin-bottom:16px;">
                  <div style="display:flex; gap:8px; margin-bottom:12px;">
                    <button id="createMode" class="btn btn-primary" style="flex:1;">Create New</button>
                    <button id="importMode" class="btn" style="flex:1;">Import from URL</button>
                  </div>
                </div>
                
                <!-- Create New Ontology Section -->
                <div id="createSection">
                  <div style="margin-bottom:12px;">
                    <label style="display:block; margin-bottom:4px; font-weight:500;">Display Label:</label>
                    <input type="text" id="ontoLabel" placeholder="Enter ontology label" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--input-bg); color:var(--text);" />
                  </div>
                  
                  <div style="margin-bottom:12px;">
                    <label style="display:block; margin-bottom:4px; font-weight:500;">Namespace (inherited from project):</label>
                    <div id="ontoNamespaceDisplay" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--panel-2); color:var(--muted); font-family: monospace;">
                      Loading project namespace...
                    </div>
                    <div style="font-size:0.9em; color:var(--muted); margin-top:4px;">
                      Ontologies automatically inherit their project's namespace
                    </div>
                  </div>
                  ${isAdmin ? `
                  <div style="margin-bottom:16px;">
                    <label style="display:flex; align-items:center; cursor:pointer;">
                      <input type="checkbox" id="isReference" style="margin-right:8px;" />
                      <span>Mark as Reference Ontology (Admin only)</span>
                    </label>
                    <div style="font-size:0.9em; color:var(--muted); margin-top:4px;">
                      Reference ontologies can be imported by other projects
                    </div>
                  </div>
                  ` : ''}
                </div>
                
                <!-- Import from URL Section -->
                <div id="importSection" style="display:none;">
                  <div style="margin-bottom:12px;">
                    <label style="display:block; margin-bottom:4px; font-weight:500;">Ontology URL:</label>
                    <input type="url" id="importUrl" placeholder="https://example.com/ontology.owl" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--input-bg); color:var(--text);" />
                  </div>
                  <div style="margin-bottom:12px;">
                    <label style="display:block; margin-bottom:4px; font-weight:500;">Display Name:</label>
                    <input type="text" id="importName" placeholder="Enter display name" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--input-bg); color:var(--text);" />
                  </div>
                  <div style="margin-bottom:12px;">
                    <label style="display:block; margin-bottom:4px; font-weight:500;">Display Label:</label>
                    <input type="text" id="importLabel" placeholder="Enter display label" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--input-bg); color:var(--text);" />
                  </div>
                  ${isAdmin ? `
                  <div style="margin-bottom:16px;">
                    <label style="display:flex; align-items:center; cursor:pointer;">
                      <input type="checkbox" id="importIsReference" style="margin-right:8px;" />
                      <span>Mark as Reference Ontology (Admin only)</span>
                    </label>
                    <div style="font-size:0.9em; color:var(--muted); margin-top:4px;">
                      Reference ontologies can be imported by other projects
                    </div>
                  </div>
                  ` : ''}
                </div>
                
                <div style="display:flex; justify-content:flex-end; gap:8px;">
                  <button id="cancelOnto" class="btn" style="background: var(--muted);">Cancel</button>
                  <button id="createOnto" class="btn btn-primary">Create</button>
                  <button id="importOnto" class="btn btn-primary" style="display:none;">Import</button>
                </div>
              </div>
            `;
            
            document.body.appendChild(overlay);
            document.body.appendChild(panel);
            
            const close = () => {
              try {
                document.body.removeChild(panel);
                document.body.removeChild(overlay);
              } catch(_) {}
            };
            
            panel.querySelector('#cancelOnto').onclick = close;
            overlay.onclick = close;
            
            // Mode toggle handlers
            panel.querySelector('#createMode').onclick = () => {
              panel.querySelector('#createMode').className = 'btn btn-primary';
              panel.querySelector('#importMode').className = 'btn';
              panel.querySelector('#createSection').style.display = 'block';
              panel.querySelector('#importSection').style.display = 'none';
              panel.querySelector('#createOnto').style.display = 'inline-block';
              panel.querySelector('#importOnto').style.display = 'none';
            };
            
            panel.querySelector('#importMode').onclick = () => {
              panel.querySelector('#importMode').className = 'btn btn-primary';
              panel.querySelector('#createMode').className = 'btn';
              panel.querySelector('#createSection').style.display = 'none';
              panel.querySelector('#importSection').style.display = 'block';
              panel.querySelector('#createOnto').style.display = 'none';
              panel.querySelector('#importOnto').style.display = 'inline-block';
            };
            
            // Load current project's namespace
            loadCurrentProjectNamespace(panel.querySelector('#ontoNamespaceDisplay'));
            
            panel.querySelector('#createOnto').onclick = async () => {
              const labelInput = panel.querySelector('#ontoLabel');
              const disp = labelInput.value.trim();
              
              if (!disp) {
                alert('Please enter a label for the ontology');
                return;
              }
              
              // Check if project has a namespace
              const currentProjectId = localStorage.getItem('active_project_id');
              if (!currentProjectId) {
                alert('No project selected - select a project first');
                return;
              }
              
              const isReference = isAdmin && panel.querySelector('#isReference').checked;
            const base = slugify(disp) || `ontology-${Date.now()}`;
            const label = disp;
              
            try {
              const pid2 = project.id || project.project_id;
                const body = { 
                  project: pid2, 
                  name: base, 
                  label
                };
                if (isReference) {
                  body.is_reference = true;
                }
                
                console.log('🔧 Creating ontology with project namespace inheritance:', body);
                console.log('🔧 Frontend sending project ID:', pid2, 'from project object:', project);
                
                const res = await fetch('/api/ontologies', { 
                  method: 'POST', 
                  headers: { 'Content-Type':'application/json', Authorization: 'Bearer ' + token }, 
                  body: JSON.stringify(body) 
                });
                
              if (!res.ok) {
                const msg = await res.text().catch(()=>String(res.status));
                alert('Create ontology failed: ' + msg);
                return;
              }
                
              const created = await res.json();
              if (created && created.graphIri) {
                try { saveOntologyLabel(created.graphIri, created.label || label); } catch(_) {}
              }
                
                close();
              await renderTree(project);
                
              // Ensure label is shown and select the created ontology (guard for valid response)
              if (created && created.graphIri) {
                const newRoot = qs('#treeRoot');
                const li = Array.from(newRoot.querySelectorAll('li[role="treeitem"]')).find(el => el.dataset && el.dataset.iri === created.graphIri);
                // Update top node label immediately
                try {
                  const ontoTop = qs('#ontoTreeRoot .onto-node-label');
                  if (ontoTop) ontoTop.textContent = created.label || label;
                } catch(_) {}
                if (li) {
                  const lbl = li.querySelector('.node-label'); if (lbl) lbl.textContent = created.label || label;
                  li.dataset.label = created.label || label;
                  selectNode(li);
                  await handleTreeSelection(li);
                } else {
                  // Fallback: set selection and force refresh display
                  activeOntologyIri = created.graphIri;
                  updateOntoGraphLabel();
                  refreshOntologyTree();
                }
              }
              } catch(err) {
                alert('Failed to create ontology: ' + err.message);
              }
            };
            
            // Import from URL handler
            panel.querySelector('#importOnto').onclick = async () => {
              const urlInput = panel.querySelector('#importUrl');
              const nameInput = panel.querySelector('#importName');
              const labelInput = panel.querySelector('#importLabel');
              
              const url = urlInput.value.trim();
              const name = nameInput.value.trim();
              const label = labelInput.value.trim();
              
              if (!url) {
                alert('Please enter an ontology URL');
                return;
              }
              
              if (!name) {
                alert('Please enter a display name');
                return;
              }
              
              if (!label) {
                alert('Please enter a display label');
                return;
              }
              
              const isReference = isAdmin && panel.querySelector('#importIsReference').checked;
              
              try {
                const response = await fetch('/api/ontologies/import-url', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + token
                  },
                  body: JSON.stringify({
                    url: url,
                    project_id: (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default',
                    name: name,
                    label: label,
                    is_reference: isReference
                  })
                });
                
                if (!response.ok) {
                  const error = await response.text();
                  throw new Error(error);
                }
                
                const result = await response.json();
                toast(`Successfully imported ontology: ${result.label}`);
                close();
                await renderTree(project);
                
                // Select the imported ontology
                if (result.graph_iri) {
                  const newRoot = qs('#treeRoot');
                  const li = Array.from(newRoot.querySelectorAll('li[role="treeitem"]')).find(el => el.dataset && el.dataset.iri === result.graph_iri);
                  if (li) {
                    const lbl = li.querySelector('.node-label'); 
                    if (lbl) lbl.textContent = result.label || label;
                    li.dataset.label = result.label || label;
                    selectNode(li);
                    await handleTreeSelection(li);
                  }
                }
                
              } catch (error) {
                console.error('URL import error:', error);
                
                // Check if it's a duplicate ontology error
                if (error.message && (
                  error.message.includes('duplicate key value violates unique constraint') ||
                  error.message.includes('ontologies_registry_graph_iri_key') ||
                  error.message.includes('already exists')
                )) {
                  toast('This ontology has already been imported. Each ontology can only be imported once per project.', true);
                } else {
                  toast(`Failed to import ontology: ${error.message}`, true);
                }
              }
            };
            
            // Focus the input
            setTimeout(() => {
              panel.querySelector('#ontoLabel').focus();
            }, 100);
          };
          headerRow.appendChild(addBtn);
        }
      } catch(_) {}

      // Handle Delete key for ontology deletion
      root.addEventListener('keydown', async (e) => {
        if (e.key === 'Delete' || e.keyCode === 46) {
          const sel = root.querySelector('.node-row.selected');
          if (!sel) return;
          const li = sel.closest('li[role="treeitem"]');
          if (!li || li.dataset.nodeType !== 'ontology') return;
          const iri = li.dataset.iri;
          if (!iri) return;
          try {
            const url = `/api/ontologies?graph=${encodeURIComponent(iri)}`;
            const token = localStorage.getItem(tokenKey);
            const res = await fetch(url, { method: 'DELETE', headers: { Authorization: 'Bearer ' + token } });
            if (res.ok) {
              await renderTree(project);
              if (activeOntologyIri === iri) { activeOntologyIri = null; updateOntoGraphLabel(); ensureOntologyInitialized(); ontoState.cy?.elements().remove(); refreshOntologyTree(); }
            }
          } catch(_) {}
        }
      });
    }

    async function refreshGraphSummary() {
      const el = qs('#graphSummary'); if (!el) return;
      el.textContent = 'Loading summary...';
      try {
        const res = await fetch('/api/ontology/summary');
        const json = await res.json();
        if (json.rows) {
          el.innerHTML = json.rows.map(r => `<div class="row"><span class="muted">${r.type}</span> — ${r.count}</div>`).join('') || '<div class="muted">No data</div>';
        } else {
          el.textContent = json.error || 'No data';
        }
      } catch (e) { el.textContent = 'Error loading summary'; }
    }
    (function(){
      const btnS = () => qs('#btnRefreshSummary');
      const btnQ = () => qs('#btnRunSparql');
      document.addEventListener('click', async (e) => {
        if (e.target === btnS()) {
          refreshGraphSummary();
        } else if (e.target === btnQ()) {
          const q = (qs('#sparqlInput')?.value) || '';
          const st = qs('#sparqlStatus'); const out = qs('#sparqlResult');
          st.textContent = 'Running...'; out.textContent = '';
          try {
            const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
            const json = await res.json();
            if (res.ok) { out.textContent = JSON.stringify(json, null, 2); st.textContent = 'OK'; }
            else { out.textContent = JSON.stringify(json, null, 2); st.textContent = 'Error'; }
          } catch (err) { out.textContent = String(err); st.textContent = 'Error'; }
        }
      });
    })();

    function refreshOntologyTree() {
      const root = qs('#ontoTreeRoot');
      if (!root || !ontoState.cy) return;
      
      // Filter nodes based on visibility settings
      const classes = ontoState.cy.nodes().filter(n => {
        const nodeType = n.data('type') || 'class';
        const isImported = n.hasClass('imported');
        
        // Always show classes in tree regardless of visibility state - visibility only affects canvas
        return !isImported && nodeType === 'class';
      });
      
      const dataProperties = ontoState.cy.nodes().filter(n => {
        const nodeType = n.data('type') || 'class';
        const isImported = n.hasClass('imported');
        
        // Always show data properties in tree regardless of visibility state
        return !isImported && nodeType === 'dataProperty';
      });
      
      const importedClasses = ontoState.cy.nodes().filter(n => {
        const nodeType = n.data('type') || 'class';
        const isImported = n.hasClass('imported');
        
        // Always show imported classes in tree regardless of visibility state
        return isImported && nodeType === 'class';
      });
      
      const notes = ontoState.cy.nodes().filter(n => {
        const nodeType = n.data('type') || '';
        const isImported = n.hasClass('imported');
        
        // Always show notes in tree regardless of visibility state - don't check isVisible
        return !isImported && nodeType === 'note';
      });
      // Simple grouping: Classes as top-level; edges shown under a "Relationships" group per class
      root.innerHTML = '';
      const makeItem = (label, expanded = true, children = []) => {
        const li = document.createElement('li');
        li.setAttribute('role', 'treeitem');
        if (children.length) li.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        const row = document.createElement('div'); row.className = 'onto-node-row';
        row.tabIndex = 0;
        const twist = document.createElement('span'); twist.className = 'onto-twist'; if (children.length) twist.onclick = (e)=>{ e.stopPropagation(); li.setAttribute('aria-expanded', li.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'); };
        const text = document.createElement('span'); text.className = 'onto-node-label'; text.textContent = label;
        row.appendChild(twist); row.appendChild(text); li.appendChild(row);
        
        // Add click handler for tree item selection
        row.onclick = async (e) => { 
          // Don't trigger if clicking on a button (like visibility toggle)
          if (e.target.tagName === 'BUTTON') return;
          console.log('🔍 Tree item clicked:', li.dataset.nodeType, li.dataset.nodeId);
          selectNode(li); 
          await handleTreeSelection(li); 
        };
        row.onkeydown = (e) => {
          const ENTER = 13, SPACE = 32;
          if (e.keyCode === ENTER || e.keyCode === SPACE) {
            selectNode(li); 
            handleTreeSelection(li).catch(console.error); 
            e.preventDefault();
          }
        };
        
        if (children.length) {
          const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
          children.forEach(c => ul.appendChild(c));
          li.appendChild(ul);
        }
        return li;
      };
      const items = [];
      classes.forEach(cls => {
        const label = cls.data('label') || cls.id();
        const outEdges = cls.outgoers('edge').filter(e => {
          // Always show edges in tree regardless of visibility state
          return true;
        });
        const rels = outEdges.map(e => {
          const other = e.target();
          const pred = e.data('predicate') || 'relatedTo';
          const type = e.data('type') || 'objectProperty';
          const item = makeItem(`${pred} → ${(other.data('label') || other.id())} (${type})`, false, []);
          // Set edge data attributes for tree selection
          item.dataset.edgeId = e.id();
          item.dataset.nodeType = 'edge';
          return item;
        });
        const classItem = makeItem(label, false, rels);
        // Set node data attributes for tree selection
        classItem.dataset.nodeId = cls.id();
        classItem.dataset.nodeType = 'class';
        
        // Add visibility toggle for individual classes
        const row = classItem.querySelector('.onto-node-row');
        if (row) {
          const visibilityBtn = document.createElement('button');
          visibilityBtn.className = 'class-visibility-toggle';
          visibilityBtn.title = 'Toggle visibility';
          visibilityBtn.innerHTML = '👁';
          visibilityBtn.style.cssText = `
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            padding: 2px 4px;
            margin-left: 4px;
            border-radius: 3px;
            font-size: 12px;
          `;
          
          // Set initial visibility state based on saved element visibility or global state
          const nodeId = cls.id();
          let isVisible = cls.visible();
          if (ontoState.elementVisibility.hasOwnProperty(nodeId)) {
            isVisible = ontoState.elementVisibility[nodeId];
          }
          visibilityBtn.style.opacity = isVisible ? '1' : '0.3';
          
          visibilityBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const node = ontoState.cy.$(`#${cls.id()}`);
            if (node.length > 0) {
              if (node.visible()) {
                node.hide();
                visibilityBtn.style.opacity = '0.3';
                // Save individual element visibility
                if (activeOntologyIri) {
                  ontoState.elementVisibility[cls.id()] = false;
                  saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                }
              } else {
                node.show();
                visibilityBtn.style.opacity = '1';
                // Save individual element visibility
                if (activeOntologyIri) {
                  ontoState.elementVisibility[cls.id()] = true;
                  saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                }
              }
              // Update properties panel if this node was selected
              updatePropertiesPanelFromSelection();
            }
          });
          
          row.appendChild(visibilityBtn);
        }
        
        items.push(classItem);
      });
      
      // Add data properties
      if (dataProperties.length) {
        const dataPropertyChildren = dataProperties.map(dp => {
          const item = makeItem(dp.data('label') || dp.id(), false, []);
          item.dataset.nodeId = dp.id();
          item.dataset.nodeType = 'dataProperty';
          
          // Add visibility toggle for data properties
          const row = item.querySelector('.onto-node-row');
          if (row) {
            const visibilityBtn = document.createElement('button');
            visibilityBtn.className = 'class-visibility-toggle';
            visibilityBtn.title = 'Toggle visibility';
            visibilityBtn.innerHTML = '👁';
            visibilityBtn.style.cssText = `
              background: none;
              border: none;
              color: var(--muted);
              cursor: pointer;
              padding: 2px 4px;
              margin-left: 4px;
              border-radius: 3px;
              font-size: 12px;
            `;
            
            // Set initial visibility state based on saved element visibility or global state
            const nodeId = dp.id();
            let isVisible = dp.visible();
            if (ontoState.elementVisibility.hasOwnProperty(nodeId)) {
              isVisible = ontoState.elementVisibility[nodeId];
            }
            visibilityBtn.style.opacity = isVisible ? '1' : '0.3';
            
            visibilityBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const node = ontoState.cy.$(`#${dp.id()}`);
              if (node.length > 0) {
                if (node.visible()) {
                  node.hide();
                  visibilityBtn.style.opacity = '0.3';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[dp.id()] = false;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                } else {
                  node.show();
                  visibilityBtn.style.opacity = '1';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[dp.id()] = true;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                }
                // Update properties panel if this node was selected
                updatePropertiesPanelFromSelection();
              }
            });
            
            row.appendChild(visibilityBtn);
          }
          
          return item;
        });
        items.push(makeItem('Data Properties', true, dataPropertyChildren));
      }
      
      if (importedClasses.length) {
        const importedChildren = importedClasses.map(cls => {
          const item = makeItem((cls.data('label')||cls.id()) + ' (imported)', false, []);
          item.dataset.nodeId = cls.id();
          item.dataset.nodeType = 'class';
          
          // Add visibility toggle for imported classes
          const row = item.querySelector('.onto-node-row');
          if (row) {
            const visibilityBtn = document.createElement('button');
            visibilityBtn.className = 'class-visibility-toggle';
            visibilityBtn.title = 'Toggle visibility';
            visibilityBtn.innerHTML = '👁';
            visibilityBtn.style.cssText = `
              background: none;
              border: none;
              color: var(--muted);
              cursor: pointer;
              padding: 2px 4px;
              margin-left: 4px;
              border-radius: 3px;
              font-size: 12px;
            `;
            
            // Set initial visibility state based on saved element visibility or global state
            const nodeId = cls.id();
            let isVisible = cls.visible();
            if (ontoState.elementVisibility.hasOwnProperty(nodeId)) {
              isVisible = ontoState.elementVisibility[nodeId];
            }
            visibilityBtn.style.opacity = isVisible ? '1' : '0.3';
            
            visibilityBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const node = ontoState.cy.$(`#${CSS.escape(cls.id())}`);
              if (node.length > 0) {
                if (node.visible()) {
                  node.hide();
                  visibilityBtn.style.opacity = '0.3';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[cls.id()] = false;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                } else {
                  node.show();
                  visibilityBtn.style.opacity = '1';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[cls.id()] = true;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                }
                // Update properties panel if this node was selected
                updatePropertiesPanelFromSelection();
              }
            });
            
            row.appendChild(visibilityBtn);
          }
          
          return item;
        });
        items.push(makeItem('Imported Classes', true, importedChildren));
      }
      if (notes.length) {
        const noteChildren = notes.map(n => {
          const item = makeItem(n.data('label') || n.id(), false, []);
          item.dataset.nodeId = n.id();
          item.dataset.nodeType = 'note';
          
          // Add visibility toggle for notes
          const row = item.querySelector('.onto-node-row');
          if (row) {
            const visibilityBtn = document.createElement('button');
            visibilityBtn.className = 'class-visibility-toggle';
            visibilityBtn.title = 'Toggle visibility';
            visibilityBtn.innerHTML = '👁';
            visibilityBtn.style.cssText = `
              background: none;
              border: none;
              color: var(--muted);
              cursor: pointer;
              padding: 2px 4px;
              margin-left: 4px;
              border-radius: 3px;
              font-size: 12px;
            `;
            
            // Set initial visibility state based on saved element visibility or global state
            const nodeId = n.id();
            let isVisible = n.visible();
            if (ontoState.elementVisibility.hasOwnProperty(nodeId)) {
              isVisible = ontoState.elementVisibility[nodeId];
            }
            visibilityBtn.style.opacity = isVisible ? '1' : '0.3';
            
            visibilityBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const node = ontoState.cy.$(`#${n.id()}`);
              if (node.length > 0) {
                if (node.visible()) {
                  node.hide();
                  visibilityBtn.style.opacity = '0.3';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[n.id()] = false;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                } else {
                  node.show();
                  visibilityBtn.style.opacity = '1';
                  // Save individual element visibility
                  if (activeOntologyIri) {
                    ontoState.elementVisibility[n.id()] = true;
                    saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
                  }
                }
                // Update properties panel if this node was selected
                updatePropertiesPanelFromSelection();
              }
            });
            
            row.appendChild(visibilityBtn);
          }
          
          return item;
        });
        items.push(makeItem('Notes', true, noteChildren));
      }
      
      // Add Named Views section
      const namedViews = loadNamedViews(activeOntologyIri);
      if (namedViews.length > 0 || true) { // Always show section even if empty
        const viewChildren = namedViews.map(view => {
          const isActive = ontoState.activeNamedView === view.id;
          const displayName = isActive ? `● ${view.name}` : view.name;
          const item = makeItem(displayName, false, []);
          item.dataset.viewId = view.id;
          item.dataset.nodeType = 'namedView';
          
          // Style active view differently
          if (isActive) {
            const label = item.querySelector('.onto-node-label');
            if (label) {
              label.style.color = '#60a5fa';
              label.style.fontWeight = 'bold';
            }
          }
          
          // Add view management buttons with SVG icons
          const row = item.querySelector('.onto-node-row');
          if (row) {
            // Add rename button with edit SVG icon
            const renameBtn = document.createElement('button');
            renameBtn.className = 'class-visibility-toggle';
            renameBtn.title = 'Rename view';
            renameBtn.innerHTML = `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px;">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            `;
            renameBtn.style.cssText = `
              background: none;
              border: none;
              color: var(--muted);
              cursor: pointer;
              padding: 2px 4px;
              margin-left: 4px;
              border-radius: 3px;
            `;
            
            renameBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              renameNamedView(view.id);
            });
            
            // Add delete button with trash SVG icon
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'class-visibility-toggle';
            deleteBtn.title = 'Delete view';
            deleteBtn.innerHTML = `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px;">
                <polyline points="3,6 5,6 21,6"/>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                <line x1="10" y1="11" x2="10" y2="17"/>
                <line x1="14" y1="11" x2="14" y2="17"/>
              </svg>
            `;
            deleteBtn.style.cssText = `
              background: none;
              border: none;
              color: var(--danger);
              cursor: pointer;
              padding: 2px 4px;
              margin-left: 4px;
              border-radius: 3px;
            `;
            
            deleteBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              deleteNamedView(view.id);
            });
            
            row.appendChild(renameBtn);
            row.appendChild(deleteBtn);
          }
          
          return item;
        });
        
        // Add the Named Views section with buttons
        const viewsSection = makeItem('Named Views', true, viewChildren);
        const viewsRow = viewsSection.querySelector('.onto-node-row');
        if (viewsRow) {
          // Add Return button (only visible when a view is active)
          if (ontoState.activeNamedView) {
            const returnBtn = document.createElement('button');
            returnBtn.className = 'btn tree-add-btn';
            returnBtn.title = 'Return to Original View';
            returnBtn.innerHTML = `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px;">
                <polyline points="9,14 4,9 9,4"/>
                <path d="M20,20v-7a4,4 0 0,0-4-4H4"/>
              </svg>
            `;
            returnBtn.style.marginLeft = '8px';
            returnBtn.style.fontSize = '12px';
            returnBtn.style.padding = '2px 6px';
            returnBtn.style.minWidth = '20px';
            returnBtn.style.height = '20px';
            returnBtn.style.color = '#60a5fa';
            returnBtn.onclick = (e) => {
              e.stopPropagation();
              restoreOriginalState();
            };
            
            viewsRow.appendChild(returnBtn);
          }
          
          // Add + button for creating new views
          const addViewBtn = document.createElement('button');
          addViewBtn.className = 'btn tree-add-btn';
          addViewBtn.title = 'Save Current View';
          addViewBtn.textContent = '+';
          addViewBtn.style.marginLeft = '8px';
          addViewBtn.style.fontSize = '12px';
          addViewBtn.style.padding = '2px 6px';
          addViewBtn.style.minWidth = '20px';
          addViewBtn.style.height = '20px';
          addViewBtn.onclick = (e) => {
            e.stopPropagation();
            createNamedView();
          };
          
          viewsRow.appendChild(addViewBtn);
        }
        
        items.push(viewsSection);
      }
      
      const ul = document.createElement('ul'); ul.setAttribute('role', 'group');
      items.forEach(i => ul.appendChild(i));
      // Root level
      const rootItem = document.createElement('li'); rootItem.setAttribute('role', 'treeitem'); rootItem.setAttribute('aria-expanded', 'true');
      const row = document.createElement('div'); row.className = 'onto-node-row';
      const twist = document.createElement('span'); twist.className = 'onto-twist'; twist.onclick = (e)=>{ e.stopPropagation(); rootItem.setAttribute('aria-expanded', rootItem.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'); };
      const text = document.createElement('span'); text.className = 'onto-node-label';
      (function(){
        try {
          const labels = loadOntologyLabelMap(activeProject);
          let modelName = 'Ontology';
          const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
          const scopedName = localStorage.getItem(`onto_model_name__${pid}`) || '';
          if (scopedName.trim()) modelName = scopedName.trim();
          else if (activeOntologyIri) {
            modelName = (labels[activeOntologyIri] && String(labels[activeOntologyIri]).trim()) || (activeOntologyIri.split('/').pop() || 'Ontology');
          }
          text.textContent = modelName;
        } catch(_) { text.textContent = 'Ontology'; }
      })();
      row.appendChild(twist); row.appendChild(text); rootItem.appendChild(row); rootItem.appendChild(ul);
      // (Do not delete projects here; project deletion is handled in the main tree top node in renderTree)
      root.innerHTML = '';
      root.appendChild(rootItem);

      // Imports node specific to current ontology
      try {
        const importsKey = 'onto_imports__' + encodeURIComponent(activeOntologyIri || '');
        const imports = JSON.parse(localStorage.getItem(importsKey) || '[]');
        const importsRoot = document.createElement('li'); importsRoot.setAttribute('role','treeitem'); importsRoot.setAttribute('aria-expanded','true');
        const row = document.createElement('div'); row.className = 'onto-node-row'; 
        const tw = document.createElement('span'); tw.className = 'onto-twist'; 
        const lbl = document.createElement('span'); lbl.className='onto-node-label'; lbl.textContent='Imports'; 
        
        // Add + button for adding reference ontologies
        const addBtn = document.createElement('button');
        addBtn.className = 'btn tree-add-btn';
        addBtn.title = 'Add Reference Ontology';
        addBtn.textContent = '+';
        addBtn.style.marginLeft = '8px';
        addBtn.style.fontSize = '12px';
        addBtn.style.padding = '2px 6px';
        addBtn.style.minWidth = '20px';
        addBtn.style.height = '20px';
        addBtn.onclick = async (e) => {
          e.stopPropagation();
          console.log('➕ Add Reference Ontology button clicked');
          await showReferenceOntologySelector();
        };
        
        // Add collapse/expand all button (hidden for now)
        const collapseBtn = document.createElement('button');
        collapseBtn.className = 'btn tree-add-btn';
        collapseBtn.title = 'Collapse/Expand All Imports';
        collapseBtn.textContent = '⊞';
        collapseBtn.style.marginLeft = '4px';
        collapseBtn.style.fontSize = '12px';
        collapseBtn.style.padding = '2px 6px';
        collapseBtn.style.minWidth = '20px';
        collapseBtn.style.height = '20px';
        collapseBtn.style.display = 'none'; // Hidden for now
        collapseBtn.onclick = (e) => {
          e.stopPropagation();
          toggleAllImportsCollapse();
        };
        
        row.appendChild(tw); 
        row.appendChild(lbl); 
        row.appendChild(addBtn);
        row.appendChild(collapseBtn);
        importsRoot.appendChild(row);
        
        const ul = document.createElement('ul'); ul.setAttribute('role','group');
        function removeImport(iri) {
          try {
            console.log('🔍 Removing import:', iri);
            const key = 'onto_imports__' + encodeURIComponent(activeOntologyIri || '');
            const curr = new Set(JSON.parse(localStorage.getItem(key) || '[]'));
            if (curr.has(iri)) { 
              curr.delete(iri); 
              localStorage.setItem(key, JSON.stringify(Array.from(curr))); 
              console.log('🔍 Import removed, refreshing tree');
              refreshOntologyTree(); 
            }
          } catch(err) {
            console.error('🔍 Error removing import:', err);
          }
        }
        async function friendlyImportName(iri) {
          try {
            const q = `PREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nSELECT ?label WHERE { GRAPH <${iri}> { <${iri}> a owl:Ontology . OPTIONAL { <${iri}> rdfs:label ?label } } }`;
            const res = await fetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: q }) });
            if (!res.ok) throw new Error('sparql');
            const json = await res.json();
            const b = json.results && json.results.bindings && json.results.bindings[0];
            const lbl = b && b.label && b.label.value;
            return (lbl && lbl.trim()) || (iri.split('/').pop() || iri);
          } catch(_) { return iri.split('/').pop() || iri; }
        }
        async function importEquivCount(importIri) {
          try {
            if (!ontoState.cy) {
              console.log('🔍 No cytoscape instance for equivalence counting');
              return 0;
            }
            const norm = s => String(s||'').trim().toLowerCase();
            
            // Get base classes from current Cytoscape graph (local storage)
            const baseClasses = ontoState.cy.nodes().filter(n => (n.data('type')||'class') === 'class' && !n.hasClass('imported'));
            console.log('🔍 Base classes found:', baseClasses.length);
            const baseByLabel = new Map();
            baseClasses.forEach(n => { 
              const label = n.data('label') || n.id();
              const normalized = norm(label);
              baseByLabel.set(normalized, n);
              console.log('🔍 Base class details - ID:', n.id(), 'Label:', label, 'Normalized:', normalized);
            });
            console.log('🔍 Base classes by label:', Array.from(baseByLabel.keys()));
            
            // Get imported classes from local storage for the imported ontology
            const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
            const importKey = `onto_graph__${pid}__` + encodeURIComponent(importIri);
            let importData = localStorage.getItem(importKey);
            
            // TEMPORARY: Clear cached data with generic labels to force fresh reload
            if (importData) {
              const cachedData = JSON.parse(importData);
              const hasGenericLabels = cachedData.nodes && cachedData.nodes.some(node => 
                node.data && node.data.label && node.data.label.match(/^Class \d+$/)
              );
              if (hasGenericLabels) {
                console.log('🔍 Clearing cached data with generic labels to force fresh reload');
                localStorage.removeItem(importKey);
                importData = null;
              }
            }
            
            if (!importData) {
              console.log('🔍 No local storage data found for import, attempting to load from API:', importIri);
              try {
                // Try to load the imported ontology data from API
                const token = localStorage.getItem(tokenKey);
                const apiUrl = `/api/ontology/?graph=${encodeURIComponent(importIri)}`;
                const response = await fetch(apiUrl, {
                  headers: token ? { 'Authorization': `Bearer ${token}` } : {}
                });
                
                if (response.ok) {
                  const ontologyData = await response.json();
                  console.log('🔍 Loaded imported ontology from API:', ontologyData);
                  console.log('🔍 API response structure - classes:', ontologyData.classes);
                  console.log('🔍 API response structure - object_properties:', ontologyData.object_properties);
                  console.log('🔍 API response data property:', ontologyData.data);
                  if (ontologyData.data) {
                    console.log('🔍 Data.classes:', ontologyData.data.classes);
                    console.log('🔍 Data.object_properties:', ontologyData.data.object_properties);
                    console.log('🔍 Full data structure:', JSON.stringify(ontologyData.data, null, 2));
                  }
                  
                  // Convert to Cytoscape format and save to local storage
                  // Use a simpler conversion since we don't have rich metadata
                  // The API response has the data nested in a 'data' property
                  const actualOntologyData = ontologyData.data || ontologyData;
                  console.log('🔍 Actual ontology data being passed to convertOntologyToCytoscape:', actualOntologyData);
                  console.log('🔍 actualOntologyData.classes:', actualOntologyData.classes);
                  const cytoscapeData = convertOntologyToCytoscape(actualOntologyData);
                  console.log('🔍 Converted cytoscape data:', cytoscapeData);
                  const storageData = {
                    nodes: cytoscapeData.nodes || [],
                    edges: cytoscapeData.edges || [],
                    timestamp: Date.now(),
                    source: 'api'
                  };
                  
                  localStorage.setItem(importKey, JSON.stringify(storageData));
                  importData = JSON.stringify(storageData);
                  console.log('🔍 Saved imported ontology data to local storage');
                } else {
                  console.log('🔍 Failed to load imported ontology from API:', response.status);
                  return 0;
                }
              } catch (err) {
                console.error('🔍 Error loading imported ontology:', err);
                return 0;
              }
            } else {
              // Check if cached data is empty and force reload
              const cachedData = JSON.parse(importData);
              if (cachedData.nodes && cachedData.nodes.length === 0 && cachedData.edges && cachedData.edges.length === 0) {
                console.log('🔍 Cached data is empty, forcing reload from API:', importIri);
                try {
                  const token = localStorage.getItem(tokenKey);
                  const apiUrl = `/api/ontology/?graph=${encodeURIComponent(importIri)}`;
                  const response = await fetch(apiUrl, {
                    headers: token ? { 'Authorization': `Bearer ${token}` } : {}
                  });
                  
                  if (response.ok) {
                    const ontologyData = await response.json();
                    console.log('🔍 Reloaded imported ontology from API:', ontologyData);
                    console.log('🔍 Reload API response structure - classes:', ontologyData.classes);
                    console.log('🔍 Reload API response structure - object_properties:', ontologyData.object_properties);
                    
                    // Convert to Cytoscape format and save to local storage
                    // The API response has the data nested in a 'data' property
                    const actualOntologyData = ontologyData.data || ontologyData;
                    console.log('🔍 Reload actual ontology data being passed to convertOntologyToCytoscape:', actualOntologyData);
                    console.log('🔍 Reload actualOntologyData.classes:', actualOntologyData.classes);
                    const cytoscapeData = convertOntologyToCytoscape(actualOntologyData);
                    console.log('🔍 Reload converted cytoscape data:', cytoscapeData);
                    const storageData = {
                      nodes: cytoscapeData.nodes || [],
                      edges: cytoscapeData.edges || [],
                      timestamp: Date.now(),
                      source: 'api'
                    };
                    
                    localStorage.setItem(importKey, JSON.stringify(storageData));
                    importData = JSON.stringify(storageData);
                    console.log('🔍 Reloaded and saved imported ontology data to local storage');
                  } else {
                    console.log('🔍 Failed to reload imported ontology from API:', response.status);
                  }
                } catch (err) {
                  console.error('🔍 Error reloading imported ontology:', err);
                }
              }
            }
            
            const importOntology = JSON.parse(importData);
            const importNodes = importOntology.nodes || [];
            const importClasses = importNodes.filter(node => (node.data && node.data.type === 'class') || !node.data?.type);
            console.log('🔍 Import classes found in local storage:', importClasses.length);
            
            const matched = new Set();
            importClasses.forEach(node => {
              const label = node.data?.label || node.data?.id || node.id;
              const key = norm(label);
              console.log('🔍 Checking match:', key, 'in base classes:', baseByLabel.has(key));
              console.log('🔍 Import class details - ID:', node.data?.id || node.id, 'Label:', label, 'Key:', key);
              if (baseByLabel.has(key)) {
                matched.add(node.data?.id || node.id);
                console.log('🔍 ✅ MATCH FOUND for:', key);
              } else {
                console.log('🔍 ❌ No match for:', key, 'Available base classes:', Array.from(baseByLabel.keys()));
              }
            });
            console.log('🔍 Matched classes:', matched.size);
            return matched.size;
          } catch(err) { 
            console.error('🔍 Error in importEquivCount:', err);
            return 0; 
          }
        }
        const visibleSet = loadVisibleImports(activeOntologyIri);
        imports.forEach(async g => {
          const li = document.createElement('li'); li.setAttribute('role','treeitem'); li.dataset.importIri = g;
          const r=document.createElement('div'); r.className='onto-node-row'; r.tabIndex = 0;
          const cb=document.createElement('input'); cb.type='checkbox'; cb.style.marginRight = '6px'; cb.checked = visibleSet.has(g);
          const t=document.createElement('span'); t.className='onto-twist';
          const l=document.createElement('span'); l.className='onto-node-label';
          const name = await friendlyImportName(g);
          const cnt = await importEquivCount(g);
          l.textContent = `${name}${cnt ? ` (${cnt})` : ''}`;
          cb.addEventListener('change', async () => {
            try {
              console.log('🔍 Checkbox changed for import:', g, 'checked:', cb.checked);
            const vis = loadVisibleImports(activeOntologyIri);
            if (cb.checked) vis.add(g); else vis.delete(g);
            saveVisibleImports(activeOntologyIri, vis);
              console.log('🔍 Visible imports updated:', Array.from(vis));
            await overlayImportsRefresh();
            } catch (err) {
              console.error('🔍 Error handling import checkbox change:', err);
              // Revert the checkbox state if there was an error
              cb.checked = !cb.checked;
            }
          });
          // Add collapse/expand button (hidden for now)
          const collapseBtn = document.createElement('button');
          collapseBtn.className = 'btn tree-add-btn';
          collapseBtn.title = 'Collapse/Expand Import';
          collapseBtn.textContent = ontoState.collapsedImports.has(g) ? '⊞' : '⊟';
          collapseBtn.style.marginLeft = '8px';
          collapseBtn.style.fontSize = '12px';
          collapseBtn.style.padding = '2px 6px';
          collapseBtn.style.minWidth = '20px';
          collapseBtn.style.height = '20px';
          collapseBtn.style.display = 'none'; // Hidden for now
          collapseBtn.onclick = (e) => {
            e.stopPropagation();
            toggleImportCollapse(g);
            // Update button text
            collapseBtn.textContent = ontoState.collapsedImports.has(g) ? '⊞' : '⊟';
          };
          
          r.onclick = (e)=>{ Array.from(ul.querySelectorAll('.onto-node-row')).forEach(n=>n.classList.remove('selected')); r.classList.add('selected'); };
          r.onkeydown = (e)=>{ const key=e.key||e.code; if (key==='Delete' || key==='Backspace') { e.preventDefault(); removeImport(g); } };
          r.appendChild(cb); r.appendChild(t); r.appendChild(l); r.appendChild(collapseBtn);
          li.appendChild(r); ul.appendChild(li);
        });
        importsRoot.appendChild(ul);
        root.appendChild(importsRoot);
        // Enable drop to import
        row.addEventListener('dragover', (e)=>{ e.preventDefault(); });
        row.addEventListener('drop', async (e)=>{
          e.preventDefault();
          const draggedIri = e.dataTransfer.getData('text/graph-iri');
          if (!draggedIri) return;
          const list = new Set(imports);
          if (!list.has(draggedIri)) { list.add(draggedIri); localStorage.setItem(importsKey, JSON.stringify(Array.from(list))); refreshOntologyTree(); }
          // Overlay imported classes (placeholder: we only list; loading remote triples is OW-2)
        });
      } catch(_) {}
    }

    // (empty-state banner removed)

    // Attribute templates for different object types
    const attributeTemplates = {
      class: {
        // Standard ontological properties
        comment: { type: 'textarea', label: 'Comment (rdfs:comment)', placeholder: 'Description of the class' },
        definition: { type: 'textarea', label: 'Definition (skos:definition)', placeholder: 'Formal definition of the class' },
        example: { type: 'textarea', label: 'Example (skos:example)', placeholder: 'Usage example' },
        identifier: { type: 'text', label: 'Identifier (dc:identifier)', placeholder: 'Unique identifier' },
        subclassOf: { type: 'text', label: 'Subclass of (rdfs:subClassOf)', placeholder: 'Parent class IRI' },
        equivalentClass: { type: 'text', label: 'Equivalent Class (owl:equivalentClass)', placeholder: 'Equivalent class IRI' },
        disjointWith: { type: 'text', label: 'Disjoint With (owl:disjointWith)', placeholder: 'Disjoint class IRI' },
        // Metadata properties
        creator: { type: 'text', label: 'Creator (dc:creator)', placeholder: 'Created by', readonly: true },
        created_date: { type: 'date', label: 'Created Date (dc:created)', placeholder: 'Creation date', readonly: true },
        created_timestamp: { type: 'text', label: 'Created Timestamp', placeholder: 'ISO timestamp', readonly: true },
        last_modified_by: { type: 'text', label: 'Last Modified By (dc:contributor)', placeholder: 'Modified by', readonly: true },
        last_modified_date: { type: 'date', label: 'Last Modified Date (dc:modified)', placeholder: 'Modification date', readonly: true },
        last_modified_timestamp: { type: 'text', label: 'Last Modified Timestamp', placeholder: 'ISO timestamp', readonly: true },
        // Custom properties
        priority: { type: 'select', label: 'Priority', options: ['High', 'Medium', 'Low'], placeholder: 'Select priority' },
        status: { type: 'select', label: 'Status', options: ['Draft', 'Review', 'Approved', 'Deprecated'], placeholder: 'Select status' }
      },
      objectProperty: {
        // Standard ontological properties
        comment: { type: 'textarea', label: 'Comment (rdfs:comment)', placeholder: 'Description of the property' },
        definition: { type: 'textarea', label: 'Definition (skos:definition)', placeholder: 'Formal definition of the property' },
        example: { type: 'textarea', label: 'Example (skos:example)', placeholder: 'Usage example' },
        identifier: { type: 'text', label: 'Identifier (dc:identifier)', placeholder: 'Unique identifier' },
        domain: { type: 'text', label: 'Domain (rdfs:domain)', placeholder: 'Source class IRI' },
        range: { type: 'text', label: 'Range (rdfs:range)', placeholder: 'Target class IRI' },
        inverseOf: { type: 'text', label: 'Inverse Of (owl:inverseOf)', placeholder: 'Inverse property IRI' },
        subPropertyOf: { type: 'text', label: 'Sub Property Of (rdfs:subPropertyOf)', placeholder: 'Parent property IRI' },
        equivalentProperty: { type: 'text', label: 'Equivalent Property (owl:equivalentProperty)', placeholder: 'Equivalent property IRI' },
        propertyType: { type: 'text', label: 'Property Type (rdf:type)', placeholder: 'Property characteristics (e.g., TransitiveProperty)' },
        // Metadata properties
        creator: { type: 'text', label: 'Creator (dc:creator)', placeholder: 'Created by', readonly: true },
        created_date: { type: 'date', label: 'Created Date (dc:created)', placeholder: 'Creation date', readonly: true },
        created_timestamp: { type: 'text', label: 'Created Timestamp', placeholder: 'ISO timestamp', readonly: true },
        last_modified_by: { type: 'text', label: 'Last Modified By (dc:contributor)', placeholder: 'Modified by', readonly: true },
        last_modified_date: { type: 'date', label: 'Last Modified Date (dc:modified)', placeholder: 'Modification date', readonly: true },
        last_modified_timestamp: { type: 'text', label: 'Last Modified Timestamp', placeholder: 'ISO timestamp', readonly: true },
        // Custom properties
        functional: { type: 'checkbox', label: 'Functional', placeholder: 'Is this a functional property?' },
        inverse_functional: { type: 'checkbox', label: 'Inverse Functional', placeholder: 'Is this inverse functional?' }
      },
      dataProperty: {
        // Standard ontological properties
        comment: { type: 'textarea', label: 'Comment (rdfs:comment)', placeholder: 'Description of the property' },
        definition: { type: 'textarea', label: 'Definition (skos:definition)', placeholder: 'Formal definition of the property' },
        example: { type: 'textarea', label: 'Example (skos:example)', placeholder: 'Usage example' },
        identifier: { type: 'text', label: 'Identifier (dc:identifier)', placeholder: 'Unique identifier' },
        domain: { type: 'text', label: 'Domain (rdfs:domain)', placeholder: 'Source class IRI' },
        range: { type: 'select', label: 'Range (rdfs:range)', options: ['xsd:string', 'xsd:integer', 'xsd:float', 'xsd:boolean', 'xsd:dateTime'], placeholder: 'Data type' },
        subPropertyOf: { type: 'text', label: 'Sub Property Of (rdfs:subPropertyOf)', placeholder: 'Parent property IRI' },
        equivalentProperty: { type: 'text', label: 'Equivalent Property (owl:equivalentProperty)', placeholder: 'Equivalent property IRI' },
        // Metadata properties
        creator: { type: 'text', label: 'Creator (dc:creator)', placeholder: 'Created by', readonly: true },
        created_date: { type: 'date', label: 'Created Date (dc:created)', placeholder: 'Creation date', readonly: true },
        created_timestamp: { type: 'text', label: 'Created Timestamp', placeholder: 'ISO timestamp', readonly: true },
        last_modified_by: { type: 'text', label: 'Last Modified By (dc:contributor)', placeholder: 'Modified by', readonly: true },
        last_modified_date: { type: 'date', label: 'Last Modified Date (dc:modified)', placeholder: 'Modification date', readonly: true },
        last_modified_timestamp: { type: 'text', label: 'Last Modified Timestamp', placeholder: 'ISO timestamp', readonly: true },
        // Custom properties
        functional: { type: 'checkbox', label: 'Functional', placeholder: 'Is this a functional property?' }
      },
      note: {
        noteType: { type: 'select', label: 'Note Type', options: ['Note', 'Warning', 'Issue', 'Todo', 'Info', 'Success', 'Question'], placeholder: 'Select note type' },
        content: { type: 'textarea', label: 'Content', placeholder: 'Note content' },
        // Metadata properties
        creator: { type: 'text', label: 'Creator (dc:creator)', placeholder: 'Created by', readonly: true },
        created_date: { type: 'date', label: 'Created Date (dc:created)', placeholder: 'Creation date', readonly: true },
        created_timestamp: { type: 'text', label: 'Created Timestamp', placeholder: 'ISO timestamp', readonly: true },
        last_modified_by: { type: 'text', label: 'Last Modified By (dc:contributor)', placeholder: 'Modified by', readonly: true },
        last_modified_date: { type: 'date', label: 'Last Modified Date (dc:modified)', placeholder: 'Modification date', readonly: true },
        last_modified_timestamp: { type: 'text', label: 'Last Modified Timestamp', placeholder: 'ISO timestamp', readonly: true },
        // Legacy fields for backward compatibility
        author: { type: 'text', label: 'Author (Legacy)', placeholder: 'Note author', readonly: true }
      },
      model: {
        // Standard ontological properties
        comment: { type: 'textarea', label: 'Comment (rdfs:comment)', placeholder: 'Description of the ontology' },
        definition: { type: 'textarea', label: 'Definition (skos:definition)', placeholder: 'Formal definition of the ontology' },
        version: { type: 'text', label: 'Version (owl:versionInfo)', placeholder: 'Ontology version' },
        namespace: { type: 'text', label: 'Namespace', placeholder: 'Base namespace URI' },
        imports: { type: 'textarea', label: 'Imports (owl:imports)', placeholder: 'Imported ontology URIs' }
      }
    };

    // Get current username synchronously for metadata
    function getCurrentUsername() {
      try {
        // First try the simple username storage (most reliable)
        const username = localStorage.getItem('odras_user');
        if (username && typeof username === 'string' && username.trim() !== '') {
          return username.trim();
        }
        
        // Try the full user object
        const userObj = localStorage.getItem('user');
        if (userObj) {
          const user = JSON.parse(userObj);
          if (user.username && typeof user.username === 'string') {
            return user.username;
          }
        }
        
        // Fallback to parsing the userMenu text
        const userMenu = document.querySelector('#userMenu');
        if (userMenu && userMenu.textContent) {
          const menuText = userMenu.textContent.trim();
          // Remove " (admin)" suffix if present
          const cleanUsername = menuText.replace(/\s*\(admin\)\s*$/, '').trim();
          if (cleanUsername && cleanUsername !== '') {
            return cleanUsername;
          }
        }
        
        return 'system';
      } catch(e) {
        console.error('Error getting current username:', e);
        return 'system';
      }
    }

    // Ontology metadata management functions
    function getCurrentTimestamp() {
      return new Date().toISOString();
    }

    function getCurrentDate() {
      return new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
    }

    function addCreationMetadata(attrs = {}) {
      const currentUser = getCurrentUsername();
      const timestamp = getCurrentTimestamp();
      
      return {
        ...attrs,
        creator: currentUser,
        created_date: getCurrentDate(),
        created_timestamp: timestamp,
        last_modified_by: currentUser,
        last_modified_date: getCurrentDate(),
        last_modified_timestamp: timestamp
      };
    }

    function updateModificationMetadata(attrs = {}) {
      const currentUser = getCurrentUsername();
      const timestamp = getCurrentTimestamp();
      
      return {
        ...attrs,
        last_modified_by: currentUser,
        last_modified_date: getCurrentDate(),
        last_modified_timestamp: timestamp
      };
    }

    // Named views persistence
    function namedViewsKey(baseIri) { return 'onto_named_views__' + encodeURIComponent(baseIri || ''); }
    function loadNamedViews(baseIri) { 
      try { 
        return JSON.parse(localStorage.getItem(namedViewsKey(baseIri)) || '[]'); 
      } catch(_) { 
        return []; 
      } 
    }
    function saveNamedViews(baseIri, views) { 
      try { 
        localStorage.setItem(namedViewsKey(baseIri), JSON.stringify(views || [])); 
      } catch(_) {} 
    }

    // Named view data structure functions
    function captureCurrentView(name) {
      if (!ontoState.cy || !activeOntologyIri) return null;
      
      const currentUser = getCurrentUsername();
      const timestamp = getCurrentTimestamp();
      
      return {
        id: `view_${Date.now()}`,
        name: name,
        creator: currentUser,
        created_date: getCurrentDate(),
        created_timestamp: timestamp,
        // Canvas state
        zoom: ontoState.cy.zoom(),
        pan: ontoState.cy.pan(),
        // Visibility state
        visibilityState: { ...ontoState.visibilityState },
        elementVisibility: { ...ontoState.elementVisibility },
        collapsedImports: Array.from(ontoState.collapsedImports),
        // Import visibility state - which imports are visible (checked in tree)
        visibleImports: Array.from(loadVisibleImports(activeOntologyIri))
      };
    }

    function restoreView(view) {
      if (!ontoState.cy || !view) return;
      
      // Restore visibility states
      ontoState.visibilityState = { ...view.visibilityState };
      ontoState.elementVisibility = { ...view.elementVisibility };
      ontoState.collapsedImports = new Set(view.collapsedImports || []);
      
      // Restore import visibility - set which imports should be visible
      if (view.visibleImports && activeOntologyIri) {
        const visibleImportsSet = new Set(view.visibleImports);
        saveVisibleImports(activeOntologyIri, visibleImportsSet);
      }
      
      // Apply visibility to canvas
      updateCanvasVisibility();
      
      // Refresh imports overlay to apply import visibility changes
      overlayImportsRefresh().then(() => {
        // After imports are refreshed, restore canvas position and zoom
        ontoState.cy.animate({
          zoom: view.zoom || 1,
          pan: view.pan || { x: 0, y: 0 }
        }, {
          duration: 500
        });
      });
      
      // Refresh tree to reflect all visibility changes
      refreshOntologyTree();
      
      // Save current states to localStorage
      if (activeOntologyIri) {
        saveVisibilityState(activeOntologyIri, ontoState.visibilityState);
        saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
        saveCollapsedImports(activeOntologyIri, ontoState.collapsedImports);
      }
      
      // Mark this view as active and refresh tree to show indicator
      ontoState.activeNamedView = view.id;
      refreshOntologyTree();
    }

    function restoreOriginalState() {
      if (!ontoState.beforeViewState) return;
      
      // Restore the state from before any named view was applied
      const beforeState = ontoState.beforeViewState;
      
      // Restore visibility states
      ontoState.visibilityState = { ...beforeState.visibilityState };
      ontoState.elementVisibility = { ...beforeState.elementVisibility };
      ontoState.collapsedImports = new Set(beforeState.collapsedImports || []);
      
      // Restore import visibility
      if (beforeState.visibleImports && activeOntologyIri) {
        const visibleImportsSet = new Set(beforeState.visibleImports);
        saveVisibleImports(activeOntologyIri, visibleImportsSet);
      }
      
      // Apply visibility to canvas
      updateCanvasVisibility();
      
      // Refresh imports overlay
      overlayImportsRefresh().then(() => {
        // Restore canvas position and zoom
        ontoState.cy.animate({
          zoom: beforeState.zoom || 1,
          pan: beforeState.pan || { x: 0, y: 0 }
        }, {
          duration: 500
        });
      });
      
      // Refresh tree
      refreshOntologyTree();
      
      // Save restored states to localStorage
      if (activeOntologyIri) {
        saveVisibilityState(activeOntologyIri, ontoState.visibilityState);
        saveElementVisibility(activeOntologyIri, ontoState.elementVisibility);
        saveCollapsedImports(activeOntologyIri, ontoState.collapsedImports);
      }
      
      // Clear the active view state
      ontoState.activeNamedView = null;
      ontoState.beforeViewState = null;
    }

    // Named view management functions
    function createNamedView() {
      if (!activeOntologyIri) return;
      
      const name = prompt('Enter a name for this view:');
      if (!name || name.trim() === '') return;
      
      const view = captureCurrentView(name.trim());
      if (!view) return;
      
      const views = loadNamedViews(activeOntologyIri);
      views.push(view);
      saveNamedViews(activeOntologyIri, views);
      
      refreshOntologyTree();
      console.log('🔍 Created named view:', name, 'with visible imports:', view.visibleImports);
    }

    function renameNamedView(viewId) {
      if (!activeOntologyIri) return;
      
      const views = loadNamedViews(activeOntologyIri);
      const view = views.find(v => v.id === viewId);
      if (!view) return;
      
      const newName = prompt('Enter new name for view:', view.name);
      if (!newName || newName.trim() === '' || newName.trim() === view.name) return;
      
      view.name = newName.trim();
      saveNamedViews(activeOntologyIri, views);
      
      refreshOntologyTree();
      console.log('🔍 Renamed view to:', newName);
    }

    function deleteNamedView(viewId) {
      if (!activeOntologyIri) return;
      
      const views = loadNamedViews(activeOntologyIri);
      const view = views.find(v => v.id === viewId);
      if (!view) return;
      
      if (!confirm(`Delete view "${view.name}"?`)) return;
      
      const updatedViews = views.filter(v => v.id !== viewId);
      saveNamedViews(activeOntologyIri, updatedViews);
      
      refreshOntologyTree();
      console.log('🔍 Deleted view:', view.name);
    }

    // Note type styling configuration
    function getNoteTypeStyle(noteType) {
      const styles = {
        'Note': {
          backgroundColor: '#2a1f0a',
          borderColor: '#8b5a1e',
          textColor: '#f5e6cc',
          symbol: '📝'
        },
        'Warning': {
          backgroundColor: '#2d1b0f',
          borderColor: '#d97706',
          textColor: '#fbbf24',
          symbol: '⚠️'
        },
        'Issue': {
          backgroundColor: '#2d0f0f',
          borderColor: '#dc2626',
          textColor: '#fca5a5',
          symbol: '❗'
        },
        'Todo': {
          backgroundColor: '#1e1b2d',
          borderColor: '#7c3aed',
          textColor: '#c4b5fd',
          symbol: '✅'
        },
        'Info': {
          backgroundColor: '#0f1a2d',
          borderColor: '#2563eb',
          textColor: '#93c5fd',
          symbol: 'ℹ️'
        },
        'Success': {
          backgroundColor: '#0f2d1a',
          borderColor: '#16a34a',
          textColor: '#86efac',
          symbol: '✨'
        },
        'Question': {
          backgroundColor: '#2d1a0f',
          borderColor: '#ea580c',
          textColor: '#fdba74',
          symbol: '❓'
        }
      };
      
      return styles[noteType] || styles['Note'];
    }

    function getTypeDisplayName(type) {
      const typeMap = {
        'class': 'Class',
        'objectProperty': 'Object Property',
        'dataProperty': 'Data Property',
        'note': 'Note',
        'model': 'Model'
      };
      return typeMap[type] || 'Class';
    }

    function updatePropertiesPanelFromSelection() {
      const form = qs('#ontoPropsForm'); if (!form || !ontoState.cy) return;
      const sel = ontoState.cy.$(':selected');
      const nameEl = qs('#propName');
      const typeValueEl = qs('#propTypeValue');
      
      let currentAttrs = {};
      let objectType = 'class';
      
      if (sel.length === 1 && sel[0].isNode()) {
        const n = sel[0];
        const isImported = n.hasClass('imported');
        nameEl.value = n.data('label') || n.id();
        nameEl.disabled = isImported; // Disable name editing for imported elements
        const nodeType = n.data('type') || 'class';
        typeValueEl.textContent = getTypeDisplayName(nodeType) + (isImported ? ' (Imported)' : '');
        currentAttrs = n.data('attrs') || {};
        objectType = nodeType;
        
        // Lazy load additional metadata for imported ontologies
        if (activeOntologyIri && activeOntologyIri.includes('/onto/') && !currentAttrs.definition) {
          loadAdditionalMetadataForElement(n.id(), activeOntologyIri);
        }
      } else if (sel.length === 1 && sel[0].isEdge()) {
        const e = sel[0];
        nameEl.value = e.data('predicate') || e.id();
        const edgeType = e.data('type') || 'objectProperty';
        typeValueEl.textContent = getTypeDisplayName(edgeType);
        currentAttrs = e.data('attrs') || {};
        
        // Lazy load additional metadata for imported ontologies
        if (activeOntologyIri && activeOntologyIri.includes('/onto/') && !currentAttrs.definition) {
          loadAdditionalMetadataForElement(e.id(), activeOntologyIri);
        }
        objectType = edgeType;
      } else {
        const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
        nameEl.value = localStorage.getItem(`onto_model_name__${pid}`) || 'Ontology Model';
        typeValueEl.textContent = getTypeDisplayName('model');
        objectType = 'model';
        try {
          currentAttrs = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}');
        } catch(_) { currentAttrs = {}; }
      }
      
      // Update attribute editor
      const isImportedElement = (sel.length === 1 && sel[0].hasClass('imported'));
      updateAttributeEditor(objectType, currentAttrs, isImportedElement);
      
      // Update element IRI display
      updateElementIriDisplay();
    }

    function updateAttributeEditor(objectType, currentAttrs, isReadOnly = false) {
      const container = qs('#propAttrsContainer');
      if (!container) return;
      
      container.innerHTML = '';
      
      if (isReadOnly) {
        // Show read-only message for imported elements
        const readOnlyMsg = document.createElement('div');
        readOnlyMsg.style.cssText = `
          padding: 12px;
          background: var(--panel-2);
          border: 1px solid var(--border);
          border-radius: 6px;
          text-align: center;
          color: var(--muted);
          font-style: italic;
          margin-bottom: 8px;
        `;
        readOnlyMsg.innerHTML = '🔒 Imported elements are read-only<br><small>Properties cannot be modified</small>';
        container.appendChild(readOnlyMsg);
      }
      
      const template = attributeTemplates[objectType] || {};
      
      // Add template attributes
      Object.entries(template).forEach(([key, config]) => {
        const attrDiv = createAttributeField(key, config, currentAttrs[key] || '', isReadOnly);
        container.appendChild(attrDiv);
      });
      
      // Add any custom attributes not in template
      Object.entries(currentAttrs).forEach(([key, value]) => {
        if (!template[key]) {
          const attrDiv = createAttributeField(key, { type: 'text', label: key }, value, isReadOnly);
          container.appendChild(attrDiv);
        }
      });
      
      // Disable save button for imported elements
      const saveBtn = qs('#propSaveBtn');
      if (saveBtn) {
        saveBtn.disabled = isReadOnly;
        saveBtn.style.opacity = isReadOnly ? '0.5' : '1';
        saveBtn.title = isReadOnly ? 'Cannot save changes to imported elements' : 'Save changes';
      }
      
      // Disable add and reset buttons for imported elements
      const addBtn = qs('#addAttrBtn');
      const resetBtn = qs('#resetAttrsBtn');
      if (addBtn) {
        addBtn.disabled = isReadOnly;
        addBtn.style.opacity = isReadOnly ? '0.5' : '1';
        addBtn.title = isReadOnly ? 'Cannot add attributes to imported elements' : 'Add custom attribute';
      }
      if (resetBtn) {
        resetBtn.disabled = isReadOnly;
        resetBtn.style.opacity = isReadOnly ? '0.5' : '1';
        resetBtn.title = isReadOnly ? 'Cannot reset attributes of imported elements' : 'Reset to template';
      }
    }

    function createAttributeField(key, config, value, isReadOnly = false) {
      const div = document.createElement('div');
      div.style.display = 'grid';
      div.style.gridTemplateColumns = '1fr auto';
      div.style.gap = '8px';
      div.style.alignItems = 'center';
      
      const label = document.createElement('label');
      label.textContent = config.label || key;
      label.style.fontSize = '12px';
      label.style.color = '#9ca3af';
      
      const inputContainer = document.createElement('div');
      inputContainer.style.display = 'flex';
      inputContainer.style.gap = '4px';
      
      let input;
      if (config.type === 'select') {
        input = document.createElement('select');
        input.style.width = '100%';
        input.style.background = '#0b1220';
        input.style.color = '#e5e7eb';
        input.style.border = '1px solid var(--border)';
        input.style.borderRadius = '4px';
        input.style.padding = '4px';
        input.style.fontSize = '12px';
        
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = config.placeholder || 'Select...';
        input.appendChild(defaultOption);
        
        if (config.options) {
          config.options.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option;
            opt.textContent = option;
            if (value === option) opt.selected = true;
            input.appendChild(opt);
          });
        }
      } else if (config.type === 'checkbox') {
        input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = value === true || value === 'true';
      } else if (config.type === 'textarea') {
        input = document.createElement('textarea');
        input.rows = 3;
        input.value = value || '';
        input.style.width = '100%';
        input.style.background = '#0b1220';
        input.style.color = '#e5e7eb';
        input.style.border = '1px solid var(--border)';
        input.style.borderRadius = '4px';
        input.style.padding = '4px';
        input.style.fontSize = '12px';
        input.style.resize = 'vertical';
      } else if (config.type === 'date') {
        input = document.createElement('input');
        input.type = 'date';
        input.value = value || '';
      } else {
        input = document.createElement('input');
        input.type = config.type || 'text';
        input.value = value || '';
        input.placeholder = config.placeholder || '';
      }
      
      if (input.type !== 'checkbox' && input.type !== 'textarea') {
        input.style.width = '100%';
        input.style.background = '#0b1220';
        input.style.color = '#e5e7eb';
        input.style.border = '1px solid var(--border)';
        input.style.borderRadius = '4px';
        input.style.padding = '4px';
        input.style.fontSize = '12px';
      }
      
      // Make input read-only for imported elements or readonly fields
      if (isReadOnly || config.readonly) {
        input.disabled = true;
        input.style.opacity = '0.6';
        input.style.cursor = 'not-allowed';
        input.title = config.readonly ? 'This field is read-only metadata' : 'This field cannot be edited for imported elements';
      }
      
      input.dataset.attrKey = key;
      input.dataset.attrType = config.type || 'text';
      
      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.textContent = '×';
      deleteBtn.style.background = '#dc2626';
      deleteBtn.style.color = 'white';
      deleteBtn.style.border = 'none';
      deleteBtn.style.borderRadius = '4px';
      deleteBtn.style.width = '24px';
      deleteBtn.style.height = '24px';
      deleteBtn.style.fontSize = '14px';
      deleteBtn.style.cursor = 'pointer';
      deleteBtn.title = 'Remove attribute';
      
      // Only show delete button for custom attributes (not in template)
      let objectType = 'class';
      if (ontoState.cy) {
        const sel = ontoState.cy.$(':selected');
        if (sel.length === 1) {
          objectType = sel[0].data('type') || 'class';
        } else {
          objectType = 'model';
        }
      }
      const template = attributeTemplates[objectType] || {};
      if (template[key]) {
        deleteBtn.style.display = 'none';
      }
      
      deleteBtn.onclick = () => {
        if (!isReadOnly) {
        div.remove();
        }
      };
      
      // Disable delete button for read-only fields
      if (isReadOnly) {
        deleteBtn.disabled = true;
        deleteBtn.style.opacity = '0.3';
        deleteBtn.style.cursor = 'not-allowed';
        deleteBtn.title = 'Cannot delete attributes of imported elements';
      }
      
      inputContainer.appendChild(input);
      inputContainer.appendChild(deleteBtn);
      
      div.appendChild(label);
      div.appendChild(inputContainer);
      
      return div;
    }

    function getCurrentAttributes() {
      const container = qs('#propAttrsContainer');
      if (!container) return {};
      
      const attrs = {};
      const inputs = container.querySelectorAll('input, select, textarea');
      
      inputs.forEach(input => {
        const key = input.dataset.attrKey;
        const type = input.dataset.attrType;
        
        if (key) {
          let value;
          if (type === 'checkbox') {
            value = input.checked;
          } else if (type === 'select' && input.value === '') {
            value = null; // Don't include empty selects
          } else {
            value = input.value.trim();
            if (value === '') value = null; // Don't include empty strings
          }
          
          if (value !== null) {
            attrs[key] = value;
          }
        }
      });
      
      return attrs;
    }

    function getModelNamespace() {
      // Get model namespace from active ontology IRI (proper project-scoped URI)
      if (activeOntologyIri) {
        console.log('🔧 getModelNamespace using activeOntologyIri:', activeOntologyIri);
        return activeOntologyIri;
      }
      
      // Try to get from stored attributes
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      try {
        const modelAttrs = JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}');
        if (modelAttrs.namespace && !modelAttrs.namespace.endsWith('/ontology')) {
          console.log('🔧 getModelNamespace using stored namespace:', modelAttrs.namespace);
          return modelAttrs.namespace;
        }
        // If the stored namespace is the old hardcoded one, update it
        if (modelAttrs.graphIri) {
          console.log('🔧 getModelNamespace updating stored namespace to use graphIri:', modelAttrs.graphIri);
          modelAttrs.namespace = modelAttrs.graphIri;
          localStorage.setItem(`onto_model_attrs__${pid}`, JSON.stringify(modelAttrs));
          return modelAttrs.graphIri;
        }
      } catch(_) {}
      
      // Use installation configuration as fallback (but this is wrong for project-scoped ontologies)
      const fallback = INSTALLATION_CONFIG.baseUri + '/ontology';
      console.log('⚠️ getModelNamespace using hardcoded fallback (this should not happen):', fallback);
      return fallback;
    }

    function updateElementIriDisplay() {
      const iriEl = qs('#ontoElementIri');
      const container = qs('#ontoElementIriContainer');
      const copyBtn = qs('#ontoCopyIriBtn');
      if (!iriEl || !container) return;
      
      // Only show container if we have a canvas
      if (!ontoState.cy) {
        container.style.display = 'none';
        return;
      }
      
      container.style.display = 'block';
      
      const sel = ontoState.cy.$(':selected');
      if (sel.length === 1) {
        const element = sel[0];
        const elementId = element.id();
        const elementType = element.data('type') || (element.isNode() ? 'class' : 'objectProperty');
        const isImported = element.hasClass('imported');
        const importSource = element.data('importSource');
        
        let iri = '';
        let namespace = '';
        
        if (isImported && importSource) {
          // For imported elements, use their original IRI and show the import source
          const originalIri = element.data('iri');
          console.log('🔍 Imported element selected:', {
            elementId,
            elementLabel: element.data('label'),
            originalIri,
            importSource,
            elementData: element.data()
          });
          
          if (originalIri && originalIri !== elementId && !originalIri.includes('Class')) {
            iri = originalIri;
            namespace = importSource;
          } else {
            // Fallback: construct IRI using import source as namespace
            const elementLabel = element.data('label') || elementId;
            const sluggedLabel = slugId(elementLabel) || elementId;
            iri = `${importSource}#${sluggedLabel}`;
            namespace = importSource;
          }
          
          iriEl.textContent = iri;
          iriEl.title = `IRI: ${iri}\nType: ${elementType}\nImported from: ${importSource}\nClick to copy`;
          iriEl.style.color = '#fbbf24'; // Different color for imported elements
          iriEl.style.opacity = '1';
        } else {
          // For local elements, use model namespace as before
          const modelNamespace = getModelNamespace();
        const elementLabel = element.data('label') || elementId;
        const sluggedLabel = slugId(elementLabel) || elementId;
        
        iri = `${modelNamespace}#${sluggedLabel}`;
          namespace = modelNamespace;
        
        iriEl.textContent = iri;
          iriEl.title = `IRI: ${iri}\nType: ${elementType}\nModel Namespace: ${namespace}\nClick to copy`;
        iriEl.style.color = '#60a5fa';
        iriEl.style.opacity = '1';
        }
        
        // Show copy button
        if (copyBtn) {
          copyBtn.style.display = 'inline-block';
          copyBtn.onclick = () => copyIriToClipboard(iri);
        }
        
        // Add click handler to IRI text
        iriEl.onclick = () => copyIriToClipboard(iri);
      } else {
        // Show current namespace when no element is selected
        const modelNamespace = getModelNamespace();
        iriEl.textContent = modelNamespace;
        iriEl.title = `Current Model Namespace: ${modelNamespace}\nClick to copy namespace`;
        iriEl.style.color = '#60a5fa';
        iriEl.style.opacity = '1';
        iriEl.onclick = () => copyIriToClipboard(modelNamespace);
        
        // Show copy button for namespace
        if (copyBtn) {
          copyBtn.style.display = 'inline-block';
          copyBtn.onclick = () => copyIriToClipboard(modelNamespace);
        }
      }
    }

    function copyIriToClipboard(iri) {
      try {
        navigator.clipboard.writeText(iri).then(() => {
          // Show temporary feedback
          const copyBtn = qs('#ontoCopyIriBtn');
          if (copyBtn) {
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            copyBtn.style.background = '#10b981';
            setTimeout(() => {
              copyBtn.textContent = originalText;
              copyBtn.style.background = '';
            }, 1000);
          }
        }).catch(() => {
          // Fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = iri;
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
          
          const copyBtn = qs('#ontoCopyIriBtn');
          if (copyBtn) {
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            copyBtn.style.background = '#10b981';
            setTimeout(() => {
              copyBtn.textContent = originalText;
              copyBtn.style.background = '';
            }, 1000);
          }
        });
      } catch (error) {
        console.warn('Failed to copy IRI to clipboard:', error);
      }
    }

    function persistOntologyToLocalStorage() {
      if (!ontoState.cy) return;
      if (ontoState.suspendAutosave) return;
      try {
        const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({ data: n.data(), position: n.position() }));
        const edges = ontoState.cy.edges().filter(e => !e.hasClass('imported')).map(e => ({ data: e.data() }));
        if (activeOntologyIri) {
          const storageData = { 
            nodes, 
            edges, 
            timestamp: Date.now(),
            source: 'local' // Mark that this data was saved locally
          };
          localStorage.setItem(storageKeyForGraph(activeOntologyIri), JSON.stringify(storageData));
          
          // Also save layout data to server
          saveLayoutToServer(activeOntologyIri, nodes, edges);
        }
      } catch(_) {}
    }

    async function saveLayoutToServer(graphIri, nodes, edges) {
      try {
        console.log('💾 Saving layout to server for:', graphIri);
        
        const pan = ontoState.cy.pan();
        const zoom = ontoState.cy.zoom();
        
        const layoutData = {
          nodes: nodes.map(n => ({
            iri: n.data.id,
            x: n.position.x,
            y: n.position.y
          })),
          edges: edges.map(e => ({
            iri: e.data.id
          })),
          zoom: zoom,
          pan: { x: pan.x, y: pan.y }
        };

        console.log('💾 Layout data:', {
          nodeCount: layoutData.nodes.length,
          edgeCount: layoutData.edges.length,
          zoom: layoutData.zoom,
          pan: layoutData.pan
        });

        const response = await authenticatedFetch(`/api/ontology/layout?graph=${encodeURIComponent(graphIri)}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(layoutData)
        });

        console.log('💾 Layout save response status:', response.status);
        console.log('💾 Layout save response ok:', response.ok);

        if (!response.ok) {
          console.warn('❌ Failed to save layout to server:', response.status);
        } else {
          console.log('✅ Layout saved to server successfully!');
        }
      } catch (error) {
        console.warn('Error saving layout to server:', error);
      }
    }

    async function loadLayoutFromServer(graphIri) {
      try {
        const response = await authenticatedFetch(`/api/ontology/layout?graph=${encodeURIComponent(graphIri)}`);

        if (response.ok) {
          const result = await response.json();
          const layoutData = result.data;
          
          if (layoutData && layoutData.nodes && layoutData.nodes.length > 0) {
            // Apply node positions
            layoutData.nodes.forEach(nodeLayout => {
              const node = ontoState.cy.$(`#${nodeLayout.iri}`);
              if (node.length > 0) {
                node.position({ x: nodeLayout.x, y: nodeLayout.y });
              }
            });
            
            // Apply zoom and pan
            if (layoutData.zoom && layoutData.pan) {
              ontoState.cy.zoom(layoutData.zoom);
              ontoState.cy.pan(layoutData.pan);
            }
            
            console.log('Layout loaded from server');
            return true;
          }
        } else if (response.status !== 404) {
          console.warn('Failed to load layout from server:', response.status);
        }
      } catch (error) {
        console.warn('Error loading layout from server:', error);
      }
      return false;
    }

    // graphKeyForActive not used; per-project keys are used via storageKeyForGraph
    function attrsFromModel() {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      try { return JSON.parse(localStorage.getItem(`onto_model_attrs__${pid}`) || '{}'); } catch(_) { return {}; }
    }
    function loadOntologyLabelMap(project) {
      const pid = project?.id || project?.project_id || (activeProject && (activeProject.id || activeProject.project_id)) || 'default';
      try { return JSON.parse(localStorage.getItem(`onto_label_map__${pid}`) || '{}'); } catch(_) { return {}; }
    }
    function saveOntologyLabel(graphIri, label) {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      try { const m = loadOntologyLabelMap(activeProject); m[graphIri] = label; localStorage.setItem(`onto_label_map__${pid}`, JSON.stringify(m)); } catch(_) {}
    }
    function storageKeyForGraph(iri) {
      const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
      return `onto_graph__${pid}__` + encodeURIComponent(iri);
    }
    function saveGraphToLocal(graphIri) {
      try {
        const nodes = ontoState.cy ? ontoState.cy.nodes().jsons() : [];
        const edges = ontoState.cy ? ontoState.cy.edges().jsons() : [];
        const storageData = { 
          nodes, 
          edges, 
          timestamp: Date.now(),
          source: 'local' // Mark that this data was saved locally
        };
        localStorage.setItem(storageKeyForGraph(graphIri), JSON.stringify(storageData));
      } catch(_) {}
    }
    function loadGraphFromLocal(graphIri) {
      try {
        const json = localStorage.getItem(storageKeyForGraph(graphIri));
        if (!json) return;
        const data = JSON.parse(json);
        if (!ontoState.cy) return;
        ontoState.cy.elements().remove();
        ontoState.cy.add(data.nodes || []);
        ontoState.cy.add(data.edges || []);
        // Ensure all loaded elements have attrs property
        ensureAttributesExist();
        // After loading, ensure nextId is advanced beyond existing ClassNNN
        recomputeNextId();
        requestAnimationFrame(()=>{ ontoState.cy.fit(); });
      } catch(_) {}
    }

    async function fetchRichMetadata(graphIri) {
      try {
        console.log('🔍 fetchRichMetadata called for:', graphIri);
        
        // Optimized SPARQL queries - fetch only essential metadata first
        // We'll fetch labels and basic info first, then load other metadata on demand
        const qClasses = `
          PREFIX owl: <http://www.w3.org/2002/07/owl#>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX dc11: <http://purl.org/dc/elements/1.1/>
          PREFIX dcterms: <http://purl.org/dc/terms/>
          PREFIX obo: <http://purl.obolibrary.org/obo/>
          SELECT ?c ?label ?comment ?definition ?example ?identifier ?subclassOf ?equivalentClass WHERE {
            GRAPH <${graphIri}> { 
              ?c a owl:Class . 
              OPTIONAL { ?c rdfs:label ?label }
              OPTIONAL { ?c rdfs:comment ?comment }
              OPTIONAL { ?c skos:definition ?definition }
              OPTIONAL { ?c skos:example ?example }
              OPTIONAL { ?c dc11:identifier ?identifier }
              OPTIONAL { ?c rdfs:subClassOf ?subclassOf }
              OPTIONAL { ?c owl:equivalentClass ?equivalentClass }
            } 
          }`;
        
        const qProps = `
          PREFIX owl: <http://www.w3.org/2002/07/owl#>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX dc11: <http://purl.org/dc/elements/1.1/>
          PREFIX dcterms: <http://purl.org/dc/terms/>
          SELECT ?p ?label ?comment ?definition ?example ?identifier ?domain ?range ?inverseOf ?subPropertyOf ?equivalentProperty ?propertyType WHERE {
            GRAPH <${graphIri}> { 
              ?p a owl:ObjectProperty . 
              OPTIONAL { ?p rdfs:label ?label }
              OPTIONAL { ?p rdfs:comment ?comment }
              OPTIONAL { ?p skos:definition ?definition }
              OPTIONAL { ?p skos:example ?example }
              OPTIONAL { ?p dc11:identifier ?identifier }
              OPTIONAL { ?p rdfs:domain ?domain }
              OPTIONAL { ?p rdfs:range ?range }
              OPTIONAL { ?p owl:inverseOf ?inverseOf }
              OPTIONAL { ?p rdfs:subPropertyOf ?subPropertyOf }
              OPTIONAL { ?p owl:equivalentProperty ?equivalentProperty }
              OPTIONAL { ?p a ?propertyType }
            } 
          }`;
        
        const classesRes = await authenticatedFetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qClasses }) });
        const propsRes = await authenticatedFetch('/api/ontology/sparql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query: qProps }) });
        const classesJson = classesRes.ok ? await classesRes.json() : { results: { bindings: [] } };
        const propsJson = propsRes.ok ? await propsRes.json() : { results: { bindings: [] } };
        
        // Enhanced class processing with rich metadata
        const classes = (classesJson.results?.bindings || []).map(b => {
          const iri = b.c.value;
          const label = (b.label && b.label.value) || (iri.includes('#') ? iri.split('#').pop() : iri.split('/').pop());
          const attrs = {};
          
          // Store all available metadata
          if (b.comment && b.comment.value) attrs.comment = b.comment.value;
          if (b.definition && b.definition.value) attrs.definition = b.definition.value;
          if (b.example && b.example.value) attrs.example = b.example.value;
          if (b.identifier && b.identifier.value) attrs.identifier = b.identifier.value;
          if (b.subclassOf && b.subclassOf.value) attrs.subclassOf = b.subclassOf.value;
          if (b.equivalentClass && b.equivalentClass.value) attrs.equivalentClass = b.equivalentClass.value;
          
          return { iri, label, attrs };
        });
        
        // Enhanced property processing with rich metadata
        const properties = [];
        (propsJson.results?.bindings || []).forEach(b => {
          const p = b.p.value;
          const label = (b.label && b.label.value) || (p.includes('#') ? p.split('#').pop() : p.split('/').pop());
          const attrs = {};
          
          // Store all available metadata
          if (b.comment && b.comment.value) attrs.comment = b.comment.value;
          if (b.definition && b.definition.value) attrs.definition = b.definition.value;
          if (b.example && b.example.value) attrs.example = b.example.value;
          if (b.identifier && b.identifier.value) attrs.identifier = b.identifier.value;
          if (b.domain && b.domain.value) attrs.domain = b.domain.value;
          if (b.range && b.range.value) attrs.range = b.range.value;
          if (b.inverseOf && b.inverseOf.value) attrs.inverseOf = b.inverseOf.value;
          if (b.subPropertyOf && b.subPropertyOf.value) attrs.subPropertyOf = b.subPropertyOf.value;
          if (b.equivalentProperty && b.equivalentProperty.value) attrs.equivalentProperty = b.equivalentProperty.value;
          if (b.propertyType && b.propertyType.value) attrs.propertyType = b.propertyType.value;
          
          properties.push({ iri: p, label, attrs });
        });
        
        return { classes, properties };
      } catch (error) {
        console.error('Failed to fetch rich metadata:', error);
        return { classes: [], properties: [] };
      }
    }

    function convertOntologyToCytoscape(ontologyData) {
      // Convert API ontology format to Cytoscape format
      const nodes = [];
      const edges = [];
      
      // Create nodes for classes
      const classes = ontologyData.classes || [];
      const classNameToId = {}; // Map class names to IDs
      
      classes.forEach((cls, index) => {
        // Use the original URI as ID if available, otherwise fall back to simple ID
        const classId = cls.iri || `Class${index + 1}`;
        classNameToId[cls.name] = classId;
        
        // Arrange in a grid layout
        const row = Math.floor(index / 4);
        const col = index % 4;
        
        const node = {
          data: {
            id: classId,
            iri: cls.iri || classId, // Preserve original URI
            label: cls.label || cls.name,
            type: 'class'
          },
          position: {
            x: 150 + (col * 200),
            y: 100 + (row * 150)
          }
        };
        nodes.push(node);
      });
      
      // Create edges for object properties
      let edgeId = 1;
      const objectProps = ontologyData.object_properties || [];
      objectProps.forEach(prop => {
        if (prop.domain && prop.range && classNameToId[prop.domain] && classNameToId[prop.range]) {
          const edge = {
            data: {
              id: `e${edgeId}`,
              source: classNameToId[prop.domain],
              target: classNameToId[prop.range],
              predicate: prop.name,
              label: prop.label || prop.name,
              type: 'objectProperty',
              attrs: {}
            }
          };
          edges.push(edge);
          edgeId++;
        }
      });
      
      // Create data property nodes and connect them to their domain classes
      let dpId = 1;
      const dataProps = ontologyData.datatype_properties || [];
      dataProps.forEach(prop => {
        if (prop.domain && classNameToId[prop.domain]) {
          const dataPropertyId = `DP${dpId}`;
          
          // Create data property node
          const domainClassId = classNameToId[prop.domain];
          const domainNode = nodes.find(n => n.data.id === domainClassId);
          let dpX = 150, dpY = 100; // fallback position
          
          if (domainNode) {
            // Position data property near its domain class
            dpX = domainNode.position.x + 180;
            dpY = domainNode.position.y + (dpId % 3 - 1) * 60; // stagger vertically
          }
          
          const dpNode = {
            data: {
              id: dataPropertyId,
              label: prop.label || prop.name,
              type: 'dataProperty'
            },
            position: {
              x: dpX,
              y: dpY
            }
          };
          nodes.push(dpNode);
          
          // Create edge connecting class to data property
          const dpEdge = {
            data: {
              id: `edp${dpId}`,
              source: domainClassId,
              target: dataPropertyId,
              predicate: prop.name,
              type: 'objectProperty', // UI uses objectProperty type for visual connection
              attrs: {}
            }
          };
          edges.push(dpEdge);
          
          dpId++;
        }
      });
      
      return { nodes, edges };
    }

    function convertOntologyToCytoscapeWithMetadata(ontologyData, richMetadata) {
      // Convert API ontology format to Cytoscape format with rich metadata
      const nodes = [];
      const edges = [];
      
      // Create a map of URI to rich metadata
      const classMetadataMap = {};
      richMetadata.classes.forEach(cls => {
        classMetadataMap[cls.iri] = cls;
      });
      
      const propertyMetadataMap = {};
      richMetadata.properties.forEach(prop => {
        propertyMetadataMap[prop.iri] = prop;
      });
      
      // Create nodes for classes
      const classes = ontologyData.classes || [];
      const classNameToId = {}; // Map class names to simple IDs
      
      classes.forEach((cls, index) => {
        // Use the original URI as ID if available, otherwise fall back to simple ID
        const classId = cls.iri || `Class${index + 1}`;
        classNameToId[cls.name] = classId;
        
        // Get rich metadata for this class
        const richClass = classMetadataMap[cls.uri] || {};
        const displayLabel = richClass.label || cls.label || cls.name;
        
        // Arrange in a circular layout for better initial positioning
        const totalClasses = classes.length;
        const angle = (2 * Math.PI * index) / totalClasses;
        const radius = Math.max(200, totalClasses * 25);
        const centerX = 400;
        const centerY = 300;
        
        const node = {
          data: {
            id: classId,
            iri: cls.iri || classId, // Preserve original URI
            label: displayLabel,
            type: 'class',
            attrs: richClass.attrs || {}
          },
          position: {
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle)
          }
        };
        nodes.push(node);
      });
      
      // Create edges for object properties
      let edgeId = 1;
      const objectProps = ontologyData.object_properties || [];
      objectProps.forEach(prop => {
        if (prop.domain && prop.range && classNameToId[prop.domain] && classNameToId[prop.range]) {
          // Get rich metadata for this property
          const richProp = propertyMetadataMap[prop.uri] || {};
          const displayLabel = richProp.label || prop.label || prop.name;
          
          const edge = {
            data: {
              id: `e${edgeId}`,
              source: classNameToId[prop.domain],
              target: classNameToId[prop.range],
              predicate: displayLabel,  // Use display label for predicate (what Cytoscape shows)
              label: displayLabel,      // Also set label for consistency
              type: 'objectProperty',
              attrs: richProp.attrs || {}
            }
          };
          edges.push(edge);
          edgeId++;
        }
      });
      
      // Create data property nodes and connect them to their domain classes
      let dpId = 1;
      const dataProps = ontologyData.datatype_properties || [];
      dataProps.forEach(prop => {
        if (prop.domain && classNameToId[prop.domain]) {
          const dataPropertyId = `DP${dpId}`;
          
          // Get rich metadata for this property
          const richProp = propertyMetadataMap[prop.uri] || {};
          const displayLabel = richProp.label || prop.label || prop.name;
          
          // Create data property node
          const domainClassId = classNameToId[prop.domain];
          const domainNode = nodes.find(n => n.data.id === domainClassId);
          let dpX = 150, dpY = 100; // fallback position
          
          if (domainNode) {
            // Position data property near its domain class
            dpX = domainNode.position.x + 180;
            dpY = domainNode.position.y + (dpId % 3 - 1) * 60; // stagger vertically
          }
          
          const dpNode = {
            data: {
              id: dataPropertyId,
              label: displayLabel,
              type: 'dataProperty',
              attrs: richProp.attrs || {}
            },
            position: {
              x: dpX,
              y: dpY
            }
          };
          nodes.push(dpNode);
          
          // Create edge connecting class to data property
          const dpEdge = {
            data: {
              id: `edp${dpId}`,
              source: domainClassId,
              target: dataPropertyId,
              predicate: prop.name,
              type: 'objectProperty', // UI uses objectProperty type for visual connection
              attrs: {}
            }
          };
          edges.push(dpEdge);
          
          dpId++;
        }
      });
      
      return { nodes, edges };
    }

    function convertCytoscapeToOntology() {
      // Convert current Cytoscape canvas to ontology JSON format
      if (!ontoState.cy) return null;
      
      const ontologyData = {
        metadata: {
          name: "Ontology from Canvas",
          namespace: activeOntologyIri || `${INSTALLATION_CONFIG.baseUri}/default`,
          created: new Date().toISOString()
        },
        classes: [],
        object_properties: [],
        datatype_properties: []
      };
      
      // Process nodes
      ontoState.cy.nodes().forEach(node => {
        const data = node.data();
        const type = data.type || 'class';
        
        if (type === 'class') {
          ontologyData.classes.push({
            name: data.id,
            label: data.label || data.id,
            comment: data.comment || ''
          });
        } else if (type === 'dataProperty') {
          ontologyData.datatype_properties.push({
            name: data.id,
            label: data.label || data.id,
            comment: data.comment || '',
            domain: data.domain || '',
            range: data.range || 'string'
          });
        }
      });
      
      // Process edges
      ontoState.cy.edges().forEach(edge => {
        const data = edge.data();
        const sourceType = ontoState.cy.$(`#${data.source}`).data('type') || 'class';
        const targetType = ontoState.cy.$(`#${data.target}`).data('type') || 'class';
        
        if (sourceType === 'class' && targetType === 'class') {
          ontologyData.object_properties.push({
            name: data.id,
            label: data.predicate || data.id,
            comment: data.comment || '',
            domain: data.source,
            range: data.target
          });
        }
      });
      
      return ontologyData;
    }

    async function loadGraphFromLocalOrAPI(graphIri) {
      try {
        console.log('🔍 loadGraphFromLocalOrAPI called for:', graphIri);
        
        // Load collapsed imports state for this ontology
        ontoState.collapsedImports = loadCollapsedImports(graphIri);
        
        // Load visibility state for this ontology
        ontoState.visibilityState = loadVisibilityState(graphIri);
        
        // Load individual element visibility for this ontology
        ontoState.elementVisibility = loadElementVisibility(graphIri);
        
        // Check if this is an imported ontology by looking for the pattern in the graph IRI
        const isImportedOntology = graphIri.includes('/onto/') && !graphIri.includes('#layout');
        
        // First, try to load from local storage for ALL ontologies (including imported ones)
        const json = localStorage.getItem(storageKeyForGraph(graphIri));
        if (json) {
          console.log('🔍 Loading from local storage:', json.substring(0, 200) + '...');
          const data = JSON.parse(json);
          if (data && (data.nodes || data.edges) && data.nodes?.length > 0) {
            if (!ontoState.cy) return;
            ontoState.cy.elements().remove();
            ontoState.cy.add(data.nodes || []);
            ontoState.cy.add(data.edges || []);
            // Ensure all loaded elements have attrs property
            ensureAttributesExist();
            recomputeNextId();
            
            // Try to load layout from server
            await loadLayoutFromServer(graphIri);
            
            // Apply saved visibility states
            updateCanvasVisibility();
            
            console.log('✅ Graph loaded from local storage, preserving current state');
            console.log('📊 Data source:', data.source || 'unknown', 'Timestamp:', data.timestamp ? new Date(data.timestamp).toLocaleString() : 'unknown');
            return;
          }
        }
        
        // Only fetch from API if local storage is empty or invalid
        if (isImportedOntology) {
          console.log('🔍 No local storage found for imported ontology, fetching from API for rich metadata');
          // Show loading indicator for imported ontologies
          showOntologyLoadingIndicator();
        } else {
          console.log('🔍 No local storage found, fetching from API');
        }
        
        // If local storage is empty, fetch from API
        console.log('Loading ontology from API:', graphIri);
        
        // Update progress: Fetching basic ontology data
        if (isImportedOntology) {
          updateOntologyLoadingProgress('Fetching ontology data...', 20);
        }
        
        const token = localStorage.getItem(tokenKey);
        const apiUrl = `/api/ontology/?graph=${encodeURIComponent(graphIri)}`;
        const response = await fetch(apiUrl, {
          headers: token ? { 'Authorization': `Bearer ${token}` } : {}
        });
        
        if (response.ok) {
          const result = await response.json();
          const ontologyData = result.data;
          
          if (ontologyData) {
            console.log('🔍 Loading ontology data from API:', ontologyData);
            
            // Update progress: Fetching rich metadata
            if (isImportedOntology) {
              updateOntologyLoadingProgress('Fetching rich metadata...', 40);
            }
            
            // Fetch rich metadata using the same queries as fetchImportGraphSnapshot
            const richMetadata = await fetchRichMetadata(graphIri);
            console.log('🔍 Rich metadata fetched:', richMetadata);
            
            // Update progress: Converting to graph format
            if (isImportedOntology) {
              updateOntologyLoadingProgress('Converting to graph format...', 60);
            }
            
            // Convert ontology JSON to Cytoscape format with rich metadata
            const cytoscapeData = convertOntologyToCytoscapeWithMetadata(ontologyData, richMetadata);
            console.log('🔍 Cytoscape data with metadata:', cytoscapeData);
            
            // Update progress: Loading graph
            if (isImportedOntology) {
              updateOntologyLoadingProgress('Loading graph...', 80);
            }
            
            if (!ontoState.cy) return;
            ontoState.cy.elements().remove();
            ontoState.cy.add(cytoscapeData.nodes || []);
            ontoState.cy.add(cytoscapeData.edges || []);
            recomputeNextId();
            
            // Save to local storage for future use with timestamp
            const storageData = {
              nodes: cytoscapeData.nodes || [],
              edges: cytoscapeData.edges || [],
              timestamp: Date.now(),
              source: 'api' // Mark that this data came from API with rich metadata
            };
            localStorage.setItem(storageKeyForGraph(graphIri), JSON.stringify(storageData));
            
            // Update progress: Loading layout
            if (isImportedOntology) {
              updateOntologyLoadingProgress('Loading layout...', 90);
            }
            
            // Try to load layout from server, fallback to fit if no layout
            const layoutLoaded = await loadLayoutFromServer(graphIri);
            if (!layoutLoaded) {
              requestAnimationFrame(()=>{ ontoState.cy.fit(); });
            }
            
            // Apply saved visibility states
            updateCanvasVisibility();
            
            // Complete loading
            if (isImportedOntology) {
              updateOntologyLoadingProgress('Complete!', 100);
              setTimeout(() => {
                hideOntologyLoadingIndicator();
                // Apply a nice layout after loading
                setTimeout(() => {
                  runAdvancedLayout('cose'); // Use force-directed layout for imported ontologies
                }, 200);
              }, 500);
            }
            
            console.log('Ontology loaded from API with', cytoscapeData.nodes?.length || 0, 'nodes and', cytoscapeData.edges?.length || 0, 'edges');
          }
        } else {
          console.error('Failed to load ontology from API:', response.status, response.statusText);
          if (isImportedOntology) {
            hideOntologyLoadingIndicator();
          }
        }
        
        // Refresh overlay imports to restore visible imported ontologies
        await overlayImportsRefresh();
        
        // Apply saved visibility states
        updateCanvasVisibility();
        
      } catch(err) {
        console.error('Error loading ontology:', err);
        // Hide loading indicator on error
        hideOntologyLoadingIndicator();
      }
    }

    // Ontology toolbar events and import handling
    (function(){
      document.addEventListener('click', async (e) => {
        if (e.target === qs('#ontoLayoutBtn')) {
          const selectedLayout = qs('#ontoLayoutSelector').value;
          runAdvancedLayout(selectedLayout);
        } else if (e.target === qs('#ontoQuickCoseBtn')) {
          runAdvancedLayout('cose');
        } else if (e.target === qs('#ontoQuickDagreBtn')) {
          runAdvancedLayout('dagre');
        } else if (e.target === qs('#ontoForceRefreshBtn')) {
          if (activeOntologyIri) {
            // Clear local storage and force reload from API
            localStorage.removeItem(storageKeyForGraph(activeOntologyIri));
            loadGraphFromLocalOrAPI(activeOntologyIri);
          }
        } else if (e.target === qs('#ontoClearCacheBtn')) {
          // Clear all ontology localStorage and reload page
          if (confirm('Clear all cached ontology data? This will reload the page and fetch everything fresh from the server.')) {
            console.log('🧹 Clearing ontology localStorage cache...');
            
            // Clear all ontology-related localStorage
            Object.keys(localStorage).forEach(key => {
              if (key.includes('onto_')) {
                localStorage.removeItem(key);
                console.log('🧹 Removed:', key);
              }
            });
            
            console.log('🧹 Cache cleared, reloading page...');
            location.reload();
          }
        } else if (e.target === qs('#ontoFitBtn')) {
          try { if (ontoState.cy) ontoState.cy.fit(undefined, 20); } catch(_) {}
        } else if (e.target === qs('#ontoFullscreenBtn')) {
          try {
            const sec = qs('#wb-ontology');
            if (!sec) return;
            if (!document.fullscreenElement) {
              if (sec.requestFullscreen) await sec.requestFullscreen();
            } else {
              if (document.exitFullscreen) await document.exitFullscreen();
            }
          } catch(_) {}
        } else if (e.target === qs('#ontoSaveBtn')) {
          try {
            if (!activeOntologyIri) { alert('Select an ontology to save.'); return; }
            if (!ontoState.cy) { alert('No ontology data to save.'); return; }
            
            console.log('💾 Starting ontology save operation...');
            console.log('💾 Active ontology IRI:', activeOntologyIri);
            
            // Convert current canvas to ontology JSON format
            const ontologyData = convertCytoscapeToOntology();
            console.log('💾 Converted ontology data:', ontologyData);
            console.log('💾 Number of nodes:', ontologyData.nodes?.length || 0);
            console.log('💾 Number of edges:', ontologyData.edges?.length || 0);
            
            // Save ontology data to server
            console.log('💾 Sending ontology data to server...');
            const response = await authenticatedFetch(`/api/ontology/?graph=${encodeURIComponent(activeOntologyIri)}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(ontologyData)
            });
            
            console.log('💾 Server response status:', response.status);
            console.log('💾 Server response ok:', response.ok);
            
            if (response.ok) {
              console.log('✅ Ontology data saved successfully!');
              
              // Also save layout data
              console.log('💾 Saving layout data...');
              const nodes = ontoState.cy.nodes().filter(n => !n.hasClass('imported')).map(n => ({ data: n.data(), position: n.position() }));
              const edges = ontoState.cy.edges().filter(e => !e.hasClass('imported')).map(e => ({ data: e.data() }));
              console.log('💾 Layout nodes:', nodes.length);
              console.log('💾 Layout edges:', edges.length);
              
              await saveLayoutToServer(activeOntologyIri, nodes, edges);
              console.log('✅ Layout data saved successfully!');
              console.log('🎉 Complete save operation successful!');
              
              alert('Ontology and layout saved successfully!');
            } else {
              const errorData = await response.json().catch(() => ({}));
              console.error('❌ Save failed:', errorData);
              console.error('❌ Response status:', response.status);
              console.error('❌ Response text:', await response.text().catch(() => 'Could not read response text'));
              alert('Save failed: ' + (errorData.detail || response.status));
            }
          } catch (err) { 
            console.error('❌ Save error:', err);
            alert('Save error: ' + err.message); 
          }
        } else if (e.target.closest && e.target.closest('#ontoLinkIdenticalBtn')) {
          // Preview: count equivalent class links that will be saved (no UI edges yet)
          try {
            if (!activeOntologyIri || !ontoState.cy) return;
            const pairs = await computeLinkedByPairs(activeOntologyIri);
            if (pairs.length) alert(`Will save ${pairs.length} owl:equivalentClass links on Save.`);
            else alert('No identical classes found');
          } catch (err) { console.error(err); alert('Link check failed'); }
        } else if (e.target === qs('#ontoExportBtn')) {
          exportOntologyJSON();
        } else if (e.target === qs('#ontoImportBtn')) {
          const inp = qs('#ontoImportFile'); if (inp) inp.click();
        } else if (e.target === qs('#ontoTreeToggle') || e.target === qs('#ontoTreeToggleIcon')) {
          const sec = qs('#wb-ontology');
          if (!sec) return;
          const collapsed = sec.classList.toggle('onto-tree-collapsed');
          const icon = qs('#ontoTreeToggleIcon');
          if (icon) {
            // Left panel: show right chevron when collapsed, left chevron when expanded
            icon.innerHTML = collapsed
              ? '<path d="M9 6l6 6-6 6"/>'
              : '<path d="M15 6l-6 6 6 6"/>';
          }
          try { localStorage.setItem('onto_tree_collapsed', collapsed ? '1' : '0'); } catch(_) {}
          requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
        } else if (e.target === qs('#ontoPropsToggle') || e.target.closest('#ontoPropsToggle')) {
          const sec = qs('#wb-ontology');
          if (!sec) return;
          const collapsed = sec.classList.toggle('onto-props-collapsed');
          const icon = qs('#ontoPropsToggleIcon');
          if (icon) {
            // Right panel: show left chevron when collapsed, right chevron when expanded
            icon.innerHTML = collapsed
              ? '<path d="M15 6l-6 6 6 6"/>'
              : '<path d="M9 6l6 6-6 6"/>';
          }
          try { localStorage.setItem('onto_props_collapsed', collapsed ? '1' : '0'); } catch(_) {}
          // Wait for reflow before resizing Cytoscape so it fits the new grid
          requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
        } else if (e.target === qs('#propSaveBtn')) {
          // Save properties
          try {
            if (!ontoState.cy) return;
            const sel = ontoState.cy.$(':selected');
            const nameEl = qs('#propName');
            const attrs = getCurrentAttributes();
            
            if (sel.length === 1 && sel[0].isNode()) {
              const n = sel[0];
              n.data('label', nameEl.value.trim() || n.data('label'));
              // Type is read-only, don't change it
              
              // Add modification metadata to attributes
              const updatedAttrs = updateModificationMetadata(attrs);
              n.data('attrs', updatedAttrs);
              
              // Force canvas refresh for notes to update styling
              if (n.data('type') === 'note') {
                n.style('background-color', getNoteTypeStyle(attrs.noteType || 'Note').backgroundColor);
                n.style('border-color', getNoteTypeStyle(attrs.noteType || 'Note').borderColor);
                n.style('color', getNoteTypeStyle(attrs.noteType || 'Note').textColor);
              }
            } else if (sel.length === 1 && sel[0].isEdge()) {
              const ed = sel[0];
              ed.data('predicate', nameEl.value.trim() || ed.data('predicate'));
              // Type is read-only, don't change it
              
              // Add modification metadata to attributes
              const updatedAttrs = updateModificationMetadata(attrs);
              ed.data('attrs', updatedAttrs);
            } else {
              const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : 'default';
              localStorage.setItem(`onto_model_name__${pid}`, nameEl.value.trim() || 'Ontology Model');
              localStorage.setItem(`onto_model_attrs__${pid}`, JSON.stringify(attrs));
            }
            refreshOntologyTree();
            persistOntologyToLocalStorage();
            const st = qs('#propSaveStatus'); if (st) { st.textContent = 'Saved'; setTimeout(()=>{ const s=qs('#propSaveStatus'); if (s) s.textContent=''; }, 1000); }
          } catch (_) {
            const st = qs('#propSaveStatus'); if (st) { st.textContent = 'Error'; setTimeout(()=>{ const s=qs('#propSaveStatus'); if (s) s.textContent=''; }, 1200); }
          }
        } else if (e.target === qs('#addAttrBtn')) {
          // Add custom attribute
          const key = prompt('Enter attribute name:');
          if (key && key.trim()) {
            const container = qs('#propAttrsContainer');
            if (container) {
              const attrDiv = createAttributeField(key.trim(), { type: 'text', label: key.trim() }, '');
              container.appendChild(attrDiv);
            }
          }
        } else if (e.target === qs('#resetAttrsBtn')) {
          // Reset to template
          let objectType = 'class';
          if (ontoState.cy) {
            const sel = ontoState.cy.$(':selected');
            if (sel.length === 1) {
              objectType = sel[0].data('type') || 'class';
            } else {
              objectType = 'model';
            }
          }
          updateAttributeEditor(objectType, {});
        }
      });
      // Keep Cytoscape sized correctly in fullscreen and update button title
      document.addEventListener('fullscreenchange', () => {
        const btn = qs('#ontoFullscreenBtn');
        if (btn) btn.title = document.fullscreenElement ? 'Exit fullscreen' : 'Enter fullscreen';
        requestAnimationFrame(() => { if (ontoState.cy) ontoState.cy.resize(); });
      });
      const header = qs('#ontoTreeHeader');
      if (header) header.addEventListener('dblclick', (e) => {
        const toggleBtn = qs('#ontoTreeToggle');
        if (toggleBtn) toggleBtn.click();
      });
      const propsHeader = qs('#ontoPropsHeader');
      if (propsHeader) propsHeader.addEventListener('dblclick', (e) => {
        const toggleBtn = qs('#ontoPropsToggle');
        if (toggleBtn) toggleBtn.click();
      });
      
      // Visibility toggle button
      const visibilityToggle = qs('#ontoVisibilityToggle');
      if (visibilityToggle) {
        visibilityToggle.addEventListener('click', (e) => {
          e.stopPropagation();
          showVisibilityMenu();
        });
      }
      
      // Type is now read-only, no event listener needed
      const fileInput = () => qs('#ontoImportFile');
      document.addEventListener('change', async (e) => {
        if (e.target === fileInput()) {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          try {
            const text = await file.text();
            const json = JSON.parse(text);
            importOntologyJSON(json);
          } catch (_) {
            alert('Invalid ontology JSON');
          } finally {
            e.target.value = '';
          }
        }
      });
    })();

    window.addEventListener('resize', () => { if (ontoState.cy) ontoState.cy.resize(); });

    function getSampleProject() {
      return {
        id: 'demo',
        name: 'Sample Project',
        ontology: {
          base: { id: 'BASE-ONTO', name: 'Base Ontology', versions: ['1.0', '1.1'] },
          systems: {
            base: { id: 'SYS-BASE', name: 'Systems Ontology', versions: ['0.1', '0.2'] },
            imports: [
              { id: 'GEO', name: 'Geo Ontology', versions: ['2023-09', '2024-02'] },
              { id: 'RELY', name: 'Reliability Ontology', versions: ['1.0'] },
              { id: 'ORG', name: 'Organization Ontology', versions: ['0.9'] }
            ]
          }
        },
        requirements: [
          { id: 'R-001', title: 'The system shall ingest documents and extract requirements.' },
          { id: 'R-002', title: 'The system should support ontology-based tagging of entities.' },
          { id: 'R-003', title: 'The system must store outputs in RDF, GraphDB, and Vector Store.' }
        ],
        documents: {
          requirements: [
            { id: 'RD-01', name: 'Concept of Operations.pdf' },
            { id: 'RD-02', name: 'Capabilities Development Document.docx' }
          ],
          knowledge: [
            { id: 'KD-01', name: 'Requirements Development Instructions.md' },
            { id: 'KD-02', name: 'Industry Spec MIL-STD-961E.pdf' }
          ]
        },
        artifacts: [
          { id: 'ART-01', name: 'White Paper - Initial Draft.md' },
          { id: 'ART-02', name: 'System Architecture Diagram.png' }
        ]
      };
    }

    function toggleNode(li) {
      const exp = li.getAttribute('aria-expanded');
      if (exp === null) return;
      li.setAttribute('aria-expanded', exp === 'true' ? 'false' : 'true');
    }

    function selectNode(li) {
      qsa('.node-row').forEach(r => r.classList.remove('selected'));
      const row = li.querySelector('.node-row');
      if (row) row.classList.add('selected');
    }

    function highlightTreeItem(elementId, elementType) {
      // Clear current tree selection
      qsa('.node-row').forEach(r => r.classList.remove('selected'));
      
      // Find the corresponding tree item
      let treeItem = null;
      if (elementType === 'node') {
        treeItem = qs(`li[data-node-id="${elementId}"]`);
      } else if (elementType === 'edge') {
        treeItem = qs(`li[data-edge-id="${elementId}"]`);
      }
      
      if (treeItem) {
        const row = treeItem.querySelector('.node-row');
        if (row) {
          row.classList.add('selected');
          // Scroll the tree item into view
          row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }
    }

    function toggleVisibility(type) {
        if (ontoState.visibilityState.hasOwnProperty(type)) {
          ontoState.visibilityState[type] = !ontoState.visibilityState[type];
          
          // Save visibility state
          if (activeOntologyIri) {
            saveVisibilityState(activeOntologyIri, ontoState.visibilityState);
          }
          
          updateCanvasVisibility();
          refreshOntologyTree();
      }
    }

    function updateCanvasVisibility() {
      if (!ontoState.cy) return;
      
      console.log('🔍 Updating canvas visibility:', ontoState.visibilityState);
      
      // Update node visibility based on type and visibility state
      ontoState.cy.nodes().forEach(node => {
        const nodeType = node.data('type') || 'class';
        const isImported = node.hasClass('imported');
        const nodeId = node.id();
        
        let shouldShow = true;
        
        if (isImported) {
          shouldShow = ontoState.visibilityState.imported;
        } else if (nodeType === 'class') {
          shouldShow = ontoState.visibilityState.classes;
        } else if (nodeType === 'dataProperty') {
          shouldShow = ontoState.visibilityState.dataProperties;
        } else if (nodeType === 'note') {
          shouldShow = ontoState.visibilityState.notes;
        }
        
        // If global visibility is enabled, check individual element visibility
        // If global visibility is disabled, hide all elements of this type regardless of individual settings
        if (shouldShow && ontoState.elementVisibility.hasOwnProperty(nodeId)) {
          shouldShow = ontoState.elementVisibility[nodeId];
        }
        
        if (shouldShow) {
          node.show();
        } else {
          node.hide();
        }
      });
      
      // Update edge visibility
      ontoState.cy.edges().forEach(edge => {
        const shouldShow = ontoState.visibilityState.edges;
        if (shouldShow) {
          edge.show();
        } else {
          edge.hide();
        }
      });
    }

    function showVisibilityMenu() {
      const menu = document.createElement('div');
      menu.className = 'visibility-menu';
      menu.style.cssText = `
        position: fixed;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        min-width: 200px;
      `;
      
      const types = [
        { key: 'classes', label: 'Classes' },
        { key: 'dataProperties', label: 'Data Properties' },
        { key: 'notes', label: 'Notes' },
        { key: 'edges', label: 'Relationships' },
        { key: 'imported', label: 'Imported Elements' }
      ];
      
      // Add Show All / Hide All buttons
      const showAllBtn = document.createElement('div');
      showAllBtn.style.cssText = `
        display: flex;
        align-items: center;
        padding: 6px 8px;
        cursor: pointer;
        border-radius: 4px;
        border-bottom: 1px solid var(--border);
        margin-bottom: 4px;
      `;
      showAllBtn.innerHTML = '<span style="color: var(--text); font-weight: bold;">Show All Classes</span>';
      showAllBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (!ontoState.cy) return;
        ontoState.cy.nodes().forEach(node => {
          if (node.data('type') === 'class' || node.data('type') === 'note') {
            node.show();
          }
        });
        refreshOntologyTree();
      });
      menu.appendChild(showAllBtn);
      
      const hideAllBtn = document.createElement('div');
      hideAllBtn.style.cssText = `
        display: flex;
        align-items: center;
        padding: 6px 8px;
        cursor: pointer;
        border-radius: 4px;
        margin-bottom: 4px;
      `;
      hideAllBtn.innerHTML = '<span style="color: var(--text); font-weight: bold;">Hide All Classes</span>';
      hideAllBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (!ontoState.cy) return;
        ontoState.cy.nodes().forEach(node => {
          if (node.data('type') === 'class' || node.data('type') === 'note') {
            node.hide();
          }
        });
        refreshOntologyTree();
      });
      menu.appendChild(hideAllBtn);
      
      types.forEach(type => {
        const item = document.createElement('div');
        item.style.cssText = `
          display: flex;
          align-items: center;
          padding: 6px 8px;
          cursor: pointer;
          border-radius: 4px;
        `;
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = ontoState.visibilityState[type.key];
        checkbox.style.marginRight = '8px';
        
        const label = document.createElement('span');
        label.textContent = type.label;
        label.style.color = 'var(--text)';
        
        item.appendChild(checkbox);
        item.appendChild(label);
        
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          checkbox.checked = !checkbox.checked;
          toggleVisibility(type.key);
        });
        
        menu.appendChild(item);
      });
      
      // Position menu near the button
      const button = qs('#ontoVisibilityToggle');
      const rect = button.getBoundingClientRect();
      menu.style.left = (rect.left - 200) + 'px';
      menu.style.top = (rect.bottom + 4) + 'px';
      
      document.body.appendChild(menu);
      
      // Close menu when clicking outside
      const closeMenu = (e) => {
        if (!menu.contains(e.target) && e.target !== button) {
          document.body.removeChild(menu);
          document.removeEventListener('click', closeMenu);
        }
      };
      
      setTimeout(() => {
        document.addEventListener('click', closeMenu);
      }, 100);
    }

    function toggleImportCollapse(importIri) {
      if (!ontoState.cy || !activeOntologyIri) return;
      
      const isCollapsed = ontoState.collapsedImports.has(importIri);
      
      if (isCollapsed) {
        // Expand: show all imported nodes and their edges, remove pseudo-node
        ontoState.collapsedImports.delete(importIri);
        const importedNodes = ontoState.cy.nodes(`[importSource="${importIri}"]`).filter(n => !n.data('isPseudo'));
        const importedEdges = ontoState.cy.edges(`[importSource="${importIri}"]`).filter(e => !e.data('isPseudo'));
        const pseudoNode = ontoState.cy.nodes(`#pseudo-import-${CSS.escape(importIri)}`);
        const pseudoEdges = ontoState.cy.edges(`[importSource="${importIri}"][isPseudo="true"]`);
        
        // Remove pseudo-node and its pseudo-edges
        pseudoNode.remove();
        pseudoEdges.remove();
        
        // Show all original imported nodes and edges
        importedNodes.show();
        importedEdges.show();
        console.log('🔍 Expanded import:', importIri, importedNodes.length, 'nodes,', importedEdges.length, 'edges');
      } else {
        // Collapse: create pseudo-node and hide all imported nodes, but maintain equivalence edges
        ontoState.collapsedImports.add(importIri);
        const importedNodes = ontoState.cy.nodes(`[importSource="${importIri}"]`).filter(n => !n.data('isPseudo'));
        const importedEdges = ontoState.cy.edges(`[importSource="${importIri}"]`).filter(e => !e.data('isPseudo'));
        
        if (importedNodes.length > 0) {
          // Get import name from localStorage or use IRI tail
          const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(activeOntologyIri || '')) || '[]');
          const importData = imports.find(imp => imp.iri === importIri);
          const importName = importData?.label || importIri.split('/').pop() || importIri;
          
          // Calculate center position of imported nodes
          const bbox = importedNodes.boundingBox();
          const centerX = bbox.x1 + (bbox.w / 2);
          const centerY = bbox.y1 + (bbox.h / 2);
          
          // Create pseudo-node representing the entire import
          const pseudoNodeId = `pseudo-import-${CSS.escape(importIri)}`;
          const pseudoNode = ontoState.cy.add({
            group: 'nodes',
            data: {
              id: pseudoNodeId,
              label: importName,
              type: 'import',
              importSource: importIri,
              isPseudo: true,
              attrs: {}
            },
            position: { x: centerX, y: centerY },
            classes: 'imported pseudo-import'
          });
          
          // Add position saving for pseudo-node
          pseudoNode.on('free', () => {
            const pseudoPositions = loadPseudoNodePositions(activeOntologyIri);
            pseudoPositions[pseudoNodeId] = { x: pseudoNode.position('x'), y: pseudoNode.position('y') };
            savePseudoNodePositions(activeOntologyIri, pseudoPositions);
          });
          
          // Hide all imported nodes
          importedNodes.hide();
          
          // Create equivalence edges from pseudo-node to base ontology classes
          const equivalenceEdges = importedEdges.filter(edge => {
            const source = edge.source();
            const target = edge.target();
            const isEquivalence = edge.data('predicate') === 'equivalentClass';
            const connectsToBase = !source.hasClass('imported') || !target.hasClass('imported');
            return isEquivalence && connectsToBase;
          });
          
          // Create new equivalence edges from pseudo-node to base classes
          equivalenceEdges.forEach(edge => {
            const baseNode = edge.source().hasClass('imported') ? edge.target() : edge.source();
            const equivEdgeId = `pseudo-equiv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            ontoState.cy.add({
              group: 'edges',
              data: {
                id: equivEdgeId,
                source: pseudoNodeId,
                target: baseNode.id(),
                predicate: 'equivalentClass',
                type: 'objectProperty',
                importSource: importIri,
                isPseudo: true,
                attrs: {}
              },
              classes: 'imported imported-equivalence pseudo-equivalence'
            });
          });
          
          // Hide original edges
          importedEdges.hide();
          
          console.log('🔍 Collapsed import:', importIri, 'created pseudo-node with', equivalenceEdges.length, 'equivalence edges');
        }
      }
      
      // Save the collapsed state
      saveCollapsedImports(activeOntologyIri, ontoState.collapsedImports);
      
      // Update the tree to reflect the change
      refreshOntologyTree();
    }

    function toggleAllImportsCollapse() {
      if (!ontoState.cy || !activeOntologyIri) return;
      
      const imports = JSON.parse(localStorage.getItem('onto_imports__' + encodeURIComponent(activeOntologyIri || '')) || '[]');
      const allCollapsed = imports.every(imp => ontoState.collapsedImports.has(imp));
      
      if (allCollapsed) {
        // Expand all
        imports.forEach(imp => {
          ontoState.collapsedImports.delete(imp);
          const importedNodes = ontoState.cy.nodes(`[importSource="${imp}"]`).filter(n => !n.data('isPseudo'));
          const importedEdges = ontoState.cy.edges(`[importSource="${imp}"]`).filter(e => !e.data('isPseudo'));
          const pseudoNode = ontoState.cy.nodes(`#pseudo-import-${CSS.escape(imp)}`);
          const pseudoEdges = ontoState.cy.edges(`[importSource="${imp}"][isPseudo="true"]`);
          
          // Remove pseudo-node and its pseudo-edges
          pseudoNode.remove();
          pseudoEdges.remove();
          
          // Show all original imported nodes and edges
          importedNodes.show();
          importedEdges.show();
        });
        console.log('🔍 Expanded all imports');
      } else {
        // Collapse all
        imports.forEach(imp => {
          ontoState.collapsedImports.add(imp);
          const importedNodes = ontoState.cy.nodes(`[importSource="${imp}"]`).filter(n => !n.data('isPseudo'));
          const importedEdges = ontoState.cy.edges(`[importSource="${imp}"]`).filter(e => !e.data('isPseudo'));
          
          if (importedNodes.length > 0) {
            // Get import name from localStorage or use IRI tail
            const importData = imports.find(importData => importData.iri === imp);
            const importName = importData?.label || imp.split('/').pop() || imp;
            
            // Calculate center position of imported nodes
            const bbox = importedNodes.boundingBox();
            const centerX = bbox.x1 + (bbox.w / 2);
            const centerY = bbox.y1 + (bbox.h / 2);
            
            // Create pseudo-node representing the entire import
            const pseudoNodeId = `pseudo-import-${CSS.escape(imp)}`;
            const pseudoNode = ontoState.cy.add({
              group: 'nodes',
              data: {
                id: pseudoNodeId,
                label: importName,
                type: 'import',
                importSource: imp,
                isPseudo: true,
                attrs: {}
              },
              position: { x: centerX, y: centerY },
              classes: 'imported pseudo-import'
            });
            
            // Add position saving for pseudo-node
            pseudoNode.on('free', () => {
              const pseudoPositions = loadPseudoNodePositions(activeOntologyIri);
              pseudoPositions[pseudoNodeId] = { x: pseudoNode.position('x'), y: pseudoNode.position('y') };
              savePseudoNodePositions(activeOntologyIri, pseudoPositions);
            });
            
            // Hide all imported nodes
            importedNodes.hide();
            
            // Create equivalence edges from pseudo-node to base ontology classes
            const equivalenceEdges = importedEdges.filter(edge => {
              const source = edge.source();
              const target = edge.target();
              const isEquivalence = edge.data('predicate') === 'equivalentClass';
              const connectsToBase = !source.hasClass('imported') || !target.hasClass('imported');
              return isEquivalence && connectsToBase;
            });
            
            // Create new equivalence edges from pseudo-node to base classes
            equivalenceEdges.forEach(edge => {
              const baseNode = edge.source().hasClass('imported') ? edge.target() : edge.source();
              const equivEdgeId = `pseudo-equiv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
              
              ontoState.cy.add({
                group: 'edges',
                data: {
                  id: equivEdgeId,
                  source: pseudoNodeId,
                  target: baseNode.id(),
                  predicate: 'equivalentClass',
                  type: 'objectProperty',
                  importSource: imp,
                  isPseudo: true,
                  attrs: {}
                },
                classes: 'imported imported-equivalence pseudo-equivalence'
              });
            });
            
            // Hide original edges
            importedEdges.hide();
          }
        });
        console.log('🔍 Collapsed all imports');
      }
      
      // Save the collapsed state
      saveCollapsedImports(activeOntologyIri, ontoState.collapsedImports);
      
      // Update the tree to reflect the change
      refreshOntologyTree();
    }

    function handleKey(e, li) {
      const LEFT = 37, UP = 38, RIGHT = 39, DOWN = 40, ENTER = 13, SPACE = 32;
      const exp = li.getAttribute('aria-expanded');
      switch (e.keyCode) {
        case LEFT:
          if (exp === 'true') { toggleNode(li); } else { focusParent(li); }
          e.preventDefault(); break;
        case RIGHT:
          if (exp === 'false') { toggleNode(li); } else { focusFirstChild(li); }
          e.preventDefault(); break;
        case UP:
          focusPrev(li); e.preventDefault(); break;
        case DOWN:
          focusNext(li); e.preventDefault(); break;
        case ENTER:
        case SPACE:
          selectNode(li); handleTreeSelection(li).catch(console.error); e.preventDefault(); break;
      }
    }

    function focusParent(li) {
      const parentLi = li.parentElement.closest('li[role="treeitem"]');
      if (parentLi) (parentLi.querySelector('.node-row') || parentLi).focus();
    }
    function focusFirstChild(li) {
      const child = li.querySelector('ul[role="group"] > li[role="treeitem"] .node-row');
      if (child) child.focus();
    }
    function visibleTreeItems() {
      const acc = [];
      function addVisible(container) {
        const items = Array.from(container.children).filter(n => n.matches('li[role="treeitem"]'));
        items.forEach(li => {
          acc.push(li);
          const exp = li.getAttribute('aria-expanded');
          if (exp === 'true') {
            const group = li.querySelector('ul[role="group"]');
            if (group) addVisible(group);
          }
        });
      }
      addVisible(qs('#treeRoot'));
      return acc;
    }
    function focusPrev(li) {
      const list = visibleTreeItems();
      const idx = list.indexOf(li);
      if (idx > 0) (list[idx - 1].querySelector('.node-row') || list[idx - 1]).focus();
    }
    function focusNext(li) {
      const list = visibleTreeItems();
      const idx = list.indexOf(li);
      if (idx >= 0 && idx < list.length - 1) (list[idx + 1].querySelector('.node-row') || list[idx + 1]).focus();
    }

    // Boot
    initAuth();
    
    // Global error handler for unhandled authentication errors
    window.addEventListener('unhandledrejection', (event) => {
      if (event.reason && event.reason.message === 'Authentication required') {
        console.warn('Unhandled authentication error, redirecting to login...');
        handleAuthFailure();
        event.preventDefault(); // Prevent the error from being logged to console
      }
    });
    
    // Add toast notification system if it doesn't exist
    if (!window.toast) {
      window.toast = function(message, isError = false) {
        // Create a simple toast notification
        const toast = document.createElement('div');
        toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${isError ? 'var(--err)' : 'var(--ok)'};
          color: white;
          padding: 12px 16px;
          border-radius: 6px;
          z-index: 10000;
          font-size: 14px;
          max-width: 300px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        toast.textContent = message;
        document.body.appendChild(toast);
        
        // Auto-remove after 3 seconds
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 3000);
      };
    }
    
    // Per-project restore happens inside renderTree; avoid global restore that can clobber state
    // Save shortcut Ctrl/Cmd+S
    document.addEventListener('keydown', async (e) => {
      const isSave = (e.key === 's' || e.key === 'S') && (e.ctrlKey || e.metaKey);
      if (!isSave) return;
      e.preventDefault();
      try {
        if (!activeOntologyIri) { alert('Select an ontology to save.'); return; }
        
        console.log('💾 Starting keyboard shortcut save (Ctrl+S)...');
        console.log('💾 Active ontology IRI:', activeOntologyIri);
        
        const ttl = toTurtle(activeOntologyIri);
        console.log('💾 Generated Turtle data length:', ttl.length);
        console.log('💾 Turtle data preview:', ttl.substring(0, 200) + '...');
        
        console.log('💾 Sending Turtle data to Fuseki...');
        const res = await fetch(`/api/ontology/save?graph=${encodeURIComponent(activeOntologyIri)}`, { method: 'POST', headers: { 'Content-Type': 'text/turtle' }, body: ttl });
        
        console.log('💾 Fuseki response status:', res.status);
        console.log('💾 Fuseki response ok:', res.ok);
        
        const json = await res.json().catch(()=>({}));
        if (res.ok) {
          console.log('✅ Ontology saved to Fuseki successfully!');
          console.log('🎉 Keyboard shortcut save complete!');
          alert('Saved to Fuseki');
        } else {
          console.error('❌ Fuseki save failed:', json);
          console.error('❌ Response status:', res.status);
          alert('Save failed: ' + (json.detail || res.status));
        }
      } catch (err) { 
        console.error('❌ Keyboard shortcut save error:', err);
        alert('Save error: ' + err.message); 
      }
    }, false);

    // Delete selected canvas entities (nodes/edges) for current ontology only
    function performDelete() {
      if (!(qs('#wb-ontology') && qs('#wb-ontology').classList.contains('active'))) return false;
      if (!ontoState.cy) return false;
      const sel = ontoState.cy.$(':selected');
      if (!sel || sel.length === 0) return false;
      ontoState.cy.remove(sel);
      refreshOntologyTree();
      persistOntologyToLocalStorage();
      return true;
    }
    function handleDeleteKey(e) {
      const key = e.key || e.code;
      const tgt = e.target;
      const isTyping = tgt && (tgt.tagName === 'INPUT' || tgt.tagName === 'TEXTAREA' || tgt.isContentEditable);
      const inline = qs('#ontoInlineEdit');
      const inlineVisible = inline ? (getComputedStyle(inline).display !== 'none') : false;
      if (isTyping || inlineVisible) return;
      if ((key === 'Delete' || key === 'Backspace') && ontoState.cy) {
        const ok = performDelete();
        if (ok) { e.preventDefault(); e.stopPropagation(); }
      }
    }
    document.addEventListener('keydown', handleDeleteKey, false);
    window.addEventListener('keydown', handleDeleteKey, true);
    // Keyup fallback in case keydown is intercepted by browser/OS
    document.addEventListener('keyup', handleDeleteKey, false);
    // Toolbar delete
    document.addEventListener('click', (e) => {
      if (e.target === qs('#ontoDeleteBtn')) {
        performDelete();
      }
    });

    // Files workbench state + helpers
    const filesState = { initialized: false, lastFiles: [], staged: [], library: [], sortBy: 'name', sortDir: 'asc' };
    function toast(msg, isError=false) {
      const el = qs('#filesToast'); if (!el) return;
      el.textContent = msg || '';
      el.style.color = isError ? '#ef4444' : '#9aa4b2';
      if (!msg) return;
      setTimeout(()=>{ if (el.textContent === msg) el.textContent=''; }, 3000);
    }
    
    // Check if file has been processed into knowledge asset
    async function getKnowledgeProcessingStatus(fileId) {
      try {
        const headers = window.authHeader ? window.authHeader() : {};
        if (!headers.Authorization) {
          return ``; // Don't show status badge if not logged in
        }
        
        // Get current project ID
        const projectId = window.currentProjectId ? window.currentProjectId() : null;
        if (!projectId) {
          return ``; // Don't show status badge if no project
        }
        
        // Check if knowledge asset exists for this file
        const response = await fetch(`/api/knowledge/assets?project_id=${projectId}`, {
          headers
        });
        
        if (!response.ok) {
          return `<span style="background:rgba(239, 68, 68, 0.2); border:1px solid #ef4444; border-radius:6px; padding:2px 6px; font-size:12px; color:#ef4444;" title="Error checking knowledge status">Error</span>`;
        }
        
        const data = await response.json();
        const assets = data.assets || [];
        
        // Find asset with matching source_file_id
        const matchingAsset = assets.find(asset => asset.source_file_id === fileId);
        
        if (matchingAsset) {
          if (matchingAsset.status === 'active') {
            return `<span style="background:rgba(34, 197, 94, 0.2); border:1px solid #22c55e; border-radius:6px; padding:2px 6px; font-size:12px; color:#22c55e;" title="Successfully processed for knowledge">Processed</span>`;
          } else if (matchingAsset.status === 'processing') {
            return `<span style="background:rgba(245, 158, 11, 0.2); border:1px solid #f59e0b; border-radius:6px; padding:2px 6px; font-size:12px; color:#f59e0b;" title="Processing in progress">Processing</span>`;
          } else {
            return `<span style="background:rgba(239, 68, 68, 0.2); border:1px solid #ef4444; border-radius:6px; padding:2px 6px; font-size:12px; color:#ef4444;" title="Processing failed">Failed</span>`;
          }
        } else {
          // No knowledge asset found - file not processed yet
          return `<span style="background:var(--panel-2); border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--muted);" title="Not processed for knowledge">Pending</span>`;
        }
        
      } catch (error) {
        console.error('Error checking knowledge status:', error);
        return `<span style="background:var(--panel-2); border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--muted);" title="Error checking status">Unknown</span>`;
      }
    }
    function renderFilesList(items, projectId = null) {
      const list = qs('#filesList'); if (!list) return;
      list.innerHTML = '';
      const arr = Array.isArray(items) ? items : [];
      if (!arr.length) {
        const div = document.createElement('div');
        div.className = 'muted';
        div.textContent = 'No files yet. Upload or import to begin.';
        list.appendChild(div);
        return;
      }
      
      // Get current project ID if not provided
      if (!projectId) {
        try { 
          projectId = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : localStorage.getItem('active_project_id'); 
        } catch(_) { 
          projectId = '';
        }
      }
      const toBadge = (text) => `<span style="border:1px solid var(--border); padding:2px 6px; border-radius:6px; font-size:12px;">${text}</span>`;
      
      // Get status badges including file status and knowledge processing status
      const getStatusBadges = (fileStatus, fileId) => {
        const fileStatusBadge = toBadge(fileStatus);
        const knowledgeStatusId = `knowledge-status-${fileId}`;
        // Knowledge processing badge with styling consistent with visibility badges
        const knowledgeStatusBadge = `<span id="${knowledgeStatusId}" style="background:var(--panel-2); border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--muted);" title="Checking knowledge processing status...">Checking</span>`;
        return `<div style="display:flex; gap:4px; flex-wrap:wrap;">${fileStatusBadge} ${knowledgeStatusBadge}</div>`;
      };
        const getVisibilityBadge = (visibility, fileProjectId, currentProjectId) => {
          const isPublic = visibility === 'public';
          const isFromOtherProject = fileProjectId !== currentProjectId;
          
          if (isPublic) {
            const badgeText = isFromOtherProject ? '🌐 Shared' : '🌐 Public';
            return `<span style="background:rgba(37, 99, 235, 0.2); border:1px solid var(--accent); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--accent);" title="Available to all projects">${badgeText}</span>`;
          } else {
            return `<span style="background:var(--panel-2); border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--muted);" title="Only available in this project">🔒 Private</span>`;
          }
        };
        
        const getActionButtons = (meta, id, currentProjectId) => {
          const isSharedFile = meta.visibility === 'public' && meta.project_id !== currentProjectId;
          const username = localStorage.getItem('odras_user') || '';
          const isAdminUser = username === 'admin';
          
          let buttons = [];
          
          // URL button - always available
          buttons.push(`<button class="btn" data-action="url" data-id="${id}">URL</button>`);
          
          // Admin visibility toggle - only for admin users
          buttons.push(`<button class="btn admin-only" data-action="toggle-visibility" data-id="${id}" data-visibility="${meta.visibility || 'private'}" title="Toggle visibility (Admin)" style="display:none;">${(meta.visibility === 'public') ? '🔒' : '🌐'}</button>`);
          
          // Reprocess button - for regenerating knowledge assets
          if (!isSharedFile || isAdminUser) {
            buttons.push(`<button class="btn" data-action="reprocess" data-id="${id}" title="Reprocess file to regenerate knowledge asset">🔄 Reprocess</button>`);
          }
          
          // Delete button - disabled for shared files for non-admin users
          if (!isSharedFile || isAdminUser) {
            buttons.push(`<button class="btn" data-action="delete" data-id="${id}">Delete</button>`);
          } else {
            buttons.push(`<button class="btn" data-action="delete" data-id="${id}" disabled style="opacity:0.5; cursor:not-allowed;" title="Cannot delete shared files">Delete</button>`);
          }
          
          return buttons.join(' ');
        };
        
        const getEditableDocTypeBadge = (docType, fileId, currentProjectId, meta) => {
          const isSharedFile = meta.visibility === 'public' && meta.project_id !== currentProjectId;
          const username = localStorage.getItem('odras_user') || '';
          const isAdminUser = username === 'admin';
          const canEdit = !isSharedFile || isAdminUser;
          
          const colors = {
            'requirements': { bg: 'rgba(239, 68, 68, 0.2)', border: '#ef4444', color: '#f87171' },
            'knowledge': { bg: 'rgba(34, 197, 94, 0.2)', border: '#22c55e', color: '#4ade80' },
            'reference': { bg: 'rgba(168, 85, 247, 0.2)', border: '#a855f7', color: '#c084fc' },
            'specification': { bg: 'rgba(59, 130, 246, 0.2)', border: '#3b82f6', color: '#60a5fa' },
            'unknown': { bg: 'var(--panel-2)', border: 'var(--border)', color: 'var(--muted)' }
          };
          
          const style = colors[docType] || colors['unknown'];
          const cursor = canEdit ? 'pointer' : 'default';
          const title = canEdit ? 'Click to change document type' : (isSharedFile ? 'Cannot edit shared files' : '');
          
          return `<span 
            class="doc-type-badge${canEdit ? ' editable-doc-type' : ''}" 
            data-file-id="${fileId}" 
            data-current-type="${docType}"
            style="background:${style.bg}; border:1px solid ${style.border}; color:${style.color}; padding:2px 6px; border-radius:6px; font-size:12px; cursor:${cursor};" 
            title="${title}"
            ${canEdit ? 'onclick="editDocType(this)"' : ''}
          >${docType.charAt(0).toUpperCase() + docType.slice(1)}</span>`;
        };
      const rows = arr.map(meta => {
        const name = meta.filename || meta.name || 'file';
        const id = meta.file_id || meta.id || '';
        const tags = meta.tags || {};
        const status = tags.status || 'new';
        const size = meta.size || 0;
        const sizeStr = size ? `${size}` : '';
        const created = meta.created_at ? new Date(meta.created_at).toLocaleString() : '';
        return `<tr>
          <td style="width:32px; text-align:center;"><input type="checkbox" class="file-select" data-id="${id}" /></td>
          <td><div style="display:flex; flex-direction:column;"><span style="font-weight:600;">${name}</span><span class="muted" style="font-size:12px;">${id}</span></div></td>
          <td>${getEditableDocTypeBadge(tags.docType || 'unknown', id, projectId, meta)}</td>
          <td>${getStatusBadges(status, id)}</td>
          <td>${getVisibilityBadge(meta.visibility || 'private', meta.project_id, projectId)}</td>
          <td style="text-align:right;">${sizeStr}</td>
          <td class="muted" style="font-size:12px;">${created}</td>
          <td style="text-align:right;">
            ${getActionButtons(meta, id, projectId)}
          </td>
        </tr>`;
      }).join('');
      list.innerHTML = `
        <div style="overflow:auto;">
          <table style="width:100%; border-collapse:separate; border-spacing:0 6px;">
            <thead>
              <tr>
                <th style="width:32px;"><input type="checkbox" id="filesSelectAll" /></th>
                <th data-sort="name" style="cursor:pointer;">Name</th>
                <th data-sort="type" style="cursor:pointer;">Type</th>
                <th data-sort="status" style="cursor:pointer;">Status</th>
                <th data-sort="visibility" style="cursor:pointer;">Visibility</th>
                <th data-sort="size" style="text-align:right; cursor:pointer;">Size</th>
                <th>Uploaded</th>
                <th style="text-align:right;">Actions</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>`;
      // Sorting handlers
      const thead = list.querySelector('thead');
      if (thead) thead.addEventListener('click', (e) => {
        const th = e.target.closest('[data-sort]'); if (!th) return;
        const key = th.getAttribute('data-sort');
        if (filesState.sortBy === key) filesState.sortDir = (filesState.sortDir === 'asc' ? 'desc' : 'asc');
        else { filesState.sortBy = key; filesState.sortDir = 'asc'; }
        // Re-sort current state
        try { renderFilesList(sortItems(filesState.library)); } catch(_) {}
      });
      const selAll = list.querySelector('#filesSelectAll');
      if (selAll) selAll.addEventListener('change', () => {
        list.querySelectorAll('.file-select').forEach(cb => { cb.checked = selAll.checked; });
        
        // Clear preview when deselecting all
        if (!selAll.checked) {
          clearFilePreview();
        }
      });
      // Update "Select All" state based on individual checkboxes
      function updateSelectAllState() {
        const selAll = list.querySelector('#filesSelectAll');
        if (!selAll) return;
        
        const allCheckboxes = list.querySelectorAll('.file-select');
        const checkedBoxes = list.querySelectorAll('.file-select:checked');
        
        if (checkedBoxes.length === 0) {
          selAll.checked = false;
          selAll.indeterminate = false;
          clearFilePreview(); // Clear preview when no files are selected
        } else if (checkedBoxes.length === allCheckboxes.length) {
          selAll.checked = true;
          selAll.indeterminate = false;
        } else {
          selAll.checked = false;
          selAll.indeterminate = true;
        }
      }
      
      // Handle individual checkbox clicks (without interfering with row clicks)
      list.querySelectorAll('.file-select').forEach(cb => {
        cb.addEventListener('click', async (e) => {
          e.stopPropagation(); // Prevent row click from firing
          const id = cb.getAttribute('data-id');
          console.log('🔲 Checkbox clicked for file:', id, 'checked:', cb.checked);
          
          // Update Select All state
          updateSelectAllState();
          
          // Update preview based on selection
          if (cb.checked && id) {
            await updateFilePreview(id);
          } else {
            clearFilePreview();
          }
        });
      });
      
      // Click to select and preview (but not on checkboxes or buttons)
      list.querySelectorAll('tbody tr').forEach(tr => {
        tr.addEventListener('click', async (e) => {
          if (e.target.closest('button')) return;
          if (e.target.closest('.file-select')) return; // Don't interfere with checkbox clicks
          const cb = tr.querySelector('.file-select');
          const id = cb ? cb.getAttribute('data-id') : '';
          if (!id) return;
          // Toggle checkbox state instead of always setting to true
          cb.checked = !cb.checked;
          console.log('🔲 Row clicked, toggled checkbox for file:', id, 'checked:', cb.checked);
          
          // Update Select All state
          updateSelectAllState();
          
          if (cb.checked) {
          await updateFilePreview(id);
          } else {
            clearFilePreview();
          }
        });
      });
      // Delegate actions
      list.onclick = async (e) => {
        const btn = e.target.closest('button[data-action]');
        if (!btn) return;
        const id = btn.getAttribute('data-id');
        const action = btn.getAttribute('data-action');
        if (!id) return;
        if (action === 'delete') {
          if (!confirm('Delete this file?')) return;
          console.log('🗑️  Starting delete for file:', id);
          const ok = await deleteStoredFileViaApi(id);
          console.log('🗑️  Delete result:', ok);
          if (ok) { 
            console.log('🗑️  Refreshing library after successful delete');
            toast('Deleted'); 
            await window.loadLibraryFromApi(); 
            console.log('🗑️  Library refresh completed');
          } else { 
            console.error('🗑️  Delete failed, not refreshing library');
            toast('Delete failed', true); 
          }
        }
        if (action === 'reprocess') {
          if (!confirm('Reprocess this file to regenerate knowledge asset?')) return;
          console.log('🔄 Starting reprocess for file:', id);
          const ok = await reprocessFileViaApi(id);
          console.log('🔄 Reprocess result:', ok);
          if (ok) {
            toast('File reprocessing started');
            await window.loadLibraryFromApi();
          } else {
            toast('Reprocess failed', true);
          }
        }
        if (action === 'toggle-visibility') {
          // Check admin status synchronously for immediate response
          const username = localStorage.getItem('odras_user') || '';
          const isAdminUser = username === 'admin';
          
          console.log('👑 Checking admin access - username:', username, 'isAdmin:', isAdminUser);
          
          if (!isAdminUser) {
            toast('Admin access required', true);
            return;
          }
          
          const currentVisibility = btn.getAttribute('data-visibility') || 'private';
          const newVisibility = currentVisibility === 'public' ? 'private' : 'public';
          const confirmText = `Make this file ${newVisibility}?\n\n${newVisibility === 'public' ? 'Public files are available to all projects.' : 'Private files are only visible in their project.'}`;
          
          if (!confirm(confirmText)) return;
          
          console.log('👑 Admin toggling file visibility:', id, 'from', currentVisibility, 'to', newVisibility);
          toast('Updating visibility...');
          
          try {
            const formData = new FormData();
            formData.append('visibility', newVisibility);
            
            console.log('👑 Making API call to /api/files/' + id + '/visibility with visibility:', newVisibility);
            
            const response = await fetch(`/api/files/${id}/visibility`, {
              method: 'PUT',
              headers: { ...window.authHeader() },
              body: formData
            });
            
            console.log('👑 API response status:', response.status, response.statusText);
            
            const result = await response.json();
            console.log('👑 API response data:', result);
            
            if (result.success) {
              toast(`File is now ${newVisibility}`);
              console.log('👑 Refreshing library to show updated visibility');
              await window.loadLibraryFromApi(); // Refresh to show updated visibility
            } else {
              console.error('👑 API returned error:', result);
              toast('Visibility update failed: ' + (result.error || result.message || 'Unknown error'), true);
            }
          } catch (error) {
            console.error('👑 Visibility update error:', error);
            toast('Network error updating visibility', true);
          }
        } else if (action === 'url') {
          const url = await getFileUrlViaApi(id);
          if (url) { try { await navigator.clipboard.writeText(url); toast('URL copied'); } catch(_) { window.open(url, '_blank'); } }
        } else if (action === 'ingest') {
          // Individual ingest action removed - knowledge processing is now streamlined
          toast('✅ This file is already processed for knowledge!', false);
        }
      };
      // Bulk buttons
      try {
        const bulkDelete = qs('#filesBulkDeleteBtn');
        const bulkProcess = qs('#filesBulkProcessBtn');
        // bulkIngest button removed - knowledge processing is now automatic
        const selectedIds = () => Array.from(list.querySelectorAll('.file-select:checked')).map(c => c.getAttribute('data-id'));
        if (bulkDelete) bulkDelete.onclick = async () => {
          const ids = selectedIds(); if (!ids.length) { toast('No files selected', true); return; }
          if (!confirm(`Delete ${ids.length} file(s)?`)) return;
          console.log('🗑️  Starting bulk delete for files:', ids);
          let ok = 0; for (const id of ids) { if (await deleteStoredFileViaApi(id)) ok++; }
          console.log('🗑️  Bulk delete completed:', ok, 'of', ids.length);
          toast(`Deleted ${ok}/${ids.length}`); 
          console.log('🗑️  Refreshing library after bulk delete');
          await window.loadLibraryFromApi();
          console.log('🗑️  Bulk delete library refresh completed');
        };
        if (bulkProcess) bulkProcess.onclick = async () => {
          const ids = selectedIds(); if (!ids.length) { toast('No files selected', true); return; }
          let ok = 0; for (const id of ids) { if (await processFileViaApi(id)) ok++; }
          toast(`Started ${ok}/${ids.length}`);
        };
        // bulkIngest removed - all uploaded files now automatically processed for knowledge
      } catch(_) {}
      
      // Update knowledge processing status badges asynchronously
      setTimeout(async () => {
        const statusElements = list.querySelectorAll('[id^="knowledge-status-"]');
        for (const element of statusElements) {
          const fileId = element.id.replace('knowledge-status-', '');
          try {
            const status = await getKnowledgeProcessingStatus(fileId);
            element.outerHTML = status;
          } catch (error) {
            console.error('Error updating knowledge status for file', fileId, error);
            element.outerHTML = `<span style="background:var(--panel-2); border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--muted);" title="Error checking status">Unknown</span>`;
          }
        }
      }, 100); // Small delay to ensure DOM is ready
    }
    function renderStagedList() {
      const list = qs('#stagedList'); if (!list) return;
      const docTypeSelector = qs('#stagedDocTypeSelector');
      const knowledgeOptions = qs('#knowledgeProcessingOptions');
      
      list.innerHTML = '';
      
      if (!filesState.staged.length) {
        const div = document.createElement('div'); div.className = 'muted'; div.textContent = 'No staged files.'; list.appendChild(div);
        // Hide options when no files are staged
        if (docTypeSelector) docTypeSelector.style.display = 'none';
        if (knowledgeOptions) knowledgeOptions.style.display = 'none';
        return;
      }
      
      // Show options when files are staged
      if (docTypeSelector) docTypeSelector.style.display = 'block';
      if (knowledgeOptions) knowledgeOptions.style.display = 'block';
      filesState.staged.forEach((f, idx) => {
        const row = document.createElement('div'); row.className = 'card'; row.style.display='grid'; row.style.gridTemplateColumns='1fr auto'; row.style.alignItems='center'; row.style.padding='8px';
        const left = document.createElement('div'); left.innerHTML = `<strong>${f.name}</strong> <span class="muted">${f.size} bytes</span>`;
        const actions = document.createElement('div'); actions.style.display='flex'; actions.style.gap='8px';
        const up = document.createElement('button'); up.className='btn'; up.textContent='Upload'; up.onclick=async()=>{ const ok = await (window.odrasUploadOne ? window.odrasUploadOne(f) : Promise.resolve(false)); if (ok) { toast('Uploaded 1/1'); filesState.staged.splice(idx,1); renderStagedList(); try { if (window.odrasLoadLibrary) await window.odrasLoadLibrary(); } catch(_) {} } else { toast('Upload failed', true); } };
        const rem = document.createElement('button'); rem.className='btn'; rem.textContent='Remove'; rem.onclick=()=>{ filesState.staged.splice(idx,1); renderStagedList(); };
        actions.appendChild(up); actions.appendChild(rem);
        row.appendChild(left); row.appendChild(actions);
        list.appendChild(row);
      });
    }
    function previewSelectedFiles(fileList) {
      const el = qs('#uploadPreview'); if (!el) return;
      if (!fileList || !fileList.length) { el.textContent = ''; return; }
      const names = Array.from(fileList).map(f => `${f.name} (${f.size} bytes)`).join(', ');
      el.textContent = `Selected: ${names}`;
    }
    function ensureFilesInitialized() {
      if (filesState.initialized) return;
      filesState.initialized = true;
      const input = qs('#fileUploadInput');
      const choose = qs('#fileChooseBtn');
      const drop = qs('#fileDropZone');
      const urlInput = qs('#fileUrlInput');
      const urlBtn = qs('#fileUrlImportBtn');
      const refreshBtn = qs('#filesRefreshBtn');
      const includePublicCheckbox = qs('#filesIncludePublic');
      const docType = qs('#filesDocType');
      const statusSel = qs('#filesStatus');
      const tags = qs('#filesTags');
      function authHeader() {
        try { 
          const t = localStorage.getItem('odras_token'); 
          if (!t) {
            return {}; 
          }
          // Always return the token if it exists - let the server validate it
          // The isAuthenticated flag is only used for UI state, not for API calls
          return { Authorization: 'Bearer ' + t }; 
        } catch(_) { 
          return {}; 
        }
      }
      function currentProjectId() {
        try { const pid = (activeProject && (activeProject.id || activeProject.project_id)) ? (activeProject.id || activeProject.project_id) : localStorage.getItem('active_project_id'); return pid || ''; } catch(_) { return ''; }
      }
      // Expose currentProjectId globally for use in other scopes
      window.currentProjectId = currentProjectId;
      async function uploadOne(fileMeta) {
        console.log('🔼 Starting upload for:', fileMeta.name, fileMeta.size, 'bytes');
        
        const pid = currentProjectId(); 
        console.log('📁 Project ID for upload:', pid);
        console.log('📁 activeProject:', window.activeProject);
        console.log('📁 localStorage project_id:', localStorage.getItem('active_project_id'));
        if (!pid) { 
          console.error('❌ No project selected');
          toast('Select a project first', true); 
          return false; 
        }
        
        const headers = { ...authHeader() };
        console.log('🔐 Auth headers:', headers.Authorization ? 'Present' : 'Missing');
        if (!headers.Authorization) { 
          console.error('❌ No auth token');
          toast('Login required', true); 
          return false; 
        }
        
        const fd = new FormData();
        fd.append('file', fileMeta);
        fd.append('project_id', pid);
        
        // Always include knowledge processing options (automatic now)
        const embeddingModel = qs('#embeddingModel')?.value || 'all-MiniLM-L6-v2';
        const chunkingStrategy = qs('#chunkingStrategy')?.value || '';  // Empty = auto-detect
        
        fd.append('embedding_model', embeddingModel);
        fd.append('chunking_strategy', chunkingStrategy);
        
        console.log('📝 Processing:', embeddingModel, chunkingStrategy || 'smart-default');
        
        try {
          const t = (tags && tags.value || '').trim();
          const list = t ? t.split(',').map(s=>s.trim()).filter(Boolean) : [];
          // Use document type from staged file if available, otherwise fall back to filter dropdown
          const selectedDocType = fileMeta.docType || (docType && docType.value) || 'unknown';
          const tagObj = { docType: selectedDocType, status: 'new' };
          if (list.length) tagObj.userTags = list;
          fd.append('tags', JSON.stringify(tagObj));
          console.log('🏷️  Tags with document type:', tagObj);
        } catch(e) {
          console.warn('⚠️  Tags error:', e);
        }
        
        try {
          console.log('📤 Making upload request to /api/files/upload');
          const res = await fetch('/api/files/upload', { method: 'POST', headers, body: fd });
          console.log('📥 Upload response status:', res.status, res.statusText);
          
          const js = await res.json().catch((e)=>{ 
            console.error('❌ Failed to parse response JSON:', e); 
            return {}; 
          });
          console.log('📄 Upload response data:', js);
          
          if (!res.ok || js.success === false) { 
            const errorMsg = js.error || js.detail || 'upload failed';
            console.error('❌ Upload failed:', errorMsg);
            toast(`Upload failed: ${errorMsg}`, true);
            throw new Error(errorMsg); 
          }
          
          console.log('✅ Upload successful, file_id:', js.file_id);
          toast(`Uploaded: ${fileMeta.name}`, false);
          return true;
        } catch (err) {
          console.error('❌ Upload exception:', err);
          toast(`Upload error: ${err.message}`, true);
          return false;
        }
      }
      // Expose for other handlers defined outside this scope
      try { window.odrasUploadOne = uploadOne; } catch(_) {}
      async function loadLibraryFromApi() {
        const pid = currentProjectId(); 
        console.log('📚 Loading library for project:', pid);
        console.log('📚 activeProject:', window.activeProject);
        console.log('📚 localStorage project_id:', localStorage.getItem('active_project_id'));
        if (!pid) { 
          console.log('📚 No project ID, clearing library');
          renderFilesList([], ''); 
          return; 
        }
        
        
        const includePublicCheckbox = qs('#filesIncludePublic');
        const includePublic = includePublicCheckbox ? includePublicCheckbox.checked : false;
        
        try {
          const url = `/api/files?project_id=${pid}${includePublic ? '&include_public=true' : ''}`;
          console.log('📚 Fetching files from', url);
          const res = await fetch(url, { headers: { ...authHeader() } });
          console.log('📚 Files API response status:', res.status, res.statusText);
          
          const js = await res.json();
          console.log('📚 Files API response data:', js);
          console.log('📚 Individual files:', js.files);
          
          let items = js && js.files ? js.files : [];
          console.log('📚 Raw files count:', items.length);
          
          // Client-side filters
          const wantType = (docType && docType.value) || '';
          const wantStatus = (statusSel && statusSel.value) || '';
          const tagFilter = (tags && tags.value || '').trim().toLowerCase();
          console.log('📚 Filters - Type:', wantType, 'Status:', wantStatus, 'Tags:', tagFilter);
          
          const filtered = items.filter(m => {
            const t = m.tags || {};
            const okType = !wantType || (t.docType || 'unknown') === wantType;
            const okStatus = !wantStatus || (t.status || 'new') === wantStatus;
            const okTags = !tagFilter || JSON.stringify(t).toLowerCase().includes(tagFilter);
            return okType && okStatus && okTags;
          });
          
          console.log('📚 Filtered files count:', filtered.length);
          if (filtered.length > 0) {
            console.log('📚 Sample file:', filtered[0]);
          } else {
            console.log('📚 No files after filtering. Original count:', items.length);
            console.log('📚 Filter settings - Type:', wantType, 'Status:', wantStatus, 'Tags:', tagFilter);
            if (items.length > 0) {
              console.log('📚 Sample raw file:', items[0]);
            }
          }
          
          filesState.library = filtered;
          renderFilesList(sortItems(filtered), pid);
          console.log('📚 Library updated and rendered');
          
          // Show admin buttons if user is admin
          toggleAdminButtons();
        } catch(e) { 
          console.error('📚 Library loading failed:', e);
          renderFilesList([], pid);
          
          // Show admin buttons if user is admin (even on error)
          toggleAdminButtons();
        }
      }
      // Show/hide admin buttons after rendering list
      async function toggleAdminButtons() {
        try {
          const adminStatus = await isAdmin();
          console.log('👑 Admin status:', adminStatus);
          
          document.querySelectorAll('.admin-only').forEach(btn => {
            btn.style.display = adminStatus ? 'inline-block' : 'none';
          });
        } catch (error) {
          console.error('👑 Error checking admin status:', error);
          // Hide admin buttons on error
          document.querySelectorAll('.admin-only').forEach(btn => {
            btn.style.display = 'none';
          });
        }
      }
      // Expose functions globally for staged-list handlers and other components
      try { 
        window.odrasLoadLibrary = loadLibraryFromApi; 
        window.loadLibraryFromApi = loadLibraryFromApi; // Also expose without prefix for internal use
        window.authHeader = authHeader; // Expose auth header function globally
        window.authenticatedFetch = authenticatedFetch; // Expose authenticated fetch globally
        window.handleAuthFailure = handleAuthFailure; // Expose auth failure handler globally
        window.editDocType = editDocType; // Expose document type editor globally
      } catch(_) {}
      
      // Document type inline editor
      async function editDocType(badgeElement) {
        const fileId = badgeElement.getAttribute('data-file-id');
        const currentType = badgeElement.getAttribute('data-current-type');
        
        // Create inline dropdown
        const select = document.createElement('select');
        select.style.cssText = 'background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:4px; padding:2px 4px; font-size:12px;';
        
        const options = ['unknown', 'requirements', 'knowledge', 'reference', 'specification'];
        options.forEach(type => {
          const option = document.createElement('option');
          option.value = type;
          option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
          option.selected = type === currentType;
          select.appendChild(option);
        });
        
        // Replace badge with dropdown temporarily
        const originalHTML = badgeElement.outerHTML;
        badgeElement.parentNode.replaceChild(select, badgeElement);
        select.focus();
        
        // Handle selection
        const handleChange = async (newType) => {
          if (newType === currentType) {
            // No change, restore original badge
            select.parentNode.innerHTML = originalHTML;
            return;
          }
          
          try {
            // Update file tags on server
            const response = await fetch(`/api/files/${fileId}/tags`, {
              method: 'PUT',
              headers: { 
                'Content-Type': 'application/json',
                ...window.authHeader() 
              },
              body: JSON.stringify({ tags: { docType: newType } })
            });
            
            const result = await response.json();
            if (result.success) {
              toast(`Document type changed to "${newType}"`);
              // Refresh library to show updated badge
              window.loadLibraryFromApi();
            } else {
              throw new Error(result.error || 'Update failed');
            }
          } catch (error) {
            console.error('Error updating document type:', error);
            toast(`Failed to update document type: ${error.message}`, true);
            // Restore original badge on error
            select.parentNode.innerHTML = originalHTML;
          }
        };
        
        // Handle dropdown events
        select.addEventListener('change', () => handleChange(select.value));
        select.addEventListener('blur', () => handleChange(select.value));
        select.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleChange(select.value);
          } else if (e.key === 'Escape') {
            e.preventDefault();
            // Restore original badge
            select.parentNode.innerHTML = originalHTML;
          }
        });
      }
      function sortItems(items) {
        const arr = Array.from(items || []);
        const dir = filesState.sortDir === 'desc' ? -1 : 1;
        const key = filesState.sortBy || 'name';
        const get = (m) => {
          const tags = m.tags || {};
          if (key === 'name') return (m.filename || '').toLowerCase();
          if (key === 'type') return (tags.docType || '').toLowerCase();
          if (key === 'status') return (tags.status || '').toLowerCase();
          if (key === 'size') return Number(m.size || 0);
          return (m.filename || '').toLowerCase();
        };
        arr.sort((a,b)=>{ const av=get(a), bv=get(b); if (av<bv) return -1*dir; if (av>bv) return 1*dir; return 0; });
        return arr;
      }
      if (input) {
        input.addEventListener('change', (e) => {
          const files = e.target.files;
          previewSelectedFiles(files);
          filesState.lastFiles = Array.from(files || []);
          filesState.staged.push(...filesState.lastFiles);
          renderStagedList();
          const n = filesState.lastFiles.length; if (n) toast(`${n} file(s) staged. Click Upload next to a file or Upload All.`); else toast('No files selected', true);
          try { input.value = ''; } catch(_) {}
        });
      }
      if (choose && input) {
        choose.addEventListener('click', ()=> { try { input.value = ''; } catch(_) {}; input.click(); });
      }
      if (drop) {
        ;['dragenter','dragover'].forEach(ev => drop.addEventListener(ev, (e)=>{ 
          e.preventDefault(); 
          drop.style.background = 'rgba(37, 99, 235, 0.2)'; 
          drop.style.borderColor = 'var(--accent)'; 
          drop.style.color = 'var(--accent)'; 
        }));
        ;['dragleave','drop'].forEach(ev => drop.addEventListener(ev, (e)=>{ 
          e.preventDefault(); 
          drop.style.background = 'rgba(15, 22, 40, 0.3)'; 
          drop.style.borderColor = 'var(--border)'; 
          drop.style.color = '#9aa4b2'; 
        }));
        drop.addEventListener('drop', (e) => {
          const dt = e.dataTransfer; const files = dt && dt.files ? dt.files : [];
          previewSelectedFiles(files);
          filesState.lastFiles = Array.from(files || []);
          filesState.staged.push(...filesState.lastFiles);
          renderStagedList();
          const n = filesState.lastFiles.length; if (n) toast(`${n} file(s) staged. Click Upload All to upload.`);
        });
        drop.addEventListener('click', ()=>{ if (input) { try { input.value = ''; } catch(_) {}; input.click(); } });
        drop.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); if (input) input.click(); } });
      }
      
      // Refresh button and Include Public Files checkbox handlers
      if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
          console.log('🔄 Manual library refresh triggered');
          window.loadLibraryFromApi();
        });
      }
      
      if (includePublicCheckbox) {
        // Restore checkbox state from localStorage
        const savedState = localStorage.getItem('files_include_public');
        if (savedState !== null) {
          includePublicCheckbox.checked = savedState === 'true';
          console.log('🌐 Restored "Include public files" state:', includePublicCheckbox.checked);
        }
        
        includePublicCheckbox.addEventListener('change', () => {
          console.log('🌐 Include public files changed:', includePublicCheckbox.checked);
          // Save checkbox state to localStorage
          localStorage.setItem('files_include_public', includePublicCheckbox.checked.toString());
          console.log('🌐 Saved "Include public files" state to localStorage');
          window.loadLibraryFromApi(); // Refresh library with new visibility setting
        });
      }
      
      // Auto-refresh Files Workbench when project changes
      let lastProjectId = window.currentProjectId ? window.currentProjectId() : '';
      setInterval(() => {
        const newProjectId = window.currentProjectId ? window.currentProjectId() : '';
        if (newProjectId !== lastProjectId) {
          console.log('🔄 Project changed from', lastProjectId, 'to', newProjectId);
          lastProjectId = newProjectId;
          // Only refresh if we're currently viewing the Files Workbench
          const filesSection = qs('#wb-files');
          if (filesSection && filesSection.style.display !== 'none') {
            console.log('🔄 Auto-refreshing Files Workbench for new project');
            window.loadLibraryFromApi();
          }
        }
      }, 1000); // Check every second
      if (urlBtn && urlInput) {
        urlBtn.addEventListener('click', async () => {
          const u = (urlInput.value || '').trim();
          const el = qs('#uploadPreview');
          if (!u) { toast('Please enter a URL', true); if (el) el.textContent=''; return; }
          try { new URL(u); } catch(_) { toast('Invalid URL', true); return; }
          const pid = window.currentProjectId ? window.currentProjectId() : ''; if (!pid) { toast('Select a project first', true); return; }
          const fd = new FormData(); fd.append('url', u); fd.append('project_id', pid);
          try {
            const res = await fetch('/api/files/import-url', { 
              method: 'POST', 
              headers: { 'Authorization': `Bearer ${localStorage.getItem('odras_token')}` },
              body: fd 
            });
            const js = await res.json().catch(()=>({}));
            if (!res.ok || js.success === false) throw new Error(js.detail || js.error || 'Import failed');
            if (el) el.textContent = `Imported URL: ${u}`;
            toast('Imported URL');
            loadLibraryFromApi();
          } catch(e) {
            toast('Import failed', true);
          }
        });
      }
      const uploadAll = qs('#filesUploadAllBtn');
      const clearStaged = qs('#filesClearStagedBtn');
      const setStagedDocTypeBtn = qs('#setStagedDocType');
      
      if (clearStaged) clearStaged.addEventListener('click', ()=>{ filesState.staged = []; renderStagedList(); previewSelectedFiles([]); });
      
      // Handle document type selector for staged files
      if (setStagedDocTypeBtn) {
        setStagedDocTypeBtn.addEventListener('click', () => {
          const selectedType = qs('#stagedDocType')?.value || 'unknown';
          
          // Add docType property to all staged files
          filesState.staged.forEach(file => {
            file.docType = selectedType;
          });
          
          toast(`Set document type to "${selectedType}" for ${filesState.staged.length} staged file(s)`);
          
          // Update hint text
          const hint = qs('#stagedDocTypeHint');
          if (hint) {
            hint.textContent = `${filesState.staged.length} file(s) will be uploaded as "${selectedType}"`;
          }
        });
      }
      
      // Knowledge processing is now automatic - no checkbox needed
      const knowledgeProcessingConfig = qs('#knowledgeProcessingConfig');
      
      if (knowledgeProcessingConfig) {
        // Always show config since processing is automatic
        knowledgeProcessingConfig.style.display = 'grid';
        console.log('⚙️ Knowledge processing ready');
      }
      if (uploadAll) uploadAll.addEventListener('click', async ()=>{
        if (!filesState.staged.length) { toast('Nothing to upload', true); return; }
        const total = filesState.staged.length; let ok = 0; const keep = [];
        for (const f of filesState.staged) { const res = await (window.odrasUploadOne ? window.odrasUploadOne(f) : Promise.resolve(false)); if (res) ok++; else keep.push(f); }
        const failed = total - ok;
        toast(`Uploaded ${ok}/${total}${failed?` (failed ${failed})`:''}`);
        filesState.staged = keep; renderStagedList(); previewSelectedFiles(keep);
        try { if (window.odrasLoadLibrary) await window.odrasLoadLibrary(); } catch(_) {}
      });
      const triggerRefresh = () => {
        loadLibraryFromApi();
        try { refreshRunsPanel(); } catch(_) {}
      };
      if (refreshBtn) refreshBtn.addEventListener('click', triggerRefresh);
      if (docType) docType.addEventListener('change', triggerRefresh);
      if (statusSel) statusSel.addEventListener('change', triggerRefresh);
      if (tags) tags.addEventListener('keyup', (e)=>{ if (e.key === 'Enter') triggerRefresh(); });
      // Initial empty list
      loadLibraryFromApi();
      renderStagedList();

      // Ingest params modal handlers
      const modal = qs('#ingestParamsModal');
      const btnClose = qs('#ingestParamsCloseBtn');
      const btnCancel = qs('#ingestParamsCancelBtn');
      const btnStart = qs('#ingestParamsStartBtn');
      const inputChunk = qs('#ing_chunk_size');
      const inputOverlap = qs('#ing_chunk_overlap');
      const inputModel = qs('#ing_model_id');
      const inputBatch = qs('#ing_batch_size');
      const chkHeadings = qs('#ing_respect_headings');
      const chkJoin = qs('#ing_join_short');
      const chkSplit = qs('#ing_split_code');
      const chkNorm = qs('#ing_normalize');
      let modalCtx = { projectId: '', fileIds: [] };
      
      // Load embedding models from API and populate selector
      async function loadEmbeddingModels() {
        try {
          const response = await fetch('/api/embedding-models/');
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.models && inputModel) {
              // Clear existing options
              inputModel.innerHTML = '';
              
              // Add models from API
              data.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = `${model.name} (${model.dimensions} dim)`;
                if (model.status === 'deprecated') {
                  option.textContent += ' [DEPRECATED]';
                  option.disabled = true;
                }
                if (model.id === 'all-MiniLM-L6-v2') {
                  option.selected = true; // Default selection
                }
                inputModel.appendChild(option);
              });
            }
          }
        } catch (error) {
          console.warn('Failed to load embedding models:', error);
          // Fall back to hardcoded options if API fails
        }
      }
      
      function openIngestParamsModal(projectId, fileIds) {
        // Modal disabled - knowledge processing is now automatic
        toast('✅ Knowledge processing is automatic! No configuration needed.', false);
        return; // Early return - don't show modal
        modalCtx = { projectId, fileIds };
        loadEmbeddingModels(); // Load latest models when modal opens
        if (modal) modal.style.display = 'flex';
      }
      function closeIngestParamsModal() { if (modal) modal.style.display = 'none'; }
      if (btnClose) btnClose.addEventListener('click', closeIngestParamsModal);
      if (btnCancel) btnCancel.addEventListener('click', closeIngestParamsModal);
      if (modal) modal.addEventListener('click', (e)=>{ if (e.target === modal) closeIngestParamsModal(); });
      if (btnStart) btnStart.addEventListener('click', async () => {
        const pid = modalCtx.projectId; const ids = modalCtx.fileIds;
        if (!pid || !ids || !ids.length) { closeIngestParamsModal(); return; }
        const sizeTokens = parseInt((inputChunk && inputChunk.value) || '350', 10);
        const overlapTokens = parseInt((inputOverlap && inputOverlap.value) || '50', 10);
        const modelId = (inputModel && inputModel.value) || 'all-MiniLM-L6-v2';
        const batchSize = parseInt((inputBatch && inputBatch.value) || '64', 10);
        const params = {
          chunking: {
            strategy: 'semantic',
            sizeTokens,
            overlapTokens,
            respectHeadings: !!(chkHeadings && chkHeadings.checked),
            joinShortParagraphs: !!(chkJoin && chkJoin.checked),
            splitCodeBlocks: !!(chkSplit && chkSplit.checked)
          },
          embedding: {
            modelId,
            normalize: !!(chkNorm && chkNorm.checked),
            batchSize
          }
        };
        // Optimistically mark status=processing for selected files
        try { await Promise.all(ids.map(async (fid)=>{
          await fetch(`/api/files/${encodeURIComponent(fid)}/tags`, { 
            method: 'PUT', 
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('odras_token')}`
            }, 
            body: JSON.stringify({ tags: { status: 'processing' } }) 
          });
        })); } catch(_) {}
        closeIngestParamsModal();
        const res = await startWorkflowStartApi('ingestion_pipeline', pid, ids, params);
        if (res.ok) { toast('Ingestion started'); try { refreshRunsPanel(); } catch(_) {} } else { toast(`Ingestion failed: ${res.error}`, true); }
      });
      // Expose for bulk handler
      // Modal functionality disabled since knowledge processing is now automatic
      window.openIngestParamsModal = openIngestParamsModal;
    }

    // Runs panel
    async function loadRecentRuns() {
      try { const res = await fetch('/api/runs'); const js = await res.json(); return (js && js.runs) ? js.runs : []; } catch(_) { return []; }
    }
    async function refreshRunsPanel() {
      const pane = qs('#fileRunsContent'); if (!pane) return;
      const runs = await loadRecentRuns();
      if (!runs.length) { pane.textContent = 'No runs yet.'; return; }
      const rows = runs.slice(-10).reverse().map(r => {
        const name = r.filename || r.processKey || 'run';
        const status = r.status || 'started';
        const url = r.camunda_url || '';
        const when = r.started_at ? new Date(r.started_at).toLocaleString() : '';
        const link = url ? `<a href="${url}" target="_blank">Open</a>` : '';
        return `<div style="display:flex; justify-content:space-between; gap:8px; align-items:center;">
          <span>${name}</span>
          <span class="muted">${status}</span>
          <span>${link}</span>
        </div>`;
      }).join('');
      pane.innerHTML = rows;
    }
    // Initial runs load
    try { refreshRunsPanel(); } catch(_) {}
    async function deleteStoredFileViaApi(fileId) {
      console.log('🗑️  Deleting file:', fileId);
      try { 
        const res = await fetch(`/api/files/${encodeURIComponent(fileId)}`, { 
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('odras_token')}`
          }
        }); 
        console.log('🗑️  Delete response:', res.status, res.statusText);
        
        if (res.ok) {
          console.log('🗑️  Delete successful');
          return true;
        } else {
          console.error('🗑️  Delete failed:', res.status);
          return false;
        }
      } catch(e) { 
        console.error('🗑️  Delete error:', e);
        return false; 
      }
    }
    async function getFileUrlViaApi(fileId) {
      try { 
        const res = await fetch(`/api/files/${encodeURIComponent(fileId)}/url`, {
          headers: { 'Authorization': `Bearer ${localStorage.getItem('odras_token')}` }
        }); 
        const js = await res.json(); 
        return (js && js.url) ? js.url : (js && js.success && js.file_id ? js.url : null); 
      } catch(_) { return null; }
    }
    async function processFileViaApi(fileId) {
      try { 
        const fd = new FormData(); 
        const res = await fetch(`/api/files/${encodeURIComponent(fileId)}/process`, { 
          method: 'POST', 
          headers: { 'Authorization': `Bearer ${localStorage.getItem('odras_token')}` },
          body: fd 
        }); 
        return res.ok; 
      } catch(_) { return false; }
    }
    
    async function reprocessFileViaApi(fileId) {
      console.log('🔄 Reprocessing file:', fileId);
      try {
        // Call the file processing endpoint to regenerate knowledge asset
        const fd = new FormData();
        fd.append('processing_type', 'extract_requirements');
        fd.append('iterations', '10');
        
        const res = await fetch(`/api/files/${encodeURIComponent(fileId)}/process`, { 
          method: 'POST', 
          headers: { 'Authorization': `Bearer ${localStorage.getItem('odras_token')}` },
          body: fd 
        }); 
        
        console.log('🔄 Reprocess response:', res.status, res.statusText);
        
        if (res.ok) {
          console.log('🔄 Reprocess successful');
          return true;
        } else {
          console.error('🔄 Reprocess failed:', res.status);
          return false;
        }
      } catch(e) { 
        console.error('🔄 Reprocess error:', e);
        return false; 
      }
    }
    function clearFilePreview() {
      console.log('👁️  Clearing file preview');
      const pane = qs('#filePreviewContent');
      const metaPane = qs('#fileMetaContent');
      
      if (pane) {
        pane.innerHTML = '<div class="muted" style="padding:20px; text-align:center;">Select a file to preview.</div>';
      }
      
      if (metaPane) {
        metaPane.innerHTML = '';
      }
      
      // Hide/clear preview controls data
      const controls = qs('#previewControls');
      if (controls) {
        controls.removeAttribute('data-file-id');
        controls.removeAttribute('data-filename');
        controls.removeAttribute('data-url');
      }
      
      // Clear current preview data
      currentPreviewData = { fileId: '', filename: '', url: '' };
    }

    async function updateFilePreview(fileId) {
      console.log('👁️  Starting preview for file:', fileId);
      try {
        const url = await getFileUrlViaApi(fileId);
        console.log('👁️  Got file URL:', url);
        
        const pane = qs('#filePreviewContent'); 
        const metaPane = qs('#fileMetaContent');
        
        if (!pane) { 
          console.error('👁️  Preview pane not found');
          return; 
        }
        
        if (!url) { 
          console.log('👁️  No URL available, showing unavailable message');
          pane.textContent = 'Preview unavailable.'; 
          if (metaPane) metaPane.textContent=''; 
          return; 
        }
        
        // Get file metadata from the current library state
        const fileMetadata = filesState.library.find(f => f.file_id === fileId);
        console.log('👁️  File metadata:', fileMetadata);
        
        // Use metadata for extension and content type
        const filename = fileMetadata ? fileMetadata.filename : '';
        const metaContentType = fileMetadata ? fileMetadata.content_type : '';
        
        // Extract extension from filename instead of URL
        const ext = filename ? filename.toLowerCase().split('.').pop() || '' : '';
        console.log('👁️  File extension from metadata:', ext, 'from filename:', filename);
        
        // Use metadata content type, fallback to HEAD request
        let contentType = metaContentType || '';
        if (!contentType) {
          console.log('👁️  No content type in metadata, trying HEAD request...');
          try { 
            const head = await fetch(url, { method: 'HEAD' }); 
            contentType = head.headers.get('Content-Type') || '';
            console.log('👁️  HEAD request successful, content type:', contentType);
          } catch(e) {
            console.log('👁️  HEAD request failed (expected for presigned URLs):', e.message);
          }
        } else {
          console.log('👁️  Using content type from metadata:', contentType);
        }
        
        // Render enhanced metadata
        try {
          if (metaPane) {
            const size = fileMetadata ? fileMetadata.size : 0;
            const sizeStr = size > 1024 * 1024 ? `${(size / (1024*1024)).toFixed(1)} MB` : size > 1024 ? `${(size / 1024).toFixed(1)} KB` : `${size} bytes`;
            const tags = fileMetadata ? fileMetadata.tags || {} : {};
            const docType = tags.docType || 'unknown';
            const status = tags.status || 'new';
            
            metaPane.innerHTML = `<div style="display:grid; gap:4px; font-size:12px;">
              <div><strong>Filename:</strong> ${filename || 'Unknown'}</div>
              <div><strong>Type:</strong> ${docType} (${contentType || ext || 'unknown'})</div>
              <div><strong>Size:</strong> ${sizeStr}</div>
              <div><strong>Status:</strong> ${status}</div>
              <div><strong>Actions:</strong> <a href="${url}" target="_blank" style="color:var(--accent);">Open</a></div>
          </div>`;
          }
        } catch(e) { 
          console.error('👁️  Metadata render error:', e);
        }
        // PDF preview (with multiple rendering options)
        if (ext === 'pdf' || (contentType && contentType.includes('pdf'))) {
          console.log('👁️  Rendering PDF preview for URL:', url);
          
          // Create container with fallback structure
          const pdfContainer = `
            <div style="border:1px solid var(--border); border-radius:6px; overflow:hidden;">
              <div id="pdf-iframe-${fileId}" style="width:100%; height:500px; display:block;">
                <iframe src="${url}#toolbar=0&navpanes=0" style="width:100%; height:100%; border:none;"></iframe>
              </div>
              
              <div id="pdf-fallback-${fileId}" style="display:none; padding:40px; text-align:center; background:var(--panel-2);">
                <div style="margin-bottom:16px; color:var(--muted);">
                  <svg style="width:48px; height:48px; margin-bottom:12px;" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                  </svg>
                  <br/>
                  <strong>PDF Document</strong>
                  <br/>
                  <small>Click to open in new tab</small>
                </div>
                <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">
                  <a href="${url}" target="_blank" class="btn" style="text-decoration:none;">
                    📄 Open PDF
                  </a>
                  <button class="btn" onclick="navigator.clipboard.writeText('${url}').then(()=>this.textContent='✓ Copied').catch(()=>this.textContent='Copy failed');">
                    📋 Copy URL
                  </button>
                </div>
              </div>
            </div>
          `;
          
          pane.innerHTML = pdfContainer;
          
          // Add proper event handling after DOM insertion
          setTimeout(() => {
            const iframe = pane.querySelector(`#pdf-iframe-${fileId} iframe`);
            const fallbackDiv = pane.querySelector(`#pdf-fallback-${fileId}`);
            const iframeContainer = pane.querySelector(`#pdf-iframe-${fileId}`);
            
            if (iframe && fallbackDiv && iframeContainer) {
              // Set up error handling
              iframe.onerror = () => {
                console.error('👁️ PDF iframe failed to load');
                iframeContainer.style.display = 'none';
                fallbackDiv.style.display = 'block';
              };
              
              iframe.onload = () => {
                console.log('👁️ PDF iframe onload triggered');
                // Check if it actually loaded a PDF or just showed source
                setTimeout(() => {
                  try {
                    // If we can't access contentDocument, assume it's working (CORS blocked)
                    iframe.contentDocument;
                    console.log('👁️ PDF iframe content accessible - might be showing source');
                    // For now, assume PDF is working if no error occurs
                  } catch(e) {
                    console.log('👁️ PDF iframe CORS blocked - PDF is likely rendering correctly');
                  }
                }, 1000);
              };
              
              // Check after 3 seconds if iframe seems to be working
              setTimeout(() => {
                try {
                  // Simple heuristic: if iframe is still visible, assume it's working
                  if (iframeContainer.style.display !== 'none') {
                    console.log('👁️ PDF iframe appears to be working');
                  }
                } catch(e) {
                  console.log('👁️ PDF iframe error check failed:', e);
                }
              }, 3000);
            }
          }, 100);
          
          return;
        }
        
        // Image inline (with size constraints)
        if (['png','jpg','jpeg','gif','webp','bmp','svg'].includes(ext) || (contentType && contentType.startsWith('image/'))) {
          console.log('👁️  Rendering image preview');
          pane.innerHTML = `<div style="text-align:center; padding:10px;">
            <img src="${url}" alt="preview" style="max-width:100%; max-height:300px; height:auto; border-radius:6px; box-shadow:0 2px 8px rgba(0,0,0,0.1);" />
          </div>`;
          return;
        }
        
        // CSV table (full content with responsive styling)
        if (ext === 'csv' || (contentType && contentType.includes('csv'))) {
          console.log('👁️  Rendering CSV preview');
          try {
          const res = await fetch(url);
            if (!res.ok) throw new Error('Fetch failed');
          const text = await res.text();
            const lines = text.split(/\r?\n/).filter(line => line.trim()); // Show all rows, filter empty lines
            const cells = lines.map(l => l.split(',').map(x => x.replace(/&/g,'&amp;').replace(/</g,'&lt;'))); // No cell content limits
          const header = cells.shift() || [];
            const rows = cells.map(row => `<tr>${row.map(c=>`<td style="padding:4px 8px; border-bottom:1px solid var(--border); font-size:12px; word-wrap:break-word; max-width:200px;">${c}</td>`).join('')}</tr>`).join('');
            pane.innerHTML = `<div style="max-height:600px; overflow:auto; border:1px solid var(--border); border-radius:6px;">
              <table style="width:100%; border-collapse:collapse; font-size:12px;">
                <thead style="position:sticky; top:0; background:var(--panel);">
                  <tr>${header.map(h=>`<th style="padding:6px 8px; text-align:left; border-bottom:2px solid var(--border); font-weight:600; word-wrap:break-word; max-width:200px;">${h}</th>`).join('')}</tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>
            </div>`;
          } catch(e) {
            console.error('👁️  CSV preview error:', e);
            pane.textContent = 'CSV preview unavailable.';
          }
          return;
        }
        
        // Markdown preview (full content with styling)
        if (['md','markdown'].includes(ext) || (contentType && contentType.includes('markdown'))) {
          console.log('👁️  Rendering Markdown preview');
          try {
          const res = await fetch(url);
            if (!res.ok) throw new Error('Fetch failed');
          const text = await res.text();
            const html = renderBasicMarkdown(text);
            pane.innerHTML = `<div style="max-height:600px; overflow:auto; padding:10px; border:1px solid var(--border); border-radius:6px; background:var(--panel-2); font-size:13px; line-height:1.5;">
              ${html}
            </div>`;
          } catch(e) {
            console.error('👁️  Markdown preview error:', e);
            pane.textContent = 'Markdown preview unavailable.';
          }
          return;
        }
        
        // Fallback text preview (full content with styling)
        console.log('👁️  Rendering fallback text preview');
        try {
        const res = await fetch(url, { method: 'GET' });
          if (!res.ok) throw new Error('Fetch failed');
        const buf = await res.arrayBuffer();
          const bytes = new Uint8Array(buf); // Load full file content
        let text = '';
          try { 
            text = new TextDecoder('utf-8', { fatal: false }).decode(bytes); 
      } catch(_) {
            pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--muted);">Binary file - preview not available<br/><small>Use "Open" link to download</small></div>';
            return;
          }
          
          const safe = (s)=>String(s||'').replace(/[&<>]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;' }[c]));
          
          if (text) {
            pane.innerHTML = `<div style="max-height:600px; overflow:auto; border:1px solid var(--border); border-radius:6px; background:var(--panel-2);">
              <pre style="white-space:pre-wrap; margin:0; padding:12px; font-size:12px; line-height:1.4; font-family:'Monaco','Menlo','Ubuntu Mono',monospace;">${safe(text)}</pre>
            </div>`;
          } else {
            pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--muted);">Empty file or unsupported format</div>';
          }
        } catch(e) {
          console.error('👁️  Text preview error:', e);
          pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--err);">Preview unavailable<br/><small>Use "Open" link to access file</small></div>';
        }
      } catch(e) {
        console.error('👁️  Preview function error:', e);
        const pane = qs('#filePreviewContent'); 
        if (pane) pane.innerHTML = '<div style="padding:20px; text-align:center; color:var(--err);">Preview error occurred</div>';
      }
      
      // Store current file info in preview controls for fullscreen/popout
      const controls = qs('#previewControls');
      if (controls) {
        // Store current file info for fullscreen/popout
        controls.setAttribute('data-file-id', fileId);
        controls.setAttribute('data-filename', filename || 'document');
        controls.setAttribute('data-url', url || '');
        console.log('👁️  Controls configured with:', { fileId, filename, url });
      }
    }
    
    // Fullscreen and popout functionality
    let currentPreviewData = { fileId: '', filename: '', url: '' };
    
    function openFullscreenPreview() {
      const pane = qs('#filePreviewContent');
      const modal = qs('#previewFullscreenModal');
      const fullscreenContent = qs('#fullscreenPreviewContent');
      const title = qs('#fullscreenPreviewTitle');
      const controls = qs('#previewControls');
      
      if (!pane || !modal || !fullscreenContent) {
        console.error('👁️  Missing elements for fullscreen');
        return;
      }
      
      // Get current file data
      if (controls) {
        currentPreviewData.fileId = controls.getAttribute('data-file-id') || '';
        currentPreviewData.filename = controls.getAttribute('data-filename') || 'Document';
        currentPreviewData.url = controls.getAttribute('data-url') || '';
      }
      
      // Clone content structure but regenerate with full height
      const originalHTML = pane.innerHTML;
      
      // For PDFs and iframes, recreate with full height instead of constrained height
      if (originalHTML.includes('<iframe') && originalHTML.includes('pdf')) {
        const url = currentPreviewData.url;
        fullscreenContent.innerHTML = `
          <div style="width:100%; height:100%; border:none;">
            <iframe src="${url}#toolbar=0&navpanes=0" style="width:100%; height:100%; border:none;"></iframe>
          </div>
        `;
      } else {
        // For other content, just clone but remove height constraints
        let fullscreenHTML = originalHTML;
        // Remove any height constraints from the cloned content
        fullscreenHTML = fullscreenHTML.replace(/max-height:\s*\d+px/gi, 'max-height: 100%');
        fullscreenHTML = fullscreenHTML.replace(/height:\s*\d+px/gi, 'height: auto');
        fullscreenContent.innerHTML = fullscreenHTML;
      }
      
      if (title) title.textContent = `${currentPreviewData.filename} - Preview`;
      
      // Show modal
      modal.style.display = 'block';
      document.body.style.overflow = 'hidden'; // Prevent body scroll
      
      console.log('👁️  Opened fullscreen preview for:', currentPreviewData.filename);
    }
    
    function closeFullscreenPreview() {
      const modal = qs('#previewFullscreenModal');
      if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = ''; // Restore body scroll
        console.log('👁️  Closed fullscreen preview');
      }
    }
    
    function popoutPreview() {
      console.log('👁️  Popout requested with data:', currentPreviewData);
      
      if (!currentPreviewData.url) {
        // Try to get URL from controls if not in currentPreviewData
        const controls = qs('#previewControls');
        if (controls) {
          currentPreviewData.url = controls.getAttribute('data-url') || '';
          console.log('👁️  Retrieved URL from controls:', currentPreviewData.url);
        }
      }
      
      if (!currentPreviewData.url) {
        console.error('👁️  No URL available for popout');
        alert('Cannot open file in new window - no URL available');
        return;
      }
      
      const filename = currentPreviewData.filename || 'Document';
      const url = currentPreviewData.url;
      
      console.log('👁️  Opening URL in new window:', url);
      
      try {
        // Open in new window with proper window features
        const popup = window.open(url, '_blank', 'width=1000,height=800,scrollbars=yes,resizable=yes,toolbar=yes,menubar=no,status=yes');
        if (popup) {
          // Set title after a brief delay to ensure content loads
          setTimeout(() => {
            try {
              popup.document.title = filename;
            } catch(e) {
              // CORS may prevent title setting, that's ok
              console.log('👁️  Could not set popup title (CORS)');
            }
          }, 1000);
          console.log('👁️  Successfully opened preview in new window');
        } else {
          console.error('👁️  Popup was blocked');
          // Fallback: try to open in new tab
          const fallback = window.open(url, '_blank');
          if (fallback) {
            console.log('👁️  Fallback: opened in new tab');
          } else {
            console.error('👁️  Both popup and fallback blocked');
            alert('Popup blocked. Please allow popups for this site or use the "Open" link in metadata.');
          }
        }
      } catch(e) {
        console.error('👁️  Error opening popup:', e);
        alert('Error opening new window: ' + e.message);
      }
    }
    
    // Initialize preview controls
    try {
      const fullscreenBtn = qs('#previewFullscreenBtn');
      const popoutBtn = qs('#previewPopoutBtn');
      const fullscreenCloseBtn = qs('#fullscreenCloseBtn');
      const fullscreenPopoutBtn = qs('#fullscreenPopoutBtn');
      const fullscreenModal = qs('#previewFullscreenModal');
      
      if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', openFullscreenPreview);
      }
      if (popoutBtn) {
        popoutBtn.addEventListener('click', popoutPreview);
      }
      if (fullscreenCloseBtn) fullscreenCloseBtn.addEventListener('click', closeFullscreenPreview);
      if (fullscreenPopoutBtn) fullscreenPopoutBtn.addEventListener('click', popoutPreview);
      
      // Close fullscreen on ESC key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && fullscreenModal && fullscreenModal.style.display === 'block') {
          closeFullscreenPreview();
        }
      });
      
      // Close fullscreen on modal background click
      if (fullscreenModal) {
        fullscreenModal.addEventListener('click', (e) => {
          if (e.target === fullscreenModal) {
            closeFullscreenPreview();
          }
        });
      }
      
    } catch(e) {
      console.error('👁️  Preview controls initialization failed:', e);
    }
    
          // Controls will show automatically when a file is selected for preview
       
       // Admin check function - checks if current user has admin role
       async function isAdmin() {
         const username = localStorage.getItem('odras_user') || '';
         const isAdminUser = username === 'admin';
         
         console.log('👑 Checking admin status - username:', username, 'isAdmin:', isAdminUser);
         return isAdminUser;
    }
    
    // Function to update admin UI elements visibility based on user admin status
    function updateAdminUIVisibility(isAdmin) {
      console.log('🔧 Updating admin UI visibility, isAdmin:', isAdmin);
      
      // Hide/show admin icon in left toolbar
      const adminIcon = document.querySelector('.icon[data-wb="admin"]');
      if (adminIcon) {
        adminIcon.style.display = isAdmin ? 'grid' : 'none';
      }
      
      // If admin workbench is currently active but user is not admin, switch to ontology workbench
      const adminWorkbench = document.querySelector('#wb-admin');
      if (!isAdmin && adminWorkbench && adminWorkbench.classList.contains('active')) {
        console.log('🔄 Switching from admin workbench to ontology workbench');
        // Remove active class from admin workbench
        adminWorkbench.classList.remove('active');
        // Remove active class from admin icon
        if (adminIcon) {
          adminIcon.classList.remove('active');
        }
        // Activate ontology workbench
        const ontologyIcon = document.querySelector('.icon[data-wb="ontology"]');
        const ontologyWorkbench = document.querySelector('#wb-ontology');
        if (ontologyIcon && ontologyWorkbench) {
          ontologyIcon.classList.add('active');
          ontologyWorkbench.classList.add('active');
          // Update URL hash
          const url = new URL(window.location);
          url.hash = 'wb=ontology';
          window.history.replaceState({}, '', url);
          // Update localStorage
          localStorage.setItem('active_workbench', 'ontology');
        }
      }
    }
    function renderBasicMarkdown(src) {
      const esc = (s)=>String(s||'').replace(/[&<>]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;' }[c]));
      let s = esc(src);
      s = s.replace(/^######\s+(.*)$/gm, '<h6>$1</h6>')
           .replace(/^#####\s+(.*)$/gm, '<h5>$1</h5>')
           .replace(/^####\s+(.*)$/gm, '<h4>$1</h4>')
           .replace(/^###\s+(.*)$/gm, '<h3>$1</h3>')
           .replace(/^##\s+(.*)$/gm, '<h2>$1</h2>')
           .replace(/^#\s+(.*)$/gm, '<h1>$1</h1>')
           .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
           .replace(/\*(.+?)\*/g, '<em>$1</em>')
           .replace(/`([^`]+)`/g, '<code>$1</code>')
           .replace(/\n\n/g, '<br/><br/>');
      return `<div>${s}</div>`;
    }
    // Ensure file handlers are bound even if Files workbench is the initial active view
    try { setTimeout(() => { try { ensureFilesInitialized(); } catch(_) {} }, 0); } catch(_) {}

    // DAS dock: state, toggle, docking, resize, persistence
    (function(){
      const storageKey = 'odras_das_state';
      const panel = document.getElementById('dasPanel');
      const resizerX = document.getElementById('dasResizerX');
      const resizerY = document.getElementById('dasResizerY');
      const transcript = document.getElementById('dasTranscript');
      const promptInput = document.getElementById('dasPrompt');
      const sendBtn = document.getElementById('dasSendBtn');
      if (!panel) return;
      let state = { open: false, dock: 'right', width: 420, height: Math.max(300, Math.round(window.innerHeight * 0.4)) };
      try { const saved = JSON.parse(localStorage.getItem(storageKey) || '{}'); state = { ...state, ...saved }; } catch(_) {}
      function applyState() {
        panel.classList.remove('das-dock-left','das-dock-right','das-dock-bottom');
        if (state.open) panel.classList.add('active'); else panel.classList.remove('active');
        const dockCls = state.dock === 'left' ? 'das-dock-left' : (state.dock === 'bottom' ? 'das-dock-bottom' : 'das-dock-right');
        panel.classList.add(dockCls);
        document.documentElement.style.setProperty('--das-w', state.width + 'px');
        document.documentElement.style.setProperty('--das-h', state.height + 'px');
        // Body classes to shift layout
        document.body.classList.remove('das-open-left','das-open-right','das-open-bottom');
        if (state.open) {
          if (state.dock === 'left') document.body.classList.add('das-open-left');
          else if (state.dock === 'bottom') document.body.classList.add('das-open-bottom');
          else document.body.classList.add('das-open-right');
        }
      }
      function persist() { try { localStorage.setItem(storageKey, JSON.stringify(state)); } catch(_) {} }
      function toggleOpen() { state.open = !state.open; applyState(); persist(); }
      function setDock(pos) { state.dock = pos; applyState(); persist(); }
      // Resize handlers
      (function(){
        let dragging = false; let startX = 0; let startY = 0; let startW = 0; let startH = 0;
        function onMove(e) {
          if (!dragging) return;
          if (state.dock === 'bottom') {
            const dy = e.clientY - startY;
            const h = Math.max(200, startH - dy);
            state.height = h;
          } else {
            const dx = e.clientX - startX;
            let w = startW;
            if (state.dock === 'right') w = Math.max(260, startW - dx);
            if (state.dock === 'left') w = Math.max(260, startW + dx);
            state.width = w;
          }
          applyState();
        }
        function endDrag() {
          if (!dragging) return;
          dragging = false; persist();
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', endDrag);
        }
        function startDragX(e){ dragging = true; startX = e.clientX; startW = state.width; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', endDrag); e.preventDefault(); }
        function startDragY(e){ dragging = true; startY = e.clientY; startH = state.height; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', endDrag); e.preventDefault(); }
        if (resizerX) resizerX.addEventListener('mousedown', startDragX);
        if (resizerY) resizerY.addEventListener('mousedown', startDragY);
      })();
      // Minimal scaffold behavior
      if (sendBtn && promptInput && transcript) {
        sendBtn.addEventListener('click', () => {
          const text = (promptInput.value || '').trim(); if (!text) return;
          const div = document.createElement('div'); div.className='card'; div.textContent = 'You: ' + text;
          transcript.appendChild(div);
          promptInput.value = '';
        });
        promptInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') { e.preventDefault(); sendBtn.click(); } });
      }
      // Keyboard shortcuts: Alt+Shift+K toggle; Alt+Shift+Arrows to dock
      const onKey = (e) => {
        // Two toggles: Alt+Shift+D or Ctrl+Alt+D to avoid browser collisions
        const toggleCombo = ((e.altKey && e.shiftKey && (e.key === 'D' || e.key === 'd')) || (e.ctrlKey && e.altKey && (e.key === 'D' || e.key === 'd')));
        if (toggleCombo) { e.preventDefault(); toggleOpen(); return; }
        if (!state.open) return;
        const isAltShift = e.altKey && e.shiftKey;
        if (!isAltShift) return;
        if (e.key === 'ArrowLeft') { e.preventDefault(); setDock('left'); }
        else if (e.key === 'ArrowRight') { e.preventDefault(); setDock('right'); }
        else if (e.key === 'ArrowDown') { e.preventDefault(); setDock('bottom'); }
      };
      // Listen high in the stack to avoid being swallowed by focused elements
      window.addEventListener('keydown', onKey, true);
      // Initialize
      applyState();
    })();

    async function startWorkflowStartApi(processKey, projectId, fileIds, params) {
      try {
        const res = await fetch('/api/workflows/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...authHeader() },
          body: JSON.stringify({ processKey, projectId, fileIds, params })
        });
        const js = await res.json().catch(()=>({}));
        if (!res.ok || js.success === false) return { ok:false, error: (js && (js.detail || js.error)) || 'failed' };
        return { ok:true, runId: js.runId, url: js.camunda_url };
      } catch(e) { return { ok:false, error: String(e) }; }
    }

    // ========================================
    // KNOWLEDGE MANAGEMENT FUNCTIONALITY
    // ========================================

    async function loadKnowledgeAssets() {
      try {
        console.log('🧠 Loading knowledge assets...');
        const response = await fetch('/api/knowledge/assets', {
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to load knowledge assets: ${response.status}`);
        }

        const data = await response.json();
        console.log('🧠 Loaded knowledge assets:', data);
        
        await displayKnowledgeAssets(data.assets || []);
        updateProcessingStatus();

      } catch (error) {
        console.error('❌ Error loading knowledge assets:', error);
        const listElement = document.getElementById('knowledgeAssetsList');
        if (listElement) {
          listElement.innerHTML = `
            <div class="muted" style="padding:20px; text-align:center; color:var(--err);">
              Error loading knowledge assets: ${error.message}<br/>
              <button class="btn" onclick="loadKnowledgeAssets()" style="margin-top:8px;">Try Again</button>
            </div>
          `;
        }
      }
    }

    async function displayKnowledgeAssets(assets) {
      const listElement = document.getElementById('knowledgeAssetsList');
      if (!listElement) return;

      if (!assets || assets.length === 0) {
        listElement.innerHTML = `
          <div class="muted" style="padding:20px; text-align:center;">
            No knowledge assets yet.<br/>
            <small>Upload and process documents to begin building your knowledge base.</small>
          </div>
        `;
        return;
      }

      // Check if current user is admin
      const currentUser = await getCurrentUser();
      const isAdmin = currentUser && currentUser.is_admin;

      const assetsHtml = assets.map(asset => {
        const stats = asset.processing_stats || {};
        const chunkCount = stats.chunk_count || 0;
        const tokenCount = stats.token_count || 0;
        const createdDate = new Date(asset.created_at).toLocaleDateString();
        
        // Public asset indicator
        const publicIndicator = asset.is_public ? 
          `<span style="background:#0f2f1f; color:#10b981; padding:2px 6px; border-radius:3px; font-size:10px; font-weight:600; margin-left:8px;">PUBLIC</span>` : '';
        
        // Action buttons
        const actionButtons = `
          <div class="asset-actions" style="display:flex; gap:4px; margin-top:8px; padding-top:8px; border-top:1px solid var(--border);">
            <button class="btn" style="padding:4px 8px; font-size:11px; background:#1e3a8a; color:#60a5fa;" 
                    onclick="event.stopPropagation(); viewAssetContent('${asset.id}')" title="View Content">
              📄 Content
            </button>
            <button class="btn" style="padding:4px 8px; font-size:11px; background:#dc2626; color:#f87171;" 
                    onclick="event.stopPropagation(); deleteAsset('${asset.id}', '${asset.title}')" title="Delete Asset">
              🗑️ Delete
            </button>
            ${isAdmin ? `
              <button class="btn" style="padding:4px 8px; font-size:11px; background:#7c3aed; color:#a78bfa;" 
                      onclick="event.stopPropagation(); toggleAssetPublic('${asset.id}', ${!asset.is_public})" 
                      title="${asset.is_public ? 'Make Private' : 'Make Public'}">
                ${asset.is_public ? '🔒 Private' : '🌐 Public'}
              </button>
            ` : ''}
          </div>
        `;
        
        return `
          <div class="knowledge-asset-card" style="background:#0b1220; border:1px solid var(--border); border-radius:6px; padding:12px; margin-bottom:8px; cursor:pointer;" 
               onclick="selectKnowledgeAsset('${asset.id}')">
            <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:8px;">
              <div style="flex:1;">
                <h4 style="margin:0 0 4px 0; color:var(--accent); display:flex; align-items:center;">
                  ${asset.title === 'unknown' ? (stats.filename || 'Untitled Asset') : asset.title}
                  ${publicIndicator}
                </h4>
                <div style="font-size:12px; color:var(--muted);">
                  ${asset.document_type} • ${createdDate}
                  ${asset.is_public && asset.made_public_by ? ` • Made public by ${asset.made_public_by}` : ''}
                </div>
              </div>
              <div style="text-align:right; font-size:11px; color:var(--muted);">
                <div>${chunkCount} chunk${chunkCount !== 1 ? 's' : ''}</div>
                <div>${tokenCount} tokens</div>
              </div>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center; font-size:11px;">
              <span class="status-badge status-${asset.status}" style="
                padding:2px 6px; border-radius:3px; font-weight:500;
                ${asset.status === 'active' ? 'background:#0f3d2c; color:#10b981;' : ''}
                ${asset.status === 'processing' ? 'background:#3d2f0f; color:#f59e0b;' : ''}
                ${asset.status === 'failed' ? 'background:#3d0f0f; color:#ef4444;' : ''}
              ">
                ${asset.status.toUpperCase()}
              </span>
              <div style="color:var(--muted);">
                Model: ${stats.embedding_model || 'N/A'}
              </div>
            </div>
            ${actionButtons}
          </div>
        `;
      }).join('');

      listElement.innerHTML = `
        <div style="margin-bottom:12px; font-size:12px; color:var(--muted);">
          Showing ${assets.length} knowledge asset${assets.length !== 1 ? 's' : ''}
          ${isAdmin ? '<span style="color:var(--accent);"> (Admin View)</span>' : ''}
        </div>
        ${assetsHtml}
      `;
    }

    async function selectKnowledgeAsset(assetId) {
      try {
        console.log('🧠 Loading knowledge asset details:', assetId);
        
        // Highlight selected asset
        document.querySelectorAll('.knowledge-asset-card').forEach(card => {
          card.style.borderColor = 'var(--border)';
        });
        event.target.closest('.knowledge-asset-card').style.borderColor = 'var(--accent)';

        const response = await fetch(`/api/knowledge/assets/${assetId}?include_chunks=true`, {
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to load asset details: ${response.status}`);
        }

        const asset = await response.json();
        displayKnowledgeAssetDetails(asset);

      } catch (error) {
        console.error('❌ Error loading asset details:', error);
        const detailsElement = document.getElementById('knowledgeDetailsContent');
        if (detailsElement) {
          detailsElement.innerHTML = `
            <div style="padding:20px; text-align:center; color:var(--err);">
              Error loading asset details: ${error.message}
            </div>
          `;
        }
      }
    }

    function displayKnowledgeAssetDetails(asset) {
      const detailsElement = document.getElementById('knowledgeDetailsContent');
      if (!detailsElement) return;

      const stats = asset.processing_stats || {};
      const chunks = asset.chunks || [];
      
      const detailsHtml = `
        <div style="padding:4px 0;">
          <h4 style="margin:0 0 12px 0; color:var(--accent);">
            ${asset.title === 'unknown' ? (stats.filename || 'Untitled Asset') : asset.title}
          </h4>
          
          <div style="display:grid; gap:12px; margin-bottom:16px;">
            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">DOCUMENT TYPE</div>
              <div style="font-size:13px;">${asset.document_type}</div>
            </div>
            
            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">PROCESSING STATS</div>
              <div style="font-size:12px;">
                • ${stats.chunk_count || 0} chunks<br/>
                • ${stats.token_count || 0} tokens<br/>
                • ${stats.embedding_model || 'N/A'} model<br/>
                • ${stats.chunking_strategy || 'N/A'} strategy
              </div>
            </div>

            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">FILE INFO</div>
              <div style="font-size:12px;">
                • Size: ${stats.original_size || 0} bytes<br/>
                • Type: ${stats.content_type || 'N/A'}<br/>
                • Extracted: ${stats.extracted_text_length || 0} chars
              </div>
            </div>

            <div>
              <div style="font-size:11px; color:var(--muted); font-weight:600;">TIMESTAMPS</div>
              <div style="font-size:12px;">
                Created: ${new Date(asset.created_at).toLocaleString()}<br/>
                Updated: ${new Date(asset.updated_at).toLocaleString()}
              </div>
            </div>

            ${asset.is_public ? `
              <div>
                <div style="font-size:11px; color:var(--muted); font-weight:600;">PUBLIC ACCESS</div>
                <div style="font-size:12px;">
                  <span style="color:#10b981; font-weight:600;">✓ Public Asset</span><br/>
                  ${asset.made_public_at ? `Made public: ${new Date(asset.made_public_at).toLocaleString()}<br/>` : ''}
                  ${asset.made_public_by ? `By: ${asset.made_public_by}` : ''}
                </div>
              </div>
            ` : `
              <div>
                <div style="font-size:11px; color:var(--muted); font-weight:600;">ACCESS</div>
                <div style="font-size:12px; color:var(--muted);">
                  🔒 Project Only
                </div>
              </div>
            `}
          </div>

          ${chunks.length > 0 ? `
            <div style="margin-top:16px;">
              <div style="font-size:11px; color:var(--muted); font-weight:600; margin-bottom:8px;">
                CONTENT CHUNKS (${chunks.length})
              </div>
              <div style="max-height:300px; overflow-y:auto; background:#0b1220; border:1px solid var(--border); border-radius:4px;">
                ${chunks.map((chunk, i) => `
                  <div style="padding:8px; border-bottom:1px solid var(--border);" title="Chunk ${chunk.sequence_number}">
                    <div style="font-size:10px; color:var(--muted); margin-bottom:4px;">
                      #${chunk.sequence_number} • ${chunk.token_count} tokens • ${chunk.chunk_type}
                    </div>
                    <div style="font-size:11px; line-height:1.4; max-height:60px; overflow:hidden;">
                      ${chunk.content.length > 200 ? chunk.content.substring(0, 200) + '...' : chunk.content}
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
          ` : ''}
        </div>
      `;

      detailsElement.innerHTML = detailsHtml;
    }

    async function updateProcessingStatus() {
      try {
        const response = await fetch('/api/knowledge/jobs', {
          headers: { ...authHeader() }
        });

        if (response.ok) {
          const jobs = await response.json();
          const statusElement = document.getElementById('knowledgeProcessingStatus');
          
          if (statusElement && Array.isArray(jobs)) {
            const activeJobs = jobs.filter(job => job.status === 'running');
            
            if (activeJobs.length > 0) {
              const jobsHtml = activeJobs.map(job => `
                <div style="margin-bottom:8px;">
                  <div style="font-size:12px; color:var(--accent);">
                    ${job.job_type} - ${job.progress_percent}%
                  </div>
                  <div style="background:#0b1220; border-radius:3px; height:6px; overflow:hidden;">
                    <div style="background:var(--accent); height:100%; width:${job.progress_percent}%; transition:width 0.3s;"></div>
                  </div>
                </div>
              `).join('');
              
              statusElement.innerHTML = jobsHtml;
            } else {
              statusElement.innerHTML = '<div class="muted">No processing jobs running</div>';
            }
          }
        }
      } catch (error) {
        console.error('Error updating processing status:', error);
      }
    }

    // Initialize knowledge management when the page loads
    function initializeKnowledgeManagement() {
      console.log('🧠 Initializing Knowledge Management...');

      // Bind refresh button
      const refreshBtn = document.getElementById('knowledgeRefreshBtn');
      if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
          console.log('🧠 Refresh button clicked');
          loadKnowledgeAssets();
        });
      }

      // Add query button event listener
      const queryBtn = document.getElementById('knowledgeQueryBtn');
      if (queryBtn) {
        queryBtn.addEventListener('click', () => {
          console.log('🔍 Query button clicked');
          showRAGQueryInterface();
        });
      }

      // Load knowledge assets if the knowledge workbench is active
      const knowledgeWorkbench = document.getElementById('wb-knowledge');
      if (knowledgeWorkbench && !knowledgeWorkbench.style.display) {
        loadKnowledgeAssets();
      }

      // Also load when switching to knowledge workbench
      const observer = new MutationObserver(() => {
        if (knowledgeWorkbench && knowledgeWorkbench.style.display !== 'none') {
          loadKnowledgeAssets();
        }
      });
      
      // Load admin data if admin workbench is already active on page load
      setTimeout(() => {
        if (document.querySelector('#wb-admin.workbench.active')) {
          loadPrefixes();
          loadDomains();
          loadUsers(); // Load user management data
          // Only load namespaces if user is authenticated
          const token = localStorage.getItem('odras_token');
          if (token) {
            loadNamespaces();
          }
        }
      }, 100);
      
      if (knowledgeWorkbench) {
        observer.observe(knowledgeWorkbench, { attributes: true, attributeFilter: ['style'] });
      }
    }

    // Auto-initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeKnowledgeManagement);
    } else {
      initializeKnowledgeManagement();
    }

    // Helper function to get current user info
    async function getCurrentUser() {
      try {
        const token = localStorage.getItem(tokenKey);
        if (!token) return null;
        
        const response = await fetch('/api/auth/me', { 
          headers: { Authorization: 'Bearer ' + token } 
        });
        if (response.ok) {
          return await response.json();
        }
        return null;
      } catch (error) {
        console.error('Error getting current user:', error);
        return null;
      }
    }

    // Function to view full asset content
    async function viewAssetContent(assetId) {
      try {
        console.log('🧠 Loading asset content:', assetId);
        
        const response = await fetch(`/api/knowledge/assets/${assetId}/content`, {
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to load content: ${response.status}`);
        }

        const contentData = await response.json();
        showContentModal(contentData);

      } catch (error) {
        console.error('❌ Error loading asset content:', error);
        alert('Error loading content: ' + error.message);
      }
    }

    // Function to show content in a modal
    function showContentModal(contentData) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
        background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; 
        z-index: 10000; padding: 20px;
      `;
      
      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; 
                    width: 90%; max-width: 1000px; height: 80vh; display: flex; flex-direction: column;">
          <div style="padding: 16px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0; color: var(--accent);">${contentData.title}</h3>
            <button onclick="this.closest('.content-modal').remove()" style="
              background: transparent; border: none; color: var(--muted); font-size: 24px; cursor: pointer;
            ">&times;</button>
          </div>
          <div style="padding: 16px; overflow-y: auto; flex: 1;">
            <div style="margin-bottom: 16px; font-size: 12px; color: var(--muted);">
              📄 ${contentData.document_type} • ${contentData.total_chunks} chunks • ${contentData.total_tokens} tokens
            </div>
            <div style="line-height: 1.6; white-space: pre-wrap; font-family: ui-monospace, monospace; font-size: 13px;">
              ${contentData.content}
            </div>
          </div>
        </div>
      `;
      
      modal.className = 'content-modal';
      document.body.appendChild(modal);
      
      // Close on backdrop click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }

    // Function to delete an asset
    async function deleteAsset(assetId, assetTitle) {
      const displayTitle = assetTitle === 'unknown' ? 'Untitled Asset' : assetTitle;
      
      if (!confirm(`Are you sure you want to delete "${displayTitle}"?\\n\\nThis will permanently remove the asset and all its chunks.`)) {
        return;
      }

      try {
        console.log('🧠 Deleting asset:', assetId);
        
        const response = await fetch(`/api/knowledge/assets/${assetId}`, {
          method: 'DELETE',
          headers: { ...authHeader() }
        });

        if (!response.ok) {
          throw new Error(`Failed to delete asset: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ Asset deleted successfully:', result);
        
        // Refresh the assets list
        loadKnowledgeAssets();
        
        // Clear details panel
        const detailsElement = document.getElementById('knowledgeDetailsContent');
        if (detailsElement) {
          detailsElement.innerHTML = `
            <div class="muted" style="padding:20px; text-align:center;">
              Select a knowledge asset to view details
            </div>
          `;
        }
        
        alert('Asset deleted successfully');

      } catch (error) {
        console.error('❌ Error deleting asset:', error);
        alert('Error deleting asset: ' + error.message);
      }
    }

    // Function to toggle asset public status (admin only)
    async function toggleAssetPublic(assetId, makePublic) {
      const action = makePublic ? 'make public' : 'make private';
      
      if (!confirm(`Are you sure you want to ${action} this knowledge asset?\\n\\n${makePublic ? 'Public assets can be viewed by all users across all projects.' : 'Private assets are only visible within their project.'}`)) {
        return;
      }

      try {
        console.log(`🧠 ${makePublic ? 'Making public' : 'Making private'} asset:`, assetId);
        
        const response = await fetch(`/api/knowledge/assets/${assetId}/public`, {
          method: 'PUT',
          headers: { 
            'Content-Type': 'application/json',
            ...authHeader() 
          },
          body: JSON.stringify({ is_public: makePublic })
        });

        if (!response.ok) {
          throw new Error(`Failed to update asset: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ Asset visibility updated:', result);
        
        // Refresh the assets list
        loadKnowledgeAssets();
        
        const status = makePublic ? 'public' : 'private';
        alert(`Asset is now ${status}`);

      } catch (error) {
        console.error('❌ Error updating asset visibility:', error);
        alert('Error updating asset: ' + error.message);
      }
    }

    // ========================================
    // RAG QUERY FUNCTIONALITY
    // ========================================

    async function showRAGQueryInterface() {
      try {
        console.log('🔍 Showing RAG query interface...');
        
        const detailsContent = document.getElementById('knowledgeDetailsContent');
        if (!detailsContent) return;
        
        detailsContent.innerHTML = `
          <div style="height:100%; display:flex; flex-direction:column;">
            <!-- Query Input -->
            <div style="margin-bottom:16px;">
              <div style="font-size:14px; font-weight:600; margin-bottom:8px;">Ask your knowledge base:</div>
              <div style="display:flex; flex-direction:column; gap:8px;">
                <textarea id="ragQueryInput" placeholder="What are the main requirements for navigation systems?" 
                  style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:6px; padding:10px; width:100%; height:80px; resize:vertical; font-family:inherit; font-size:13px;">
                </textarea>
                <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                  <button class="btn" id="ragQueryBtn" style="background:#059669; border-color:#059669;">🔍 Ask</button>
                  <button class="btn" id="ragSuggestionsBtn">💡 Suggestions</button>
                  <select id="ragStyleSelect" style="background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:4px; padding:4px 8px; font-size:12px;">
                    <option value="comprehensive">📖 Comprehensive</option>
                    <option value="concise">⚡ Concise</option>
                    <option value="technical">🔧 Technical</option>
                  </select>
                  <div class="muted" style="font-size:11px; margin-left:auto;" id="ragStatus"></div>
                </div>
              </div>
            </div>
            
            <!-- Query Response -->
            <div style="flex:1; border:1px solid var(--border); border-radius:6px; background:#0f1419; overflow:hidden; display:flex; flex-direction:column;">
              <div style="background:var(--accent-subtle); padding:8px 12px; border-bottom:1px solid var(--border); font-size:12px; font-weight:600; color:var(--accent); display:flex; justify-content:space-between; align-items:center;">
                <span>💬 Response</span>
                <div id="ragMetadata" class="muted" style="font-size:10px;"></div>
              </div>
              <div id="ragResponseContent" style="flex:1; padding:16px; overflow-y:auto; line-height:1.5;">
                <div class="muted" style="text-align:center; padding:40px 20px;">
                  Enter a question above and click "Ask" to query your knowledge base.<br/>
                  <small>Powered by AI retrieval and generation</small>
                </div>
              </div>
            </div>
          </div>
        `;
        
        // Add event listeners
        document.getElementById('ragQueryBtn')?.addEventListener('click', executeRAGQuery);
        document.getElementById('ragSuggestionsBtn')?.addEventListener('click', loadQuerySuggestions);
        
        // Load suggestions immediately
        loadQuerySuggestions();
        
      } catch (error) {
        console.error('Error showing RAG interface:', error);
      }
    }
    
    async function executeRAGQuery() {
      try {
        const queryInput = document.getElementById('ragQueryInput');
        const styleSelect = document.getElementById('ragStyleSelect');
        const statusDiv = document.getElementById('ragStatus');
        const responseContent = document.getElementById('ragResponseContent');
        const metadataDiv = document.getElementById('ragMetadata');
        
        if (!queryInput || !queryInput.value.trim()) {
          alert('Please enter a question to ask your knowledge base.');
          return;
        }
        
        const question = queryInput.value.trim();
        const responseStyle = styleSelect?.value || 'comprehensive';
        
        // Show loading state
        statusDiv.textContent = 'Thinking...';
        responseContent.innerHTML = `
          <div style="display:flex; align-items:center; justify-content:center; padding:40px;">
            <div style="display:flex; flex-direction:column; align-items:center; gap:16px;">
              <div class="loading-spinner" style="width:24px; height:24px; border:2px solid var(--border); border-top:2px solid var(--accent); border-radius:50%; animation:spin 1s linear infinite;"></div>
              <div class="muted">Analyzing your knowledge base...</div>
            </div>
          </div>
        `;
        
        console.log('🔍 Executing RAG query:', { question, responseStyle });
        
        // Execute RAG query
        const response = await fetch('/api/knowledge/query', {
          method: 'POST',
          headers: {
            ...authHeader(),
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            question: question,
            response_style: responseStyle,
            max_chunks: 5,
            similarity_threshold: 0.5,  // More permissive threshold
            include_metadata: true
          })
        });
        
        if (!response.ok) {
          throw new Error(`RAG query failed: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('🔍 RAG response:', data);
        
        // Display response
        displayRAGResponse(data);
        
      } catch (error) {
        console.error('RAG query error:', error);
        const statusDiv = document.getElementById('ragStatus');
        const responseContent = document.getElementById('ragResponseContent');
        
        statusDiv.textContent = 'Query failed';
        responseContent.innerHTML = `
          <div style="padding:20px; text-align:center; color:#ef4444;">
            <div style="font-weight:600; margin-bottom:8px;">❌ Query Failed</div>
            <div class="muted">${error.message}</div>
            <button class="btn" onclick="executeRAGQuery()" style="margin-top:12px;">🔄 Retry</button>
          </div>
        `;
      }
    }
    
    function displayRAGResponse(data) {
      const responseContent = document.getElementById('ragResponseContent');
      const metadataDiv = document.getElementById('ragMetadata');
      const statusDiv = document.getElementById('ragStatus');
      
      if (!data.success) {
        responseContent.innerHTML = `
          <div style="padding:20px; text-align:center; color:#ef4444;">
            <div style="font-weight:600; margin-bottom:8px;">❌ Error</div>
            <div class="muted">${data.error || 'Unknown error occurred'}</div>
          </div>
        `;
        statusDiv.textContent = 'Error';
        return;
      }
      
      // Update metadata
      const confidence = data.confidence || 'medium';
      const confidenceIcon = confidence === 'high' ? '🟢' : confidence === 'medium' ? '🟡' : '🟠';
      const chunksFound = data.chunks_found || 0;
      
      metadataDiv.innerHTML = `
        ${confidenceIcon} ${confidence} confidence • ${chunksFound} sources • ${data.model_used}
      `;
      statusDiv.textContent = `${chunksFound} sources found`;
      
      // Display main response
      let responseHTML = `
        <div style="margin-bottom:20px; padding:16px; background:#0a0e13; border-radius:6px; border-left:3px solid #059669;">
          <div style="line-height:1.6; white-space:pre-wrap;">${escapeHtml(data.response)}</div>
        </div>
      `;
      
      // Add sources if available
      if (data.sources && data.sources.length > 0) {
        responseHTML += `
          <div style="margin-top:16px;">
            <div style="font-size:12px; font-weight:600; color:var(--muted); margin-bottom:8px; padding-bottom:4px; border-bottom:1px solid var(--border);">📚 SOURCES</div>
        `;
        
        data.sources.forEach((source, index) => {
          const relevanceScore = Math.round(source.relevance_score * 100);
          responseHTML += `
            <div style="margin-bottom:8px; padding:8px; background:#0b1220; border-radius:4px; border-left:2px solid var(--accent-subtle);">
              <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:4px;">
                <div style="font-size:12px; font-weight:600; color:var(--accent);">${escapeHtml(source.title)}</div>
                <div style="font-size:10px; color:var(--muted);">${relevanceScore}% relevant</div>
              </div>
              <div style="font-size:11px; color:var(--muted);">${escapeHtml(source.document_type)} • Asset ID: ${source.asset_id}</div>
            </div>
          `;
        });
        
        responseHTML += `</div>`;
      }
      
      responseContent.innerHTML = responseHTML;
    }
    
    async function loadQuerySuggestions() {
      try {
        console.log('💡 Loading query suggestions...');
        
        const response = await fetch('/api/knowledge/query/suggestions', {
          headers: authHeader()
        });
        
        if (!response.ok) {
          throw new Error(`Failed to load suggestions: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('💡 Query suggestions:', data);
        
        // Update query input placeholder with a random suggestion
        const queryInput = document.getElementById('ragQueryInput');
        if (queryInput && data.suggestions && data.suggestions.length > 0) {
          const randomSuggestion = data.suggestions[Math.floor(Math.random() * data.suggestions.length)];
          queryInput.placeholder = randomSuggestion;
        }
        
      } catch (error) {
        console.error('Failed to load query suggestions:', error);
      }
    }
    
    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Make functions globally available
    window.loadKnowledgeAssets = loadKnowledgeAssets;
    window.selectKnowledgeAsset = selectKnowledgeAsset;
    window.viewAssetContent = viewAssetContent;
    window.deleteAsset = deleteAsset;
    window.toggleAssetPublic = toggleAssetPublic;
    window.showRAGQueryInterface = showRAGQueryInterface;

    // Namespace Management Functions
    async function loadNamespaces() {
      console.log('🔄 Loading namespaces...');
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.error('No auth token found for namespaces');
          return;
        }

        const response = await fetch('/api/admin/namespaces/', {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const namespaces = await response.json();
        console.log('✅ Loaded namespaces:', namespaces.length);
        renderNamespaceList(namespaces);
      } catch (error) {
        console.error('Error loading namespaces:', error);
        document.getElementById('namespaceList').innerHTML = 
          `<div style="color: var(--err); text-align: center;">Error loading namespaces: ${error.message}</div>`;
      }
    }

    function renderNamespaceList(namespaces) {
      const container = document.getElementById('namespaceList');
      
      if (namespaces.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: var(--muted);">No namespaces found</div>';
        return;
      }

      const html = namespaces.map(ns => {
        const statusColor = ns.status === 'released' ? 'var(--success)' : 
                           ns.status === 'deprecated' ? 'var(--warning)' : 'var(--muted)';
        const statusIcon = ns.status === 'released' ? '✓' : 
                          ns.status === 'deprecated' ? '⚠' : '📝';
        
        return `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px; background: var(--panel-2); ${ns.status !== 'released' ? 'opacity: 0.8;' : ''}">
          <div>
            <div style="font-weight: 600; color: var(--text); display: flex; align-items: center; gap: 8px;">
              ${ns.name}
              <span style="font-size: 0.8em; color: ${statusColor}; font-weight: normal;">
                ${statusIcon} ${ns.status.toUpperCase()}
              </span>
            </div>
            <div style="font-size: 0.9em; color: var(--muted);">
              Type: ${ns.type} | Prefix: ${ns.prefix}
            </div>
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Path: ${ns.path} | Owners: ${ns.owners.join(', ')}
            </div>
            ${ns.description ? `<div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">${ns.description}</div>` : ''}
          </div>
          <div style="display: flex; gap: 8px;">
            <button class="btn" onclick="viewNamespaceDetails('${ns.id}')" style="font-size: 0.8em;">View</button>
            <button class="btn" onclick="editNamespace('${ns.id}')" style="font-size: 0.8em;">Edit</button>
            <button class="btn" onclick="viewNamespaceOntologies('${ns.id}', '${ns.name}')" style="font-size: 0.8em; background: var(--accent); color: white; border-color: var(--accent);">View Ontologies</button>
            <button class="btn" onclick="deleteNamespace('${ns.id}', '${ns.name}')" style="font-size: 0.8em; background: var(--err); color: white; border-color: var(--err);">Delete</button>
          </div>
        </div>
      `;
      }).join('');

      container.innerHTML = html;
    }

    function showCreateNamespaceModal() {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.8); display: flex; align-items: center; 
        justify-content: center; z-index: 1000;
      `;
      
      modal.innerHTML = `
        <div>
          <h3>Create New Namespace</h3>
          
          <div style="margin-bottom: 16px;">
            <label>Prefixes (select in order):</label>
            <div id="nsPrefixSelector" style="border: 1px solid var(--border); border-radius: 4px; padding: 8px; height: 150px; background: var(--panel-2); overflow-y: auto; overflow-x: hidden;">
              <div style="text-align: center; color: var(--muted);">Loading prefixes...</div>
            </div>
            <div id="selectedNsPrefixes" style="margin-top: 8px; font-size: 0.9em; color: var(--text);">
              Selected (in order): <span id="selectedNsPrefixList">None</span>
            </div>
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Select prefixes in the order you want them to appear in the namespace path, or <a href="#" onclick="showCreatePrefixModal(); this.closest('.modal').remove();">create a new one</a>
            </div>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Type:</label>
            <select id="nsType" onchange="updateNamespaceFields()">
              <option value="core">Core</option>
              <option value="service">Service</option>
              <option value="domain">Domain</option>
              <option value="program">Program</option>
              <option value="project">Project</option>
              <option value="industry">Industry</option>
              <option value="vocab">Vocabulary</option>
              <option value="shapes">Shapes</option>
              <option value="align">Alignment</option>
            </select>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Name (auto-generated):</label>
            <input type="text" id="nsName" readonly style="background: var(--panel-2); color: var(--muted);" />
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Name is automatically generated as prefix-type
            </div>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Path (auto-generated):</label>
            <input type="text" id="nsPath" readonly style="background: var(--panel-2); color: var(--muted);" />
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Path is automatically generated based on prefix and type
            </div>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Description:</label>
            <textarea id="nsDescription" placeholder="Optional description"></textarea>
          </div>
          
          <div style="margin-bottom: 20px;">
            <label>Owners (comma-separated emails):</label>
            <input type="text" id="nsOwners" placeholder="admin@organization.mil, user@example.com" />
          </div>
          
          <div class="button-group">
            <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="createNamespace()" style="background: var(--accent); color: white; border-color: var(--accent);">Create</button>
          </div>
        </div>
      `;
      
      modal.className = 'modal';
      document.body.appendChild(modal);
      
      // Reset selection order and load prefixes
      selectedPrefixOrder = [];
      loadPrefixesForNamespaceSelector();
      updateNamespaceFields();
    }

    async function createNamespace() {
      try {
        const name = document.getElementById('nsName').value.trim();
        const type = document.getElementById('nsType').value;
        const path = document.getElementById('nsPath').value.trim();
        const description = document.getElementById('nsDescription').value.trim();
        const owners = document.getElementById('nsOwners').value.trim().split(',').map(o => o.trim()).filter(o => o);

        // Use the ordered prefixes
        const selectedPrefixes = selectedPrefixOrder;

        if (!name || !path || selectedPrefixes.length === 0) {
          alert('Please fill in all required fields and select at least one prefix');
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }

        // Use the compound name as the prefix identifier (matches the name pattern)
        const prefixString = selectedPrefixes.join('-');
        const prefix = `${prefixString}-${type}`;

        const response = await fetch('/api/admin/namespaces/', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name,
            type,
            path,
            prefix,
            description: description || null,
            owners
          })
        });

        if (!response.ok) {
          const error = await response.text();
          throw new Error(`HTTP ${response.status}: ${error}`);
        }

        const newNamespace = await response.json();
        console.log('Created namespace:', newNamespace);
        
        // Close modal and refresh list
        document.querySelector('.modal').remove();
        await loadNamespaces();
        
        toast('Namespace created successfully!');
      } catch (error) {
        console.error('Error creating namespace:', error);
        alert(`Error creating namespace: ${error.message}`);
      }
    }

    async function viewNamespaceDetails(namespaceId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.error('No auth token found');
          return;
        }

        const response = await fetch(`/api/admin/namespaces/${namespaceId}`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const namespace = await response.json();
        
        // Create a detailed view modal
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1000;
        `;
        
        modal.innerHTML = `
          <div style="
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
          ">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
              <h3 style="margin: 0; color: var(--text);">Namespace Details</h3>
              <button onclick="this.closest('.modal').remove()" style="
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: var(--muted);
                padding: 0;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
              ">×</button>
            </div>
            
            <div style="display: grid; gap: 16px;">
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Name:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">${namespace.name}</div>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Type:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">${namespace.type}</div>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Path:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text); font-family: monospace;">${namespace.path}</div>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Prefix:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text); font-family: monospace;">${namespace.prefix}</div>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Status:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">
                  <span style="
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 0.8em;
                    font-weight: 600;
                    background: ${namespace.status === 'released' ? 'var(--success)' : 'var(--warning)'};
                    color: white;
                  ">${namespace.status.toUpperCase()}</span>
                </div>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Owners:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">
                  ${namespace.owners.map(owner => `<div style="margin-bottom: 4px;">${owner}</div>`).join('')}
                </div>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Description:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">${namespace.description || 'No description provided'}</div>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Created:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">${new Date(namespace.created_at).toLocaleString()}</div>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Updated:</label>
                <div style="padding: 8px; background: var(--panel-2); border-radius: 6px; color: var(--text);">${new Date(namespace.updated_at).toLocaleString()}</div>
              </div>
            </div>
            
            <div class="button-group">
              <button onclick="this.closest('.modal').remove()" class="btn" style="background: var(--muted);">Close</button>
              <button onclick="editNamespace('${namespaceId}'); this.closest('.modal').remove();" class="btn" style="background: var(--accent); color: white; border-color: var(--accent);">Edit</button>
            </div>
          </div>
        `;
        
        modal.className = 'modal';
        document.body.appendChild(modal);
        
      } catch (error) {
        console.error('Error loading namespace details:', error);
        alert(`Error loading namespace details: ${error.message}`);
      }
    }

    async function editNamespace(namespaceId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.error('No auth token found');
          return;
        }

        // First, get the current namespace data
        const response = await fetch(`/api/admin/namespaces/${namespaceId}`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const namespace = await response.json();
        
        // Create an edit modal
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1000;
        `;
        
        modal.innerHTML = `
          <div style="
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
          ">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
              <h3 style="margin: 0; color: var(--text);">Edit Namespace</h3>
              <button onclick="this.closest('.modal').remove()" style="
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: var(--muted);
                padding: 0;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
              ">×</button>
            </div>
            
            <form id="editNamespaceForm" style="display: grid; gap: 16px;">
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Name:</label>
                <input type="text" id="editName" value="${namespace.name}" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                " readonly>
                <small style="color: var(--muted); font-size: 0.8em;">Name cannot be changed after creation</small>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Type:</label>
                <input type="text" id="editType" value="${namespace.type}" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                " readonly>
                <small style="color: var(--muted); font-size: 0.8em;">Type cannot be changed after creation</small>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Path:</label>
                <input type="text" id="editPath" value="${namespace.path}" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                " readonly>
                <small style="color: var(--muted); font-size: 0.8em;">Path cannot be changed after creation</small>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Prefix:</label>
                <input type="text" id="editPrefix" value="${namespace.prefix}" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                " readonly>
                <small style="color: var(--muted); font-size: 0.8em;">Prefix cannot be changed after creation</small>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Status:</label>
                <select id="editStatus" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                ">
                  <option value="draft" ${namespace.status === 'draft' ? 'selected' : ''}>Draft</option>
                  <option value="released" ${namespace.status === 'released' ? 'selected' : ''}>Released</option>
                  <option value="deprecated" ${namespace.status === 'deprecated' ? 'selected' : ''}>Deprecated</option>
                </select>
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Owners (comma-separated emails):</label>
                <input type="text" id="editOwners" value="${namespace.owners.join(', ')}" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                " placeholder="admin@organization.mil, user@domain.mil">
              </div>
              
              <div>
                <label style="font-weight: 600; color: var(--text); display: block; margin-bottom: 4px;">Description:</label>
                <textarea id="editDescription" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--border);
                  border-radius: 6px;
                  background: var(--panel-2);
                  color: var(--text);
                  min-height: 80px;
                  resize: vertical;
                " placeholder="Enter namespace description...">${namespace.description || ''}</textarea>
              </div>
            </form>
            
            <div class="button-group">
              <button onclick="this.closest('.modal').remove()" class="btn" style="background: var(--muted);">Cancel</button>
              <button onclick="updateNamespace('${namespaceId}')" class="btn" style="background: var(--accent); color: white; border-color: var(--accent);">Save Changes</button>
            </div>
          </div>
        `;
        
        modal.className = 'modal';
        document.body.appendChild(modal);
        
      } catch (error) {
        console.error('Error loading namespace for edit:', error);
        alert(`Error loading namespace: ${error.message}`);
      }
    }

    async function updateNamespace(namespaceId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          console.error('No auth token found');
          return;
        }

        const form = document.getElementById('editNamespaceForm');
        const owners = document.getElementById('editOwners').value.split(',').map(email => email.trim()).filter(email => email);
        
        const updateData = {
          status: document.getElementById('editStatus').value,
          owners: owners,
          description: document.getElementById('editDescription').value
        };

        const response = await fetch(`/api/admin/namespaces/${namespaceId}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(updateData)
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const updatedNamespace = await response.json();
        console.log('Namespace updated:', updatedNamespace);
        
        // Close modal and refresh list
        document.querySelector('.modal').remove();
        await loadNamespaces();
        
        // Show success message
        const successDiv = document.createElement('div');
        successDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: var(--success);
          color: white;
          padding: 12px 20px;
          border-radius: 6px;
          z-index: 1001;
          box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        `;
        successDiv.textContent = 'Namespace updated successfully!';
        document.body.appendChild(successDiv);
        
        setTimeout(() => successDiv.remove(), 3000);
        
      } catch (error) {
        console.error('Error updating namespace:', error);
        alert(`Error updating namespace: ${error.message}`);
      }
    }

    // Prefix Management Functions
    async function loadPrefixes() {
      console.log('🔄 Loading prefixes...');
      try {
        const response = await fetch('/api/admin/prefixes/?status_filter=all');
        if (response.ok) {
          const prefixes = await response.json();
          console.log('✅ Loaded prefixes:', prefixes.length);
          renderPrefixList(prefixes);
        } else {
          console.error('Failed to load prefixes:', response.status, response.statusText);
          document.getElementById('prefixList').innerHTML = 
            `<div style="color: var(--err); text-align: center;">Error loading prefixes: ${response.statusText}</div>`;
        }
      } catch (error) {
        console.error('Error loading prefixes:', error);
        document.getElementById('prefixList').innerHTML = 
          `<div style="color: var(--err); text-align: center;">Error loading prefixes: ${error.message}</div>`;
      }
    }

    function renderPrefixList(prefixes) {
      const container = document.getElementById('prefixList');
      
      if (prefixes.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: var(--muted);">No prefixes found</div>';
        return;
      }

      const html = prefixes.map(prefix => {
        const statusColor = prefix.status === 'active' ? 'var(--success)' : 
                           prefix.status === 'deprecated' ? 'var(--warning)' : 'var(--muted)';
        const statusIcon = prefix.status === 'active' ? '✓' : 
                          prefix.status === 'deprecated' ? '⚠' : '📁';
        
        return `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px; background: var(--panel-2); ${prefix.status !== 'active' ? 'opacity: 0.8;' : ''}">
          <div>
            <div style="font-weight: 600; color: var(--text); display: flex; align-items: center; gap: 8px;">
              ${prefix.prefix}
              <span style="font-size: 0.8em; color: ${statusColor}; font-weight: normal;">
                ${statusIcon} ${prefix.status.toUpperCase()}
              </span>
            </div>
            <div style="font-size: 0.9em; color: var(--muted);">
              ${prefix.description} | Owner: ${prefix.owner}
            </div>
          </div>
          <div style="display: flex; gap: 8px;">
            <button class="btn" onclick="editPrefix('${prefix.id}')" style="font-size: 0.8em;">Edit</button>
            <button class="btn" onclick="deletePrefix('${prefix.id}', '${prefix.prefix}')" style="font-size: 0.8em; background: var(--err); color: white; border-color: var(--err);">Delete</button>
          </div>
        </div>
      `;
      }).join('');

      container.innerHTML = html;
    }

    function showCreatePrefixModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div>
          <h3>Create New Prefix</h3>
          
          <div style="margin-bottom: 16px;">
            <label>Prefix:</label>
            <input type="text" id="pfxPrefix" placeholder="e.g., dod" oninput="validatePrefix(this)" />
            <div id="prefixValidation" style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Lowercase letters and numbers only, start with letter, 2-20 characters
            </div>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Description:</label>
            <input type="text" id="pfxDescription" placeholder="e.g., Department of Defense" />
          </div>
          
          <div style="margin-bottom: 20px;">
            <label>Owner:</label>
            <input type="text" id="pfxOwner" placeholder="admin@organization.mil" />
          </div>
          
          <div class="button-group">
            <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="createPrefix()" style="background: var(--accent); color: white; border-color: var(--accent);">Create</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }


    function validatePrefix(input) {
      const prefix = input.value.trim();
      const validation = document.getElementById('prefixValidation');
      
      if (!prefix) {
        validation.textContent = 'Lowercase letters and numbers only, start with letter, 2-20 characters';
        validation.style.color = 'var(--muted)';
        return;
      }
      
      const isValid = /^[a-z][a-z0-9]{1,19}$/.test(prefix);
      if (isValid) {
        validation.textContent = '✓ Valid prefix format';
        validation.style.color = 'var(--success)';
      } else {
        validation.textContent = '✗ Invalid format - lowercase letters and numbers only, start with letter, 2-20 characters';
        validation.style.color = 'var(--err)';
      }
    }

    async function createPrefix() {
      try {
        const prefix = document.getElementById('pfxPrefix').value.trim();
        const description = document.getElementById('pfxDescription').value.trim();
        const owner = document.getElementById('pfxOwner').value.trim();

        if (!prefix || !description || !owner) {
          alert('Please fill in all fields');
          return;
        }

        // Validate prefix format
        if (!/^[a-z][a-z0-9]{1,19}$/.test(prefix)) {
          alert('Invalid prefix format - lowercase letters and numbers only, start with letter, 2-20 characters');
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }

        const response = await fetch('/api/admin/prefixes/', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            prefix,
            description,
            owner
          })
        });

        if (response.ok) {
          alert('Prefix created successfully');
          document.querySelector('.modal').remove();
          loadPrefixes();
        } else {
          const error = await response.json();
          alert(`Error creating prefix: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error creating prefix:', error);
        alert('Error creating prefix: ' + error.message);
      }
    }

    function showEditPrefixModal(prefix) {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div>
          <h3>Edit Prefix: ${prefix.prefix}</h3>
          
          <div style="margin-bottom: 16px;">
            <label>Prefix:</label>
            <input type="text" id="editPfxPrefix" value="${prefix.prefix}" readonly style="background: var(--muted); color: var(--text-muted);" />
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Prefix cannot be changed after creation
            </div>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Description:</label>
            <input type="text" id="editPfxDescription" value="${prefix.description}" placeholder="e.g., Department of Defense" />
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Owner:</label>
            <input type="text" id="editPfxOwner" value="${prefix.owner}" placeholder="admin@organization.mil" />
          </div>
          
          <div style="margin-bottom: 20px;">
            <label>Status:</label>
            <select id="editPfxStatus" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);">
              <option value="active" ${prefix.status === 'active' ? 'selected' : ''}>Active</option>
              <option value="deprecated" ${prefix.status === 'deprecated' ? 'selected' : ''}>Deprecated</option>
              <option value="archived" ${prefix.status === 'archived' ? 'selected' : ''}>Archived</option>
            </select>
          </div>
          
          <div class="button-group">
            <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="updatePrefix('${prefix.id}')" style="background: var(--accent); color: white; border-color: var(--accent);">Update</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }

    async function updatePrefix(prefixId) {
      try {
        const description = document.getElementById('editPfxDescription').value.trim();
        const owner = document.getElementById('editPfxOwner').value.trim();
        const status = document.getElementById('editPfxStatus').value;

        if (!description || !owner) {
          alert('Please fill in all fields');
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }

        const response = await fetch(`/api/admin/prefixes/${prefixId}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            description,
            owner,
            status
          })
        });

        if (response.ok) {
          alert('Prefix updated successfully');
          document.querySelector('.modal').remove();
          loadPrefixes();
        } else {
          const error = await response.json();
          alert(`Error updating prefix: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error updating prefix:', error);
        alert('Error updating prefix: ' + error.message);
      }
    }

    async function editPrefix(prefixId) {
      try {
        // First, get the current prefix data
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/admin/prefixes/?status_filter=all`, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        
        if (!response.ok) {
          throw new Error('Failed to load prefixes');
        }
        
        const prefixes = await response.json();
        const prefix = prefixes.find(p => p.id === prefixId);
        
        if (!prefix) {
          alert('Prefix not found');
          return;
        }
        
        // Show edit modal
        showEditPrefixModal(prefix);
        
      } catch (error) {
        console.error('Error loading prefix for edit:', error);
        alert('Error loading prefix: ' + error.message);
      }
    }

    async function deletePrefix(prefixId, prefixName) {
      try {
        if (!confirm(`Are you sure you want to delete the prefix "${prefixName}"?\n\nThis action cannot be undone.`)) {
          return;
        }

        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/admin/prefixes/${prefixId}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          alert(`Prefix "${prefixName}" deleted successfully.`);
          loadPrefixes();
        } else {
          const error = await response.json();
          alert(`Error deleting prefix: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error deleting prefix:', error);
        alert('Error deleting prefix: ' + error.message);
      }
    }

    // Load prefixes for namespace creation dropdown
    async function loadPrefixesForNamespace(selectElement) {
      try {
        const response = await fetch('/api/admin/prefixes/');
        if (response.ok) {
          const prefixes = await response.json();
          
          selectElement.innerHTML = '<option value="">Select a prefix...</option>' +
            prefixes.map(pfx => `<option value="${pfx.prefix}">${pfx.prefix} - ${pfx.description}</option>`).join('');
        } else {
          selectElement.innerHTML = '<option value="">Error loading prefixes</option>';
        }
      } catch (error) {
        console.error('Error loading prefixes:', error);
        selectElement.innerHTML = '<option value="">Error loading prefixes</option>';
      }
    }

    async function loadPrefixesForNamespaceSelector() {
      try {
        const response = await fetch('/api/admin/prefixes/?status_filter=active');
        if (response.ok) {
          const prefixes = await response.json();
          const selector = document.getElementById('nsPrefixSelector');
          
          if (prefixes.length === 0) {
            selector.innerHTML = '<div style="text-align: center; color: var(--muted);">No active prefixes found. Create some prefixes first.</div>';
            return;
          }
          
          const html = prefixes.map(prefix => `
            <div id="prefix-${prefix.prefix}" style="display: flex; align-items: flex-start; margin: 6px 0; padding: 8px; border-radius: 4px; background: var(--panel); border: 1px solid var(--border);">
              <input type="checkbox" value="${prefix.prefix}" onchange="updateSelectedNsPrefixes()" style="margin-right: 12px; margin-top: 2px; flex-shrink: 0; width: 16px; height: 16px;">
              <div style="flex: 1; min-width: 0;">
                <div style="font-weight: 600; color: var(--text); margin-bottom: 2px; font-size: 14px;">
                  ${prefix.prefix}
                  <span id="order-${prefix.prefix}" style="margin-left: 8px; font-size: 12px; color: var(--accent); font-weight: bold;"></span>
                </div>
                <div style="color: var(--muted); font-size: 12px; line-height: 1.3;">${prefix.description}</div>
              </div>
            </div>
          `).join('');
          
          selector.innerHTML = html;
        } else {
          document.getElementById('nsPrefixSelector').innerHTML = '<div style="text-align: center; color: var(--err);">Error loading prefixes</div>';
        }
      } catch (error) {
        console.error('Error loading active prefixes:', error);
        document.getElementById('nsPrefixSelector').innerHTML = '<div style="text-align: center; color: var(--err);">Error loading prefixes</div>';
      }
    }

    // Track selection order
    let selectedPrefixOrder = [];

    function updateSelectedNsPrefixes() {
      const checkboxes = document.querySelectorAll('#nsPrefixSelector input[type="checkbox"]');
      const selectedPrefixes = [];
      
      // Maintain selection order by checking which were just checked/unchecked
      checkboxes.forEach(checkbox => {
        if (checkbox.checked && !selectedPrefixOrder.includes(checkbox.value)) {
          // Newly selected - add to end
          selectedPrefixOrder.push(checkbox.value);
        } else if (!checkbox.checked && selectedPrefixOrder.includes(checkbox.value)) {
          // Newly unchecked - remove from order
          selectedPrefixOrder = selectedPrefixOrder.filter(p => p !== checkbox.value);
        }
      });
      
      // Update order indicators
      checkboxes.forEach(checkbox => {
        const orderSpan = document.getElementById(`order-${checkbox.value}`);
        if (orderSpan) {
          if (checkbox.checked) {
            const orderIndex = selectedPrefixOrder.indexOf(checkbox.value) + 1;
            orderSpan.textContent = `#${orderIndex}`;
            orderSpan.style.color = 'var(--accent)';
          } else {
            orderSpan.textContent = '';
          }
        }
      });
      
      // Update display
      const selectedList = document.getElementById('selectedNsPrefixList');
      
      if (selectedPrefixOrder.length === 0) {
        selectedList.textContent = 'None';
        selectedList.style.color = 'var(--muted)';
      } else {
        selectedList.textContent = selectedPrefixOrder.join(' / ');
        selectedList.style.color = 'var(--success)';
      }
      
      // Update namespace fields when selection changes
      updateNamespaceFields();
    }

    // Make namespace functions globally available
    window.loadNamespaces = loadNamespaces;
    window.showCreateNamespaceModal = showCreateNamespaceModal;
    window.createNamespace = createNamespace;
    window.loadPrefixesForNamespaceSelector = loadPrefixesForNamespaceSelector;
    window.updateSelectedNsPrefixes = updateSelectedNsPrefixes;
    window.viewNamespaceDetails = viewNamespaceDetails;
    window.editNamespace = editNamespace;
    window.updateNamespace = updateNamespace;
    window.updateNamespaceFields = updateNamespaceFields;
    window.deleteNamespace = deleteNamespace;


    function showCreateProjectModal() {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.8); display: flex; align-items: center; 
        justify-content: center; z-index: 1000;
      `;
      
      modal.innerHTML = `
        <div>
          <h3>Create New Project</h3>
          
          <div style="margin-bottom: 16px;">
            <label>Project Name:</label>
            <input type="text" id="projectName" placeholder="e.g., f35-avionics" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);" />
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Alphanumeric characters, hyphens, and underscores only
            </div>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Namespace:</label>
            <select id="projectNamespace" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);">
              <option value="">Loading namespaces...</option>
            </select>
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Select from available released namespaces
            </div>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Domain:</label>
            <select id="projectDomain" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);">
              <option value="">Loading domains...</option>
            </select>
            <div style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Select the functional domain for this project
            </div>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Description (optional):</label>
            <textarea id="projectDescription" placeholder="Brief description of the project..." style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text); height: 80px; resize: vertical;"></textarea>
          </div>
          
          <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--panel-2); color: var(--text); border-color: var(--border);">Cancel</button>
            <button class="btn" onclick="createProject()" style="background: var(--accent); color: white; border-color: var(--accent);">Create Project</button>
          </div>
        </div>
      `;
      
      modal.className = 'modal';
      document.body.appendChild(modal);
      
      // Load released namespaces and active domains
      loadReleasedNamespaces();
      loadActiveDomains();
    }

    async function loadReleasedNamespaces() {
      try {
        console.log('🔧 Loading released namespaces...');
        const response = await fetch('/api/namespaces/released');
        
        if (response.ok) {
          const namespaces = await response.json();
          console.log('🔧 Loaded namespaces:', namespaces);
          const select = document.getElementById('projectNamespace');
          
          if (namespaces.length === 0) {
            select.innerHTML = '<option value="">No released namespaces available</option>';
            return;
          }
          
          select.innerHTML = '<option value="">Select a namespace...</option>' +
            namespaces.map(ns => `<option value="${ns.id}">${ns.path} - ${ns.name}</option>`).join('');
        } else {
          document.getElementById('projectNamespace').innerHTML = '<option value="">Error loading namespaces</option>';
        }
      } catch (error) {
        console.error('Error loading released namespaces:', error);
        document.getElementById('projectNamespace').innerHTML = '<option value="">Error loading namespaces</option>';
      }
    }

    async function loadActiveDomains() {
      try {
        console.log('🔧 Loading active domains...');
        const response = await fetch('/api/domains/active');
        
        if (response.ok) {
          const domains = await response.json();
          console.log('🔧 Loaded domains:', domains);
          const select = document.getElementById('projectDomain');
          
          if (domains.length === 0) {
            select.innerHTML = '<option value="">No domains available</option>';
            return;
          }
          
          select.innerHTML = '<option value="">Select a domain...</option>' +
            domains.map(domain => `<option value="${domain.domain}">${domain.domain} - ${domain.description}</option>`).join('');
        } else {
          document.getElementById('projectDomain').innerHTML = '<option value="">Error loading domains</option>';
        }
      } catch (error) {
        console.error('Error loading active domains:', error);
        document.getElementById('projectDomain').innerHTML = '<option value="">Error loading domains</option>';
      }
    }

    async function createProject() {
      try {
        const name = document.getElementById('projectName').value.trim();
        const namespaceId = document.getElementById('projectNamespace').value;
        const domain = document.getElementById('projectDomain').value;
        const description = document.getElementById('projectDescription').value.trim();

        if (!name || !namespaceId) {
          alert('Please fill in project name and select a namespace');
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }

        const requestData = {
          name,
          namespace_id: namespaceId,
          domain: domain || null,
          description: description || null
        };
        
        console.log('🔧 Creating project with data:', requestData);
        console.log('🔧 Token:', token ? 'Present' : 'Missing');

        const response = await fetch('/api/projects', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestData)
        });

        if (response.ok) {
          const newProject = await response.json();
          document.querySelector('.modal').remove();
          
          // Reload and select the newly created project using the old API format
          const pr = await fetch('/api/projects', { headers: { Authorization: 'Bearer ' + token }}).then(r=>r.json()).catch(()=>({projects:[]}));
          const raw = pr.projects || [];
          const list = raw.map(p => ({ id: p.id || p.project_id || p.projectId, name: p.name || p.project_name || 'Project' })).filter(p => !!p.id);
          const sel = qs('#projectSelect2');
          if (sel && list.length) {
            sel.innerHTML = list.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
            const pid = newProject.id || newProject.project_id || list[list.length - 1].id;
            sel.value = pid;
            try { 
              localStorage.setItem('active_project_id', pid);
              updateURL(pid); // Update URL with new project
            } catch(_) {}
            sel.disabled = false;
            // Save current ontology canvas before switching projects
            try { if (ontoState && ontoState.cy && activeOntologyIri) saveGraphToLocal(activeOntologyIri); } catch(_) {}
            const selected = list.find(p => p.id === pid) || list[list.length - 1];
            await renderTree(selected);
            updateNamespaceDisplay(pid);
            // Update project info page if it's active
            if (document.querySelector('#wb-project.workbench.active')) {
              loadProjectInfo();
            }
          }
          
          alert('Project created successfully!');
        } else {
          const error = await response.json();
          console.error('🔧 Backend error response:', error);
          console.error('🔧 Response status:', response.status);
          alert(`Error creating project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error creating project:', error);
        alert('Error creating project: ' + error.message);
      }
    }

    // Update namespace display in bottom toolbar
    async function updateNamespaceDisplay(projectId) {
      const namespaceElement = document.getElementById('currentNamespace');
      if (!namespaceElement) return;
      
      console.log('🔧 Updating namespace display for project:', projectId);
      
      if (!projectId) {
        namespaceElement.textContent = 'No project selected';
        return;
      }
      
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          namespaceElement.textContent = 'Project selected (no auth)';
          return;
        }
        
        // Get project with namespace in one query
        const response = await fetch(`/api/projects/${projectId}/namespace`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('🔧 Project namespace data:', data);
          namespaceElement.textContent = `${data.name} → ${data.namespace_path}`;
          namespaceElement.title = `Project: ${data.name} in namespace: ${data.namespace_path}`;
        } else {
          // Fallback: just show project name
          namespaceElement.textContent = `Project → unknown namespace`;
        }
      } catch (error) {
        console.error('🔧 Error updating namespace display:', error);
        namespaceElement.textContent = 'Error loading namespace';
      }
    }

    // Load current project's namespace for ontology creation
    async function loadCurrentProjectNamespace(displayElement) {
      if (!displayElement) return;
      
      try {
        const currentProjectId = localStorage.getItem('active_project_id');
        if (!currentProjectId) {
          displayElement.textContent = 'No project selected - select a project first';
          displayElement.style.color = 'var(--warning)';
          return;
        }
        
        const token = localStorage.getItem('odras_token');
        if (!token) {
          displayElement.textContent = 'Authentication required';
          displayElement.style.color = 'var(--err)';
          return;
        }
        
        // Get project namespace info
        const response = await fetch(`/api/projects/${currentProjectId}/namespace`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.namespace_path && data.namespace_path !== 'no namespace') {
            displayElement.textContent = `${data.namespace_path}/${data.name}`;
            displayElement.style.color = 'var(--text)';
            displayElement.title = `Project: ${data.name} in namespace: ${data.namespace_path}`;
          } else {
            displayElement.textContent = 'Project has no namespace - assign one first';
            displayElement.style.color = 'var(--warning)';
          }
        } else {
          displayElement.textContent = 'Error loading project namespace';
          displayElement.style.color = 'var(--err)';
        }
      } catch (error) {
        console.error('Error loading project namespace:', error);
        displayElement.textContent = 'Error loading namespace';
        displayElement.style.color = 'var(--err)';
      }
    }

    // Make project functions globally available
    window.showCreateProjectModal = showCreateProjectModal;
    window.createProject = createProject;
    window.loadReleasedNamespaces = loadReleasedNamespaces;
    window.loadActiveDomains = loadActiveDomains;
    window.updateNamespaceDisplay = updateNamespaceDisplay;
    window.loadCurrentProjectNamespace = loadCurrentProjectNamespace;
    window.createSimpleOntology = createSimpleOntology;

    // Project Information Functions
    async function loadProjectInfo() {
      const projectInfoCard = document.getElementById('projectInfoCard');
      if (!projectInfoCard) return;
      
      const currentProjectId = localStorage.getItem('active_project_id');
      if (!currentProjectId) {
        projectInfoCard.innerHTML = `
          <div style="text-align: center; color: var(--muted);">
            <h3>No Project Selected</h3>
            <p>Select a project from the dropdown or create a new one to view project information.</p>
          </div>
        `;
        return;
      }
      
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          projectInfoCard.innerHTML = `
            <div style="text-align: center; color: var(--warning);">
              <h3>Authentication Required</h3>
              <p>Please log in to view project information.</p>
            </div>
          `;
          return;
        }
        
        projectInfoCard.innerHTML = `
          <div style="text-align: center; color: var(--muted);">
            <div>Loading project information...</div>
          </div>
        `;
        
        // Get project details with namespace info
        const response = await fetch(`/api/projects/${currentProjectId}/namespace`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (response.status === 403) {
          // Project access denied - clear the project selection and show message
          console.warn('Project access denied, clearing project selection');
          try {
            localStorage.removeItem('active_project_id');
          } catch (error) {
            console.warn('Failed to clear project selection:', error);
          }
          
          projectInfoCard.innerHTML = `
            <div style="text-align: center; color: var(--warning);">
              <h3>Project Access Denied</h3>
              <p>The selected project is not accessible with your current permissions.</p>
              <p>Please select a different project from the dropdown.</p>
            </div>
          `;
          return;
        }
        
        if (response.ok) {
          const projectData = await response.json();
          
          // Get additional project details from main API
          const projectsResponse = await fetch('/api/projects', {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          
          let fullProjectData = projectData;
          if (projectsResponse.ok) {
            const projectsList = await projectsResponse.json();
            const projects = projectsList.projects || [];
            const currentProject = projects.find(p => (p.id || p.project_id) === currentProjectId);
            if (currentProject) {
              fullProjectData = { ...projectData, ...currentProject };
            }
          }
          
          renderProjectInfo(fullProjectData);
        } else {
          projectInfoCard.innerHTML = `
            <div style="text-align: center; color: var(--err);">
              <h3>Error Loading Project</h3>
              <p>Could not load project information. Please try again.</p>
            </div>
          `;
        }
      } catch (error) {
        console.error('Error loading project info:', error);
        projectInfoCard.innerHTML = `
          <div style="text-align: center; color: var(--err);">
            <h3>Error</h3>
            <p>Failed to load project information: ${error.message}</p>
          </div>
        `;
      }
    }

    function renderProjectInfo(projectData) {
      const projectInfoCard = document.getElementById('projectInfoCard');
      if (!projectInfoCard) return;
      
      const createdDate = projectData.created_at ? new Date(projectData.created_at).toLocaleDateString() : 'Unknown';
      const updatedDate = projectData.updated_at ? new Date(projectData.updated_at).toLocaleDateString() : 'Unknown';
      const createdBy = projectData.created_by_username || projectData.created_by || 'Unknown';
      const projectId = projectData.project_id || projectData.id;
      
      projectInfoCard.innerHTML = `
        <div style="margin-bottom: 32px;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
            <h2 style="margin: 0; color: var(--text); font-size: 1.75rem; font-weight: 600;">
              ${projectData.project_name || projectData.name || 'Project'}
            </h2>
            <span style="font-size: 14px; padding: 6px 12px; background: var(--accent); color: white; border-radius: 16px; font-weight: 500; text-transform: capitalize;">
              ${projectData.status || 'active'}
            </span>
          </div>
          ${projectData.description ? `
            <div style="background: var(--panel-2); padding: 16px; border-radius: 8px; border-left: 4px solid var(--accent);">
              <p style="color: var(--text); margin: 0; line-height: 1.5;">${projectData.description}</p>
            </div>
          ` : ''}
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 32px;">
          <div style="background: var(--panel-2); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
            <h3 style="margin: 0 0 16px 0; color: var(--text); font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; gap: 8px;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                <polyline points="9,22 9,12 15,12 15,22"/>
              </svg>
              Organization
            </h3>
            <div style="display: grid; gap: 12px;">
              <div>
                <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Namespace</label>
                <div style="font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; color: var(--accent); font-weight: 500; background: var(--panel); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border);">
                  ${projectData.namespace_path || 'No namespace assigned'}
                </div>
              </div>
              ${projectData.domain ? `
                <div>
                  <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Domain</label>
                  <div style="color: var(--text); font-weight: 500; background: var(--panel); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border);">
                    ${projectData.domain}
                  </div>
                </div>
              ` : ''}
              <div>
                <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Project ID</label>
                <div style="font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; color: var(--text); font-size: 14px; background: var(--panel); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border); word-break: break-all;">
                  ${projectId}
                </div>
              </div>
            </div>
          </div>
          
          <div style="background: var(--panel-2); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
            <h3 style="margin: 0 0 16px 0; color: var(--text); font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; gap: 8px;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="16" y1="13" x2="8" y2="13"/>
                <line x1="16" y1="17" x2="8" y2="17"/>
                <polyline points="10,9 9,9 8,9"/>
              </svg>
              Details
            </h3>
            <div style="display: grid; gap: 12px;">
              <div>
                <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Created</label>
                <div style="color: var(--text); font-weight: 500;">${createdDate}</div>
              </div>
              <div>
                <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Last Updated</label>
                <div style="color: var(--text); font-weight: 500;">${updatedDate}</div>
              </div>
              <div>
                <label style="display: block; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Created By</label>
                <div style="color: var(--text); font-weight: 500; display: flex; align-items: center; gap: 8px;">
                  <span style="width: 32px; height: 32px; background: var(--accent); color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 14px;">
                    ${createdBy.charAt(0).toUpperCase()}
                  </span>
                  ${createdBy}
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div style="margin-bottom: 32px;">
          <h3 style="margin: 0 0 16px 0; color: var(--text); font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; gap: 8px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
            </svg>
            Project URI
          </h3>
          <div style="background: var(--panel-2); padding: 16px; border-radius: 12px; border: 1px solid var(--border);">
            <code style="font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; color: var(--accent); word-break: break-all; font-size: 14px; line-height: 1.4;">
              ${projectData.namespace_path ? `http://${projectData.namespace_path}/${projectId}/` : 'No namespace assigned'}
            </code>
          </div>
          <div style="font-size: 13px; color: var(--muted); margin-top: 8px; display: flex; align-items: center; gap: 6px;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"/>
              <path d="M12 16v-4"/>
              <path d="M12 8h.01"/>
            </svg>
            Base URI for all project resources (ontologies, files, knowledge assets)
          </div>
        </div>
        
        <div style="display: flex; gap: 12px; justify-content: flex-end; padding-top: 20px; border-top: 1px solid var(--border);">
          <button class="btn" onclick="editProjectInfo('${projectId}')" style="background: var(--accent); color: white; border-color: var(--accent); padding: 12px 24px; font-weight: 500; display: flex; align-items: center; gap: 8px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
              <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
              <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg>
            Edit Project
          </button>
          <button class="btn" onclick="showProjectActions('${projectId}')" style="background: var(--panel-2); color: var(--text); border-color: var(--border); padding: 12px 24px; font-weight: 500; display: flex; align-items: center; gap: 8px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="3"/>
              <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"/>
            </svg>
            Actions
          </button>
        </div>
      `;
    }

    async function editProjectInfo(projectId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('Please log in to edit projects');
          return;
        }
        
        // Get current project data
        const response = await fetch(`/api/projects/${projectId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!response.ok) {
          alert('Error loading project data');
          return;
        }
        
        const data = await response.json();
        const project = data.project;
        
        // Create edit modal
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
              <h3>Edit Project</h3>
              <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
            </div>
            <div class="modal-body">
              <form id="editProjectForm">
                <div class="form-group">
                  <label for="editProjectName">Project Name *</label>
                  <input type="text" id="editProjectName" value="${project.name || ''}" required>
                </div>
                
                <div class="form-group">
                  <label for="editProjectDescription">Description</label>
                  <textarea id="editProjectDescription" rows="3">${project.description || ''}</textarea>
                </div>
                
                <div class="form-group">
                  <label for="editProjectDomain">Domain</label>
                  <select id="editProjectDomain">
                    <option value="">Select a domain...</option>
                  </select>
                </div>
                
                <div class="form-group">
                  <label for="editProjectNamespace">Namespace</label>
                  <select id="editProjectNamespace">
                    <option value="">Select a namespace...</option>
                  </select>
                </div>
              </form>
            </div>
            <div class="modal-footer">
              <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--panel-2); color: var(--text); border-color: var(--border);">Cancel</button>
              <button class="btn" onclick="saveProjectEdit('${projectId}')" style="background: var(--accent); color: white; border-color: var(--accent);">Save Changes</button>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
        
        // Load domains and namespaces
        await loadDomainsForEdit(project.domain);
        await loadNamespacesForEdit(project.namespace_id);
        
      } catch (error) {
        console.error('Error opening edit modal:', error);
        alert('Error opening edit modal');
      }
    }

    async function loadDomainsForEdit(currentDomain) {
      try {
        console.log('🔧 Loading domains for edit...');
        const response = await fetch('/api/domains/active');
        
        if (response.ok) {
          const domains = await response.json();
          console.log('🔧 Loaded domains for edit:', domains);
          const select = document.getElementById('editProjectDomain');
          
          if (domains.length === 0) {
            select.innerHTML = '<option value="">No domains available</option>';
            return;
          }
          
          select.innerHTML = '<option value="">Select a domain...</option>' +
            domains.map(domain => {
              const selected = domain.domain === currentDomain ? ' selected' : '';
              return `<option value="${domain.domain}"${selected}>${domain.domain} - ${domain.description}</option>`;
            }).join('');
        } else {
          document.getElementById('editProjectDomain').innerHTML = '<option value="">Error loading domains</option>';
        }
      } catch (error) {
        console.error('Error loading domains for edit:', error);
        document.getElementById('editProjectDomain').innerHTML = '<option value="">Error loading domains</option>';
      }
    }

    async function loadNamespacesForEdit(currentNamespaceId) {
      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch('/api/namespaces/released', {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        const namespaces = await response.json();
        
        const select = document.getElementById('editProjectNamespace');
        select.innerHTML = '<option value="">Select a namespace...</option>';
        
        namespaces.forEach(ns => {
          const option = document.createElement('option');
          option.value = ns.id;
          option.textContent = `${ns.path} (${ns.name})`;
          if (ns.id === currentNamespaceId) {
            option.selected = true;
          }
          select.appendChild(option);
        });
      } catch (error) {
        console.error('Error loading namespaces:', error);
      }
    }

    async function saveProjectEdit(projectId) {
      try {
        const token = localStorage.getItem('odras_token');
        const form = document.getElementById('editProjectForm');
        
        const updateData = {
          name: document.getElementById('editProjectName').value.trim(),
          description: document.getElementById('editProjectDescription').value.trim() || null,
          domain: document.getElementById('editProjectDomain').value || null,
          namespace_id: document.getElementById('editProjectNamespace').value || null
        };
        
        if (!updateData.name) {
          alert('Project name is required');
          return;
        }
        
        const response = await fetch(`/api/projects/${projectId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(updateData)
        });
        
        if (response.ok) {
          // Close modal
          document.querySelector('.modal').remove();
          
          // Reload project info
          loadProjectInfo();
          
          // Refresh project list and tree to reflect updated name/details
          try { await loadProjects(); } catch(_) {}

          // Update namespace display
          updateNamespaceDisplay(projectId);
          
          // Verify via API that changes persisted
          try {
            const verifyRes = await fetch(`/api/projects/${projectId}`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            if (verifyRes.ok) {
              const verifyJson = await verifyRes.json();
              const serverProject = verifyJson.project || verifyJson;
              const mismatches = [];
              const expectedName = updateData.name;
              const serverName = (serverProject.name || serverProject.project_name || '').trim();
              if (serverName !== expectedName) mismatches.push(`name: expected "${expectedName}", got "${serverName}"`);
              const expectedDesc = updateData.description || null;
              const serverDesc = (serverProject.description === '' ? null : serverProject.description);
              if ((serverDesc || null) !== expectedDesc) mismatches.push('description');
              const expectedDomain = updateData.domain || null;
              const serverDomain = serverProject.domain || null;
              if ((serverDomain || null) !== expectedDomain) mismatches.push('domain');
              const expectedNs = updateData.namespace_id ? String(updateData.namespace_id) : null;
              const serverNs = serverProject.namespace_id != null ? String(serverProject.namespace_id) : null;
              if (serverNs !== expectedNs) mismatches.push('namespace_id');
              if (mismatches.length) {
                alert('Project saved but verification mismatch for: ' + mismatches.join(', '));
              }
            } else {
              const t = await verifyRes.text().catch(()=>String(verifyRes.status));
              alert('Project saved, but verification request failed: ' + t);
            }
          } catch (_) {
            // Non-fatal verification error
          }

          alert('Project updated successfully!');
        } else {
          const error = await response.json();
          alert(`Error updating project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error saving project edit:', error);
        alert('Error saving project changes');
      }
    }

    async function showProjectActions(projectId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('Please log in to perform project actions');
          return;
        }
        
        // Create actions modal
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
              <h3>Project Actions</h3>
              <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
            </div>
            <div class="modal-body">
              <div style="display: grid; gap: 12px;">
                <button class="btn" onclick="archiveProject('${projectId}')" style="background: var(--warning); color: white; border-color: var(--warning); width: 100%; text-align: left; padding: 12px; display: flex; align-items: flex-start; gap: 12px;">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
                    <polyline points="21,8 21,21 3,21 3,8"/>
                    <rect x="1" y="3" width="22" height="5"/>
                    <line x1="10" y1="12" x2="14" y2="12"/>
                  </svg>
                  <div>
                    <strong>Archive Project</strong><br>
                    <small>Hide project from active list (can be restored later)</small>
                  </div>
                </button>
                
                <button class="btn" onclick="exportProject('${projectId}')" style="background: var(--accent); color: white; border-color: var(--accent); width: 100%; text-align: left; padding: 12px; display: flex; align-items: flex-start; gap: 12px;">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7,10 12,15 17,10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                  </svg>
                  <div>
                    <strong>Export Project</strong><br>
                    <small>Download project data and ontologies</small>
                  </div>
                </button>
                
                <button class="btn" onclick="duplicateProject('${projectId}')" style="background: var(--panel-2); color: var(--text); border-color: var(--border); width: 100%; text-align: left; padding: 12px; display: flex; align-items: flex-start; gap: 12px;">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                  </svg>
                  <div>
                    <strong>Duplicate Project</strong><br>
                    <small>Create a copy of this project</small>
                  </div>
                </button>
                
                <button class="btn" onclick="deleteProject('${projectId}')" style="background: var(--err); color: white; border-color: var(--err); width: 100%; text-align: left; padding: 12px; display: flex; align-items: flex-start; gap: 12px;">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
                    <polyline points="3,6 5,6 21,6"/>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    <line x1="10" y1="11" x2="10" y2="17"/>
                    <line x1="14" y1="11" x2="14" y2="17"/>
                  </svg>
                  <div>
                    <strong>Delete Project</strong><br>
                    <small>Permanently delete project (cannot be undone)</small>
                  </div>
                </button>
              </div>
            </div>
            <div class="modal-footer">
              <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--panel-2); color: var(--text); border-color: var(--border);">Close</button>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
        
      } catch (error) {
        console.error('Error opening actions modal:', error);
        alert('Error opening project actions');
      }
    }

    async function archiveProject(projectId) {
      if (!confirm('Are you sure you want to archive this project? It will be hidden from your active projects but can be restored later.')) {
        return;
      }
      
      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/projects/${projectId}/archive`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (response.ok) {
          document.querySelector('.modal').remove();
          alert('Project archived successfully!');
          
          // Reload projects and switch to a different one if needed
          const currentProjectId = localStorage.getItem('active_project_id');
          if (currentProjectId === projectId) {
            // Switch to first available project
            const projectsResponse = await fetch('/api/projects', {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            const projectsData = await projectsResponse.json();
            const projects = projectsData.projects || [];
            
            if (projects.length > 0) {
              const newProject = projects[0];
              localStorage.setItem('active_project_id', newProject.id || newProject.project_id);
              document.getElementById('projectSelect2').value = newProject.id || newProject.project_id;
              await renderTree(newProject);
              updateNamespaceDisplay(newProject.id || newProject.project_id);
              if (document.querySelector('#wb-project.workbench.active')) {
                loadProjectInfo();
              }
            } else {
              // No projects left, clear selection
              localStorage.removeItem('active_project_id');
              document.getElementById('projectSelect2').value = '';
              document.getElementById('projectSelect2').innerHTML = '<option value="">No projects</option>';
            }
          }
        } else {
          const error = await response.json();
          alert(`Error archiving project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error archiving project:', error);
        alert('Error archiving project');
      }
    }

    async function exportProject(projectId) {
      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/projects/${projectId}/export`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (response.ok) {
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `project-${projectId}-export.zip`;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
          
          document.querySelector('.modal').remove();
          alert('Project exported successfully!');
        } else {
          const error = await response.json();
          alert(`Error exporting project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error exporting project:', error);
        alert('Error exporting project');
      }
    }

    async function duplicateProject(projectId) {
      try {
        const token = localStorage.getItem('odras_token');
        
        // Get current project data
        const projectResponse = await fetch(`/api/projects/${projectId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!projectResponse.ok) {
          alert('Error loading project data for duplication');
          return;
        }
        
        const projectData = await projectResponse.json();
        const project = projectData.project;
        
        // Create duplicate with new name
        const duplicateData = {
          name: `${project.name} (Copy)`,
          description: project.description,
          namespace_id: project.namespace_id,
          domain: project.domain
        };
        
        const createResponse = await fetch('/api/projects', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(duplicateData)
        });
        
        if (createResponse.ok) {
          const newProjectData = await createResponse.json();
          const newProject = newProjectData.project;
          
          document.querySelector('.modal').remove();
          alert('Project duplicated successfully!');
          
          // Switch to the new project
          localStorage.setItem('active_project_id', newProject.project_id);
          document.getElementById('projectSelect2').value = newProject.project_id;
          await renderTree(newProject);
          updateNamespaceDisplay(newProject.project_id);
          if (document.querySelector('#wb-project.workbench.active')) {
            loadProjectInfo();
          }
        } else {
          const error = await createResponse.json();
          alert(`Error duplicating project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error duplicating project:', error);
        alert('Error duplicating project');
      }
    }

    async function deleteProject(projectId) {
      if (!confirm('⚠️ WARNING: This will permanently delete the project and cannot be undone!\n\nAre you absolutely sure you want to delete this project?')) {
        return;
      }
      
      if (!confirm('This is your final warning. The project will be permanently deleted. Continue?')) {
        return;
      }
      
      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/projects/${projectId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (response.ok) {
          document.querySelector('.modal').remove();
          alert('Project deleted successfully!');
          
          // Switch to a different project if needed
          const currentProjectId = localStorage.getItem('active_project_id');
          if (currentProjectId === projectId) {
            // Switch to first available project
            const projectsResponse = await fetch('/api/projects', {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            const projectsData = await projectsResponse.json();
            const projects = projectsData.projects || [];
            
            if (projects.length > 0) {
              const newProject = projects[0];
              localStorage.setItem('active_project_id', newProject.id || newProject.project_id);
              document.getElementById('projectSelect2').value = newProject.id || newProject.project_id;
              await renderTree(newProject);
              updateNamespaceDisplay(newProject.id || newProject.project_id);
              if (document.querySelector('#wb-project.workbench.active')) {
                loadProjectInfo();
              }
            } else {
              // No projects left, clear selection
              localStorage.removeItem('active_project_id');
              document.getElementById('projectSelect2').value = '';
              document.getElementById('projectSelect2').innerHTML = '<option value="">No projects</option>';
            }
          }
        } else {
          const error = await response.json();
          alert(`Error deleting project: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error deleting project:', error);
        alert('Error deleting project');
      }
    }

    // Make project info functions globally available
    window.loadProjectInfo = loadProjectInfo;
    window.renderProjectInfo = renderProjectInfo;
    window.editProjectInfo = editProjectInfo;
    window.showProjectActions = showProjectActions;
    window.saveProjectEdit = saveProjectEdit;
    window.archiveProject = archiveProject;
    window.exportProject = exportProject;
    window.duplicateProject = duplicateProject;
    window.deleteProject = deleteProject;

    // Domain Management Functions
    async function loadDomains() {
      console.log('🔄 Loading domains...');
      try {
        const response = await fetch('/api/admin/domains/?status_filter=all', {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('odras_token')}`
          }
        });
        if (response.ok) {
          const domains = await response.json();
          console.log('✅ Loaded domains:', domains.length);
          renderDomainList(domains);
        } else {
          console.error('Failed to load domains:', response.status, response.statusText);
          document.getElementById('domainList').innerHTML = 
            `<div style="color: var(--err); text-align: center;">Error loading domains: ${response.statusText}</div>`;
        }
      } catch (error) {
        console.error('Error loading domains:', error);
        document.getElementById('domainList').innerHTML = 
          `<div style="color: var(--err); text-align: center;">Error loading domains: ${error.message}</div>`;
      }
    }

    function renderDomainList(domains) {
      const container = document.getElementById('domainList');
      
      if (domains.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: var(--muted);">No domains found</div>';
        return;
      }

      const html = domains.map(domain => {
        const statusColor = domain.status === 'active' ? 'var(--success)' : 
                           domain.status === 'deprecated' ? 'var(--warning)' : 'var(--muted)';
        const statusIcon = domain.status === 'active' ? '✓' : 
                          domain.status === 'deprecated' ? '⚠' : '📁';
        
        return `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px; background: var(--panel-2); ${domain.status !== 'active' ? 'opacity: 0.8;' : ''}">
          <div>
            <div style="font-weight: 600; color: var(--text); display: flex; align-items: center; gap: 8px;">
              ${domain.domain}
              <span style="font-size: 0.8em; color: ${statusColor}; font-weight: normal;">
                ${statusIcon} ${domain.status.toUpperCase()}
              </span>
            </div>
            <div style="font-size: 0.9em; color: var(--muted);">
              ${domain.description} | Owner: ${domain.owner}
            </div>
          </div>
          <div style="display: flex; gap: 8px;">
            <button class="btn" onclick="editDomain('${domain.id}')" style="font-size: 0.8em;">Edit</button>
            <button class="btn" onclick="deleteDomain('${domain.id}', '${domain.domain}')" style="font-size: 0.8em; background: var(--err); color: white; border-color: var(--err);">Delete</button>
          </div>
        </div>
      `;
      }).join('');

      container.innerHTML = html;
    }

    function showCreateDomainModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div>
          <h3>Create New Domain</h3>
          
          <div style="margin-bottom: 16px;">
            <label>Domain:</label>
            <input type="text" id="dmDomain" placeholder="e.g., avionics" oninput="validateDomain(this)" />
            <div id="domainValidation" style="font-size: 0.8em; color: var(--muted); margin-top: 4px;">
              Lowercase letters, numbers, and hyphens only, start with letter, 2-50 characters
            </div>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label>Description:</label>
            <input type="text" id="dmDescription" placeholder="e.g., Aircraft electronics and flight systems" />
          </div>
          
          <div style="margin-bottom: 20px;">
            <label>Owner:</label>
            <input type="text" id="dmOwner" placeholder="admin@odras.local" />
          </div>
          
          <div class="button-group">
            <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="createDomain()" style="background: var(--accent); color: white; border-color: var(--accent);">Create</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }

    function validateDomain(input) {
      const domain = input.value.trim();
      const validation = document.getElementById('domainValidation');
      
      if (!domain) {
        validation.textContent = 'Lowercase letters, numbers, and hyphens only, start with letter, 2-50 characters';
        validation.style.color = 'var(--muted)';
        return;
      }
      
      const isValid = /^[a-z][a-z0-9-]{1,49}$/.test(domain);
      if (isValid) {
        validation.textContent = '✓ Valid domain format';
        validation.style.color = 'var(--success)';
      } else {
        validation.textContent = '✗ Invalid format - lowercase letters, numbers, and hyphens only, start with letter, 2-50 characters';
        validation.style.color = 'var(--err)';
      }
    }

    async function createDomain() {
      try {
        const domain = document.getElementById('dmDomain').value.trim();
        const description = document.getElementById('dmDescription').value.trim();
        const owner = document.getElementById('dmOwner').value.trim();

        if (!domain || !description || !owner) {
          alert('Please fill in all fields');
          return;
        }

        // Validate domain format
        if (!/^[a-z][a-z0-9-]{1,49}$/.test(domain)) {
          alert('Invalid domain format - lowercase letters, numbers, and hyphens only, start with letter, 2-50 characters');
          return;
        }

        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('No auth token found');
          return;
        }

        const response = await fetch('/api/admin/domains/', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            domain,
            description,
            owner
          })
        });

        if (response.ok) {
          alert('Domain created successfully');
          document.querySelector('.modal').remove();
          loadDomains();
        } else {
          const error = await response.json();
          alert(`Error creating domain: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error creating domain:', error);
        alert('Error creating domain: ' + error.message);
      }
    }

    async function editDomain(domainId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('Please log in to edit domains');
          return;
        }

        // Get current domain data
        const response = await fetch(`/api/admin/domains/${domainId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!response.ok) {
          alert('Error loading domain data');
          return;
        }
        
        const domain = await response.json();
        
        // Create edit modal
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
              <h3>Edit Domain</h3>
              <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
            </div>
            <div class="modal-body">
              <form id="editDomainForm">
                <div class="form-group">
                  <label for="editDomainName">Domain Name</label>
                  <input type="text" id="editDomainName" value="${domain.domain}" readonly style="background: var(--panel-2); color: var(--muted);">
                  <small style="color: var(--muted);">Domain name cannot be changed after creation</small>
                </div>
                
                <div class="form-group">
                  <label for="editDomainDescription">Description</label>
                  <textarea id="editDomainDescription" rows="3">${domain.description || ''}</textarea>
                </div>
                
                <div class="form-group">
                  <label for="editDomainOwner">Owner</label>
                  <input type="email" id="editDomainOwner" value="${domain.owner || ''}">
                </div>
                
                <div class="form-group">
                  <label for="editDomainStatus">Status</label>
                  <select id="editDomainStatus">
                    <option value="active" ${domain.status === 'active' ? 'selected' : ''}>Active</option>
                    <option value="deprecated" ${domain.status === 'deprecated' ? 'selected' : ''}>Deprecated</option>
                    <option value="archived" ${domain.status === 'archived' ? 'selected' : ''}>Archived</option>
                  </select>
                </div>
              </form>
            </div>
            <div class="modal-footer">
              <button class="btn" onclick="this.closest('.modal').remove()" style="background: var(--panel-2); color: var(--text); border-color: var(--border);">Cancel</button>
              <button class="btn" onclick="saveDomainEdit('${domainId}')" style="background: var(--accent); color: white; border-color: var(--accent);">Save Changes</button>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
        
      } catch (error) {
        console.error('Error opening edit modal:', error);
        alert('Error opening edit modal');
      }
    }

    async function saveDomainEdit(domainId) {
      try {
        const token = localStorage.getItem('odras_token');
        if (!token) {
          alert('Please log in to save domain changes');
          return;
        }
        
        const updateData = {
          description: document.getElementById('editDomainDescription').value.trim() || null,
          owner: document.getElementById('editDomainOwner').value.trim() || null,
          status: document.getElementById('editDomainStatus').value
        };
        
        if (!updateData.description) {
          alert('Description is required');
          return;
        }
        
        const response = await fetch(`/api/admin/domains/${domainId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(updateData)
        });
        
        if (response.ok) {
          // Close modal and refresh domain list
          document.querySelector('.modal').remove();
          loadDomains();
          alert('Domain updated successfully');
        } else {
          const error = await response.json();
          alert(`Error updating domain: ${error.detail || response.statusText}`);
        }
      } catch (error) {
        console.error('Error saving domain edit:', error);
        alert('Error saving domain changes');
      }
    }

    async function deleteDomain(domainId, domainName) {
      try {
        if (!confirm(`Are you sure you want to delete the domain "${domainName}"?\n\nThis action cannot be undone.`)) {
          return;
        }

        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/admin/domains/${domainId}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          alert(`Domain "${domainName}" deleted successfully.`);
          loadDomains();
        } else {
          const error = await response.json();
          alert(`Error deleting domain: ${error.detail || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error deleting domain:', error);
        alert('Error deleting domain: ' + error.message);
      }
    }

    // Make domain functions globally available
    window.loadDomains = loadDomains;
    window.showCreateDomainModal = showCreateDomainModal;
    window.createDomain = createDomain;
    window.editDomain = editDomain;
    window.saveDomainEdit = saveDomainEdit;
    window.deleteDomain = deleteDomain;
    window.validateDomain = validateDomain;

    // Make prefix functions globally available
    window.loadPrefixes = loadPrefixes;
    window.showCreatePrefixModal = showCreatePrefixModal;
    window.createPrefix = createPrefix;
    window.editPrefix = editPrefix;
    window.deletePrefix = deletePrefix;
    window.loadPrefixesForNamespace = loadPrefixesForNamespace;
    window.toggleSection = toggleSection;
    window.showEditPrefixModal = showEditPrefixModal;
    window.updatePrefix = updatePrefix;

    // User Management Functions
    async function loadUsers() {
      console.log('🔄 Loading users...');
      try {
        const token = localStorage.getItem('odras_token');
        const showInactive = document.getElementById('showInactiveUsers')?.checked || false;
        const url = `/api/users/?include_inactive=${showInactive}`;
        
        const response = await fetch(url, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        
        if (response.ok) {
          const users = await response.json();
          console.log('✅ Loaded users:', users.length);
          renderUserList(users);
        } else {
          console.error('Failed to load users:', response.status, response.statusText);
          document.getElementById('userList').innerHTML = 
            `<div style="color: var(--err); text-align: center;">Error loading users: ${response.statusText}</div>`;
        }
      } catch (error) {
        console.error('Error loading users:', error);
        document.getElementById('userList').innerHTML = 
          `<div style="color: var(--err); text-align: center;">Error loading users: ${error.message}</div>`;
      }
    }

    function renderUserList(users) {
      const container = document.getElementById('userList');
      
      if (users.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: var(--muted);">No users found</div>';
        return;
      }

      const html = users.map(user => {
        const statusColor = user.is_active ? 'var(--success)' : 'var(--err)';
        const statusText = user.is_active ? 'Active' : 'Inactive';
        const adminBadge = user.is_admin ? '<span style="background: var(--accent); color: white; padding: 2px 6px; border-radius: 4px; font-size: 12px; margin-left: 8px;">ADMIN</span>' : '';
        const createdDate = new Date(user.created_at).toLocaleDateString();
        
        return `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px; background: var(--bg);">
            <div style="flex: 1;">
              <div style="display: flex; align-items: center; margin-bottom: 4px;">
                <span style="font-weight: bold; color: var(--text);">${user.username}</span>
                ${adminBadge}
                <span style="width: 8px; height: 8px; border-radius: 50%; background: ${statusColor}; margin-left: 12px;"></span>
                <span style="color: ${statusColor}; margin-left: 4px; font-size: 14px;">${statusText}</span>
              </div>
              <div style="color: var(--muted); font-size: 14px;">
                <div>Display Name: ${user.display_name || 'Not set'}</div>
                <div>Created: ${createdDate}</div>
              </div>
            </div>
            <div style="display: flex; gap: 8px;">
              <button class="btn" onclick="editUser('${user.user_id}')" style="padding: 6px 12px; font-size: 12px;">Edit</button>
              <button class="btn" onclick="toggleUserStatus('${user.user_id}', ${user.is_active})" style="padding: 6px 12px; font-size: 12px; background: ${user.is_active ? 'var(--err)' : 'var(--success)'};">
                ${user.is_active ? 'Deactivate' : 'Activate'}
              </button>
            </div>
          </div>
        `;
      }).join('');

      container.innerHTML = html;
    }

    function showCreateUserModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.5); display: flex; align-items: center; 
        justify-content: center; z-index: 1000;
      `;
      
      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 24px; width: 400px; max-width: 90vw;">
          <h3 style="margin: 0 0 16px 0; color: var(--text);">Create New User</h3>
          
          <div style="display: grid; gap: 16px;">
            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">Username *</label>
              <input type="text" id="newUserUsername" placeholder="Enter username" 
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">Password *</label>
              <input type="password" id="newUserPassword" placeholder="Enter password (min 8 characters)" 
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">Display Name</label>
              <input type="text" id="newUserDisplayName" placeholder="Enter display name (optional)" 
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>
            
            <div style="display: flex; align-items: center; gap: 8px;">
              <input type="checkbox" id="newUserIsAdmin" style="margin: 0;">
              <label for="newUserIsAdmin" style="color: var(--text); margin: 0;">Admin privileges</label>
            </div>
          </div>
          
          <div style="display: flex; gap: 12px; margin-top: 20px; justify-content: flex-end;">
            <button class="btn" onclick="document.querySelector('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="createUser()" style="background: var(--accent);">Create User</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }

    async function createUser() {
      try {
        const username = document.getElementById('newUserUsername').value.trim();
        const password = document.getElementById('newUserPassword').value;
        const displayName = document.getElementById('newUserDisplayName').value.trim();
        const isAdmin = document.getElementById('newUserIsAdmin').checked;
        
        if (!username || !password) {
          alert('Username and password are required');
          return;
        }
        
        if (password.length < 8) {
          alert('Password must be at least 8 characters long');
          return;
        }
        
        const token = localStorage.getItem('odras_token');
        const response = await fetch('/api/users/', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            username: username,
            password: password,
            display_name: displayName || null,
            is_admin: isAdmin
          })
        });
        
        if (response.ok) {
          document.querySelector('.modal').remove();
          await loadUsers();
          alert('User created successfully!');
        } else {
          const error = await response.text();
          alert(`Error creating user: ${error}`);
        }
      } catch (error) {
        console.error('Error creating user:', error);
        alert(`Error creating user: ${error.message}`);
      }
    }

    function editUser(userId) {
      // For now, just show a simple edit modal
      // In a full implementation, you'd load user details and show an edit form
      const newDisplayName = prompt('Enter new display name:');
      if (newDisplayName !== null) {
        updateUser(userId, { display_name: newDisplayName });
      }
    }

    async function updateUser(userId, updates) {
      try {
        const token = localStorage.getItem('odras_token');
        const response = await fetch(`/api/users/${userId}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(updates)
        });
        
        if (response.ok) {
          await loadUsers();
          alert('User updated successfully!');
        } else {
          const error = await response.text();
          alert(`Error updating user: ${error}`);
        }
      } catch (error) {
        console.error('Error updating user:', error);
        alert(`Error updating user: ${error.message}`);
      }
    }

    async function toggleUserStatus(userId, currentStatus) {
      const action = currentStatus ? 'deactivate' : 'activate';
      const confirmMessage = `Are you sure you want to ${action} this user?`;
      
      if (!confirm(confirmMessage)) {
        return;
      }
      
      try {
        const token = localStorage.getItem('odras_token');
        const url = currentStatus ? `/api/users/${userId}` : `/api/users/${userId}/activate`;
        const method = currentStatus ? 'DELETE' : 'POST';
        
        const response = await fetch(url, {
          method: method,
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        
        if (response.ok) {
          await loadUsers();
          alert(`User ${action}d successfully!`);
        } else {
          const error = await response.text();
          alert(`Error ${action}ing user: ${error}`);
        }
      } catch (error) {
        console.error(`Error ${action}ing user:`, error);
        alert(`Error ${action}ing user: ${error.message}`);
      }
    }

    function showChangePasswordModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.5); display: flex; align-items: center; 
        justify-content: center; z-index: 1000;
      `;
      
      modal.innerHTML = `
        <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 24px; width: 400px; max-width: 90vw;">
          <h3 style="margin: 0 0 16px 0; color: var(--text);">Change Password</h3>
          
          <div style="display: grid; gap: 16px;">
            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">Current Password *</label>
              <input type="password" id="currentPassword" placeholder="Enter current password" 
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">New Password *</label>
              <input type="password" id="newPassword" placeholder="Enter new password (min 8 characters)" 
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 4px; color: var(--text); font-weight: bold;">Confirm New Password *</label>
              <input type="password" id="confirmPassword" placeholder="Confirm new password" 
                     style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text);">
            </div>
          </div>
          
          <div style="display: flex; gap: 12px; margin-top: 20px; justify-content: flex-end;">
            <button class="btn" onclick="document.querySelector('.modal').remove()" style="background: var(--muted);">Cancel</button>
            <button class="btn" onclick="changePassword()" style="background: var(--accent);">Change Password</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }

    async function changePassword() {
      try {
        const currentPassword = document.getElementById('currentPassword').value;
        const newPassword = document.getElementById('newPassword').value;
        const confirmPassword = document.getElementById('confirmPassword').value;
        
        if (!currentPassword || !newPassword || !confirmPassword) {
          alert('All fields are required');
          return;
        }
        
        if (newPassword.length < 8) {
          alert('New password must be at least 8 characters long');
          return;
        }
        
        if (newPassword !== confirmPassword) {
          alert('New passwords do not match');
          return;
        }
        
        const token = localStorage.getItem('odras_token');
        const response = await fetch('/api/users/me/password', {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            old_password: currentPassword,
            new_password: newPassword
          })
        });
        
        if (response.ok) {
          document.querySelector('.modal').remove();
          alert('Password changed successfully!');
        } else {
          const error = await response.text();
          alert(`Error changing password: ${error}`);
        }
      } catch (error) {
        console.error('Error changing password:', error);
        alert(`Error changing password: ${error.message}`);
      }
    }

    // Make user management functions globally available
    window.loadUsers = loadUsers;
    window.showCreateUserModal = showCreateUserModal;
    window.createUser = createUser;
    window.editUser = editUser;
    window.updateUser = updateUser;
    window.toggleUserStatus = toggleUserStatus;
    window.showChangePasswordModal = showChangePasswordModal;
    window.changePassword = changePassword;
    
          // Test function for debugging
      function testToggle() {
        console.log('🧪 Testing toggle function...');
        const firstSection = document.querySelector('.section');
        if (firstSection) {
          const header = firstSection.querySelector('.section-header');
          if (header) {
            console.log('Found section and header, calling toggleSection...');
            toggleSection(header);
          } else {
            console.error('No header found in first section');
          }
        } else {
          console.error('No section found');
        }
      }
    window.testToggle = testToggle;
    
          // Add event listeners to section headers
      function addSectionListeners() {
        console.log('🔧 Adding event listeners to section headers...');
        const sectionHeaders = document.querySelectorAll('.section-header');
        console.log('Found section headers:', sectionHeaders.length);
        
        sectionHeaders.forEach((header, index) => {
          console.log(`Adding listener to header ${index}:`, header);
          header.addEventListener('click', function(e) {
            console.log(`Section header ${index} clicked via event listener`);
            e.preventDefault();
            e.stopPropagation();
            toggleSection(this);
          });
        });
      }
    window.addSectionListeners = addSectionListeners;

    // Menu functionality for ontology workbench
    function initializeOntologyMenus() {
      // Close all menus when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.menu-group')) {
          document.querySelectorAll('.menu-dropdown').forEach(menu => {
            menu.style.display = 'none';
          });
        }
      });

      // Handle menu button clicks
      const menuButtons = ['ontoLayoutMenuBtn', 'ontoViewMenuBtn', 'ontoEditMenuBtn', 'ontoFileMenuBtn'];
      menuButtons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const dropdown = btn.nextElementSibling;
            if (dropdown) {
              // Close other menus
              document.querySelectorAll('.menu-dropdown').forEach(menu => {
                if (menu !== dropdown) {
                  menu.style.display = 'none';
                }
              });
              // Toggle current menu
              dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
            }
          });
        }
      });
    }

    // Initialize menus when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeOntologyMenus);
    } else {
      initializeOntologyMenus();
    }

  </script>
</body>
</html>


