# CQ/MT UI Test Script Plan

## Objective
Create a comprehensive test script that sets up a complete CQ/MT Workbench environment visible in the UI for testing and demonstration.

## Tasks Review

### ✅ Complete Tasks
1. **Create new project**: `cqmt-test` in user's account
2. **Create ontology**: Test ontology with proper structure
3. **Add ontology elements**: Classes, object properties, datatype properties
4. **Add individuals**: Directly to microtheory (no individuals table yet)
5. **Create default microtheory**: Set as project default
6. **Set active ontology context**: For CQ creation
7. **Create 3 competency questions**: With DAS-suggested SPARQL
8. **Execute CQs**: Show pass/fail status
9. **Coverage information**: Display test results

### ⚠️ Potential Gaps Identified

#### Gap 1: Active Ontology Context
- **Issue**: `window.cqmtState.currentOntologyIri` is UI state, not persisted
- **Impact**: CQs need to know which ontology to use for context
- **Solution**: 
  - Store `ontology_context` in CQ metadata
  - OR ensure DAS uses the project's ontologies appropriately
  - OR set the context via URL parameter when accessing project

#### Gap 2: Coverage Tab Data
- **Issue**: Need to understand what coverage tab displays
- **Questions**: 
  - Does it show all CQs in project?
  - Does it aggregate pass/fail stats?
  - Does it show last execution results?
- **Solution**: Review coverage tab implementation and ensure data is populated

#### Gap 3: DAS SPARQL for Multiple CQs
- **Issue**: Need different problem statements for 3 CQs
- **Considerations**:
  - Each CQ should test different aspects
  - CQ1: List all classes
  - CQ2: List instances of a specific class
  - CQ3: Query with filters/joins
- **Solution**: Design varied CQs that exercise different query patterns

#### Gap 4: Individual Management
- **Issue**: No individuals UI yet
- **Current**: Inject directly as triples in microtheory
- **Future**: Need individuals CRUD API and UI
- **Note**: Capture this as future enhancement

## Test Scenario Design

### Project Setup
- **Name**: `cqmt-test-project`
- **Description**: "UI test project for CQ/MT Workbench demonstration"
- **Domain**: systems-engineering

### Ontology Setup
- **Name**: `TestOntology`
- **Graph IRI**: Auto-generated
- **Classes**: 
  - `Aircraft` (base class)
  - `FighterJet` (subclass of Aircraft)
  - `TransportPlane` (subclass of Aircraft)
- **Object Properties**:
  - `hasRole`
  - `operatedBy`
- **Datatype Properties**:
  - `hasMaxSpeed`
  - `hasCapacity`
  - `isOperational`

### Microtheory Setup
- **Name**: `test-microtheory`
- **Is Default**: Yes
- **Individuals** (directly as triples):
  - `F22`: FighterJet, maxSpeed "Mach 2.25", operational true
  - `F35`: FighterJet, maxSpeed "Mach 1.6", operational true
  - `C130`: TransportPlane, capacity "92", operational true
  - `C17`: TransportPlane, capacity "102", operational true

### Competency Questions

#### CQ1: List All Classes
- **Name**: "List All Classes"
- **Problem**: "What classes are defined in our ontology?"
- **Expected**: Returns Aircraft, FighterJet, TransportPlane
- **SPARQL**: Generated by DAS

#### CQ2: List All Fighter Jets
- **Name**: "List All Fighter Jets"
- **Problem**: "What fighter jets are in our inventory?"
- **Expected**: Returns F22, F35
- **SPARQL**: Generated by DAS

#### CQ3: List Operational Aircraft with Speed
- **Name**: "Operational Aircraft with Speed"
- **Problem**: "What operational aircraft have speed information?"
- **Expected**: Returns F22, F35 with their speeds
- **SPARQL**: Generated by DAS

## Implementation Steps

### Step 1: Create Project
```python
POST /api/projects
{
  "name": "cqmt-test-project",
  "description": "UI test project for CQ/MT Workbench",
  "domain": "systems-engineering"
}
```

### Step 2: Create Ontology
```python
POST /api/ontologies
{
  "project": project_id,
  "name": "TestOntology",
  "label": "Test Ontology",
  "is_reference": false
}
```

### Step 3: Add Classes
```python
POST /api/ontology/{ontology_id}/classes
[
  {"name": "Aircraft", "description": "Base aircraft class"},
  {"name": "FighterJet", "description": "Fighter aircraft", "subclass_of": "Aircraft"},
  {"name": "TransportPlane", "description": "Transport aircraft", "subclass_of": "Aircraft"}
]
```

### Step 4: Add Properties
```python
POST /api/ontology/{ontology_id}/object-properties
[
  {"name": "hasRole", "domain": "Aircraft", "range": "string"},
  {"name": "operatedBy", "domain": "Aircraft", "range": "Organization"}
]

POST /api/ontology/{ontology_id}/datatype-properties
[
  {"name": "hasMaxSpeed", "domain": "Aircraft", "range": "string"},
  {"name": "hasCapacity", "domain": "TransportPlane", "range": "integer"},
  {"name": "isOperational", "domain": "Aircraft", "range": "boolean"}
]
```

### Step 5: Create Microtheory with Individuals
```python
POST /api/cqmt/projects/{project_id}/microtheories
{
  "label": "test-microtheory",
  "description": "Test microtheory with aircraft data",
  "setDefault": true,
  "triples": [
    # F22
    {"subject": "http://example.org/test#F22", "predicate": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", "object": "http://example.org/test#FighterJet"},
    {"subject": "http://example.org/test#F22", "predicate": "http://example.org/test#hasMaxSpeed", "object": "Mach 2.25"},
    {"subject": "http://example.org/test#F22", "predicate": "http://example.org/test#isOperational", "object": "true"},
    # F35
    {"subject": "http://example.org/test#F35", "predicate": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", "object": "http://example.org/test#FighterJet"},
    {"subject": "http://example.org/test#F35", "predicate": "http://example.org/test#hasMaxSpeed", "object": "Mach 1.6"},
    {"subject": "http://example.org/test#F35", "predicate": "http://example.org/test#isOperational", "object": "true"},
    # C130
    {"subject": "http://example.org/test#C130", "predicate": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", "object": "http://example.org/test#TransportPlane"},
    {"subject": "http://example.org/test#C130", "predicate": "http://example.org/test#hasCapacity", "object": "92"},
    {"subject": "http://example.org/test#C130", "predicate": "http://example.org/test#isOperational", "object": "true"},
    # C17
    {"subject": "http://example.org/test#C17", "predicate": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", "object": "http://example.org/test#TransportPlane"},
    {"subject": "http://example.org/test#C17", "predicate": "http://example.org/test#hasCapacity", "object": "102"},
    {"subject": "http://example.org/test#C17", "predicate": "http://example.org/test#isOperational", "object": "true"}
  ]
}
```

### Step 6: Create CQs with DAS
```python
for each CQ:
    1. Call DAS suggest-sparql with problem statement
    2. Create CQ with returned SPARQL
    3. Execute CQ against microtheory
    4. Display pass/fail status
```

## Expected UI Behavior

### After Script Execution:
1. **Project List**: `cqmt-test-project` appears
2. **CQ/MT Tab**: Shows 3 CQs with status badges
3. **Coverage Tab**: Shows aggregation of CQ results
4. **CQ Cards**: Show "List All Classes", "List All Fighter Jets", "Operational Aircraft with Speed"
5. **Each CQ**: Has pass/fail badge based on execution
6. **Microtheory**: Shows as DEFAULT badge

## Validation Checklist

- [ ] Project created and visible in UI
- [ ] Ontology created with classes and properties
- [ ] Microtheory created with individuals data
- [ ] All 3 CQs created successfully
- [ ] DAS generated valid SPARQL for each CQ
- [ ] Each CQ executed successfully
- [ ] Pass/fail badges show correct status
- [ ] Coverage tab displays aggregated results
- [ ] Can open and view each CQ in modal
- [ ] Can execute CQs from UI

## Future Enhancements

1. **Individuals UI**: Create CRUD interface for individuals
2. **Coverage Dashboard**: Enhanced visualization and analytics
3. **CQ Templates**: Pre-built CQ templates for common patterns
4. **Batch Execution**: Run all CQs at once with results summary
5. **Ontology Diff**: Compare CQ results across ontology versions
