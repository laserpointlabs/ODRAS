You are helping me build ProcOS, a process-oriented operating system using BPMN for workflows, LLMs for task execution, and DAS (Digital Assistance System) for ambient intelligence. The goal is usability for generalists (visual editing without coding) and power for super users, starting simple and evolving with user knowledge. Keep everything modular, lean, and scalable—deployable locally on a GPU laptop or to AWS.
Key Architecture Overview:

Nanocernel (formerly microkernel): A ridiculously small Python script (~50-100 lines max) that bootstraps the system. It initializes Camunda (or a lightweight Python state machine like transitions for process tracking), the vector store (Milvus or Pinecone for semantic memory), the graph database (Neo4j for relational context), and DAS. It listens for new process triggers (e.g., via Camunda API or state machine events) and spawns PDOs. No execution logic—just init and monitoring. Deployable to AWS via CDK.
PDO (Process Definition Orchestrator, formerly PEO): A generic BPMN process (defined in BPMN.io XML) that manages an entire workflow instance. It runs in a while-loop-like nature: queries Camunda/state machine for the current process state (active tasks, previous/next tasks), handles sequential or parallel tasks (spawning TDEs dynamically only when tasks are ready), updates the state, and terminates on completion. The while-loop is embedded in the BPMN flow (e.g., a loop gateway that checks for pending tasks). PDO is lightweight and generic—no hard-coded tools or tasks. It must not require modification of the BPMN diagram when adding new tools or tasks; instead, it routes tasks to TDEs, where the LLM decides actions based on prompts.
TDE (Task Definition Executor): A generic BPMN process (XML template) for executing individual tasks. It receives a task from PDO, uses an LLM (OpenAI or Ollama) at the front for decision-making (e.g., evaluate input, choose action like "write file" or "run Python script"), and executes probabilistically (iterate until convergence on weighted outcomes, using Monte Carlo/Bayesian for uncertainty) or deterministically (call tools like Python, MATLAB, or Docker containers). Logs outcomes to vector store/graph database via DAS. TDEs are isolated, spawned horizontally (one per task, terminable after execution), and generic—no BPMN changes needed for new tools/tasks; the LLM prompt handles flexibility.
DAS (Digital Assistance System): Central ambient intelligence, started by nanocernel. Monitors everything (user inputs, process states, logs) via vector store/graph database. Accepts text/voice inputs to generate BPMN processes (e.g., "save to memory" creates a file write process). Pre-loads a priori memory (5-10 sample BPMN processes like file ops). Logs to vector store (semantic embeddings) and graph database (relational graphs, e.g., process-task links). Features: process generation, contextual suggestions, short/long-term memory, learning from errors/iterations.
Tools and MCP Servers: Use AWS MCP servers (e.g., Diagram MCP, Documentation MCP, CDK MCP) for development—prompt Amazon Q CLI in Cursor to generate architecture diagrams, docs, and CDK stacks for AWS deployment (ECS for TDEs, Bedrock for LLMs, Neptune for graph DB). Integrate tools like BPMN.io for BPMN XML, React Flow for ontologies, Docker for containerized tasks. No custom state machine coding if Camunda works; evaluate transitions only if Camunda bloats.
Requirements:

Simplicity: No overcomplication—PDO/TDE are generic BPMN templates; LLM in TDE decides actions without modifying diagrams for new tools/tasks (e.g., add a new API call via prompt update, not BPMN change).
Usability: Generalists edit BPMN visually; DAS generates processes from natural language.
Persistence: DAS handles "save to memory" by writing to vector store/graph DB.
Prototyping: Start slow—build nanocernel first, then DAS, then PDO/TDE. Test with sample processes (e.g., file ops with parallel tasks). Log all iterations/errors for DAS learning.



Task: Generate starter code, BPMN XML templates, and diagrams for ProcOS. Start with the nanocernel in Python (~50 lines). Then, create BPMN XML for a generic PDO (with while-loop gateway for task handling) and TDE (with LLM decision front-end). Use AWS MCP via Amazon Q for a deployment diagram. Ensure PDO diagram doesn't need changes for new tools—rely on TDE's LLM prompts. Finally, implement a basic DAS script that generates a BPMN process from input and logs to Milvus/Neo4j.